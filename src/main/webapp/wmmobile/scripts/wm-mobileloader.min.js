/*global window*/
/*jslint todo: true */

/* Aliasing the 'angular' variable */
var WM = window.angular;

/*Namespace for the application*/
var wm = {};

wm.init = (function () {
    'use strict';

    /*wm modules*/
    wm.modules = {};

    /*Plugin modules*/
    wm.plugins = {};

    /*Module to define some base classes*/
    wm.baseClasses = wm.baseClasses || {};

}());

WM.module('wm.layouts.page', []);
WM.module('wm.layouts.containers', []);
WM.module('wm.layouts.device', []);

WM.module('wm.widgets.basic', ['toaster']);
WM.module('wm.widgets.form', []);
WM.module('wm.widgets.dialog', ['ui.bootstrap.modal']);
WM.module('wm.widgets.grid', []);
WM.module('wm.widgets.live', []);
WM.module('wm.widgets.advanced', ['ui.calendar']);
WM.module('wm.prefabs', ['wm.widgets.base']);
WM.module('wm.themes', ['wm.widgets.base']);

WM.module('wm.layouts', ['wm.layouts.page', 'wm.layouts.containers', 'wm.layouts.device']);

WM.module('wm.widgets', [
    'wm.widgets.base',
    'wm.widgets.basic',
    'wm.widgets.form',
    'wm.widgets.dialog',
    'wm.widgets.grid',
    'wm.widgets.live',
    'wm.widgets.advanced'
]);
/*global WM, wm, window, document, navigator, Image, location, console, _, $, moment*/
/*jslint todo: true */

/**
 * @ngdoc service
 * @name wm.utils.Utils
 * @requires $rootScope
 * @requires $location
 * @requires $window
 * @requires CONSTANTS
 * @requires $sce
 * @description
 * The `Utils` service provides utility methods.
 */

WM.module('wm.utils', [])
    .service('Utils', ['$rootScope', '$location', '$window', 'CONSTANTS', '$sce', function ($rootScope, $location, $window, APPCONSTANTS, $sce) {
        'use strict';

        var userAgent = navigator.userAgent,
            scriptEl = document.createElement('script'),
            linkEl = document.createElement('link'),
            headNode = document.getElementsByTagName('head')[0],
            isAppleProduct = /Mac|iPod|iPhone|iPad/.test(navigator.platform),
            REGEX = {
                SNAKE_CASE: /[A-Z]/g,
                ANDROID: /Android/i,
                IPHONE: /iPhone/i,
                IPOD: /iPod/i,
                MOBILE: /Mobile/i,
                WINDOWS: /Windows Phone/i,
                SUPPORTED_IMAGE_FORMAT: /\.(bmp|gif|jpe|jpg|jpeg|tif|tiff|pbm|png|ico)$/i,
                SUPPORTED_FILE_FORMAT: /\.(txt|js|css|html|script|properties|json|java|xml|smd|xmi|sql|log|wsdl)$/i,
                SUPPORTED_AUDIO_FORMAT: /\.(mp3|ogg|webm|wma|3gp|wav)$/i,
                SUPPORTED_VIDEO_FORMAT: /\.(mp4|ogg|webm|wmv|mpeg|mpg|avi)$/i,
                PAGE_RESOURCE_PATH: /^\/pages\/.*\.(js|css|html|json)$/,
                MIN_PAGE_RESOURCE_PATH: /.*(page.min.html)$/,
                VALID_EMAIL: /^[a-zA-Z][\w.]+@[a-zA-Z_]+?\.[a-zA-Z.]{1,4}[a-zA-Z]$/,
                VALID_WEB_URL: /^(http[s]?:\/\/)(www\.){0,1}[a-zA-Z0-9\.\-]+\.[a-zA-Z]{2,5}[\.]{0,1}/,  //ref : http://stackoverflow.com/questions/4314741/url-regex-validation
                REPLACE_PATTERN: /\$\{([^\}]+)\}/g,
                ZIP_FILE: /\.zip$/i,
                EXE_FILE: /\.exe$/i,
                NO_QUOTES_ALLOWED: /^[^'|"]*$/,
                VALID_HTML: /<[a-z][\s\S]*>/i,
                VALID_PASSWORD: /^[0-9a-zA-Z-_.@&*!#$%]+$/
            },
            NUMBER_TYPES = ['int', 'integer', 'float', 'double', 'long', 'short', 'byte', 'big_integer', 'big_decimal'],
            SYSTEM_FOLDER_PATHS = {
                'project': ['../lib', '../project', '../project/services', '../project/lib', '../project/src', '../project/test', '../project/src/main', '../project/src/main/webapp', '../project/src/main/resources', '../project/src/main/webapp/services', '../project/src/main/webapp/resources', '../project/src/main/webapp/pages', '../project/src/main/webapp/resources/images', '../project/src/main/webapp/resources/WEB-INF', '../project/src/main/webapp/resources/ngLocale', '../project/src/main/webapp/resources/i18n', '../project/src/main/webapp/resources/images/imagelists', '../project/src/main/webapp/resources/audio', '../project/src/main/webapp/resources/video'],
                'resources': ['', '/services', '/resources', '/WEB-INF', '/app', '/pages', '/resources/i18n', '/resources/ngLocale', 'resources/images', 'resources/audio', 'resources/video', 'resources/images/imagelists'],
                'lib': ['../lib'],
                'jar': ['../lib'],
                'locale': ['resources/i18n'],
                'services': ['services'],
                'image': ['resources/images', 'resources/images/imagelists'],
                'audio': ['resources/audio'],
                'video': ['resources/video']
            },
            hasLocalStorage = 'localStorage' in window && window.localStorage !== null,
            browserStorage = {
                storeItem: function (key, value) {
                    if (hasLocalStorage) {
                        window.localStorage.setItem(key, value);
                    }
                },
                getItem: function (key) {
                    if (hasLocalStorage) {
                        return window.localStorage.getItem(key);
                    }
                },
                deleteItem: function (key) {
                    if (hasLocalStorage) {
                        delete window.localStorage[key];
                    }
                }
            },
            isIE = function () {
                return userAgent.indexOf('MSIE') > -1;
            },
            isIE11 = function () {
                return navigator.appVersion.indexOf('Trident/') > -1;
            },
            isIE9 = function () {
                return navigator.appVersion.indexOf('MSIE 9') > -1;
            },
            getNode = function (tree, nodeId) {
                var index, treeLength;
                /*Return undefined if the 'tree' is undefined*/
                if (WM.isUndefined(tree)) {
                    return undefined;
                }
                treeLength = tree.length;
                /*Loop through the tree and match the specified nodeId against the ids of the tree elements*/
                for (index = 0; index < treeLength; index += 1) {
                    /*Return the node if it exists*/
                    if (tree[index].id === nodeId) {
                        return tree[index];
                    }
                }
                /*Return undefined if the tree does not contain the node*/
                return undefined;
            },
            variableCategoryMap = {
                'wm.Variable'            : 'variable',
                'wm.ServiceVariable'     : 'service-variable',
                'wm.LiveVariable'        : 'live-variable',
                'wm.LoginVariable'       : 'login-variable',
                'wm.LogoutVariable'      : 'logout-variable',
                'wm.NavigationVariable'  : 'navigation-variable',
                'wm.NotificationVariable': 'notification-variable',
                'wm.TimerVariable'       : 'time',
                'wm.DeviceVariable'      :  'device-variable'
            },
            dateTimeTypes = {
                'date'      : true,
                'time'      : true,
                'timestamp' : true,
                'datetime'  : true
            },
            dataSetWidgets = {
                'select': true,
                'checkboxset': true,
                'radioset': true
            },
            daysOptions = [{
                'name': 'Sunday',
                'value': '0'
            }, {
                'name': 'Monday',
                'value': '1'
            }, {
                'name': 'Tuesday',
                'value': '2'
            }, {
                'name': 'Wednesday',
                'value': '3'
            }, {
                'name': 'Thursday',
                'value': '4'
            }, {
                'name': 'Friday',
                'value': '5'
            }, {
                'name': 'Saturday',
                'value': '6'
            }],
            dateTimeDefaultFormats = {
                'date'           : 'yyyy-MM-dd',
                'time'           : 'HH:mm:ss',
                'timestamp'      : 'timestamp',
                'datetime'       : 'yyyy-MM-ddTHH:mm:ss',
                'datetime_oracle': 'yyyy-MM-dd HH:mm:ss'
            },
            indexPage = getIndexPage();

        /* set default attrs for link */
        linkEl.rel = 'stylesheet';
        linkEl.type = 'text/css';

        /* convert camelCase string to a snake-case string */
        function hyphenate(name) {
            return name.replace(REGEX.SNAKE_CASE, function (letter, pos) {
                return (pos ? '-' : '') + letter.toLowerCase();
            });
        }
        /* convert a hyphenated string to a space separated string. */
        function deHyphenate(name) {
            return name.split('-').join(' ');
        }
        /* convert camelCase string to a space separated string */
        function spaceSeparate(name) {
            if (name === name.toUpperCase()) {
                return name;
            }
            return name.replace(REGEX.SNAKE_CASE, function (letter, pos) {
                return (pos ? ' ' : '') + letter;
            });
        }

        /*Replace the character at a particular index*/
        function replaceAt(string, index, character) {
            return string.substr(0, index) + character + string.substr(index + character.length);
        }

        /*Replace '.' with space and capitalize the next letter*/
        function periodSeparate(name) {
            var dotIndex;
            dotIndex = name.indexOf('.');
            if (dotIndex !== -1) {
                name = replaceAt(name, dotIndex + 1, name.charAt(dotIndex + 1).toUpperCase());
                name = replaceAt(name, dotIndex, ' ');
            }
            return name;
        }

        /* capitalize the first-letter of the string passed */
        function initCaps(name) {
            if (!name) {
                return '';
            }
            return name.charAt(0).toUpperCase() + name.substring(1);
        }

        /* capitalize ONLY the first-letter of the string passed, remaining is made lower cased */
        function firstCaps(name) {
            if (!name) {
                return '';
            }
            return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
        }

        function prettifyLabel(label) {
            /*capitalize the initial Letter*/
            label = initCaps(label);
            /*Convert camel case words to separated words*/
            label = spaceSeparate(label);
            /*Replace '.' with space and capitalize the next letter*/
            label = periodSeparate(label);
            return label;
        }

        /*Accepts an array or a string separated with symbol and returns prettified result*/
        function prettifyLabels(names, separator) {
            var modifiedNames,
                namesArray = [],
                isArray    = WM.isArray(names);
            separator = separator || ',';

            if (!isArray) {
                namesArray = names.split(separator);
            }

            modifiedNames = _.map(namesArray, prettifyLabel);
            if (isArray) {
                return modifiedNames;
            }
            return modifiedNames.join(separator);
        }

        /*function to get variable name bound to an element*/
        function getVariableName(iScope, scope) {
            if (iScope.binddataset) {
                var variableName,
                    widgetScope,
                    widgetName,
                    isBoundToVariable,
                    isBoundToWidget,
                    parts = iScope.binddataset.split('.');

                isBoundToVariable = _.includes(iScope.binddataset, 'bind:Variables.');

                if (!isBoundToVariable) {
                    isBoundToWidget = _.includes(iScope.binddataset, 'bind:Widgets.');
                }

                if (isBoundToVariable) {
                    variableName = parts[1];
                } else if (isBoundToWidget) {
                    if (WM.isString(iScope.binddataset) && iScope.binddataset !== '') {
                        if (!_.includes(iScope.binddataset, 'selecteditem.')) {
                            widgetName = parts[1];
                            widgetScope = (scope || iScope).Widgets[widgetName];
                            variableName = getVariableName(widgetScope);
                        } else {
                            // Return null if widget is bound to selecteditem.something.
                            variableName = null;
                        }
                    }
                }
                return variableName;
            }
        }
        function isValidWebURL(url) {
            return (REGEX.VALID_WEB_URL).test(url);
        }

        /* returns the zIndex of the parent elements overlay */
        function getParentOverlayElZIndex(element) {
            var parentEl, parentOverlay, parentOvleryZIndex;
            parentEl = element.parent().closest('[widgetid]');
            /* fetch the z-index of parent element */
            if (parentEl.length > 0) {
                parentEl = parentEl.eq(0);
                parentOverlay = parentEl.data('overlayElement');
                if (parentOverlay) {
                    parentOvleryZIndex = parentOverlay.css('zIndex');
                } else if (parentEl.parent().data('overlayElement')) {
                    parentOvleryZIndex = parseInt(parentEl.parent().data('overlayElement').css('zIndex'), 10) + 10;
                } else {
                    /*Temporary fix to assign z-index for elements with no parent overlayElement - Ex: Database-column*/
                    parentOvleryZIndex = 10;
                }
            } else {
                return 100;
            }
            return +parentOvleryZIndex;
        }

    /**
     * Method to check the markup and return valid content even if users makes mistakes
     * @param htmlString
     * @param handleValidMarkUp
     * @param handleInValidMarkUp
     * @return {String}
     */
        function getValidMarkUp(htmlString, handleValidMarkUp, handleInValidMarkUp) {
            var newMarkup = '', checkValidRootElement = function (ele) {
                return WM.element(ele).is('wm-page, wm-partial, wm-template');
            },
                $htm,
                $outerEle,
                $innerEle;

            $htm = WM.element.parseHTML(htmlString);
            //check if the root element is either of the valid elements
            if (checkValidRootElement($htm[0])) {
                newMarkup = htmlString;
                triggerFn(handleValidMarkUp);
            } else {
                //handle the invalid condition
                triggerFn(handleInValidMarkUp);
                //the page markup is not valid
                $outerEle = WM.element('<div>' + htmlString + '</div>');
                $innerEle = $outerEle.find('wm-page, wm-partial, wm-template');

                if ($innerEle.length > 0) {
                    newMarkup = $innerEle[0].outerHTML;
                }
            }
            return newMarkup;
        }
        function formatVariableIconClass(variableCategory) {
            return variableCategoryMap[variableCategory];
        }

        /*helper function for prepareFieldDefs*/
        function pushFieldDef(dataObject, columnDefObj, namePrefix, propObj, noModifyTitle) {
            /*loop over the fields in the dataObject to process them*/
            var modifiedTitle;
            WM.forEach(dataObject, function (value, title) {
                if (noModifyTitle) {
                    modifiedTitle = title;
                } else {
                    if (WM.isString(title)) {
                        /*capitalize the initial Letter*/
                        modifiedTitle = initCaps(title);
                        /*Convert camel case words to separated words*/
                        modifiedTitle = spaceSeparate(modifiedTitle);
                        /*Replace '.' with space and capitalize the next letter*/
                        modifiedTitle = periodSeparate(modifiedTitle);
                        modifiedTitle = deHyphenate(modifiedTitle);
                        modifiedTitle = namePrefix ? initCaps(namePrefix) + ' ' + modifiedTitle : modifiedTitle;
                    } else {
                        modifiedTitle = title;
                    }
                }
                title = namePrefix ? namePrefix + '.' + title : title;
                var defObj = propObj.setBindingField ? {'displayName': modifiedTitle, 'field': title} : {'displayName': modifiedTitle};
                /*if field is a leaf node, push it in the columnDefs*/
                if (!WM.isObject(value) || (WM.isArray(value) && !value[0])) {
                    /*if the column counter has reached upperBound return*/
                    if (propObj.columnCount === propObj.upperBound) {
                        return;
                    }
                    columnDefObj.push(defObj);

                    /*increment the column counter*/
                    propObj.columnCount += 1;
                } else {
                    /*else field is an object, process it recursively*/
                    /* if parent node to be included, include it */
                    if (propObj.includeParentNode && propObj.columnCount !== propObj.upperBound) {
                        columnDefObj.push(defObj);
                    }

                    /* if field is an array node, process its first child */
                    if (WM.isArray(value) && value[0]) {
                        pushFieldDef(value[0], columnDefObj, title + '[0]', propObj);
                    } else {
                        pushFieldDef(value, columnDefObj, title, propObj);
                    }
                }
            });
        }

        /*function to prepare column definition objects from the data provided*/
        function prepareFieldDefs(data, columnUpperBound, includeParentNode, noModifyTitle) {
            var defaultDefs = false,
                dataObject,
                columnDef = [];
            /*if no data provided, initialize default column definitions*/
            if (!data || data.length === 0) {
                data = [
                    {'column1': '', 'column2': '', 'column3': '', 'column4': '', 'column5': ''}
                ];
                defaultDefs = true;
            }

            dataObject = WM.isArray(data) ? data[0] : [data];
            /*first of the many data objects from grid data*/
            pushFieldDef(dataObject, columnDef, '', {'upperBound': columnUpperBound, 'columnCount': 0, includeParentNode: includeParentNode, setBindingField: !defaultDefs}, noModifyTitle);
            return columnDef;
        }

        /*function to swap two elements in an array*/
        function swapArrayElements(array, index1, index2) {
            var temp = array[index1];
            array[index1] = array[index2];
            array[index2] = temp;
            return array;
        }

        /*function to swap the given two properties in the object*/
        function swapProperties(data, property1, property2) {
            var temp = data[property1];
            data[property1] = data[property2];
            data[property2] = temp;
        }

        /*function to check if fn is a function and then execute*/
        function triggerFn(fn) {
            /* Use of slice on arguments will make this function not optimizable
            * https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments
            * */

            var start = 1, len = arguments.length, args = new Array(len - start);
            for (start; start < len; start++) {
                args[start - 1] = arguments[start];
            }

            if (WM.isFunction(fn)) {
                return fn.apply(null, args);
            }
        }

        /*function to check if the stylesheet is already loaded */
        function isStyleSheetLoaded(href) {
            return WM.element('link[href="' + href + '"]').length > 0;
        }

        /*function to remove stylesheet if the stylesheet is already loaded */
        function removeStyleSheetLoaded(href) {
            var styleTag = WM.element('link[href="' + href + '"]');
            if (styleTag.length) {
                styleTag.remove();
            }
        }

        /*function to load a stylesheet */
        function loadStyleSheet(url, attr) {
            if (isStyleSheetLoaded(url)) {
                return;
            }
            var link = linkEl.cloneNode();
            link.href = url;
            /*To add attributes to link tag*/
            if (attr && attr.name) {
                link.setAttribute(attr.name, attr.value);
            }
            headNode.appendChild(link);
            return link;
        }

        /*function to load stylesheets */
        function loadStyleSheets(urlArray) {
            if (!urlArray) {
                return;
            }
            /* if the first argument is not an array, convert it to an array */
            if (!WM.isArray(urlArray)) {
                urlArray = [urlArray];
            }
            WM.forEach(urlArray, loadStyleSheet);
        }

        /*function to check if the script is already loaded*/
        function isScriptLoaded(src) {
            return WM.element('script[src="' + src + '"]').length > 0 || WM.element('script[data-src="' + src + '"]').length > 0;
        }

        /* util function to load the content from a url */
        function fetchContent(dataType, url, successCallback, errorCallback, inSync) {

            // IE9: xdomain.js will not allow us to make synchronous requests. Use nativeXMLHTTP
            if (inSync && window.nativeXMLHTTP) {
                var xhr = new window.nativeXMLHTTP(),
                    response;
                xhr.open('GET', url, false);
                xhr.onload = function () {
                    if (xhr.readyState === 4) {
                        if (xhr.status === 200) {
                            response = xhr.responseText;
                            if (dataType === 'json') {
                                response = JSON.parse(xhr.responseText);
                            }
                            successCallback(response);
                        } else {
                            errorCallback();
                        }
                    }
                };
                xhr.send();
            } else {
                WM.element.ajax({
                    type: 'get',
                    dataType: dataType,
                    url: url,
                    success: successCallback,
                    error: errorCallback,
                    async: !inSync
                });
            }
        }

        /*function to load a javascript files */
        function loadScripts(scripts, onsuccess, onerror, hasError, jqxhr) {

            if (!scripts || scripts.length === 0) {
                if (hasError) {
                    triggerFn(onerror, jqxhr);
                } else {
                    triggerFn(onsuccess, jqxhr);
                }
                return;
            }

            var url = scripts.shift();
            if (isScriptLoaded(url)) {
                loadScripts(scripts, onsuccess, onerror);
                return;
            }

            WM.element.getScript(url)
                .done(function (script, textStatus, jqxhr) {
                    loadScripts(scripts, onsuccess, onerror, false, jqxhr);
                })
                .fail(function (jqxhr) {
                    loadScripts([], onsuccess, onerror, true, jqxhr);
                });
        }

        function loadScriptsInSync(urlArray) {

            if (urlArray.length === 0) {
                return;
            }

            var url = urlArray.shift();

            if (isScriptLoaded(url) || !url) {
                return;
            }

            if (url) {
                fetchContent('text', url, function (response) {
                    var script = scriptEl.cloneNode();
                    script.text = response;
                    script.setAttribute('data-src', url);
                    headNode.appendChild(script);
                    loadScriptsInSync(urlArray);
                }, null, true); //load in sync
            }
        }

        /* functions for resource Tab*/
        function isImageFile(fileName) {
            return (REGEX.SUPPORTED_IMAGE_FORMAT).test(fileName);
        }

        function isZipFile(fileName) {
            return (REGEX.ZIP_FILE).test(fileName);
        }

        function isExeFile(fileName) {
            return (REGEX.EXE_FILE).test(fileName);
        }

        function isTextLikeFile(fileName) {
            return (REGEX.SUPPORTED_FILE_FORMAT).test(fileName);
        }

        function isAudioFile(fileName) {
            return (REGEX.SUPPORTED_AUDIO_FORMAT).test(fileName);
        }

        function isVideoFile(fileName) {
            return (REGEX.SUPPORTED_VIDEO_FORMAT).test(fileName);
        }

        function isPageResource(path) {
            return (REGEX.PAGE_RESOURCE_PATH).test(path) && !(REGEX.MIN_PAGE_RESOURCE_PATH).test(path);
        }

        function isAndroid() {
            return (REGEX.ANDROID.test(userAgent));
        }

        function isAndroidPhone() {
            return isAndroid() && (REGEX.MOBILE.test(userAgent));
        }

        function isIphone() {
            return (REGEX.IPHONE.test(userAgent));
        }

        function isIpod() {
            return (REGEX.IPOD.test(userAgent));
        }

        function isWindowsPhone() {
            return (REGEX.WINDOWS.test(userAgent));
        }

        function isMobile() {
            if (APPCONSTANTS.isRunMode) {
                return isAndroidPhone() || isIphone() || isIpod() || isWindowsPhone() || WM.element('#wm-mobile-display:visible').length > 0;
            }

            return false;
        }

        /*function to check valid java package name*/
        function isValidJavaPackageName(pkgName) {
            return pkgName.match(/^\w[\w\d_.]*[\w\d]$/);
        }

        /*function to check if quotes (both single and double) are NOT present in a string.*/
        function isQuoteNotPresent(str) {
            return REGEX.NO_QUOTES_ALLOWED.test(str);
        }

        /*function to check if string contains HTML tags.*/
        function isValidHtml(str) {
            return REGEX.VALID_HTML.test(str);
        }

        /*This function returns the url to the image after checking the validity of url*/
        function getImageUrl(urlString) {
            if (APPCONSTANTS.isRunMode) {
                return urlString;
            }
            /*In studio mode before setting picturesource, check if the studioController is loaded and new picturesource is in 'styles/images/' path or not.
             * When page is refreshed, loader.gif will be loaded first and it will be in 'style/images/'.
             * Prepend 'services/projects/' + $rootScope.project.id + '/web/resources/images/imagelists/'  if the image url is just image name in the project root,
             * and if the url pointing to resources/images/ then 'services/projects/' + $rootScope.project.id + '/web/'*/
            if (isValidWebURL(urlString)) {
                return urlString;
            }
            if (!isImageFile(urlString)) {
                urlString = 'resources/images/imagelists/default-image.png';
            }

            // if the resource to be loaded is inside a prefab
            if (stringStartsWith(urlString, 'services/prefabs')) {
                return urlString;
            }

            urlString = getProjectResourcePath($rootScope.project.id) + urlString;
            return urlString;
        }

        /*This function returns the url to the resource after checking the validity of url*/
        function getResourceURL(urlString) {
            if (isValidWebURL(urlString)) {
                return $sce.trustAsResourceUrl(urlString);
            }
            if (APPCONSTANTS.isRunMode) {
                return urlString;
            }

            // if the resource to be loaded is inside a prefab
            if (stringStartsWith(urlString, 'services/prefabs')) {
                return urlString;
            }

            urlString = getProjectResourcePath($rootScope.project.id) + urlString;
            return urlString;
        }

        /*This function returns the url to the backgroundImage*/
        function getBackGroundImageUrl(urlString) {
            if (urlString === '' || urlString === 'none') {
                return urlString;
            }
            return 'url(' + getImageUrl(urlString) + ')';
        }

        /* defining safe apply on root scope, so that it is accessible to all other $scope variables.*/
        $rootScope.$safeApply = function ($scope, fn) {
            if ($rootScope.$$phase || $scope.$$phase) {
                //don't worry, the value gets set and AngularJS picks up on it...
                triggerFn(fn);
            } else {
                //this will fire to tell angularjs to notice that a change has happened
                //if it is outside of it's own behavior...
                $scope.$apply(fn);
            }
        };

        /* util function which returns true if the given string starts with test string else returns false */
        function stringStartsWith(str, startsWith, ignoreCase) {
            if (!str) {
                return false;
            }

            var regEx = new RegExp('^' + startsWith, ignoreCase ? 'i' : []);

            return regEx.test(str);
        }

        /* util function which returns true if the given string starts with test string else returns false */
        function stringEndsWith(str, endsWith, ignoreCase) {
            if (!str) {
                return false;
            }

            var regEx = new RegExp(endsWith + '$', ignoreCase ? 'i' : []);

            return regEx.test(str);
        }

        /* function to check if provided object is empty*/
        function isEmptyObject(obj) {
            if (WM.isObject(obj) && !WM.isArray(obj)) {
                return Object.keys(obj).length === 0;
            }
            return false;
        }

        /* function to verify whether the email is valid or not*/
        function isValidEmail(email) {
            return REGEX.VALID_EMAIL.test(email);
        }

        /* function to verify whether the password is valid or not*/
        function isValidPassword(text) {
            return !!REGEX.VALID_PASSWORD.test(text);
        }

        /* fetch the column names and nested column names from the propertiesMap object */
        function fetchPropertiesMapColumns(propertiesMap, namePrefix) {
            var columns = {}, relatedColumnsArr = [];
            /* iterated trough the propertiesMap columns of all levels and build object with columns having required configuration*/
            WM.forEach(propertiesMap.columns, function (val) {
                /* if the object is nested type repeat the above process for that nested object through recursively */
                if (val.isRelated) {
                    if (!val.isPrimaryKey) {
                        val.disableInlineEditing = 'true';
                    }
                    if (val.isList) {
                        return;
                    }
                    relatedColumnsArr.push(val);
                } else {
                    /* otherwise build object with required configuration */
                    var columnName = namePrefix ? namePrefix + '.' + val.fieldName : val.fieldName;
                    columns[columnName] = {
                        'type'                : val.type,
                        'isPrimaryKey'        : val.isPrimaryKey,
                        'generator'           : val.generator,
                        'disableInlineEditing': val.disableInlineEditing,
                        'isRelatedPk'         : val.isRelatedPk
                    };
                }
            });
            WM.forEach(relatedColumnsArr, function (val) {
                WM.forEach(val.columns, function (col) {
                    if (!col.isPrimaryKey) {
                        col.disableInlineEditing = 'true';
                    } else {
                        if (val.isRelated && col.isPrimaryKey) {
                            col.isRelatedPk = 'true';
                        }
                    }
                });
                WM.extend(columns, fetchPropertiesMapColumns(val, val.fieldName));
            });

            return columns;
        }

        /*set empty values to all properties of  given object */
        function resetObjectWithEmptyValues(object) {
            var properties;
            if (object) {
                properties = {};
                WM.forEach(object, function (value, key) {
                    properties[key] = '';
                });
            }
            return properties;
        }

        /*function get current Page*/
        function getCurrentPage() {
            var pathName = location.pathname;
            return pathName.split('/').pop() || 'index.html';
        }

        /*function to find if executing in debug mode or normal mode*/
        function isDebugMode() {
            return getCurrentPage().indexOf('-debug') !== -1;
        }

        /*function get current Page*/
        function getIndexPage() {
            return isDebugMode() ? 'index-debug.html' : 'index.html';
        }

        /*function to go to a route in index page*/
        function redirectToIndexPage(path) {
            if (!path) {
                $window.location = indexPage;
            } else {
                $window.location = indexPage + '#' + path;
            }
        }

        /*function to go to a route in index page*/
        function redirectToLoginPage() {
            var locationHash = $location.$$path,
                currentPageName = getCurrentPage();

            /* store the reference url in local storage*/
            browserStorage.storeItem('wm.referenceUrlToStudio', currentPageName + '#' + locationHash);

            $window.location = APPCONSTANTS.LOGIN_PAGE;
        }

        /*function to handle the load event of the iframe which is called when the iframe is loaded after form submit to
         * handle manipulations after file upload.*/
        function handleUploadIFrameOnLoad(iFrameElement, successCallback, errorCallback, evt) {
            var serverResponse;
            /*removing event listener for the iframe*/
            iFrameElement.off('load', handleUploadIFrameOnLoad);
            /*obtaining the server response of the form submit and prefab import*/
            serverResponse = WM.element('#fileUploadIFrame').contents().find('body').text();
            if (evt && evt.currentTarget) {
                evt.currentTarget.responseText = serverResponse;
            }
            /*removing the iframe element from the DOM markup after import/upload is successful.*/
            iFrameElement.first().remove();
            /*triggering the callback function when succes response is encountered*/
            if (!serverResponse.errorDetails) {
                triggerFn(successCallback,  evt);
            } else {
                triggerFn(errorCallback);
            }
        }

        /*TODO: file upload fallback has been implemented currently only for prefabs. Need to implement for other scenarios.*/
        /*function to facilitate file upload fallback when HTML5 File API is not supported by the browser*/
        function fileUploadFallback(uploadConfig, successCallback, errorCallback) {
            /*creating a hidden iframe to facilitate file upload by way of form submit.*/
            var iFrameElement = WM.element('<iframe id="fileUploadIFrame" name="fileUploadIFrame" class="ng-hide"></iframe>'),
                formElement,
                formAction,
                dataArray,
                index,
                dataObj,
                dataElement,
                elementName,
                elementValue,
                key;

            if (uploadConfig) {
                formAction = uploadConfig.url;
            }

            /*appending iframe element to the body*/
            WM.element('body').append(iFrameElement);

            /*event handler for handling load event of iframe*/
            iFrameElement.on('load', function (evt) {
                handleUploadIFrameOnLoad(iFrameElement, successCallback, errorCallback, evt);
            });

            formElement = WM.element('*[name=' + uploadConfig.formName + ']').first();

            /*creating fields which are necessary as params for importing resources.*/
            if (uploadConfig.data) {
                dataArray = uploadConfig.data;
                /*iterating over data array*/
                for (index = 0; index < dataArray.length; index += 1) {
                    dataObj = dataArray[index];
                    /*iterating over each object to get element name and element value*/
                    for (key in dataObj) {
                        if (dataObj.hasOwnProperty(key)) {
                            elementName = key;
                            elementValue = dataObj[key];
                        }
                    }
                    /*creating element using element name and value obtained.*/
                    dataElement = WM.element('<input type="hidden" name="' + elementName + '" value="' + elementValue + '"/>');
                    /*appending element to formElement*/
                    formElement.append(dataElement);
                }
            }

            /*setting form attributes before form submit. Applying iframe as form target to avoid page reflow.*/
            formElement.attr({
                'target'  : 'fileUploadIFrame',
                'action'  : formAction,
                'method'  : 'post',
                'enctype' : 'multipart/form-data',
                'encoding': 'multipart/form-data'
            });

            /*triggering the form submit event*/
            formElement.submit();
        }

        /*
         * Util method to find the value of a key in the object
         * if key not found and create is true, an object is created against that node
         * Examples:
         * var a = {
         *  b: {
         *      c : {
         *          d: 'test'
         *      }
         *  }
         * }
         * Utils.findValue(a, 'b.c.d') --> 'test'
         * Utils.findValue(a, 'b.c') --> {d: 'test'}
         * Utils.findValue(a, 'e') --> undefined
         * Utils.findValue(a, 'e', true) --> {} and a will become:
         * {
         *   b: {
         *      c : {
         *          d: 'test'
         *      }
         *  },
         *  e: {
         *  }
         * }
         */
        function findValueOf(obj, key, create) {

            if (!obj || !key) {
                return;
            }

            if (!create) {
                return _.get(obj, key);
            }

            var parts = key.split('.'),
                keys  = [],
                skipProcessing;

            _.forEach(parts, function (part) {
                if (!parts.length) { // if the part of a key is not valid, skip the processing.
                    skipProcessing = true;
                    return false;
                }

                var subParts = part.match(/\w+/g),
                    subPart;

                while (subParts.length) {
                    subPart = subParts.shift();
                    keys.push({'key': subPart, 'value': subParts.length ? [] : {}}); // determine whether to create an array or an object
                }
            });

            if (skipProcessing) {
                return undefined;
            }

            _.forEach(keys, function (_key) {
                var tempObj = obj[_key.key];
                if (!WM.isObject(tempObj)) {
                    tempObj = getValidJSON(tempObj);
                    if (!tempObj) {
                        tempObj = _key.value;
                    }
                }
                obj[_key.key] = tempObj;
                obj           = tempObj;
            });

            return obj;
        }

        /*
         * Util method to replace patterns in string with object keys or array values
         * Examples:
         * Utils.replace('Hello, ${first} ${last} !', {first: 'wavemaker', last: 'ng'}) --> Hello, wavemaker ng
         * Utils.replace('Hello, ${0} ${1} !', ['wavemaker','ng']) --> Hello, wavemaker ng
         */
        function replace(template, map) {
            if (!template) {
                return;
            }

            return template.replace(REGEX.REPLACE_PATTERN, function (match, key) {
                return _.get(map, key);
            });
        }

        /* returns the prefab names loaded in the markup of current page */
        function getLoadedPrefabNames() {
            return WM.element('[prefabname]').map(function () {return WM.element(this).attr('prefabname'); });
        }

        function initializeAction(op, callback) {
            var img = new Image();
                //version = ($rootScope.studioInfo && $rootScope.studioInfo.product && $rootScope.studioInfo.product.version) || '',
                //revision = ($rootScope.studioInfo && $rootScope.studioInfo.product && $rootScope.studioInfo.product.revision) || '';
            img.onload = function () {
                /* image loaded successfully. trigger the callback */
                triggerFn(callback);
            };
            img.onerror = function () {
                /* image failed to load. trigger the callback */
                triggerFn(callback);
            };

           // img.src = 'http://wavemaker.com/img/blank.gif?op=' + op + '&v=' + version + '&r=' + revision + '&preventCache=' + String(Math.random(new Date().getTime())).replace(/\D/, '').substring(0, 8);
        }

        function getNodeFromJson(tree, nodeId, parentNodeId) {
            var nodeUId,
                parentNodeUId,
                nodeIndex,
                nodeStartIndex,
                node;

            /*Loop through the nodeMap of the tree.*/
            WM.element.each(tree[0].nodeMap, function (uid, name) {
                /*Check if the name matches with the specified nodeId*/
                if (name === nodeId) {
                    nodeUId = uid;

                    if (!parentNodeId) {
                        return false;
                    }
                    /*Check if the name of the parent node matches with the parentNodeId.
                    * If matched, break out of the loop.*/
                    parentNodeUId = nodeUId.substr(0, nodeUId.lastIndexOf('-'));
                    if (tree[0].nodeMap[parentNodeUId] === parentNodeId) {
                        return false;
                    }
                }
            });

            /*Check for sanity.*/
            if (nodeUId) {
                nodeIndex = nodeUId.split('-');
                nodeStartIndex = nodeIndex.shift();
                node = tree[nodeStartIndex];

                /*Get the node based on the nodeIndex*/
                nodeIndex.forEach(function (index) {
                    node = node.children[index];
                });
                return node;
            }
        }

        function addNodeToJson(tree, nodeId, parentNodeUId, options, parentNodeId) {

            options = options || {};

            var node = {
                    'id'         : nodeId,
                    'label'      : options.label,
                    'collapsed'  : options.collapsed,
                    'class'      : options.class,
                    'active'     : options.active,
                    'props'      : options.nodeProps,
                    'isDeletable': options.isDeletable,
                    'title'      : options.title,
                    'onDelete'   : options.onDelete
                },
                parentIndex,
                parentStartIndex,
                parentNode,
                existingNode;

            /*Return if the 'tree' is undefined*/
            if (WM.isUndefined(tree)) {
                return;
            }
            /*If parentNodeUId is not specified, insert the node into the tree and return*/
            if (WM.isUndefined(parentNodeUId) && WM.isUndefined(parentNodeId)) {
                parentNode = tree[0];
            } else {
                if (parentNodeId && !parentNodeUId) {
                    parentNodeUId = getNodeFromJson(tree, parentNodeId).uid;
                }
                parentIndex = parentNodeUId.split('-');
                parentStartIndex = parentIndex.shift();
                parentNode = tree[parentStartIndex];
                parentIndex.forEach(function (index) {
                    parentNode = parentNode.children[index];
                });
            }

            /* case, no node in the tree (empty tree) */
            if (!parentNode) {
                /* make it as a root node and push into the tree */
                node.uid = '0';
                node.nodeMap = {
                    '0': node.id
                };
                tree.push(node);
                return node;
            }

            /*Case: The tree has no children*/
            if (!(parentNode.children) || !(WM.isArray(parentNode.children))) {
                /*Initialize the tree children*/
                parentNode.children = [];
            } else {
                /*Check if a node with the specified id already exists in the tree children and return if found*/
                existingNode = getNode(parentNode.children, nodeId);
                if (existingNode) {
                    return existingNode;
                }
            }
            node.uid = parentNode.uid + '-' + (parentNode.children.length);
            /*Insert the node as a child to the tree and return*/
            parentNode.children.push(node);

            tree[0].nodeMap[node.uid] = nodeId;
            return node;
        }

        function removeJsonNodeChildren(tree, nodeId, parentNodeId) {
            var node = getNodeFromJson(tree, nodeId, parentNodeId);
            /*Check for sanity.*/
            if (node) {
                node.children = undefined;
            }
        }

        function getValidJSON(content) {
            if (!content) {
                return false;
            }
            try {
                /*obtaining json from editor content string*/
                return WM.isObject(content) ? content : JSON.parse(content);
            } catch (e) {
                /*terminating execution if new variable object is not valid json.*/
                return false;
            }
        }

        /* prettify the js content */
        function prettifyJS(content) {
            if (window.js_beautify) {
                return window.js_beautify(content);
            }
            loadScriptsInSync(['_static_/components/js-beautify/js/lib/beautify.js']);
            return window.js_beautify(content);
        }

        /* prettify the html content */
        function prettifyHTML(content) {
            if (window.html_beautify) {
                return window.html_beautify(content);
            }
            loadScriptsInSync(['_static_/components/js-beautify/js/lib/beautify-html.js']);
            return window.html_beautify(content);
        }

        /* prettify the css content */
        function prettifyCSS(content) {
            if (window.css_beautify) {
                return window.css_beautify(content);
            }
            loadScriptsInSync(['_static_/components/js-beautify/js/lib/beautify-css.js']);
            return window.css_beautify(content);
        }

        function getActionFromKey(event) {

            var ctrlOrMetaKey = isAppleProduct ? event.metaKey : event.ctrlKey,
                altKey = event.altKey;
            if (isAppleProduct) {
                if (event.which === 8) {
                    return 'DELETE';
                }
            } else {
                if (event.which === 46) {
                    return 'DELETE';
                }
            }

            if (ctrlOrMetaKey) {
                switch (event.which) {
                case 82:
                    return altKey ? 'RUN' : 'UNKNOWN';
                case 68:
                    return altKey ? 'DEPLOY' : 'UNKNOWN';
                case 83:
                    return 'SAVE';
                case 88:
                    return 'CUT';
                case 67:
                    return 'COPY';
                case 86:
                    return 'PASTE';
                case 90:
                    return event.shiftKey ? 'REDO' : 'UNDO';
                }
            } else {
                switch (event.which) {
                case 13:
                    return 'ENTER';
                case 27:
                    return 'ESC';
                case 38:
                    return 'UP-ARROW';
                case 40:
                    return 'DOWN-ARROW';
                }
            }

            return 'UNKNOWN';
        }

        function preventCachingOf(url) {
            return url;
        }

        function getAllKeysOf(obj, prefix) {
            var keys = [];
            prefix = prefix ? prefix + '.' : '';

            if (WM.isObject(obj) && !WM.isArray(obj)) {
                Object.keys(obj).forEach(function (key) {
                    keys.push(prefix + key);
                    keys = keys.concat(getAllKeysOf(obj[key], prefix + key));
                });
            }
            return keys;
        }

        /* returns the requested service if available */
        function getService(serviceName) {
            if (!serviceName) {
                return;
            }
            /* get a reference to the element where ng-app is defined */
            var appEl = WM.element('[id=ng-app]'), injector;
            if (appEl) {
                try {
                    injector = appEl.injector(); // get the angular injector
                    if (injector) {
                        return injector.get(serviceName); // return the service
                    }
                } catch (e) {
                    return undefined;
                }
            }
        }

        /*removes protocol information from url*/
        function removeProtocol(url) {
            var newUrl;
            if (url.indexOf('http') !== -1) {
                /*Removing the protocol from the url*/
                if (url.indexOf('https:') !== -1) {
                    newUrl = url.substr(6);
                } else {
                    newUrl = url.substr(5);
                }
            } else {
                newUrl = url;
            }
            return newUrl;
        }

        function getCookieByName(name) {
            var cookiesArray = document.cookie.split('; '),
                cookies      = {};

            if (_.some(cookiesArray, function (cookie) {
                    var cookieArray         = cookie.split('=');
                    cookies[cookieArray[0]] = cookieArray[1];

                    if (cookieArray[0] === name) { // break the loop when the required cookie is found
                        return true;
                    }

                })) {
                return decodeURIComponent(cookies[name]);
            }
        }

        /*Function to check whether the specified object is a pageable object or not.*/
        function isPageable(obj) {
            var pageable = {
                'content'         : [],
                'first'           : true,
                'last'            : true,
                'number'          : 0,
                'numberOfElements': 10,
                'size'            : 20,
                'sort'            : null,
                'totalElements'   : 10,
                'totalPages'      : 1
            };
            return (WM.equals(_.keys(pageable), _.keys(obj).sort()));
        }

        /* returns true if HTML5 File API is available else false*/
        function isFileUploadSupported() {
            return (window.File && window.FileReader && window.FileList && window.Blob);
        }

        function processMarkup(markupStr) {
            if (!markupStr) {
                return '';
            }
            markupStr = getValidMarkUp(markupStr);

            var content = markupStr.replace(/>\s+</g, '><'),
                root = WM.element('<div></div>');

            /* wm-livelist and wm-login elements will have ngController directive this will result in
             * error:multidir Multiple Directive Resource Contention
             * to resolve this issue,
             * RunMode: remove the ngController directive from the element and add a wrapper with the controller name
             * StudioMode: remove the ngController directive
             */
            if (APPCONSTANTS.isRunMode) {
                root.html(content).find('wm-livelist, wm-login, wm-template')
                    .each(function () {
                        var widget = WM.element(this),
                            wrapper,
                            ctrlName = widget.attr('data-ng-controller') || widget.attr('ng-controller');

                        if (ctrlName) {
                            wrapper = WM.element('<div class="app-controller"></div>').attr('data-ng-controller', ctrlName);
                            widget.removeAttr('data-ng-controller ng-controller').wrap(wrapper);
                        }
                    });
                content = root[0].innerHTML;
            }

            return content;
        }
        /*Function to get date time types*/
        function getDateTimeTypes() {
            return dateTimeTypes;
        }
        function getDataSetWidgets() {
            return dataSetWidgets;
        }
        /*Function to get days options*/
        function getDaysOptions() {
            return daysOptions;
        }
        /*Function to get date time default formats*/
        function getDateTimeDefaultFormats() {
            return dateTimeDefaultFormats;
        }

        /*Function that checks if the dataset is valid or not*/
        function isValidDataSet(dataset) {
            return ((WM.isArray(dataset) && dataset.length > 0) || (WM.isObject(dataset) && Object.keys(dataset).length > 0));
        }

        /* to generate all individual contents from the combined version(min.html) of the page */
        function parseCombinedPageContent(pageContent, pageName) {
            /*creating a parent for the content & converting to dom-like element, to process the content*/
            var pageDom = WM.element('<div>' + pageContent + '</div>'),
                htmlEle = pageDom.find('script[id="' + pageName + '.html' + '"]'),
                variableContext = '_' + pageName + 'Page_Variables_';
            /* remove the previously loaded styles in studio-mode*/
            if (APPCONSTANTS.isStudioMode) {
                WM.element('script[id="' + pageName + '.css' + '"]').remove();
            }
            try {
                /*load the styles & scripts*/
                WM.element('head').append(pageDom.find('style, script'));
            } catch (e) {
                console.log(e.message);
            }
            return {
                html: htmlEle.html() || '',
                variables: window[variableContext] || {}
            };
        }

        /*
         * extracts and returns the last bit from full typeRef of a field
         * e.g. returns 'String' for typeRef = 'java.lang.String'
         * @params: {typeRef} type reference
         */
        function extractType(typeRef) {
            if (!typeRef) {
                return 'string';
            }
            return typeRef.substring(typeRef.lastIndexOf('.') + 1);
        }

        /* returns true if the provided data type matches number type */
        function isNumberType(type) {
            return (NUMBER_TYPES.indexOf(extractType(type).toLowerCase()) !== -1);
        }

        function isDeleteResourceAllowed(context, path) {
            return (!SYSTEM_FOLDER_PATHS[context] || SYSTEM_FOLDER_PATHS[context].indexOf(path) === -1);
        }

        /*Function to generate a random number*/
        function random() {
            return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
        }

        /*Function to generate a guid based on random numbers.*/
        function generateGUId() {
            return random() + '-' + random() + '-' + random();
        }

        /*to check duplicate names*/
        function isDuplicateName(list, newName, caseSensitive) {
            var retVal = false,
                i;
            /* if list or name doesn't exist, return  */
            if (!list || !newName) {
                return retVal;
            }
            if (caseSensitive) {
                for (i = 0; i < list.length; i += 1) {
                    /* if name found in list, return true */
                    if (list[i].toLowerCase() === newName.toLowerCase()) {
                        retVal = true;
                        break;
                    }
                }
            } else {
                if (list.indexOf(newName) !== -1) {
                    retVal = true;
                }
            }
            return retVal;
        }

        /*
         * scrolls the given element into the visible area of the container.
         * @params: {element} element to be scrolled in to view
         * @params: {container} container of the element
         */
        function scrollIntoView(element, container) {
            var $container = WM.element(container),
                $element = WM.element(element),
                containerTop = $container.scrollTop(),
                containerHeight = $container.height(),
                containerBottom = containerTop + containerHeight,
                elemTop = $element[0] && $element[0].offsetTop,
                elemBottom = elemTop + $element.height();
            if (elemTop < containerTop) {
                $container.scrollTop(elemTop);
            } else if (elemBottom > containerBottom) {
                $container.scrollTop(elemBottom - containerHeight);
            }
        }

        /*function to compare two arrays and check if the contents are equal*/
        function arraysEqual(arr1, arr2) {
            var i;
            if (arr1.length !== arr2.length) {
                return false;
            }
            for (i = 0; i < arr1.length; i++) {
                if (arr1[i] !== arr2[i]) {
                    return false;
                }
            }
            return true;
        }

        /*Iterate over events and populate 'Javascript' with appropriate event name and args*/
        function getNewEventsObject(prefix, events) {
            var newEventName,
                newCustomEvent,
                eventNumber = 0,
                customEvents = [],
                args = '($event, $scope)';
            _.forEach(events, function (event, index) {
                if (event === 'Javascript') {
                    newCustomEvent = prefix;
                    newEventName = newCustomEvent + args;
                    while (_.includes(events, newEventName)) {
                        eventNumber += 1;
                        newCustomEvent = prefix + eventNumber;
                        newEventName = newCustomEvent + args;
                    }
                    events[index] = newEventName;
                    customEvents = customEvents.concat(newCustomEvent);
                }
            });
            return {
                'events' : events,
                'customEvents' : customEvents
            };
        }

        /*
         * Evaluates expression passed and returns corresponding value of object
         * @params: {object} object from which values are extracted
         * @params: {expression} expression to be evaluated
         * @params: {scope} scope of the fucntion called. Used for eval
         */
        function getEvaluatedExprValue(object, expression, scope) {
            return scope.$eval(expression, object);
        }

        //extend jQuery -- referred from jQuery-UI
        $.fn.extend({
            scrollParent: function (includeHidden) {
                var position = this.css('position'),
                    excludeStaticParent = position === 'absolute',
                    overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
                    docHeight = document.body.clientHeight,
                    scrollParent = this.parents().filter(function () {
                        var parent = $(this),
                            hasOverFlowAuto;
                        if (excludeStaticParent && parent.css('position') === 'static') {
                            return false;
                        }
                        hasOverFlowAuto = overflowRegex.test(parent.css('overflow') + parent.css('overflow-y'));
                        return hasOverFlowAuto && this.clientHeight <= docHeight;
                    }).eq(0);

                return position === 'fixed' || !scrollParent.length ? $(this[0].ownerDocument || document) : scrollParent;
            }
        });

        function getProjectResourcePath(projectId) {
            return 'services/projects/' + projectId + '/resources/content/web/';
        }

        function getVariableNameFromExpr(expr) {
            var variableRegex = /^bind:Variables\.(.*)\.dataSet/,
                matchValue = expr.match(variableRegex);
            return matchValue && matchValue[1];
        }

        /**
         * Returns a deep cloned replica of the passed object/array
         * @param object object/array to clone
         * @returns a clone of the passed object
         */
        function getClonedObject(object) {
            return _.cloneDeep(object);
        }
        /*  This function returns date object. If val is undefined it returns invalid date */
        function getValidDateObject(val) {
            if (WM.isDate(val)) {
                return val;
            }
            /*if the value is a timestamp string, convert it to a number*/
            if (!isNaN(val)) {
                val = parseInt(val, 10);
            } else {
                /*if the value is in HH:mm:ss format, it returns a wrong date. So append the date to the given value to get date*/
                if (!(new Date(val).getTime())) {
                    val = new Date().toDateString() + ' ' + val;
                }
            }
            return new Date(moment(val).valueOf());
        }

        /**
         * Returns an object of variable details from given event value
         * @param evtVal new event value
         * @returns an object of variable details
         */
        /*This function will find category for variable chosen and open corresponding variable*/
        function getVariableDetails(evtVal) {
            var variableType,
                variableCategory,
                matchStr,
                VARIABLE_TYPES = {
                    DATA: 'data',
                    CALL: 'call'
                },
                VARIABLE_CATEGORIES = {
                    SERVICE: 'wm.ServiceVariable',
                    LIVE: 'wm.LiveVariable',
                    NAVIGATION: 'wm.NavigationVariable',
                    DEVICE: 'wm.DeviceVariable',
                    NOTIFICATION: 'wm.NotificationVariable'
                },
                NEW_VARIABLE = {
                    SERVICE: 'New ServiceVariable',
                    LIVE: 'New LiveVariable',
                    NAVIGATION: 'New NavigationCall',
                    DEVICE: 'New DeviceVariable',
                    NOTIFICATION: 'New NotificationCall'
                };
            if (_.includes(evtVal, NEW_VARIABLE.SERVICE)) {
                matchStr = NEW_VARIABLE.SERVICE;
                variableType = VARIABLE_TYPES.DATA;
                variableCategory = VARIABLE_CATEGORIES.SERVICE;
            } else if (_.includes(evtVal, NEW_VARIABLE.LIVE)) {
                matchStr = NEW_VARIABLE.LIVE;
                variableType = VARIABLE_TYPES.DATA;
                variableCategory = VARIABLE_CATEGORIES.LIVE;
            } else if (_.includes(evtVal, NEW_VARIABLE.NAVIGATION)) {
                matchStr = NEW_VARIABLE.NAVIGATION;
                variableType = VARIABLE_TYPES.CALL;
                variableCategory = VARIABLE_CATEGORIES.NAVIGATION;
            } else if (_.includes(evtVal, NEW_VARIABLE.NOTIFICATION)) {
                matchStr = NEW_VARIABLE.NOTIFICATION;
                variableType = VARIABLE_TYPES.CALL;
                variableCategory = VARIABLE_CATEGORIES.NOTIFICATION;
            } else if (_.includes(evtVal, NEW_VARIABLE.DEVICE)) {
                matchStr = NEW_VARIABLE.DEVICE;
                variableType = VARIABLE_TYPES.DATA;
                variableCategory = VARIABLE_CATEGORIES.DEVICE;
            }
            evtVal = evtVal.replace(matchStr, '${0}');
            return {
                'type'      : variableType,
                'category'  : variableCategory,
                'evtVal'    : evtVal
            };
        }
        function getMatchModes() {
            return {
                'start'    : 'start',
                'end'      : 'end',
                'anywhere' : 'anywhere',
                'exact'    : 'exact'
            };
        }

        // The bound value is replaced with {{item.fieldname}} here. This is needed by the liveList when compiling inner elements
        function updateTmplAttrs($root, parentDataSet) {

            var _parentDataSet = parentDataSet.replace('bind:', ''),
                regex          = new RegExp('(' + _parentDataSet + ')(\\[0\\])?(.data\\[\\$i\\])?(.content\\[\\$i\\])?(\\[\\$i\\])?', 'g');

            $root.find('*').each(function () {
                var node = this;

                _.forEach(node.attributes, function (attr) {
                    var value = attr.value;

                    if (_.startsWith(value, 'bind:')) {
                        /*if the attribute value is "bind:xxxxx.xxxx", either the dataSet/scopeDataSet has to contain "xxxx.xxxx" */
                        if (_.includes(value, _parentDataSet)) {
                            value = value.replace('bind:', '');
                            value = value.replace(regex, 'item');
                            attr.value = '{{' + value + '}}';
                        }
                    }
                });
            });
        }
        // expose the methods on the service instance.

        this.camelCase                  = WM.element.camelCase;
        this.initCaps                   = initCaps;
        this.firstCaps                  = firstCaps;
        this.periodSeparate             = periodSeparate;
        this.spaceSeparate              = spaceSeparate;
        this.prettifyLabel              = prettifyLabel;
        this.prettifyLabels             = prettifyLabels;
        this.getVariableName            = getVariableName;
        this.getImageUrl                = getImageUrl;
        this.getResourceUrl             = getResourceURL;
        this.formatVariableIconClass    = formatVariableIconClass;
        this.getBackGroundImageUrl      = getBackGroundImageUrl;
        this.getParentOverlayElZIndex   = getParentOverlayElZIndex;
        this.hyphenate                  = hyphenate;
        this.deHyphenate                = deHyphenate;
        this.isAndroid                  = isAndroid;
        this.isAndroidPhone             = isAndroidPhone;
        this.isIphone                   = isIphone;
        this.isIpod                     = isIpod;
        this.isMobile                   = isMobile;
        this.isScriptLoaded             = isScriptLoaded;
        this.isValidJavaPackageName     = isValidJavaPackageName;
        this.isValidHtml                = isValidHtml;
        this.isQuoteNotPresent          = isQuoteNotPresent;
        this.stringStartsWith           = stringStartsWith;
        this.stringEndsWith             = stringEndsWith;
        this.isStyleSheetLoaded         = isStyleSheetLoaded;
        this.isValidWebURL              = isValidWebURL;
        this.loadScripts                = loadScripts;
        this.loadStyleSheets            = loadStyleSheets;
        this.loadStyleSheet             = loadStyleSheet;
        this.prepareFieldDefs           = prepareFieldDefs;
        this.prettifyCSS                = prettifyCSS;
        this.prettifyHTML               = prettifyHTML;
        this.prettifyJS                 = prettifyJS;
        this.swapArrayElements          = swapArrayElements;
        this.swapProperties             = swapProperties;
        this.triggerFn                  = triggerFn;
        this.isEmptyObject              = isEmptyObject;
        this.isValidEmail               = isValidEmail;
        this.isValidPassword            = isValidPassword;
        this.resetObjectWithEmptyValues = resetObjectWithEmptyValues;
        this.isImageFile                = isImageFile;
        this.isZipFile                  = isZipFile;
        this.isExeFile                  = isExeFile;
        this.isTextLikeFile             = isTextLikeFile;
        this.isAudioFile                = isAudioFile;
        this.isVideoFile                = isVideoFile;
        this.isPageResource             = isPageResource;
        this.findValueOf                = findValueOf;
        this.replace                    = replace;
        this.removeStyleSheetLoaded     = removeStyleSheetLoaded;
        this.fileUploadFallback         = fileUploadFallback;
        this.getCurrentPage             = getCurrentPage;
        this.isDebugMode                = isDebugMode;
        this.getIndexPage               = getIndexPage;
        this.redirectToIndexPage        = redirectToIndexPage;
        this.redirectToLoginPage        = redirectToLoginPage;
        this.browserStorage             = browserStorage;
        this.fetchPropertiesMapColumns  = fetchPropertiesMapColumns;
        this.getLoadedPrefabNames       = getLoadedPrefabNames;
        this.initializeAction           = initializeAction;
        this.addNodeToJson              = addNodeToJson;
        this.getNodeFromJson            = getNodeFromJson;
        this.removeJsonNodeChildren     = removeJsonNodeChildren;
        this.isIE                       = isIE;
        this.isIE9                       = isIE9;
        this.isIE11                     = isIE11;
        this.getValidJSON               = getValidJSON;
        this.getActionFromKey           = getActionFromKey;
        this.preventCachingOf           = preventCachingOf;
        this.getAllKeysOf               = getAllKeysOf;
        this.fetchContent               = fetchContent;
        this.getService                 = getService;
        this.removeProtocol             = removeProtocol;
        this.getCookieByName            = getCookieByName;
        this.isPageable                 = isPageable;
        this.isNumberType               = isNumberType;
        this.isFileUploadSupported      = isFileUploadSupported;
        this.processMarkup              = processMarkup;
        this.getDateTimeTypes           = getDateTimeTypes;
        this.getDataSetWidgets          = getDataSetWidgets;
        this.getDaysOptions             = getDaysOptions;
        this.getDateTimeDefaultFormats  = getDateTimeDefaultFormats;
        this.isValidDataSet             = isValidDataSet;
        this.parseCombinedPageContent   = parseCombinedPageContent;
        this.extractType                = extractType;
        this.isDeleteResourceAllowed    = isDeleteResourceAllowed;
        this.generateGUId               = generateGUId;
        this.isDuplicateName            = isDuplicateName;
        this.getValidMarkUp             = getValidMarkUp;
        this.scrollIntoView             = scrollIntoView;
        this.arraysEqual                = arraysEqual;
        this.getNewEventsObject         = getNewEventsObject;
        this.getEvaluatedExprValue      = getEvaluatedExprValue;
        this.getProjectResourcePath     = getProjectResourcePath;
        this.getVariableNameFromExpr    = getVariableNameFromExpr;
        this.getClonedObject            = getClonedObject;
        this.getValidDateObject         = getValidDateObject;
        this.getVariableDetails         = getVariableDetails;
        this.getMatchModes              = getMatchModes;
        this.updateTmplAttrs            = updateTmplAttrs;
    }]);

/*global WM, moment*/

WM.module('wm.utils')
    .config(['$filterProvider', function ($filterProvider) {
        'use strict';
        WM.module('wm.utils').$filter = $filterProvider.register;
    }])
    .service('DataFormatService', [
        '$filter',
        'CURRENCYCONSTANTS',

        function ($filter, CURRENCYCONSTANTS) {
            'use strict';

            var DATE_PATTERNS = ['yyyy-MM-dd', 'yyyy-M-dd', 'M-dd-yyyy', 'MM-dd-yy', 'yyyy, dd MMMM', 'yyyy, MMM dd', 'MM/dd/yyyy', 'M/d/yyyy', 'EEE, dd MMM yyyy', 'EEE MMM dd yyyy', 'EEEE, MMMM dd, yyyy', "timestamp"],
                DATE_TIME_PATTERNS = ["dd/MM/yyyy", "yyyy-MM-dd", "yyyy-M-dd", "M-dd-yyyy", "M/d/yyyy", "MM/dd/yyyy", "yyyy, MMM dd", "yyyy, dd MMMM", "yyyy-MM-ddTHH:mm:ss", "MM-dd-yy hh:mm:ss a", "MM-dd-yy hh:mm:ss a Z", "dd-MMM-yyyy HH:mm:ss", "yyyy-MM-dd HH:mm", "yyyy-MM-dd HH:mm:ss:sss", "yyyy-MM-dd hh:mm a", "yyyy-MM-dd hh:mm:ss a", "yyyy-MM-dd hh:mm:ss:sss Z", "yyyy-MM-dd hh:mm:ss:sss a", "EEE MMM dd hh:mm:ss Z yyyy", "EEE, dd MMM yyyy HH:mm:ss Z", "EEEE, MMMM dd, yyyy", "timestamp"],
                TIME_PATTERNS = ['HH:mm:ss', 'HH:mm', 'hh:mm:ss', 'hh:mm', 'hh:mm a', 'H:m:s', 'h:m:s', 'timestamp'],
                CURRENCY_OPTIONS = ["AED", "AFN", "ALL", "AMD", "ARS", "AUD", "AZN", "BAM", "BDT", "BGN", "BHD", "BIF", "BND", "BOB", "BRL", "BWP", "BYR", "BZD", "CAD", "CDF", "CHF", "CLP", "CNY", "COP", "CRC", "CVE", "CZK", "DJF", "DKK", "DOP", "DZD", "EEK", "EGP", "ERN", "ETB", "EUR", "GBP", "GEL", "GHS", "GNF", "GTQ", "HKD", "HNL", "HRK", "HUF", "IDR", "ILS", "INR", "IQD", "IRR", "ISK", "JMD", "JOD", "JPY", "KES", "KHR", "KMF", "KRW", "KWD", "KZT", "LBP", "LKR", "LTL", "LVL", "LYD", "MAD", "MDL", "MGA", "MKD", "MMK", "MOP", "MUR", "MXN", "MYR", "MZN", "NAD", "NGN", "NIO", "NOK", "NPR", "NZD", "OMR", "PAB", "PEN", "PHP", "PKR", "PLN", "PYG", "QAR", "RON", "RSD", "RUB", "RWF", "SAR", "SDG", "SEK", "SGD", "SOS", "SYP", "THB", "TND", "TOP", "TRY", "TTD", "TWD", "TZS", "UAH", "UGX", "USD", "UYU", "UZS", "VEF", "VND", "XAF", "XOF", "YER", "ZAR", "ZMK"],
                FORMAT_OPTIONS = ["toDate", "toCurrency", "prefix", "suffix", "toNumber", "None"],
                customFilters = {};
            function getDateTimePatterns() {
                return DATE_TIME_PATTERNS;
            }
            function getDatePatterns() {
                return DATE_PATTERNS;
            }
            function getTimePatterns() {
                return TIME_PATTERNS;
            }
            function getCurrencyOptions() {
                return CURRENCY_OPTIONS;
            }
            function getFormatPatterns() {
                return FORMAT_OPTIONS;
            }
            /* converts given string to number */
            function string2number(data, fracSize) {
                return $filter('number')(data, fracSize);
            }

            /* converts given number to currency */
            function number2currency(data, currencySymbol, fractionSize) {
                var _sym = currencySymbol || '',
                    _val = string2number(data, fractionSize);

                return _val ? _sym + _val : '';
            }

            /* converts epoch or date object to date-string in the given format */
            function toDate(data, format) {
                var timestamp;
                /* 'null' is to be treated as a special case, If user wants to enter null value, empty string will be passed to the backend */
                if (data === 'null') {
                    return '';
                }
                if (!WM.isDefined(data)) {
                    return undefined;
                }
                if (!isNaN(data)) {
                    data = parseInt(data, 10);
                }
                /*get the timestamp value. If data is time string, append date string to the time value*/
                timestamp = moment(data).valueOf() || moment(new Date().toDateString() + ' ' + data).valueOf();
                if (timestamp) {
                    if (format === 'timestamp') {
                        return timestamp;
                    }
                    return $filter('date')(timestamp, format);
                }
                return undefined;
            }

            /* converts given input to string */
            function toNumber(data, fracSize) {
                return string2number(data, fracSize);
            }

            /* converts given input to currency */
            function toCurrency(data, currencySymbol, fracSize) {
                var _currencySymbol = (CURRENCYCONSTANTS[currencySymbol] || {}).symbol || currencySymbol;
                return number2currency(data, _currencySymbol, fracSize);
            }

            /* padding string will be added to the left of the data */
            function lpad(data, padding) {
                return data ? padding + data : padding;
            }

            /* padding string will be added to the right of the data */
            function rpad(data, padding) {
                return data ? data + padding : padding;
            }

            function prefix(data, padding) {
                return data ? padding + data : padding;
            }

            /* padding string will be added to the right of the data */
            function suffix(data, padding) {
                return data ? data + padding : padding;
            }

            /* register a formatter/filter */
            function register(formatterName, formatterFn) {
                WM.module('wm.utils').$filter(formatterName, formatterFn);
            }

            customFilters.toDate = toDate;
            customFilters.toNumber = toNumber;
            customFilters.toCurrency = toCurrency;
            customFilters.lpad = lpad;
            customFilters.rpad = rpad;
            customFilters.prefix = prefix;
            customFilters.suffix = suffix;

            Object.keys(customFilters).forEach(function (filterName) {
                WM.module('wm.utils').$filter(filterName, function () {
                    return customFilters[filterName];
                });
            });

            /* expose the register method on service */
            this.register = register;
            /*Getter for date time patterns*/
            this.getDateTimePatterns = getDateTimePatterns;
            this.getDatePatterns = getDatePatterns;
            this.getTimePatterns = getTimePatterns;
            this.getCurrencyOptions = getCurrencyOptions;
            this.getFormatPatterns = getFormatPatterns;
        }
    ])
    .constant('CURRENCYCONSTANTS', {
        "USD": {
            "symbol": "$",
            "name": "US Dollar",
            "symbol_native": "$",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "USD",
            "name_plural": "US dollars"
        },
        "CAD": {
            "symbol": "CA$",
            "name": "Canadian Dollar",
            "symbol_native": "$",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "CAD",
            "name_plural": "Canadian dollars"
        },
        "EUR": {
            "symbol": "",
            "name": "Euro",
            "symbol_native": "",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "EUR",
            "name_plural": "euros"
        },
        "AED": {
            "symbol": "AED",
            "name": "United Arab Emirates Dirham",
            "symbol_native": "..",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "AED",
            "name_plural": "UAE dirhams"
        },
        "AFN": {
            "symbol": "Af",
            "name": "Afghan Afghani",
            "symbol_native": "",
            "decimal_digits": 0,
            "rounding": 0,
            "code": "AFN",
            "name_plural": "Afghan Afghanis"
        },
        "ALL": {
            "symbol": "ALL",
            "name": "Albanian Lek",
            "symbol_native": "Lek",
            "decimal_digits": 0,
            "rounding": 0,
            "code": "ALL",
            "name_plural": "Albanian lek"
        },
        "AMD": {
            "symbol": "AMD",
            "name": "Armenian Dram",
            "symbol_native": ".",
            "decimal_digits": 0,
            "rounding": 0,
            "code": "AMD",
            "name_plural": "Armenian drams"
        },
        "ARS": {
            "symbol": "AR$",
            "name": "Argentine Peso",
            "symbol_native": "$",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "ARS",
            "name_plural": "Argentine pesos"
        },
        "AUD": {
            "symbol": "AU$",
            "name": "Australian Dollar",
            "symbol_native": "$",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "AUD",
            "name_plural": "Australian dollars"
        },
        "AZN": {
            "symbol": "man.",
            "name": "Azerbaijani Manat",
            "symbol_native": ".",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "AZN",
            "name_plural": "Azerbaijani manats"
        },
        "BAM": {
            "symbol": "KM",
            "name": "Bosnia-Herzegovina Convertible Mark",
            "symbol_native": "KM",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "BAM",
            "name_plural": "Bosnia-Herzegovina convertible marks"
        },
        "BDT": {
            "symbol": "Tk",
            "name": "Bangladeshi Taka",
            "symbol_native": "",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "BDT",
            "name_plural": "Bangladeshi takas"
        },
        "BGN": {
            "symbol": "BGN",
            "name": "Bulgarian Lev",
            "symbol_native": ".",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "BGN",
            "name_plural": "Bulgarian leva"
        },
        "BHD": {
            "symbol": "BD",
            "name": "Bahraini Dinar",
            "symbol_native": "..",
            "decimal_digits": 3,
            "rounding": 0,
            "code": "BHD",
            "name_plural": "Bahraini dinars"
        },
        "BIF": {
            "symbol": "FBu",
            "name": "Burundian Franc",
            "symbol_native": "FBu",
            "decimal_digits": 0,
            "rounding": 0,
            "code": "BIF",
            "name_plural": "Burundian francs"
        },
        "BND": {
            "symbol": "BN$",
            "name": "Brunei Dollar",
            "symbol_native": "$",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "BND",
            "name_plural": "Brunei dollars"
        },
        "BOB": {
            "symbol": "Bs",
            "name": "Bolivian Boliviano",
            "symbol_native": "Bs",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "BOB",
            "name_plural": "Bolivian bolivianos"
        },
        "BRL": {
            "symbol": "R$",
            "name": "Brazilian Real",
            "symbol_native": "R$",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "BRL",
            "name_plural": "Brazilian reals"
        },
        "BWP": {
            "symbol": "BWP",
            "name": "Botswanan Pula",
            "symbol_native": "P",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "BWP",
            "name_plural": "Botswanan pulas"
        },
        "BYR": {
            "symbol": "BYR",
            "name": "Belarusian Ruble",
            "symbol_native": "BYR",
            "decimal_digits": 0,
            "rounding": 0,
            "code": "BYR",
            "name_plural": "Belarusian rubles"
        },
        "BZD": {
            "symbol": "BZ$",
            "name": "Belize Dollar",
            "symbol_native": "$",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "BZD",
            "name_plural": "Belize dollars"
        },
        "CDF": {
            "symbol": "CDF",
            "name": "Congolese Franc",
            "symbol_native": "FrCD",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "CDF",
            "name_plural": "Congolese francs"
        },
        "CHF": {
            "symbol": "CHF",
            "name": "Swiss Franc",
            "symbol_native": "CHF",
            "decimal_digits": 2,
            "rounding": 0.05,
            "code": "CHF",
            "name_plural": "Swiss francs"
        },
        "CLP": {
            "symbol": "CL$",
            "name": "Chilean Peso",
            "symbol_native": "$",
            "decimal_digits": 0,
            "rounding": 0,
            "code": "CLP",
            "name_plural": "Chilean pesos"
        },
        "CNY": {
            "symbol": "CN",
            "name": "Chinese Yuan",
            "symbol_native": "CN",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "CNY",
            "name_plural": "Chinese yuan"
        },
        "COP": {
            "symbol": "CO$",
            "name": "Colombian Peso",
            "symbol_native": "$",
            "decimal_digits": 0,
            "rounding": 0,
            "code": "COP",
            "name_plural": "Colombian pesos"
        },
        "CRC": {
            "symbol": "",
            "name": "Costa Rican Coln",
            "symbol_native": "",
            "decimal_digits": 0,
            "rounding": 0,
            "code": "CRC",
            "name_plural": "Costa Rican colns"
        },
        "CVE": {
            "symbol": "CV$",
            "name": "Cape Verdean Escudo",
            "symbol_native": "CV$",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "CVE",
            "name_plural": "Cape Verdean escudos"
        },
        "CZK": {
            "symbol": "K",
            "name": "Czech Republic Koruna",
            "symbol_native": "K",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "CZK",
            "name_plural": "Czech Republic korunas"
        },
        "DJF": {
            "symbol": "Fdj",
            "name": "Djiboutian Franc",
            "symbol_native": "Fdj",
            "decimal_digits": 0,
            "rounding": 0,
            "code": "DJF",
            "name_plural": "Djiboutian francs"
        },
        "DKK": {
            "symbol": "Dkr",
            "name": "Danish Krone",
            "symbol_native": "kr",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "DKK",
            "name_plural": "Danish kroner"
        },
        "DOP": {
            "symbol": "RD$",
            "name": "Dominican Peso",
            "symbol_native": "RD$",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "DOP",
            "name_plural": "Dominican pesos"
        },
        "DZD": {
            "symbol": "DA",
            "name": "Algerian Dinar",
            "symbol_native": "..",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "DZD",
            "name_plural": "Algerian dinars"
        },
        "EEK": {
            "symbol": "Ekr",
            "name": "Estonian Kroon",
            "symbol_native": "kr",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "EEK",
            "name_plural": "Estonian kroons"
        },
        "EGP": {
            "symbol": "EGP",
            "name": "Egyptian Pound",
            "symbol_native": "..",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "EGP",
            "name_plural": "Egyptian pounds"
        },
        "ERN": {
            "symbol": "Nfk",
            "name": "Eritrean Nakfa",
            "symbol_native": "Nfk",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "ERN",
            "name_plural": "Eritrean nakfas"
        },
        "ETB": {
            "symbol": "Br",
            "name": "Ethiopian Birr",
            "symbol_native": "Br",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "ETB",
            "name_plural": "Ethiopian birrs"
        },
        "GBP": {
            "symbol": "",
            "name": "British Pound Sterling",
            "symbol_native": "",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "GBP",
            "name_plural": "British pounds sterling"
        },
        "GEL": {
            "symbol": "GEL",
            "name": "Georgian Lari",
            "symbol_native": "GEL",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "GEL",
            "name_plural": "Georgian laris"
        },
        "GHS": {
            "symbol": "GH",
            "name": "Ghanaian Cedi",
            "symbol_native": "GH",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "GHS",
            "name_plural": "Ghanaian cedis"
        },
        "GNF": {
            "symbol": "FG",
            "name": "Guinean Franc",
            "symbol_native": "FG",
            "decimal_digits": 0,
            "rounding": 0,
            "code": "GNF",
            "name_plural": "Guinean francs"
        },
        "GTQ": {
            "symbol": "GTQ",
            "name": "Guatemalan Quetzal",
            "symbol_native": "Q",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "GTQ",
            "name_plural": "Guatemalan quetzals"
        },
        "HKD": {
            "symbol": "HK$",
            "name": "Hong Kong Dollar",
            "symbol_native": "$",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "HKD",
            "name_plural": "Hong Kong dollars"
        },
        "HNL": {
            "symbol": "HNL",
            "name": "Honduran Lempira",
            "symbol_native": "L",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "HNL",
            "name_plural": "Honduran lempiras"
        },
        "HRK": {
            "symbol": "kn",
            "name": "Croatian Kuna",
            "symbol_native": "kn",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "HRK",
            "name_plural": "Croatian kunas"
        },
        "HUF": {
            "symbol": "Ft",
            "name": "Hungarian Forint",
            "symbol_native": "Ft",
            "decimal_digits": 0,
            "rounding": 0,
            "code": "HUF",
            "name_plural": "Hungarian forints"
        },
        "IDR": {
            "symbol": "Rp",
            "name": "Indonesian Rupiah",
            "symbol_native": "Rp",
            "decimal_digits": 0,
            "rounding": 0,
            "code": "IDR",
            "name_plural": "Indonesian rupiahs"
        },
        "ILS": {
            "symbol": "",
            "name": "Israeli New Sheqel",
            "symbol_native": "",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "ILS",
            "name_plural": "Israeli new sheqels"
        },
        "INR": {
            "symbol": "",
            "name": "Indian Rupee",
            "symbol_native": "",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "INR",
            "name_plural": "Indian rupees"
        },
        "IQD": {
            "symbol": "IQD",
            "name": "Iraqi Dinar",
            "symbol_native": "..",
            "decimal_digits": 0,
            "rounding": 0,
            "code": "IQD",
            "name_plural": "Iraqi dinars"
        },
        "IRR": {
            "symbol": "IRR",
            "name": "Iranian Rial",
            "symbol_native": "",
            "decimal_digits": 0,
            "rounding": 0,
            "code": "IRR",
            "name_plural": "Iranian rials"
        },
        "ISK": {
            "symbol": "Ikr",
            "name": "Icelandic Krna",
            "symbol_native": "kr",
            "decimal_digits": 0,
            "rounding": 0,
            "code": "ISK",
            "name_plural": "Icelandic krnur"
        },
        "JMD": {
            "symbol": "J$",
            "name": "Jamaican Dollar",
            "symbol_native": "$",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "JMD",
            "name_plural": "Jamaican dollars"
        },
        "JOD": {
            "symbol": "JD",
            "name": "Jordanian Dinar",
            "symbol_native": "..",
            "decimal_digits": 3,
            "rounding": 0,
            "code": "JOD",
            "name_plural": "Jordanian dinars"
        },
        "JPY": {
            "symbol": "",
            "name": "Japanese Yen",
            "symbol_native": "",
            "decimal_digits": 0,
            "rounding": 0,
            "code": "JPY",
            "name_plural": "Japanese yen"
        },
        "KES": {
            "symbol": "Ksh",
            "name": "Kenyan Shilling",
            "symbol_native": "Ksh",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "KES",
            "name_plural": "Kenyan shillings"
        },
        "KHR": {
            "symbol": "KHR",
            "name": "Cambodian Riel",
            "symbol_native": "",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "KHR",
            "name_plural": "Cambodian riels"
        },
        "KMF": {
            "symbol": "CF",
            "name": "Comorian Franc",
            "symbol_native": "FC",
            "decimal_digits": 0,
            "rounding": 0,
            "code": "KMF",
            "name_plural": "Comorian francs"
        },
        "KRW": {
            "symbol": "",
            "name": "South Korean Won",
            "symbol_native": "",
            "decimal_digits": 0,
            "rounding": 0,
            "code": "KRW",
            "name_plural": "South Korean won"
        },
        "KWD": {
            "symbol": "KD",
            "name": "Kuwaiti Dinar",
            "symbol_native": "..",
            "decimal_digits": 3,
            "rounding": 0,
            "code": "KWD",
            "name_plural": "Kuwaiti dinars"
        },
        "KZT": {
            "symbol": "KZT",
            "name": "Kazakhstani Tenge",
            "symbol_native": ".",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "KZT",
            "name_plural": "Kazakhstani tenges"
        },
        "LBP": {
            "symbol": "LB",
            "name": "Lebanese Pound",
            "symbol_native": "..",
            "decimal_digits": 0,
            "rounding": 0,
            "code": "LBP",
            "name_plural": "Lebanese pounds"
        },
        "LKR": {
            "symbol": "SLRs",
            "name": "Sri Lankan Rupee",
            "symbol_native": "SL Re",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "LKR",
            "name_plural": "Sri Lankan rupees"
        },
        "LTL": {
            "symbol": "Lt",
            "name": "Lithuanian Litas",
            "symbol_native": "Lt",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "LTL",
            "name_plural": "Lithuanian litai"
        },
        "LVL": {
            "symbol": "Ls",
            "name": "Latvian Lats",
            "symbol_native": "Ls",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "LVL",
            "name_plural": "Latvian lati"
        },
        "LYD": {
            "symbol": "LD",
            "name": "Libyan Dinar",
            "symbol_native": "..",
            "decimal_digits": 3,
            "rounding": 0,
            "code": "LYD",
            "name_plural": "Libyan dinars"
        },
        "MAD": {
            "symbol": "MAD",
            "name": "Moroccan Dirham",
            "symbol_native": "..",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "MAD",
            "name_plural": "Moroccan dirhams"
        },
        "MDL": {
            "symbol": "MDL",
            "name": "Moldovan Leu",
            "symbol_native": "MDL",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "MDL",
            "name_plural": "Moldovan lei"
        },
        "MGA": {
            "symbol": "MGA",
            "name": "Malagasy Ariary",
            "symbol_native": "MGA",
            "decimal_digits": 0,
            "rounding": 0,
            "code": "MGA",
            "name_plural": "Malagasy Ariaries"
        },
        "MKD": {
            "symbol": "MKD",
            "name": "Macedonian Denar",
            "symbol_native": "MKD",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "MKD",
            "name_plural": "Macedonian denari"
        },
        "MMK": {
            "symbol": "MMK",
            "name": "Myanma Kyat",
            "symbol_native": "K",
            "decimal_digits": 0,
            "rounding": 0,
            "code": "MMK",
            "name_plural": "Myanma kyats"
        },
        "MOP": {
            "symbol": "MOP$",
            "name": "Macanese Pataca",
            "symbol_native": "MOP$",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "MOP",
            "name_plural": "Macanese patacas"
        },
        "MUR": {
            "symbol": "MURs",
            "name": "Mauritian Rupee",
            "symbol_native": "MURs",
            "decimal_digits": 0,
            "rounding": 0,
            "code": "MUR",
            "name_plural": "Mauritian rupees"
        },
        "MXN": {
            "symbol": "MX$",
            "name": "Mexican Peso",
            "symbol_native": "$",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "MXN",
            "name_plural": "Mexican pesos"
        },
        "MYR": {
            "symbol": "RM",
            "name": "Malaysian Ringgit",
            "symbol_native": "RM",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "MYR",
            "name_plural": "Malaysian ringgits"
        },
        "MZN": {
            "symbol": "MTn",
            "name": "Mozambican Metical",
            "symbol_native": "MTn",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "MZN",
            "name_plural": "Mozambican meticals"
        },
        "NAD": {
            "symbol": "N$",
            "name": "Namibian Dollar",
            "symbol_native": "N$",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "NAD",
            "name_plural": "Namibian dollars"
        },
        "NGN": {
            "symbol": "",
            "name": "Nigerian Naira",
            "symbol_native": "",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "NGN",
            "name_plural": "Nigerian nairas"
        },
        "NIO": {
            "symbol": "C$",
            "name": "Nicaraguan Crdoba",
            "symbol_native": "C$",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "NIO",
            "name_plural": "Nicaraguan crdobas"
        },
        "NOK": {
            "symbol": "Nkr",
            "name": "Norwegian Krone",
            "symbol_native": "kr",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "NOK",
            "name_plural": "Norwegian kroner"
        },
        "NPR": {
            "symbol": "NPRs",
            "name": "Nepalese Rupee",
            "symbol_native": "",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "NPR",
            "name_plural": "Nepalese rupees"
        },
        "NZD": {
            "symbol": "NZ$",
            "name": "New Zealand Dollar",
            "symbol_native": "$",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "NZD",
            "name_plural": "New Zealand dollars"
        },
        "OMR": {
            "symbol": "OMR",
            "name": "Omani Rial",
            "symbol_native": "..",
            "decimal_digits": 3,
            "rounding": 0,
            "code": "OMR",
            "name_plural": "Omani rials"
        },
        "PAB": {
            "symbol": "B/.",
            "name": "Panamanian Balboa",
            "symbol_native": "B/.",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "PAB",
            "name_plural": "Panamanian balboas"
        },
        "PEN": {
            "symbol": "S/.",
            "name": "Peruvian Nuevo Sol",
            "symbol_native": "S/.",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "PEN",
            "name_plural": "Peruvian nuevos soles"
        },
        "PHP": {
            "symbol": "",
            "name": "Philippine Peso",
            "symbol_native": "",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "PHP",
            "name_plural": "Philippine pesos"
        },
        "PKR": {
            "symbol": "PKRs",
            "name": "Pakistani Rupee",
            "symbol_native": "",
            "decimal_digits": 0,
            "rounding": 0,
            "code": "PKR",
            "name_plural": "Pakistani rupees"
        },
        "PLN": {
            "symbol": "z",
            "name": "Polish Zloty",
            "symbol_native": "z",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "PLN",
            "name_plural": "Polish zlotys"
        },
        "PYG": {
            "symbol": "",
            "name": "Paraguayan Guarani",
            "symbol_native": "",
            "decimal_digits": 0,
            "rounding": 0,
            "code": "PYG",
            "name_plural": "Paraguayan guaranis"
        },
        "QAR": {
            "symbol": "QR",
            "name": "Qatari Rial",
            "symbol_native": "..",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "QAR",
            "name_plural": "Qatari rials"
        },
        "RON": {
            "symbol": "RON",
            "name": "Romanian Leu",
            "symbol_native": "RON",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "RON",
            "name_plural": "Romanian lei"
        },
        "RSD": {
            "symbol": "din.",
            "name": "Serbian Dinar",
            "symbol_native": ".",
            "decimal_digits": 0,
            "rounding": 0,
            "code": "RSD",
            "name_plural": "Serbian dinars"
        },
        "RUB": {
            "symbol": "RUB",
            "name": "Russian Ruble",
            "symbol_native": ".",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "RUB",
            "name_plural": "Russian rubles"
        },
        "RWF": {
            "symbol": "RWF",
            "name": "Rwandan Franc",
            "symbol_native": "FR",
            "decimal_digits": 0,
            "rounding": 0,
            "code": "RWF",
            "name_plural": "Rwandan francs"
        },
        "SAR": {
            "symbol": "SR",
            "name": "Saudi Riyal",
            "symbol_native": "..",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "SAR",
            "name_plural": "Saudi riyals"
        },
        "SDG": {
            "symbol": "SDG",
            "name": "Sudanese Pound",
            "symbol_native": "SDG",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "SDG",
            "name_plural": "Sudanese pounds"
        },
        "SEK": {
            "symbol": "Skr",
            "name": "Swedish Krona",
            "symbol_native": "kr",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "SEK",
            "name_plural": "Swedish kronor"
        },
        "SGD": {
            "symbol": "S$",
            "name": "Singapore Dollar",
            "symbol_native": "$",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "SGD",
            "name_plural": "Singapore dollars"
        },
        "SOS": {
            "symbol": "Ssh",
            "name": "Somali Shilling",
            "symbol_native": "Ssh",
            "decimal_digits": 0,
            "rounding": 0,
            "code": "SOS",
            "name_plural": "Somali shillings"
        },
        "SYP": {
            "symbol": "SY",
            "name": "Syrian Pound",
            "symbol_native": "..",
            "decimal_digits": 0,
            "rounding": 0,
            "code": "SYP",
            "name_plural": "Syrian pounds"
        },
        "THB": {
            "symbol": "",
            "name": "Thai Baht",
            "symbol_native": "",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "THB",
            "name_plural": "Thai baht"
        },
        "TND": {
            "symbol": "DT",
            "name": "Tunisian Dinar",
            "symbol_native": "..",
            "decimal_digits": 3,
            "rounding": 0,
            "code": "TND",
            "name_plural": "Tunisian dinars"
        },
        "TOP": {
            "symbol": "T$",
            "name": "Tongan Paanga",
            "symbol_native": "T$",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "TOP",
            "name_plural": "Tongan paanga"
        },
        "TRY": {
            "symbol": "TL",
            "name": "Turkish Lira",
            "symbol_native": "TL",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "TRY",
            "name_plural": "Turkish Lira"
        },
        "TTD": {
            "symbol": "TT$",
            "name": "Trinidad and Tobago Dollar",
            "symbol_native": "$",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "TTD",
            "name_plural": "Trinidad and Tobago dollars"
        },
        "TWD": {
            "symbol": "NT$",
            "name": "New Taiwan Dollar",
            "symbol_native": "NT$",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "TWD",
            "name_plural": "New Taiwan dollars"
        },
        "TZS": {
            "symbol": "TSh",
            "name": "Tanzanian Shilling",
            "symbol_native": "TSh",
            "decimal_digits": 0,
            "rounding": 0,
            "code": "TZS",
            "name_plural": "Tanzanian shillings"
        },
        "UAH": {
            "symbol": "",
            "name": "Ukrainian Hryvnia",
            "symbol_native": "",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "UAH",
            "name_plural": "Ukrainian hryvnias"
        },
        "UGX": {
            "symbol": "USh",
            "name": "Ugandan Shilling",
            "symbol_native": "USh",
            "decimal_digits": 0,
            "rounding": 0,
            "code": "UGX",
            "name_plural": "Ugandan shillings"
        },
        "UYU": {
            "symbol": "$U",
            "name": "Uruguayan Peso",
            "symbol_native": "$",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "UYU",
            "name_plural": "Uruguayan pesos"
        },
        "UZS": {
            "symbol": "UZS",
            "name": "Uzbekistan Som",
            "symbol_native": "UZS",
            "decimal_digits": 0,
            "rounding": 0,
            "code": "UZS",
            "name_plural": "Uzbekistan som"
        },
        "VEF": {
            "symbol": "Bs.F.",
            "name": "Venezuelan Bolvar",
            "symbol_native": "Bs.F.",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "VEF",
            "name_plural": "Venezuelan bolvars"
        },
        "VND": {
            "symbol": "",
            "name": "Vietnamese Dong",
            "symbol_native": "",
            "decimal_digits": 0,
            "rounding": 0,
            "code": "VND",
            "name_plural": "Vietnamese dong"
        },
        "XAF": {
            "symbol": "FCFA",
            "name": "CFA Franc BEAC",
            "symbol_native": "FCFA",
            "decimal_digits": 0,
            "rounding": 0,
            "code": "XAF",
            "name_plural": "CFA francs BEAC"
        },
        "XOF": {
            "symbol": "CFA",
            "name": "CFA Franc BCEAO",
            "symbol_native": "CFA",
            "decimal_digits": 0,
            "rounding": 0,
            "code": "XOF",
            "name_plural": "CFA francs BCEAO"
        },
        "YER": {
            "symbol": "YR",
            "name": "Yemeni Rial",
            "symbol_native": "..",
            "decimal_digits": 0,
            "rounding": 0,
            "code": "YER",
            "name_plural": "Yemeni rials"
        },
        "ZAR": {
            "symbol": "R",
            "name": "South African Rand",
            "symbol_native": "R",
            "decimal_digits": 2,
            "rounding": 0,
            "code": "ZAR",
            "name_plural": "South African rand"
        },
        "ZMK": {
            "symbol": "ZK",
            "name": "Zambian Kwacha",
            "symbol_native": "ZK",
            "decimal_digits": 0,
            "rounding": 0,
            "code": "ZMK",
            "name_plural": "Zambian kwachas"
        }
    });

/*global WM, moment, _, confirm*/

/**
 * @ngdoc service
 * @name wm.widgets.live.LiveWidgetUtils
 * @requires Utils
 * The `LiveWidgetUtils` service provides utility methods for Live widgets.
 */
WM.module('wm.widgets.live')
    .service('LiveWidgetUtils', [
        'Utils',
        '$rootScope',
        'FormWidgetUtils',
        'PropertiesFactory',
        '$compile',
        '$liveVariable',

        function (Utils, $rs, FormWidgetUtils, PropertiesFactory, $compile, $liveVariable) {
            'use strict';
            var keyEventsWidgets = ['number', 'text', 'select', 'password', 'textarea'],
                eventTypes = ['onChange', 'onBlur', 'onFocus', 'onMouseleave', 'onMouseenter', 'onClick'],
                allEventTypes = eventTypes.concat('onKeypress', 'onKeydown', 'onKeyup'),
                defaultNgClassesConfig = {'className': '', 'condition': ''};
            /**
             * @ngdoc function
             * @name wm.widgets.live.LiveWidgetUtils#formatBooleanValue
             * @methodOf wm.widgets.live.LiveWidgetUtils
             * @function
             *
             * @description
             * return the formatted boolean value
             *
             * @param {string} value value to be formatted
             */
            function formatBooleanValue(value) {
                if (value === 'true') {
                    return true;
                }
                if (value === 'false') {
                    return false;
                }
                return value;
            }

            /**
             * @ngdoc function
             * @name wm.widgets.live.LiveWidgetUtils#getEventTypes
             * @methodOf wm.widgets.live.LiveWidgetUtils
             * @function
             *
             * @description
             * return event types based on widget type if provided
             *
             * @param {string} widgetType type to the widget
             */
            function getEventTypes(widgetType) {
                if (widgetType) {
                    if (_.includes(keyEventsWidgets, widgetType.toLowerCase())) {
                        return allEventTypes;
                    }
                    return eventTypes;
                }
                return allEventTypes;
            }

            /**
             * @ngdoc function
             * @name wm.widgets.live.LiveWidgetUtils#getDefaultValue
             * @methodOf wm.widgets.live.LiveWidgetUtils
             * @function
             *
             * @description
             * return the formatted default value
             *
             * @param {string} value value to be formatted
             * @param {string} type column type of the value
             */
            function getDefaultValue(value, type) {
                if (Utils.isNumberType(type)) {
                    return isNaN(Number(value)) ? null : Number(value);
                }
                if (type === 'boolean') {
                    return formatBooleanValue(value);
                }
                return value;
            }

            /**
             * @ngdoc function
             * @name wm.widgets.live.LiveWidgetUtils#getLiveWidgetButtons
             * @methodOf wm.widgets.live.LiveWidgetUtils
             * @function
             *
             * @description
             * return the default button definitions of live form.
             */
            function getLiveWidgetButtons(widgetType) {
                var defaultButtons;
                switch (widgetType) {
                case 'LIVEFORM':
                    defaultButtons = [
                        {
                            key         :    'reset',
                            class       :    'form-reset btn-secondary',
                            iconclass   :    'glyphicon glyphicon-refresh',
                            action      :    'reset()',
                            displayName :    'Reset',
                            show        :    true,
                            type        :    'button',
                            updateMode  :    true
                        },
                        {
                            key         :   'cancel',
                            class       :   'form-cancel btn-secondary',
                            iconclass   :   'glyphicon glyphicon-remove-circle',
                            action      :   'cancel()',
                            displayName :   'Cancel',
                            show        :   true,
                            type        :   'button',
                            updateMode  :   true
                        },
                        {
                            key         :   'save',
                            class       :   'form-save btn-success',
                            iconclass   :   $rs.isMobileApplicationType ? 'glyphicon glyphicon-ok' : 'glyphicon glyphicon-save',
                            action      :   '',
                            displayName :   'Save',
                            show        :   true,
                            type        :   'submit',
                            updateMode  :   true
                        },
                        {
                            key         :   'delete',
                            class       :   'form-delete btn-secondary',
                            iconclass   :   'glyphicon glyphicon-remove',
                            action      :   'delete()',
                            displayName :   'Delete',
                            show        :   true,
                            type        :   'button',
                            updateMode  :   false
                        },
                        {
                            key         :   'edit',
                            class       :   'form-update btn-secondary',
                            iconclass   :   'glyphicon glyphicon-pencil',
                            action      :   'edit()',
                            displayName :   'Edit',
                            show        :   true,
                            type        :   'button',
                            updateMode  :   false
                        },
                        {
                            key         :   'new',
                            class       :   'form-new btn-success',
                            iconclass   :   'glyphicon glyphicon-plus',
                            action      :   'new()',
                            displayName :   'New',
                            show        :   true,
                            type        :   'button',
                            updateMode  :   false
                        }
                    ];
                    break;
                case 'LIVEFILTER':
                    defaultButtons = [
                        {
                            key         :   'filter',
                            class       :   'btn-primary',
                            iconclass   :   'glyphicon glyphicon-filter',
                            action      :   'filter()',
                            displayName :   'Filter',
                            show        :   true,
                            type        :   'button'
                        },
                        {
                            key         :   'clear',
                            class       :   'btn',
                            iconclass   :   'glyphicon glyphicon-remove-circle',
                            action      :   'clearFilter()',
                            displayName :   'Clear',
                            show        :   true,
                            type        :   'button'
                        }];
                    break;
                case 'GRID':
                    defaultButtons = [
                        {
                            'key': 'addNewRow',
                            'displayName': 'New',
                            'iconclass': 'glyphicon glyphicon-plus',
                            'show': true,
                            'class': 'btn-primary',
                            'action': 'addNewRow()'
                        }
                    ];
                    break;
                }
                return defaultButtons;
            }
            /**
             * @ngdoc function
             * @name wm.widgets.live.LiveWidgetUtils#getFieldTypeWidgetTypesMap
             * @methodOf wm.widgets.live.LiveWidgetUtils
             * @function
             *
             * @description
             * return the widget types for liveFilter and liveForm .
             */
            function getFieldTypeWidgetTypesMap() {
                var fieldTypeWidgetTypeMap = {
                    'integer'    : ['number', 'text', 'select', 'checkboxset', 'radioset', 'rating', 'slider'],
                    'big_integer': ['number', 'text', 'select', 'checkboxset', 'radioset', 'rating', 'slider'],
                    'short'      : ['number', 'text', 'select', 'checkboxset', 'radioset', 'slider'],
                    'float'      : ['number', 'text', 'select', 'checkboxset', 'radioset', 'slider'],
                    'big_decimal': ['number', 'text', 'select', 'checkboxset', 'radioset', 'slider'],
                    'double'     : ['number', 'text', 'select', 'checkboxset', 'radioset', 'slider'],
                    'byte'       : ['text', 'number', 'select', 'checkboxset', 'radioset'],
                    'string'     : ['text', 'number',  'textarea', 'password', 'richtext', 'select', 'checkboxset', 'radioset', 'date', 'time', 'timestamp'],
                    'character'  : ['text', 'number',  'textarea', 'password', 'richtext', 'select', 'checkboxset', 'radioset'],
                    'text'       : ['text', 'number',  'textarea', 'password', 'richtext', 'select', 'checkboxset', 'radioset', 'date', 'time', 'timestamp'],
                    'date'       : ['date', 'text', 'number', 'select', 'checkboxset', 'radioset'],
                    'time'       : ['time', 'text', 'number', 'select', 'checkboxset', 'radioset'],
                    'timestamp'  : ['timestamp', 'text', 'number', 'select', 'checkboxset', 'radioset'],
                    'datetime'   : ['datetime', 'text', 'select', 'checkboxset', 'radioset'],
                    'boolean'    : ['checkbox', 'radioset', 'toggle', 'select'],
                    'list'       : ['select', 'radioset', 'checkboxset', 'text', 'number'],
                    'clob'       : ['text', 'number', 'select', 'textarea', 'richtext'],
                    'blob'       : ['upload', 'text', 'number', 'select', 'textarea', 'richtext'],
                    'custom'     : ['text', 'number',  'textarea', 'password', 'checkbox', 'slider', 'richtext', 'select', 'checkboxset', 'radioset', 'date', 'time', 'timestamp']
                };
                return fieldTypeWidgetTypeMap;
            }
            /**
             * @ngdoc function
             * @name wm.widgets.live.LiveWidgetUtils#getColumnDef
             * @methodOf wm.widgets.live.LiveWidgetUtils
             * @function
             *
             * @description
             * return the common properties to liveFilter and liveForm .
             */
            function getColumnDef(attrs) {
                var columnDef = {},
                    widgetType = attrs.widget || (attrs.widgetType && attrs.widgetType.toLowerCase()) || getFieldTypeWidgetTypesMap()[attrs.type || 'text'][0],
                    excludeKeys = ['$attr', '$$element', 'initWidget', 'role', 'wmResizable', 'wmWidgetDrag', 'value', 'dataset', 'extensions', 'filetype'];
                /*Loop through the attrs keys and set it to columndef*/
                _.each(attrs, function (value, key) {
                    /*Exclude special type of keys*/
                    if (!_.includes(excludeKeys, key)) {
                        columnDef[key] = value;
                    }
                });
                /*Handle special cases properties*/
                columnDef.displayname = attrs.displayname || attrs.caption;
                columnDef.pcDisplay = WM.isDefined(attrs.pcDisplay) ? (attrs.pcDisplay === "1" || attrs.pcDisplay === "true") : true;
                columnDef.mobileDisplay = WM.isDefined(attrs.mobileDisplay) ? (attrs.mobileDisplay === "1" || attrs.mobileDisplay === "true") : true;
                columnDef.type = attrs.type || 'text';
                columnDef.widget = widgetType; /*Widget type support for older projects*/
                columnDef.primaryKey = attrs.primaryKey === 'true' || attrs.primaryKey === true;
                columnDef.readonly = attrs.readonly === 'false' ? false : (attrs.readonly === 'readonly' || attrs.readonly === 'true' || attrs.readonly);
                columnDef.multiple = attrs.multiple === 'true' || attrs.multiple === true;
                columnDef.class = attrs.class || '';
                columnDef.required = attrs.required === 'false' ? false : (attrs.required === 'required' || attrs.required === 'true' || attrs.required);
                columnDef.show = attrs.show === 'false' ? false : (attrs.show === '1' || attrs.show === 'true' || attrs.show);
                columnDef.disabled = attrs.disabled === 'false' ? false : (attrs.disabled === 'disabled' || attrs.disabled === 'true' || attrs.disabled);
                return columnDef;
            }
            /**
             * @ngdoc function
             * @name wm.widgets.live.LiveWidgetUtils#getButtonDef
             * @methodOf wm.widgets.live.LiveWidgetUtils
             * @function
             *
             * @description
             * return the common button attributes to liveFilter, liveForm and grid .
             */
            function getButtonDef(attrs) {
                return {
                    'key'           :   attrs.key || attrs.binding,
                    'displayName'   :   attrs.displayName || attrs.label || attrs.caption,
                    'show'          :   attrs.show === '1' || attrs.show === 'true' || attrs.show === true,
                    'class'         :   attrs.class || '',
                    'iconclass'     :   attrs.iconclass,
                    'action'        :   attrs.action,
                    'accessroles'   :   attrs.accessroles || ''
                };
            }

            /*Returns step attribute value based on input type*/
            function getStepValue(type) {
                switch (type) {
                case 'text':
                    return '';
                case 'float':
                case 'double':
                case 'big_decimal':
                    return 0.01;
                case 'integer':
                    return 1;
                default:
                    return undefined;
                }
            }

            function getCaptionByWidget(type, index) {
                var caption = 'formFields[' + index + '].value';
                if (type === 'password') {
                    return '********';
                }
                if (type === 'datetime' || type === 'timestamp') {
                    caption += ' | date:formFields[' + index + '].datepattern || \'yyyy-MM-dd HH:mm:ss\'';
                } else if (type === 'time') {
                    caption += ' | date:\'HH:mm:ss\'';
                } else if (type === 'date') {
                    caption += ' | date:formFields[' + index + '].datepattern';
                } else if (type === 'select') {
                    caption =  'formFields[' + index + '].isRelated ? getDisplayExpr(formFields[' + index + '].value, formFields[' + index + '].displayexpression || formFields[' + index + '].displayfield) : formFields[' + index + '].value';
                } else if (type === 'rating') {
                    caption = '';
                }
                return '{{' + caption + '}}';
            }

            function getFormFields(fieldDef, index, type) {
                var fields = '',
                    dateTypes = ['date', 'datetime'],
                    textTypes = ['text', 'password', 'textarea'],
                    evtTypes = getEventTypes(),
                    excludeProperties = ['caption', 'type', 'show', 'placeholder', 'maxPlaceholder', 'readonly', 'inputtype', 'widgettype'];
                Object.keys(fieldDef).forEach(function (field) {
                    if (_.includes(excludeProperties, field)) {
                        return;
                    }
                    if (fieldDef[field]) {
                        if (field === 'key' || field === 'field') {
                            fields += ' name="{{formFields[' + index + '].' + field + '}}"';
                        } else if (field === 'widgetid') {
                            fields += ' widgetid="' + fieldDef.widgetid + '_' + fieldDef.name + '"';
                        } else if (field === 'permitted') {
                            fields += ' accept="{{formFields[' + index + '].' + field + '}}"';
                        } else if (_.includes(dateTypes, type) && (field === 'minvalue' || field === 'maxvalue')) {
                            //For date, datetime, timestamp special cases
                            if (field === 'minvalue') {
                                fields += ' mindate="{{formFields[' + index + '].' + field + '}}"';
                            } else if (field === 'maxvalue') {
                                fields += ' maxdate="{{formFields[' + index + '].' + field + '}}"';
                            }
                        } else if (_.includes(textTypes, type) && field === 'maxvalue' && fieldDef.inputtype === 'text') {
                            fields += ' maxchars="{{formFields[' + index + '].' + field + '}}"';
                        } else if (_.includes(evtTypes, field)) {
                            fields += ' ' + Utils.hyphenate(field) + '="{{formFields[' + index + '].' + field + '}}"';
                        } else if (field === 'textAlignment') {
                            fields += ' textalign="{{formFields[' + index + '].' + field + '}}"';
                        } else if (field === 'ngclass') {
                            fields += ' data-ng-class="{{formFields[' + index + '].' + field + '}}"';
                        } else {
                            fields += ' ' + field + '="{{formFields[' + index + '].' + field + '}}"';
                        }
                    }
                });
                return fields;
            }
            /*Returns the default template*/
            function getDefaultTemplate(widgetType, fieldDef, index, minPlaceholderDefault, maxPlaceholderDefault, defaultPlaceholder, additionalFields, isCustomWidget) {
                var template = '',
                    widgetName = 'wm-' + widgetType,
                    updateModeCondition = isCustomWidget ? '' : ' show="{{isUpdateMode}}"',
                    allowInvalidAttr = fieldDef.widget === 'number' ? ' allowinvalid=true ' : '';
                additionalFields = additionalFields || '';
                if (fieldDef.isRange) {
                    fieldDef.placeholder = fieldDef.placeholder || minPlaceholderDefault;
                    fieldDef.maxPlaceholder = fieldDef.maxPlaceholder || maxPlaceholderDefault;
                    template = template +
                        '<div class="' + ($rs.isMobileApplicationType ? 'col-xs-6' : 'col-sm-6') + '"><' + widgetName + ' ' +  getFormFields(fieldDef, index, widgetType) + ' scopedatavalue="formFields[' + index + '].minValue" placeholder="{{formFields[' + index + '].placeholder}}" readonly="{{!isUpdateMode || formFields[' + index + '].readonly}}"' + allowInvalidAttr + updateModeCondition +  additionalFields + '></' +  widgetName + '></div>' +
                        '<div class="' + ($rs.isMobileApplicationType ? 'col-xs-6' : 'col-sm-6') + '"><' + widgetName + ' ' +  getFormFields(fieldDef, index, widgetType) + ' scopedatavalue="formFields[' + index + '].maxValue" placeholder="{{formFields[' + index + '].maxPlaceholder}}" readonly="{{!isUpdateMode || formFields[' + index + '].readonly}}"' + allowInvalidAttr + updateModeCondition + additionalFields + '></' +  widgetName + '></div>';
                } else {
                    fieldDef.placeholder = fieldDef.placeholder || defaultPlaceholder;
                    template = template + '<' + widgetName + ' ' +  getFormFields(fieldDef, index, widgetType) + ' scopedatavalue="formFields[' + index + '].value" placeholder="{{formFields[' + index + '].placeholder}}" readonly="{{!isUpdateMode || formFields[' + index + '].readonly}}"' + allowInvalidAttr + updateModeCondition + additionalFields + '></' +  widgetName + '>';
                }
                return template;
            }
            /*Returns datatime/timestamp template*/
            function getDateTimeTemplate(fieldDef, index) {
                return getDefaultTemplate('datetime', fieldDef, index, 'Select Min date time', 'Select Max date time', 'Select date time');
            }

            /*Returns time template*/
            function getTimeTemplate(fieldDef, index) {
                return getDefaultTemplate('time', fieldDef, index, 'Select Min time', 'Select Max time', 'Select time');
            }

            /*Returns date template*/
            function getDateTemplate(fieldDef, index) {
                return getDefaultTemplate('date', fieldDef, index, 'Select Min date', 'Select Max date', 'Select date');
            }

            /*Returns upload template */
            function getFileUploadTemplate(fieldDef, index) {
                var template = '';
                if (fieldDef.filetype === 'image') {
                    template = template + '<a class="form-control-static" target="_blank" href="{{formFields[' + index + '].href}}" data-ng-show="formFields[' + index + '].value || formFields[' + index + '].href"><img style="height:2em" class="glyphicon glyphicon-file" src="{{formFields[' + index + '].href}}"/></a>';
                } else {
                    template = template + '<a class="form-control-static" target="_blank" href="{{formFields[' + index + '].href}}" data-ng-show="formFields[' + index + '].value !== null"><i class="glyphicon glyphicon-file"></i></a>';
                }
                template = template + '<input data-ng-class="{\'file-readonly\': formFields[' + index + '].readonly}" required="{{formFields[' + index + '].required}}" type="file" name="{{formFields[' + index + '].key}}" ng-required="{{formFields[' + index + '].required}}" ng-readonly="{{formFields[' + index + '].readonly}}" data-ng-show="isUpdateMode" data-ng-model="formFields[' + index + '].value" accept="{{formFields[' + index + '].permitted}}"/>';
                return template;
            }

            /*Returns textarea template */
            function getTextareaTemplate(fieldDef, index) {
                return getDefaultTemplate('textarea', fieldDef, index, '', '', 'Enter value');
            }

            /*Returns richtext template */
            function getRichtextTemplate(fieldDef, index) {
                return getDefaultTemplate('richtexteditor', fieldDef, index, '', '', 'Enter value');
            }

            /*Returns slider template */
            function getSliderTemplate(fieldDef, index) {
                var additionalFields,
                    stepVal = fieldDef.step || getStepValue(fieldDef.type);
                additionalFields = stepVal ? ' step="' + stepVal + '" ' : '';
                return getDefaultTemplate('slider', fieldDef, index, '', '', '', additionalFields);
            }

            /*Returns radioset template */
            function getRadiosetTemplate(fieldDef, index) {
                var additionalFields = ' scopedataset="formFields[' + index + '].dataset" datafield="{{formFields[' + index + '].datafield}}" displayfield="{{formFields[' + index + '].displayfield}}" dataset=""';
                return getDefaultTemplate('radioset', fieldDef, index, '', '', '', additionalFields);
            }

            /*Returns checkboxset template */
            function getCheckboxsetTemplate(fieldDef, index) {
                var additionalFields = ' scopedataset="formFields[' + index + '].dataset" datafield="{{formFields[' + index + '].datafield}}" displayfield="{{formFields[' + index + '].displayfield}}" dataset=""';
                return getDefaultTemplate('checkboxset', fieldDef, index, '', '', '', additionalFields);
            }

            /*Returns checkbox template */
            function getCheckboxTemplate(fieldDef, index, widgetType) {
                var additionalFields = widgetType === 'toggle' ? 'type="toggle"' : '';
                return getDefaultTemplate('checkbox', fieldDef, index, '', '', '', additionalFields);
            }

            /*Returns select template */
            function getSelectTemplate(fieldDef, index) {
                var additionalFields = 'scopedataset="formFields[' + index + '].dataset" datafield="{{formFields[' + index + '].datafield}}" displayfield="{{formFields[' + index + '].displayfield}}"';
                return getDefaultTemplate('select', fieldDef, index, 'Select Min value', 'Select Max value', 'Select value', additionalFields);
            }

            /*Returns text template */
            function getTextNumberTemplate(fieldDef, index) {
                var stepVal, additionalFields;
                stepVal = fieldDef.step || getStepValue(fieldDef.type);
                additionalFields = 'type="{{formFields[' + index + '].inputtype}}" ' + (stepVal ? (' step="' + stepVal + '"') : "");
                return getDefaultTemplate('text', fieldDef, index, 'Enter Min value', 'Enter Max value', 'Enter value', additionalFields);
            }

            function getRatingTemplate(fieldDef, index) {
                var additionalFields = ' maxvalue="{{formFields[' + index + '].maxvalue}}" ';
                return getDefaultTemplate('rating', fieldDef, index, '', '', '', additionalFields, true);
            }
            /**
             * @ngdoc function
             * @name wm.widgets.live.LiveWidgetUtils#getHiddenTemplate
             * @methodOf wm.widgets.live.LiveWidgetUtils
             * @function
             *
             * @description
             * returns the hidden template for liveFilter and liveForm.
             */
            function getHiddenTemplate(fieldDef, index) {
                var additionalFields = 'type="hidden" ';
                return getDefaultTemplate('text', fieldDef, index, '', '', '', additionalFields);
            }
            /**
             * @ngdoc function
             * @name wm.widgets.live.LiveWidgetUtils#getTemplate
             * @methodOf wm.widgets.live.LiveWidgetUtils
             * @function
             *
             * @description
             * return template based on widgetType for liveFilter and liveForm.
             */
            function getTemplate(fieldDef, index) {
                var template = '',
                    widgetType,
                    fieldTypeWidgetTypeMap = getFieldTypeWidgetTypesMap();
                    //Set 'Readonly field' placeholder for fields which are readonly and contain generated values if the user has not given any placeholder
                if (fieldDef.readonly && fieldDef.generator === 'identity') {
                    fieldDef.placeholder = fieldDef.placeholder || '';
                }
                //Construct the template based on the Widget Type, if widget type is not set refer to the fieldTypeWidgetTypeMap
                widgetType = fieldDef.widget || fieldTypeWidgetTypeMap[fieldDef.type][0];
                widgetType = widgetType.toLowerCase();
                template = template +
                    '<wm-composite widget="' + widgetType + '" show="{{formFields[' + index + '].show}}" class="live-field">' +
                    '<wm-label class="' + ($rs.isMobileApplicationType ? 'col-xs-4' : 'col-sm-3') + '" caption="{{formFields[' + index + '].displayname}}" hint="{{formFields[' + index + '].displayname}}" required="{{formFields[' + index + '].required}}"></wm-label>' +
                    '<div class="' + ($rs.isMobileApplicationType ? 'col-xs-8' : 'col-sm-9') + ' {{formFields[' + index + '].class}}">' +
                    '<wm-label class="form-control-static" caption="' + getCaptionByWidget(widgetType, index) + '" show="{{!isUpdateMode}}"></wm-label>';

                switch (widgetType) {
                case 'number':
                case 'text':
                case 'password':
                    template += getTextNumberTemplate(fieldDef, index);
                    break;
                case 'select':
                    template += getSelectTemplate(fieldDef, index);
                    break;
                case 'checkbox':
                case 'toggle':
                    template += getCheckboxTemplate(fieldDef, index, widgetType);
                    break;
                case 'checkboxset':
                    template += getCheckboxsetTemplate(fieldDef, index);
                    break;
                case 'radioset':
                    template += getRadiosetTemplate(fieldDef, index);
                    break;
                case 'slider':
                    template += getSliderTemplate(fieldDef, index);
                    break;
                case 'richtext':
                    template += getRichtextTemplate(fieldDef, index);
                    break;
                case 'textarea':
                    template += getTextareaTemplate(fieldDef, index);
                    break;
                case 'upload':
                    template += getFileUploadTemplate(fieldDef, index);
                    break;
                case 'date':
                    template += getDateTemplate(fieldDef, index);
                    break;
                case 'time':
                    template += getTimeTemplate(fieldDef, index);
                    break;
                case 'datetime':
                case 'timestamp':
                    template += getDateTimeTemplate(fieldDef, index);
                    break;
                case 'rating':
                    template += getRatingTemplate(fieldDef, index);
                    break;
                default:
                    template += getDefaultTemplate('text', fieldDef, index, 'Enter Min value', 'Enter Max value', 'Enter value');
                    break;
                }
                template = template + '</div></wm-composite>';
                return template;
            }

            /**
            * @ngdoc function
            * @name wm.widgets.live.LiveWidgetUtils#getCustomItems
            * @methodOf wm.widgets.live.LiveWidgetUtils
            * @function
            *
            * @description
            * return the array of custom actions/events defined by the user.
            *
            * @param {string} actions actions/events of a button
            * @param {object} definedActions Predefined actions for the widget
            */
            function getCustomItems(actions, definedActions) {
                var customItems = [];
                actions = actions && actions.split(';');
                if (WM.isArray(actions)) {
                    actions.forEach(function (action) {
                        if (!_.includes(definedActions, action)) {
                            action = action.substring(0, action.indexOf('('));
                            customItems.push(action);
                        }
                    });
                }
                return customItems;
            }

            /**
             * @ngdoc function
             * @name wm.widgets.live.LiveWidgetUtils#translateVariableObject
             * @methodOf wm.widgets.live.LiveWidgetUtils
             * @function
             *
             * @description
             * consumes the raw object received from LiveVariable and returns consumable field objects agains each column.
             *
             * @param {object} rawObject data object received from the LiveVariable
             * @param {object} widget scope Caller Widget scope (optional)
             */
            function translateVariableObject(rawObject, scope) {
                var translatedObj = [],
                    columnArray = rawObject.propertiesMap.columns,
                    fieldNames = [],
                    widgetsMap = getFieldTypeWidgetTypesMap();

                if (scope) {
                    scope.propertiesMap = rawObject.propertiesMap;
                    scope.columnArray = scope.propertiesMap.columns;
                    scope.primaryKey = scope.primaryKey || [];
                }
                _.each(columnArray, function (fieldObj) {
                    var column;
                    if (!_.includes(fieldNames, fieldObj.fieldName) && !fieldObj.readonly) {
                        fieldNames.push(fieldObj.fieldName);
                        column = {
                            'displayname'   : Utils.prettifyLabel(fieldObj.fieldName),
                            'show'          : true,
                            'primaryKey'    : fieldObj.isPrimaryKey,
                            'generator'     : fieldObj.generator,
                            'key'           : fieldObj.fieldName,
                            'value'         : '',
                            'type'          : fieldObj.isRelated ? 'list' : fieldObj.fullyQualifiedType,
                            'maxvalue'      : '',
                            'isRelated'     : fieldObj.isRelated,
                            'readonly'      : fieldObj.isPrimaryKey,
                            'required'      : fieldObj.notNull === 'true' || fieldObj.notNull === true,
                            'pcDisplay'     : true,
                            'mobileDisplay' : true
                        };
                        column.widget = widgetsMap[column.type || 'custom'][0];
                        if (fieldObj.defaultValue) {
                            column.defaultvalue = getDefaultValue(fieldObj.defaultValue, fieldObj.type);
                        }
                        if (fieldObj.type === 'string' || fieldObj.type === 'character' || fieldObj.type === 'text' || fieldObj.type === 'blob' || fieldObj.type === 'clob') {
                            column.maxchars = fieldObj.length;
                        }
                        if (fieldObj.isPrimaryKey) {
                            /*Store the primary key of data*/
                            if (scope) {
                                scope.setPrimaryKey(fieldObj.fieldName);
                            }
                            /*If the field has assigned generator, make read only false*/
                            if (fieldObj.generator === 'assigned') {
                                column.readonly = false;
                            } else {
                                /*Hiding primary if it is generated automatically(User can un-hide it from edit feilds dialog)*/
                                column.show = false;
                            }
                        }
                        translatedObj.push(column);
                    }
                });
                return translatedObj;
            }

            /**
             * @ngdoc function
             * @name wm.widgets.live.LiveWidgetUtils#getColumnCountByLayoutType
             * @methodOf wm.widgets.live.LiveWidgetUtils
             * @function
             *
             * @description
             * returns the number of columns based on the provided layout type. E.g. 1 for "One Column", 2 for "Two Column", etc.
             *
             * @param {object} layout layout type
             */
            function getColumnCountByLayoutType(layout) {
                var layoutObj = {
                    'One Column': 1,
                    'Two Column': 2,
                    'Three Column': 3,
                    'Four Column': 4
                };
                return layoutObj[layout] || 1;
            }

            /*function to update script link visibility*/
            function toggleActionMessage(selectedItem, actionsList, isField, eventType, value) {
                if (isField && eventType) {
                    selectedItem[eventType] = value;
                    return selectedItem.include && !selectedItem.remove && _.includes(selectedItem[eventType], 'Javascript');
                }
                return selectedItem.include && !selectedItem.remove && !_.includes(actionsList, selectedItem.action);
            }

            /**
             * @ngdoc function
             * @name wm.widgets.live.LiveWidgetUtils#getCustomFieldKey
             * @methodOf wm.widgets.live.LiveWidgetUtils
             * @function
             *
             * @description
             * returns the auto incremented event string based on the already existing events
             *
             * @param {object} fields array of the columns/ buttons
             * @param {string} key key where the field name is stored in object
             * @param {string} prefix name for the event/ action
             */
            function getCustomFieldKey(fields, key, prefix) {
                var keys = fields.map(function (event) {
                    return event[key];
                }), index;
                if (keys && _.includes(keys, prefix)) {
                    index = 1;
                    while (_.includes(keys, prefix + index)) {
                        index += 1;
                    }
                    prefix = prefix + index;
                }
                return prefix;
            }
            /**
             * @ngdoc function
             * @name wm.widgets.live.LiveWidgetUtils#splitDimension
             * @methodOf wm.widgets.live.LiveWidgetUtils
             * @function
             *
             * @description
             * extracts value and unit from the given width or height
             *
             * @param {object} column column pr field definition
             * @param {string} type width or height
             */
            function splitDimension(column, type) {
                var value,
                    unit,
                    width,
                    height;
                switch (type) {
                case 'width':
                    /*extract the width and width unit from width*/
                    width = column.width || '';
                    value = parseInt(width, 10) || '';
                    unit = width.indexOf('%') === -1 ? 'px' : '%';

                    column.widthValue = value;
                    column.widthUnit = unit;
                    break;
                case 'height':
                    /*extract the width and width unit from width*/
                    height = column.height || '';
                    value = parseInt(height, 10) || '';
                    unit = height.indexOf('%') === -1 ? 'px' : '%';

                    column.heightValue = value;
                    column.heightUnit = unit;
                    break;
                }
            }
            /**
             * @ngdoc function
             * @name wm.widgets.live.LiveWidgetUtils#mergeDimension
             * @methodOf wm.widgets.live.LiveWidgetUtils
             * @function
             *
             * @description
             * sets width or height from the value and unit
             *
             * @param {object} column column or field definition
             * @param {string} type width or height
             */
            function mergeDimension(column, type) {
                /*if width is given and a number set it*/
                switch (type) {
                case 'width':
                    if (column.widthValue && !isNaN(column.widthValue)) {
                        column.width = column.widthValue + column.widthUnit;
                    } else if (!column.widthValue || (!column.widthValue.length && Utils.stringStartsWith(column.width, column.widthValue))) {
                        /* Reset the width to default value when the widthValue is cleared from the UI. */
                        column.width = undefined;
                    }
                    column.widthValue = undefined;
                    column.widthUnit = undefined;
                    break;
                case 'height':
                    if (column.heightValue && !isNaN(column.heightValue)) {
                        column.height = column.heightValue + column.heightUnit;
                    } else if (!column.heightValue || (!column.heightValue.length && Utils.stringStartsWith(column.width, column.heightValue))) {
                        /* Reset the height to default value when the heightValue is cleared from the UI. */
                        column.height = undefined;
                    }
                    column.heightValue = undefined;
                    column.heightUnit = undefined;
                    break;
                }
            }
            /**
             * @ngdoc function
             * @name wm.widgets.live.LiveWidgetUtils#fieldPropertyChangeHandler
             * @methodOf wm.widgets.live.LiveWidgetUtils
             * @function
             *
             * @description
             * Define the property change handler for form and filter. This function will be triggered when there is a change in the widget property
             *
             * @param {object} scope scope of the field
             * @param {object} element element of the field
             * @param {object} attrs attributes of the field
             * @param {string} key key which value is changed
             * @param {string} newVal new value for the key
             */
            function fieldPropertyChangeHandler(scope, element, attrs, parentScope, index, key, newVal) {
                var variable,
                    eleScope = element.scope(),
                    isDataSetWidgets = Utils.getDataSetWidgets(),
                    template = '',
                    wdgtProperties = scope.widgetProps,
                    compileField = function () {
                        /*On changing of a property in studio mode, generate the template again so that change is reflected*/
                        template = getTemplate(parentScope.formFields[index], index);
                        element.html(template);
                        $compile(element.contents())(parentScope);
                    };
                switch (key) {
                case 'dataset':
                    /*if studio-mode, then update the displayField & dataField in property panel for dataset widgets*/
                    if (scope.widgetid && isDataSetWidgets[attrs.widget] && WM.isDefined(newVal) && newVal !== null) {
                        //Get variable and properties map only on binddataset change
                        if (scope.oldBindDataSet !== scope.binddataset) {
                            if (!WM.isString(newVal)) {
                                variable = Utils.getVariableName(scope, eleScope);
                                newVal.propertiesMap = eleScope.Variables[variable].category === 'wm.ServiceVariable' ? undefined : eleScope.Variables[variable].propertiesMap;
                            }
                            scope.oldBindDataSet = scope.binddataset;
                        }
                        FormWidgetUtils.updatePropertyPanelOptions(newVal.data || newVal, newVal.propertiesMap, scope, false);
                    }
                    compileField();
                    break;
                case 'inputtype':
                    FormWidgetUtils.setPropertiesTextWidget(wdgtProperties, newVal);
                    compileField();
                    break;
                case 'required':
                    parentScope.formFields[index][key] = newVal;
                    compileField();
                    break;
                case 'active':
                    if (scope.widget === 'number' || scope.widget === 'password' || scope.widget === 'text') {
                        FormWidgetUtils.setPropertiesTextWidget(wdgtProperties, scope.inputtype);
                        compileField();
                    }
                    break;
                default:
                    compileField();
                }
            }
            /**
             * @ngdoc function
             * @name wm.widgets.live.LiveWidgetUtils#getWidgetProps
             * @methodOf wm.widgets.live.LiveWidgetUtils
             * @function
             *
             * @description
             * Get the respective widget properties for the widget
             *
             * @param {string} widgetType type of the widget
             */
            function getWidgetProps(widgetType) {
                var widgetProps,
                    baseProperties,
                    extendedProperties,
                    textWidgets = ['text', 'number', 'password'],
                    setDefaultValueProps = function () {
                        var defaultProp;
                        /*Use default value instead of datavalue for fields*/
                        if (widgetType === 'radioset') {
                            defaultProp = 'selectedvalue';
                        } else if (widgetType === 'checkboxset') {
                            defaultProp = 'selectedvalues';
                        } else {
                            defaultProp = 'datavalue';
                        }
                        if (widgetProps[defaultProp]) {
                            widgetProps.defaultvalue = WM.copy(widgetProps[defaultProp]);
                            delete widgetProps[defaultProp];
                        }
                    };
                widgetType = widgetType.toLowerCase();
                switch (widgetType) {
                case 'textarea':
                    baseProperties = 'wm.textarea';
                    extendedProperties = ['wm.base', 'wm.base.editors', 'wm.base.editors.abstracteditors', 'wm.base.events.keyboard'];
                    break;
                case 'toggle':
                case 'checkbox':
                    baseProperties = 'wm.checkbox';
                    extendedProperties = ['wm.base', 'wm.base.editors', 'wm.base.editors.abstracteditors'];
                    break;
                case 'slider':
                    baseProperties = 'wm.slider';
                    extendedProperties = ['wm.base', 'wm.base.editors', 'wm.base.events.change'];
                    break;
                case 'richtext':
                    baseProperties = 'wm.richtexteditor';
                    extendedProperties = ['wm.base', 'wm.base.editors'];
                    break;
                case 'select':
                    baseProperties = 'wm.select';
                    extendedProperties = ['wm.base', 'wm.base.editors', 'wm.base.editors.abstracteditors', 'wm.base.editors.dataseteditors', 'wm.base.events.keyboard'];
                    break;
                case 'checkboxset':
                    baseProperties = 'wm.checkboxset';
                    extendedProperties = ['wm.base', 'wm.booleaneditors'];
                    break;
                case 'radioset':
                    baseProperties = 'wm.radioset';
                    extendedProperties = ['wm.base', 'wm.booleaneditors'];
                    break;
                case 'date':
                    baseProperties = 'wm.date';
                    extendedProperties = ['wm.base', 'wm.base.editors.abstracteditors', 'wm.base.datetime'];
                    break;
                case 'time':
                    baseProperties = 'wm.time';
                    extendedProperties = ['wm.base', 'wm.base.editors.abstracteditors', 'wm.base.datetime'];
                    break;
                case 'datetime':
                case 'timestamp':
                    baseProperties = 'wm.datetime';
                    extendedProperties = ['wm.base', 'wm.base.editors.abstracteditors', 'wm.base.datetime'];
                    break;
                case 'rating':
                    baseProperties = 'wm.rating';
                    extendedProperties = ['wm.base', 'wm.base.editors'];
                    break;
                case 'upload':
                    baseProperties = '';
                    extendedProperties = ['wm.base', 'wm.base.editors', 'wm.base.editors.abstracteditors'];
                    break;
                default:
                    baseProperties = 'wm.text';
                    extendedProperties = ['wm.base', 'wm.base.editors', 'wm.base.editors.abstracteditors', 'wm.base.events.keyboard'];
                    break;
                }
                widgetProps = PropertiesFactory.getPropertiesOf(baseProperties, extendedProperties);
                widgetProps.displayname =  {'type': "string", 'show': true, 'bindable': "in-bound"};
                widgetProps.widget = {'type': 'label', 'show': true};
                if (_.includes(textWidgets, widgetType)) {
                    /*In form and filter, type conflicts with data type. Change the type to input type.*/
                    widgetProps.inputtype = WM.copy(widgetProps.type);
                    delete widgetProps.type;
                }
                if (widgetType === 'upload') {
                    widgetProps = WM.extend(widgetProps, {
                        'readonly'   : {'type': 'boolean', 'show': true},
                        'required'   : {'type': 'boolean', 'show': true},
                        'filetype'   : {'type': 'datalist', 'options': ['image', 'audio', 'video'], 'show': true},
                        'extensions' : {'type': 'string', 'show': true}
                    });
                }
                setDefaultValueProps();
                /*No support for scopedatavalue and scopedataset for fields yet*/
                if (widgetProps.scopedatavalue) {
                    delete widgetProps.scopedatavalue;
                }
                if (widgetProps.scopedataset) {
                    delete widgetProps.scopedataset;
                }
                return widgetProps;
            }
            /**
             * @ngdoc function
             * @name wm.widgets.live.LiveWidgetUtils#handleBackwardCompatibility
             * @methodOf wm.widgets.live.LiveWidgetUtils
             * @function
             *
             * @description
             * handle the backward compatibility for some of the field attributes
             *
             * @param {string} fieldType filter field/ form field
             * @param {object} scope scope of the widget
             * @param {object} attrs attributes of the widget
             * @param {string} tElement template of the field
             */
            function handleBackwardCompatibility(fieldType, scope, attrs, tElement) {
                var changeAttr = function (newAttr, oldAttr) {
                    /*Function to change the attribute names*/
                    scope[newAttr] = attrs[newAttr] = attrs[oldAttr];
                    WM.element(tElement.context).attr(newAttr, scope[newAttr]);
                    delete attrs[oldAttr];
                };
                /*Support for old projects*/
                if (!attrs.defaultvalue && attrs.defaultValue) {
                    changeAttr('defaultvalue', 'defaultValue');
                }
                if (!attrs.displayname && attrs.displayName) {
                    changeAttr('displayname', 'displayName');
                }
                if (attrs.maxvalue && (attrs.inputtype === 'text' || attrs.inputtype === 'password' || attrs.widget === 'textarea')) {
                    changeAttr('maxchars', 'maxvalue');
                }
                if (attrs.widget === 'date' || attrs.widget === 'datetime') {
                    if (attrs.minvalue) {
                        changeAttr('mindate', 'minvalue');
                    }
                    if (attrs.maxvalue) {
                        changeAttr('maxdate', 'maxvalue');
                    }
                }
                if (attrs.minPlaceholder && !attrs.placeholder && fieldType === 'wm-filter-field') {
                    changeAttr('placeholder', 'minPlaceholder');
                }
                if (!attrs.displayexpression && attrs.displayvalue) {
                    changeAttr('displayexpression', 'displayvalue');
                }
            }
            /**
             * @ngdoc function
             * @name wm.widgets.live.LiveWidgetUtils#preProcessFields
             * @methodOf wm.widgets.live.LiveWidgetUtils
             * @function
             *
             * @description
             * Get the respective widget properties for the widget
             *
             * @param {string} fieldType filter field/ form field
             * @param {object} scope scope of the widget
             * @param {object} attrs attributes of the widget
             * @param {string} tElement template of the field
             */
            function preProcessFields(fieldType, scope, attrs, tElement) {
                var inputtype;
                scope.widgettype = fieldType;
                attrs.widget = attrs.widget || (attrs.widgetType && attrs.widgetType.toLowerCase()) || getFieldTypeWidgetTypesMap()[attrs.type || 'text'][0];
                /*Support for older projects, in which widget type was not stored*/
                scope.widget = attrs.widget;
                WM.element(tElement.context).attr('widget', scope.widget);
                /*Based on the widget, get the input types*/
                if (attrs.widget === 'text') {
                    inputtype = attrs.inputtype || 'text';
                } else if (attrs.widget === 'number') {
                    inputtype = 'number';
                } else if (attrs.widget === 'password') {
                    inputtype = 'password';
                }
                scope.inputtype = attrs.inputtype = inputtype;
                WM.element(tElement.context).attr('inputtype', inputtype);
                handleBackwardCompatibility(fieldType, scope, attrs, tElement);
               /*Get the respective widget properties*/
                scope.widgetProps = getWidgetProps(attrs.widget);
            }

            function parseNgClasses(classExpression) {
                var ngClasses = [],
                    conditionalClasses;
                defaultNgClassesConfig = {'className': '', 'condition': ''};
                /* Return default config. */
                if (!classExpression) {
                    ngClasses.push(WM.copy(defaultNgClassesConfig));
                    return ngClasses;
                }
                /* Remove curly brackets and get each expression. */
                conditionalClasses = classExpression.substring(1, classExpression.length - 1).split(',');
                /* Generate the config. */
                _.each(conditionalClasses, function (conditionalClassConfig) {
                    var conditionalExpression = conditionalClassConfig.split(':'),
                        className = conditionalExpression[0].trim(),
                        classCondition = conditionalExpression[1].trim(),
                        classNameLen = className.length,
                        config = WM.copy(defaultNgClassesConfig);
                    /* Strip the single quotes from className. */
                    if (className[0] === "'" && className[classNameLen - 1] === "'") {
                        className = className.substring(1, classNameLen - 1);
                    }
                    config.className = className;
                    config.condition = classCondition;
                    ngClasses.push(config);
                });
                return ngClasses;
            }

            function generateNgClassExpression(conditionalClasses) {
                var ngClassExpression = '';
                _.each(conditionalClasses, function (config) {
                    if (config.className && config.condition) {
                        if (ngClassExpression.length) {
                            ngClassExpression += ', ';
                        }
                        ngClassExpression += "'" + config.className + "':" + config.condition;
                    }
                });
                return ngClassExpression.length ? '{' + ngClassExpression + '}' : ngClassExpression;
            }

            function setColumnCustomExpression(column) {
                var widgetNgClassesExpression = generateNgClassExpression(column.widgetConfig.ngClasses);
                switch (column.widgetType) {
                case 'image':
                    if (column.type === 'blob') {
                        column.widgetConfig.src = "{{contentBaseUrl + row[primaryKey] + \'/content/\'+ colDef.field}}";
                        column.customExpression = '<img width="48px" class="" data-ng-src="' + column.widgetConfig.src + '"/>';
                    } else {
                        column.customExpression = '<img data-ng-src="' + column.widgetConfig.src + '" alt="' + column.widgetConfig.src + '" class="' + column.widgetConfig.class +
                            '" data-ng-class="' + widgetNgClassesExpression + '"/>';
                    }
                    break;
                case 'button':
                    column.customExpression = '<wm-button caption="' + column.widgetConfig.title + '" show="true" class="' + column.widgetConfig.class + '" iconname="' +
                        column.widgetConfig.icon + '" on-click="' + column.widgetConfig.action + '" data-ng-class="' + widgetNgClassesExpression + '"></wm-button>';
                    break;
                case 'checkbox':
                    column.customExpression = '<input type="checkbox" ng-model="' + column.widgetConfig.model + '" ng-disabled="' + column.widgetConfig.disabled + '" ' +
                        'class = "' + column.widgetConfig.class + '" data-ng-class="' + widgetNgClassesExpression + '">';
                    break;
                default:
                    if (column.type === 'blob') {
                        column.customExpression = '<a data-ng-if="columnValue != null" class="col-md-9" target="_blank" data-ng-href="{{contentBaseUrl + row[primaryKey] + \'/content/\'+ colDef.field}}"><i class="wm-icon wm-icon24 glyphicon glyphicon-file"></i></a>';
                    }
                }
            }

            function setDefaultWidgetConfig(column) {
                var widgetType = column.widgetType,
                    field = column.field,
                    val = column.widgetType === 'button' ? "{{row.getProperty('" + field + "') || 'Button'}}" : "{{row.getProperty('" + field + "')}}",
                    defaultModel = "row." + field,
                    widgetNgClasses = [Utils.getClonedObject(defaultNgClassesConfig)];
                /* Not storing widget config, it is only on for UI display. Only customExpression will be saved. */
                column.widgetConfig = {};
                switch (widgetType) {
                case 'image':
                    column.widgetConfig = {
                        'src': val,
                        'class': '',
                        'ngClasses': widgetNgClasses
                    };
                    break;
                case 'button':
                    column.widgetConfig = {
                        'icon': '',
                        'action': '',
                        'title': val,
                        'class': 'btn-sm btn-primary',
                        'ngClasses': widgetNgClasses
                    };
                    break;
                case 'checkbox':
                    column.widgetConfig = {
                        'model': defaultModel,
                        'disabled': '{{colDef.readonly || !isGridEditMode}}',
                        'class': '',
                        'ngClasses': widgetNgClasses
                    };
                    break;
                default:
                    column.widgetConfig = {
                        'src': val,
                        'class': '',
                        'ngClasses': widgetNgClasses
                    };
                    break;
                }
            }

            function extractWidgetConfig(column) {
                var customExpression = column.customExpression,
                    widgetType = column.widgetType,
                    widgetDisabled,
                    widgetAction,
                    widgetIcon,
                    widgetTitle,
                    widgetClass,
                    widgetNgClasses,
                    widgetSrc,
                    widgetModel,
                    el;
                column.widgetConfig = {};
                /* If custom expression does not contain any HTML tags, append span. */
                if (!Utils.isValidHtml(customExpression)) {
                    customExpression = '<span>' + customExpression + '</span>';
                }
                el = WM.element(customExpression);
                widgetClass = el.attr('widget-class');
                widgetNgClasses = parseNgClasses(el.attr('data-ng-class'));
                switch (widgetType) {
                case 'image':
                    widgetSrc = el.attr('data-ng-src');
                    column.widgetConfig = {
                        'src': widgetSrc,
                        'class': widgetClass,
                        'ngClasses': widgetNgClasses
                    };
                    break;
                case 'button':
                    widgetIcon = el.attr('iconname');
                    widgetTitle = el.attr('caption');
                    widgetAction = el.attr('on-click');
                    column.widgetConfig = {
                        'icon': widgetIcon,
                        'action': widgetAction,
                        'title': widgetTitle,
                        'class': widgetClass,
                        'ngClasses': widgetNgClasses
                    };
                    break;
                case 'checkbox':
                    widgetModel = el.attr('ng-model');
                    widgetDisabled = el.attr('ng-disabled');
                    column.widgetConfig = {
                        'model': widgetModel,
                        'disabled': widgetDisabled,
                        'class': widgetClass,
                        'ngClasses': widgetNgClasses
                    };
                    break;
                default:
                    column.widgetConfig = {
                        'src': '',
                        'class': widgetClass,
                        'ngClasses': widgetNgClasses
                    };
                    break;
                }
            }
            /**
             * @ngdoc function
             * @name wm.widgets.live.LiveWidgetUtils#setColumnConfig
             * @methodOf wm.widgets.live.LiveWidgetUtils
             * @function
             *
             * @description
             * Sets the column config for the selected field
             *
             * @param {object} column for which config needs to be set
             */
            function setColumnConfig(column) {
                /* Not storing ngClasses, it is only on for UI display. Only ngClass expression will be saved. */
                column.ngClasses = parseNgClasses(column.ngclass);
                if (!column.customExpression) {
                    setDefaultWidgetConfig(column);
                    setColumnCustomExpression(column);
                } else {
                    extractWidgetConfig(column);
                }
            }
            /**
             * @ngdoc function
             * @name wm.widgets.live.LiveWidgetUtils#fetchPropertiesMapColumns
             * @methodOf wm.widgets.live.LiveWidgetUtils
             * @function
             *
             * @description
             * Returns columns and sets related data for provided propertiesMap
             *
             * @param {object} propertiesMap from which columns are retrieved
             * @param {object} relatedData for live filter dataset
             * @param {object} variableObj to which filter is binded
             *
             */
            function fetchPropertiesMapColumns(propertiesMap, variableObj) {
                var columns = {}, columnName, data = {}, primaryKey;
                /* iterated trough the propertiesMap columns of all levels and build object with columns having required configuration*/
                _.each(propertiesMap.columns, function (val) {
                    /* if the object is nested type repeat the above process for that nested object through recursively */
                    if (val.isRelated) {
                        if (val.isList) {
                            return;
                        }
                        data.relatedData = data.relatedData || {};
                        var relatedTableColumns = $liveVariable.getRelatedColumnsList(variableObj, val.fieldName),
                            columnNameTypeMap = {};
                        _.each(val.columns, function (column) {
                            if (column.isPrimaryKey) {
                                primaryKey = column.fieldName;
                            }
                            columnNameTypeMap[column.fieldName] = column.type;
                        });
                        data.relatedData[val.relatedEntityName] = {
                            columns: relatedTableColumns,
                            primaryKey: primaryKey,
                            columnNameTypeMap: columnNameTypeMap
                        };

                        /* otherwise build object with required configuration */
                        columnName = val.fieldName.charAt(0).toLowerCase() + val.fieldName.slice(1);
                        columns[columnName] = {};
                        columns[columnName].isRelated = val.isRelated === 'true' || val.isRelated === true;
                        columns[columnName].relatedEntityName = val.relatedEntityName;
                        columns[columnName].relatedPrimaryKey = primaryKey;
                    } else {
                        /* otherwise build object with required configuration */
                        columnName = val.fieldName;
                        columns[columnName] = {};
                    }
                    columns[columnName].type = val.type;
                    columns[columnName].isPrimaryKey = val.isPrimaryKey;
                    columns[columnName].generator = val.generator;
                });
                return {
                    'columns'     : columns,
                    'relatedData' : data.relatedData
                };
            }

            this.toggleActionMessage        = toggleActionMessage;
            this.getEventTypes              = getEventTypes;
            this.getDefaultValue            = getDefaultValue;
            this.getLiveWidgetButtons       = getLiveWidgetButtons;
            this.getCustomItems             = getCustomItems;
            this.getColumnDef               = getColumnDef;
            this.getButtonDef               = getButtonDef;
            this.getTemplate                = getTemplate;
            this.getHiddenTemplate          = getHiddenTemplate;
            this.translateVariableObject    = translateVariableObject;
            this.getColumnCountByLayoutType = getColumnCountByLayoutType;
            this.getCustomFieldKey          = getCustomFieldKey;
            this.getStepValue               = getStepValue;
            this.splitDimension             = splitDimension;
            this.mergeDimension             = mergeDimension;
            this.getFieldTypeWidgetTypesMap = getFieldTypeWidgetTypesMap;
            this.fieldPropertyChangeHandler = fieldPropertyChangeHandler;
            this.preProcessFields           = preProcessFields;
            this.setColumnConfig            = setColumnConfig;
            this.fetchPropertiesMapColumns  = fetchPropertiesMapColumns;
        }
    ])
    .directive('liveActions', ['Utils', 'wmToaster', '$rootScope', function (Utils, wmToaster, $rs) {
        'use strict';
        var getRecords = function (options, success, error) {
                var variable = options.variable;

                variable.update({}, function (response) {
                    Utils.triggerFn(success, response);
                }, function (err) {
                    Utils.triggerFn(error, err);
                });
            },
            insertRecord = function (options, success, error) {
                var variable = options.variable,
                    dataObject = {
                        'row': options.row,
                        'transform': true,
                        'multipartData': options.multipartData
                    };

                variable.insertRecord(dataObject, function (response) {
                    Utils.triggerFn(success, response);
                }, function (err) {
                    Utils.triggerFn(error, err);
                });
            },
            updateRecord = function (options, success, error) {
                var variable = options.variable,
                    dataObject = {
                        'row': options.row,
                        'prevData': options.prevData,
                        'multipartData': options.multipartData,
                        'transform': true
                    };

                variable.updateRecord(dataObject, function (response) {
                    Utils.triggerFn(success, response);
                }, function (err) {
                    Utils.triggerFn(error, err);
                });
            },
            deleteRecord = function (options, success, error) {
                var variable = options.variable,
                    confirmMsg = options.scope.confirmdelete || 'Are you sure you want to delete this?',
                    dataObject = {
                        'row': options.row,
                        'transform': true
                    };

                if (variable.propertiesMap && variable.propertiesMap.tableType === 'VIEW') {
                    wmToaster.show('info', 'Not Editable', 'Table of type view, not editable');
                    $rs.$safeApply(options.scope);
                    return;
                }
                /* delete if user confirm to delete*/
                if (confirm(confirmMsg)) {

                    variable.deleteRecord(dataObject, function (response) {
                        Utils.triggerFn(success, response);
                    }, function (err) {
                        Utils.triggerFn(error, err);
                    });
                } else {
                    Utils.triggerFn(options.cancelDeleteCallback);
                }
            },
            performOperation = function (operation, options) {
                var fn,
                    scope = options.scope,
                    successHandler = function (response) {
                        Utils.triggerFn(scope.liveActionSuccess, operation, response);
                        Utils.triggerFn(options.success, response);
                    },
                    errorHandler = function (error) {
                        Utils.triggerFn(scope.liveActionError, operation, error);
                        wmToaster.show('error', 'ERROR', error);
                        Utils.triggerFn(options.error, error);
                    };

                /* decide routine based on CRUD operation to be performed */
                switch (operation) {
                case 'create':
                    fn = insertRecord;
                    break;
                case 'update':
                    fn = updateRecord;
                    break;
                case 'delete':
                    fn = deleteRecord;
                    break;
                case 'read':
                    fn = getRecords;
                    break;
                }

                fn(options, function (response) {
                    if (response.error) {
                        errorHandler(response.error);
                        return;
                    }
                    if (fn !== 'read') {
                        getRecords(options, function () {
                            successHandler(response);
                        }, function () {
                            successHandler(response);
                        });
                    } else {
                        successHandler(response);
                    }
                }, function (error) {
                    errorHandler(error);
                });
            };

        return {
            'restrict': 'A',
            'link': {
                'post': function ($is, $el) {
                    $is.addRow = function () {
                        $rs.$emit('wm-event', $is.name, 'create');
                    };
                    $is.updateRow = function () {
                        $rs.$emit('wm-event', $is.name, 'update');
                    };
                    $is.deleteRow = function () {
                        $rs.$emit('wm-event', $is.name, 'delete');
                    };

                    /* API exposed to make CRUD operations */
                    $is.call = function (operation, data, success, error) {
                        var $elScope = $el.scope(),
                            variableName = Utils.getVariableName($is, $elScope);

                        data.scope = data.scope || $is;
                        data.success = success;
                        data.error = error;
                        data.variable = $elScope.Variables[variableName];

                        performOperation(operation, data);
                    };
                }
            }
        };
    }]);

/*global WM, _, moment, alert*/

/**
 * @ngdoc service
 * @name wm.widgets.form.FormWidgetUtils
 * @requires Utils
 * The `FormWidgetUtils` service provides utility methods for form widgets.
 */
WM.module('wm.widgets.form')
    .service('FormWidgetUtils', [
        'WidgetUtilService',
        'CONSTANTS',
        'Utils',
        'Variables',
        '$rootScope',
        '$filter',

        function (WidgetUtilService, CONSTANTS, Utils, Variables, $rootScope, $filter) {
            'use strict';
            var ALLFIELDS = 'All Fields';

            /**
             * @ngdoc function
             * @name wm.widgets.form.FormWidgetUtils#getDisplayField
             * @methodOf wm.widgets.form.FormWidgetUtils
             * @function
             *
             * @description
             * return the default display field, if the widget does not have a display field or it is set to All fields
             *
             * @param {object} dataSet data set of the widget
             * @param {string} displayField display field of the widget
             */
            function getDisplayField(dataSet, displayField) {
                /*if displayField is not set or set to all fields*/
                if (!displayField || displayField === ALLFIELDS) {
                    /*if dataSet is an array*/
                    if (WM.isArray(dataSet) && dataSet.length > 0) {
                        /*if dataSet is an array of objects*/
                        if (WM.isObject(dataSet[0])) {
                            /* get the first field of the object*/
                            displayField = Object.keys(dataSet[0])[0];
                        } else {
                            displayField = '';
                        }
                    } else if (WM.isObject(dataSet)) {
                        displayField = '';
                    }
                }
                /* return dataValue to be the default key */
                return displayField;
            }
            /**
             * @ngdoc function
             * @name wm.widgets.form.FormWidgetUtils#setPropertiesTextWidget
             * @methodOf wm.widgets.form.FormWidgetUtils
             * @function
             *
             * @description
             * Use this function to set the properties of the text widget based on the input type
             *
             * @param {object} widgetProps properties of the text widget
             * @param {string} newVal new input type value of the widget
             */
            function setPropertiesTextWidget(widgetProps, newVal) {
                var datavalueObj = widgetProps.datavalue || widgetProps.defaultvalue;
                widgetProps.step.show = widgetProps.minvalue.show = widgetProps.maxvalue.show = false;
                widgetProps.placeholder.show = widgetProps.maxchars.show = widgetProps.updateon.show = widgetProps.updatedelay.show = true;
                datavalueObj.type = (newVal === 'number' || newVal === 'date') ? newVal : 'string';
                switch (newVal) {
                case 'number':
                    widgetProps.step.show = widgetProps.minvalue.show = widgetProps.maxvalue.show = true;
                    widgetProps.placeholder.show = widgetProps.maxchars.show = true;
                    break;
                case 'date':
                case 'datetime-local':
                case 'month':
                case 'time':
                case 'week':
                    widgetProps.step.show = widgetProps.minvalue.show = widgetProps.maxvalue.show = true;
                    widgetProps.placeholder.show = widgetProps.maxchars.show = false;
                    break;
                case 'color':
                    widgetProps.updateon.show = widgetProps.updatedelay.show = widgetProps.maxchars.show = false;
                    widgetProps.placeholder.show = false;
                    break;
                }
            }

            /**
             * @ngdoc function
             * @name wm.widgets.form.FormWidgetUtils#createDataKeys
             * @methodOf wm.widgets.form.FormWidgetUtils
             * @function
             *
             * @description
             * function to create the dataKeys from the dataSet provided based on the type of the dataSet
             *
             * @param {object} scope isolate scope of the widget
             * @param {object} dataSet data set of the widget
             */
            function createDataKeys(scope, dataSet) {
                /*if dataSet is an array, process it to create the keys for the radioset.*/
                if (WM.isArray(dataSet)) {
                    /*if array values are objects*/
                    if (WM.isObject(dataSet[0])) {
                        _.forEach(dataSet, function (data) {
                            /*getting the dataObject*/
                            scope.dataObject[data.name] = data.dataValue;
                        });
                        /*getting the dataKeys for creating the option texts*/
                        scope.dataKeys = Object.keys(scope.dataObject);
                    } else {
                        scope.dataObject = dataSet;
                        /*getting the dataKeys for creating the option texts*/
                        scope.dataKeys = dataSet;
                    }
                } else if (WM.isString(dataSet)) {
                    scope.dataObject = dataSet;
                    /*getting the dataKeys for creating the option texts*/
                    scope.dataKeys = dataSet.split(',').map(function (option) { return option.trim(); });
                } else if (WM.isObject(dataSet)) {
                    scope.dataObject = dataSet;
                    /*getting the dataKeys for creating the option texts*/
                    scope.dataKeys = Object.keys(scope.dataObject);
                }
            }

            /**
             * @ngdoc function
             * @name wm.widgets.form.FormWidgetUtils#updatePropertyPanelOptions
             * @methodOf wm.widgets.form.FormWidgetUtils
             * @function
             *
             * @description
             * function to update datafield, display field in the property panel
             *
             * @param {object} dataset data set of the widget
             * @param {object} propertiesMap properties map of the data set
             * @param {object} scope isolate scope of the widget
             * @param {boolean} removeNull removeNull determines to remove the null values or not from the keys
             */
            function updatePropertyPanelOptions(dataset, propertiesMap, scope, removeNull) {
                var variableKeys = [];
                /* on binding of data*/
                if (dataset && WM.isObject(dataset)) {
                    dataset = dataset[0] || dataset;
                    variableKeys = WidgetUtilService.extractDataSetFields(dataset, propertiesMap) || [];
                }

                /*removing null values from the variableKeys*/
                if (removeNull) {
                    _.forEach(variableKeys, function (variableKey, index) {
                        if (dataset[variableKey] === null || WM.isObject(dataset[variableKey])) {
                            variableKeys.splice(index, 1);
                        }
                    });
                }

                /* re-initialize the property values */
                if (scope.newcolumns) {
                    scope.newcolumns = false;
                    scope.datafield = ALLFIELDS;
                    scope.displayfield = '';
                    scope.$root.$emit("set-markup-attr", scope.widgetid, {'datafield': ALLFIELDS, 'displayfield': ''});
                }
                /* ALLFIELDS option is not shown for the rating widget */
                if (scope.widgettype === 'wm-rating') {
                    scope.widgetProps.datafield.options = [''].concat(variableKeys);
                } else {
                    scope.widgetProps.datafield.options = ['', ALLFIELDS].concat(variableKeys);
                }
                scope.widgetProps.displayfield.options = [''].concat(variableKeys);
            }

            /**
             * @ngdoc function
             * @name wm.widgets.form.FormWidgetUtils#parseDataSet
             * @methodOf wm.widgets.form.FormWidgetUtils
             * @function
             *
             * @description
             * parse dataSet to filter the options based on the datafield, displayfield & displayexpression
             *
             * @param {object} dataSet data set of the widget
             * @param {object} scope isolate scope of the widget
             * @param {object} element element of widget
             */
            function parseDataSet(dataSet, scope, element) {
                /*store parsed data in 'data'*/
                var data = dataSet,
                    dataField = scope.datafield,
                    useKeys = scope.usekeys,
                    objectKeys = [],
                    displayField = getDisplayField(dataSet, scope.displayfield),
                    showAllKeys = CONSTANTS.isStudioMode && element.attr('data-identifier') === 'chart-columns';

                scope.widgetProps.displayfield.value = displayField;

                /*parsing the dataSet only if it is an array*/
                if (WM.isArray(dataSet)) {
                    /*if only keys of the object within dataset value needs to be used.*/
                    if (useKeys) {
                        data = {};
                        /*Decides whether to get all the data fields of the object columns or not*/
                        if (showAllKeys && Utils.isValidDataSet(dataSet)) {
                            /*Passing the properties map also since it is not accessible through the dataset*/
                            objectKeys = WidgetUtilService.extractDataSetFields(dataSet, scope.dataset.propertiesMap);
                        } else {
                            /*getting keys of the object*/
                            objectKeys = WM.isObject(dataSet[0]) ? Object.keys(dataSet[0]) : [];
                        }
                        /*iterating over object keys and creating checkboxset dataset*/
                        _.forEach(objectKeys, function (key) {
                            data[key] = key;
                        });
                    } else {
                        /*if filter dataSet if datafield is select other than 'All Fields'*/
                        if (dataField) {
                            data = {};
                            if (dataField !== ALLFIELDS) {
                                _.forEach(dataSet, function (option) {
                                    data[WidgetUtilService.getEvaluatedData(scope, option, {fieldName: "displayfield", expressionName: "displayexpression"}, displayField)] = option[dataField];
                                });
                            } else {
                                _.forEach(dataSet, function (option) {
                                    data[WidgetUtilService.getEvaluatedData(scope, option, {fieldName: "displayfield", expressionName: "displayexpression"}, displayField)] = option;
                                });
                            }
                        }
                    }
                } else if (WM.isObject(dataSet)) {
                    /* check for supporting data from sources other than live variable */
                    data = {};
                    if (showAllKeys &&  Utils.isValidDataSet(dataSet)) {
                        objectKeys = WidgetUtilService.extractDataSetFields(dataSet, scope.dataset.propertiesMap);
                    } else {
                        /*getting keys of the object*/
                        objectKeys = Object.keys(dataSet);
                    }
                    /*iterating over object keys and creating checkboxset dataset*/
                    _.forEach(objectKeys, function (key) {
                        data[key] = key;
                    });
                }
                return data;
            }

            /**
             * @ngdoc function
             * @name wm.widgets.form.FormWidgetUtils#parseData
             * @methodOf wm.widgets.form.FormWidgetUtils
             * @function
             *
             * @description
             * function to check if the data must be parsed or not
             *
             * @param {object} scope isolate scope of the widget
             */
            function parseData(scope) {
                /*if dataset is a string, no need to parse data*/
                if (WM.isString(scope.dataset || scope.scopedataset)) {
                    return false;
                }
                /*if dataset is array of strings, no need to parse data*/
                if ((WM.isArray(scope.dataset) && !WM.isObject(scope.dataset[0]))) {
                    return false;
                }
                return (!(WM.isArray(scope.scopedataset) && !WM.isObject(scope.scopedataset[0])));
            }

            /**
             * @ngdoc function
             * @name wm.widgets.form.FormWidgetUtils#getParsedDataSet
             * @methodOf wm.widgets.form.FormWidgetUtils
             * @function
             *
             * @description
             * function to return the parsed dataset
             *
             * @param {object} dataSet data set of the widget
             * @param {object} scope isolate scope of the widget
             * @param {object} element element of the widget
             *
             */
            function getParsedDataSet(dataSet, scope, element) {
                /*assign dataSet according to liveVariable or other variable*/
                dataSet = dataSet ? dataSet.data || dataSet : [];

                /*filter the dataSet based on datafield & displayfield*/
                if (parseData(scope)) {
                    dataSet = parseDataSet(dataSet, scope, element);
                }
                return dataSet;
            }

            /**
             * @ngdoc function
             * @name wm.widgets.form.FormWidgetUtils#getModelValue
             * @methodOf wm.widgets.form.FormWidgetUtils
             * @function
             *
             * @description
             * function to return the model value
             *
             * @param {object} scope isolate scope of the widget
             * @param {object} dataSet data set of the widget
             * @param {object} value selected value
             * @param {string} checkedValue current selected value
             *
             */
            function getModelValue(scope, dataSet, value, checkedValue) {
                value = WM.isString(value) ? value.trim() : value;
                /*populating model if dataSet is string*/
                if (WM.isString(dataSet)) {
                    return value;
                }
                if (WM.isArray(dataSet)) {
                    /*if dataSet is array and array values are objects*/
                    if (WM.isObject(dataSet[0])) {
                        return scope.dataObject[value];
                    }
                    /*if dataSet is array*/
                    return value;
                }
                /*if dataSet is object*/
                if (checkedValue) {
                    return scope.dataObject[value];
                }
                return value;
            }

            /**
             * @ngdoc function
             * @name wm.widgets.form.FormWidgetUtils#getRadiosetCheckboxsetTemplate
             * @methodOf wm.widgets.form.FormWidgetUtils
             * @function
             *
             * @description
             * function to create the widget template for radioset and checkboxset based on the dataKeys created.
             *
             * @param {object} scope isolate scope of the widget
             * @param {string} widgetType radioset or checkboxset
             *
             */
            function getRadiosetCheckboxsetTemplate(scope, widgetType) {
                var template = '',
                    liClass,
                    labelClass,
                    type;
                switch (widgetType) {
                case 'checkboxset':
                    liClass = 'checkbox app-checkbox';
                    labelClass = 'app-checkboxset-label';
                    type = 'checkbox';
                    break;
                case 'radioset':
                    liClass = 'radio app-radio';
                    labelClass = 'app-radioset-label';
                    type = 'radio';
                    break;
                }
                /*iterating over the keys to create the template for the widget.*/
                _.forEach(scope.dataKeys, function (dataKey, index) {
                    dataKey = WM.isString(dataKey) ? dataKey.trim() : dataKey;
                    template = template +
                        '<li class="' + liClass + ' {{itemclass}}" data-ng-class="{\'active\':checkedValues[' + "'" + dataKey + "'" + ']}">' +
                            '<label class="' + labelClass + '" data-ng-class="{\'disabled\':disabled}" title="' + dataKey + '">' +
                                 '<input type="' + type + '" ' + (scope.disabled ? ' disabled="disabled" ' : '') + 'data-attr-index=' + index + ' value="' + dataKey + '" data-ng-checked="checkedValues[' + "'" + dataKey + "'" + ']""/>' +
                                 '<span class="caption">' + dataKey + '</span>' +
                            '</label>' +
                        '</li>';
                });
                /*Holder for the model for submitting values in a form and a wrapper to for readonly mode*/
                template = template + '<input name="{{name}}" data-ng-disabled="disabled" data-ng-hide="true" class="model-holder" data-ng-model="_model_">'  + '<div data-ng-if="readonly || disabled" class="readonly-wrapper"></div>';
                return template;
            }

            /**
             * @ngdoc function
             * @name wm.widgets.form.FormWidgetUtils#getBoundVariableCategory
             * @methodOf wm.widgets.form.FormWidgetUtils
             * @function
             *
             * @description
             * function to get category of variable to which widget is bound to.
             *
             * @param {object} scope scope of the widget
             *
             */
            function getBoundVariableCategory(scope) {
                var variableName,
                    variableObj;
                variableName = Utils.getVariableName(scope);
                variableObj = variableName && Variables.getVariableByName(variableName);
                return variableObj && variableObj.category;
            }

            /**
             * @ngdoc function
             * @name wm.widgets.form.FormWidgetUtils#appendMessage
             * @methodOf wm.widgets.form.FormWidgetUtils
             * @function
             *
             * @description
             * function to append 'no data' message to element
             *
             * @param {object} element element of the widget
             *
             */
            function appendMessage(element) {
                var noDataMsg;
                noDataMsg = '<li>' + $rootScope.locale.MESSAGE_GRID_CANNOT_LOAD_DATA_IN_STUDIO + '</li>';
                element.empty().append(noDataMsg);
            }
            /**
             * @ngdoc function
             * @name wm.widgets.form.FormWidgetUtils#getProxyEventsMap
             * @methodOf wm.widgets.form.FormWidgetUtils
             * @function
             *
             * @description
             * function to get the proxy events map for radioset, checkboxset, radio, checkbox
             *
             */
            function getProxyEventsMap() {
                return {
                    'onClick':          {'name': 'data-ng-click',       'value': 'eventProxy("onClick", {$event: $event, $scope: this})'},
                    'onDblclick':       {'name': 'data-ng-dblclick',    'value': 'onDblclick({$event: $event, $scope: this})'},
                    'onMouseenter':     {'name': 'data-ng-mouseenter',  'value': 'onMouseenter({$event: $event, $scope: this})'},
                    'onMouseleave':     {'name': 'data-ng-mouseleave',  'value': 'onMouseleave({$event: $event, $scope: this})'},
                    'onMouseover':      {'name': 'data-ng-mouseover',   'value': 'onMouseover({$event: $event, $scope: this})'},
                    'onMouseout':       {'name': 'data-ng-mouseout',    'value': 'onMouseout({$event: $event, $scope: this})'}
                };
            }
            /**
             * @ngdoc function
             * @name wm.widgets.form.FormWidgetUtils#getFocusBlurEvents
             * @methodOf wm.widgets.form.FormWidgetUtils
             * @function
             *
             * @description
             * function to get the blur and focus events map for radioset, checkboxset, radio, checkbox
             *
             */
            function getFocusBlurEvents() {
                return {
                    'onFocus':          {'name': 'data-ng-focus',       'value': 'onFocus({$event: $event, $scope: this})'},
                    'onBlur':           {'name': 'data-ng-blur',        'value': 'onBlur({$event: $event, $scope: this})'}
                };
            }
            /**
             * @ngdoc function
             * @name wm.widgets.form.FormWidgetUtils#eventProxy
             * @methodOf wm.widgets.form.FormWidgetUtils
             * @function
             *
             * @description
             * function to trigger the event
             *
             * @param {object} scope scope of the widget
             * @param {string} eventType type of the event
             * @param {object} eventArgs arguments passed for the event
             */
            function eventProxy(scope, eventType, eventArgs) {
                /*On click of caption for the label, two events are triggered. Event is not called for caption event*/
                if (_.includes(eventArgs.$event.target.classList, 'caption')) {
                    return;
                }
                Utils.triggerFn(scope[eventType], eventArgs);
            }
            /**
             * @ngdoc function
             * @name wm.widgets.form.FormWidgetUtils#getProxyExcludeDates
             * @methodOf wm.widgets.form.FormWidgetUtils
             * @function
             *
             * @description
             * function to get all dates to be excluded.
             *
             * @param {object} excludeDates dates to be excluded
             */
            function getProxyExcludeDates(excludeDates) {
                var dates,
                    proxyExcludeDates = [];
                dates = WM.isString(excludeDates) ? excludeDates.split(',') : (WM.isArray(excludeDates) ? excludeDates : [excludeDates]);
                dates = dates.map(function (date) {
                    if (WM.isDate(date)) {
                        return date;
                    }
                    if (!isNaN(date)) {
                        return parseInt(date, 10);
                    }
                    return date;
                });
                _.forEach(dates, function (date) {
                    /*formatting date/timestamp in to date and converting it to long value and populating
                     'proxyExcludeDates' which is used in 'excludeDates()'*/
                    proxyExcludeDates.push(moment(moment(date).format('MM/DD/YYYY')).valueOf());
                });
                return proxyExcludeDates;
            }

            /**
             * @ngdoc function
             * @name wm.widgets.form.FormWidgetUtils#getUpdatedModel
             * @methodOf wm.widgets.form.FormWidgetUtils
             * @function
             *
             * @description
             * function to get the model value of date, datetime, time widgets in mobile.
             *
             * @param {string} minDate minimum date
             * @param {string} maxDate maximum date
             * @param {string} modelValue model value
             * @param {string} proxyModelValue proxy model value
             * @param {string} previousValue previous model value
             */
            function getUpdatedModel(minDate, maxDate, modelValue, proxyModelValue, previousValue) {
                if (minDate || maxDate) {
                    var startDate = Date.parse($filter('date')(minDate, 'yyyy-MM-dd')),
                        endDate = Date.parse($filter('date')(maxDate, 'yyyy-MM-dd')),
                        selectedDate = Date.parse(new Date(modelValue).toLocaleDateString());
                    if (startDate <= selectedDate && selectedDate <= endDate) {
                        return proxyModelValue;
                    }
                    alert('Please enter date between ' + minDate + " & " + maxDate);
                    return previousValue;
                }
                return proxyModelValue;
            }

            this.getDisplayField = getDisplayField;
            this.setPropertiesTextWidget = setPropertiesTextWidget;
            this.createDataKeys = createDataKeys;
            this.updatePropertyPanelOptions = updatePropertyPanelOptions;
            this.getParsedDataSet = getParsedDataSet;
            this.getModelValue = getModelValue;
            this.getRadiosetCheckboxsetTemplate = getRadiosetCheckboxsetTemplate;
            this.getBoundVariableCategory = getBoundVariableCategory;
            this.appendMessage = appendMessage;
            this.getProxyEventsMap = getProxyEventsMap;
            this.getFocusBlurEvents = getFocusBlurEvents;
            this.eventProxy = eventProxy;
            this.getProxyExcludeDates = getProxyExcludeDates;
            this.getUpdatedModel = getUpdatedModel;
        }
    ]);


/*global WM, wm, studio*/

/* Defining modules for wmCommonModule application */
wm.modules.wmCommon = WM.module('wm.common', []);

wm.modules.wmCommon.controllers = {};
wm.modules.wmCommon.directives = {};
wm.modules.wmCommon.factories = {};
wm.modules.wmCommon.services = {};
wm.modules.wmCommon.providers = {};

/*created a dummy $ocLazyLoad service to imitate perfect flow, to avoid execution stoppages.*/
wm.modules.wmCommon.services.$ocLazyLoad = WM.noop;

wm.modules.wmCommon.controller(wm.modules.wmCommon.controllers);
wm.modules.wmCommon.directive(wm.modules.wmCommon.directives);
wm.modules.wmCommon.factory(wm.modules.wmCommon.factories);
wm.modules.wmCommon.service(wm.modules.wmCommon.services);
wm.modules.wmCommon.provider(wm.modules.wmCommon.providers);

wm.modules.wmCommon.constant('SERVICE_TYPE_CONSTANTS', {
    JAVA_SERVICE: "JavaService",
    WM_JAVA_SERVICE: "wm.JavaService",
    WM_WEB_SERVICE: "wm.WebService",
    WM_DB_SERVICE: "wm.DataModel",
    JAVA_SERVICE_WORKSPACE_TYPE: "javaservice",
    DEFAULT_JAVA_SERVICE_NAME: "MyJavaService",
    JAVA_SERVICE_TREE_ROOT_NODE_ICON_CLASS: "java-service",
    SECURITY_SERVICE: "Security",
    SECURITY_SERVICE_CLASS: "security-service",
    SECURITY_SERVICE_WORKSPACE_TYPE: 'securityservice',
    SECURITY_SERVICE_TYPE: "SecurityServiceType"
});



/* Defining service urls for file services for run mode */
wm.modules.wmCommon.constant("WM_COMMON_SERVICE_URLS", {
    Project_Run: {
        inplaceDeploy: {
            url: "services/projects/:projectId/deployment/inplaceDeploy",
            method: "POST"
        }
    },
    FILE_RUN: {
        read: {
            url: ":filePath",
            method: "GET"
        }
    }
});

/*Defining the config for the*/
wm.modules.wmCommon.config(function (BaseServiceManagerProvider, WM_COMMON_SERVICE_URLS) {
    'use strict';

    BaseServiceManagerProvider.register(WM_COMMON_SERVICE_URLS);
});

wm.modules.wmCommon.run(function (Utils, CONSTANTS) {
    'use strict';
    CONSTANTS.isMobile = Utils.isMobile();
    CONSTANTS.isIE = Utils.isIE();
    CONSTANTS.isIE11 = Utils.isIE11();
});

/*global WM, wm*/
/*jslint todo: true */

/**
 * @ngdoc service
 * @name wm.common.$BaseServiceManager
 * @description
 * The `BaseServiceManager` contains the registration of all the plugin & core services.
 */

wm.modules.wmCommon.providers.BaseServiceManager = function () {
    'use strict';

    var baseServiceConfig = {};

    /*registers the config object with the core and all the plugins*/
    function register(serviceConfig) {
        WM.extend(baseServiceConfig, serviceConfig);
    }

    /*returns the config object*/
    function getConfig() {
        return WM.copy(baseServiceConfig);
    }

    this.getConfig = getConfig;
    this.register = register;

    this.$get = function () {
        return {
            /**
             * @ngdoc function
             * @name wm.common.$BaseServiceManager#getConfig
             * @methodOf wm.common.$BaseServiceManager
             * @function
             *
             * @description
             * returns the configuration object for all the services
             */
            getConfig: getConfig,

            /**
             * @ngdoc function
             * @name wm.common.$BaseServiceManager#register
             * @methodOf wm.common.$BaseServiceManager
             * @function
             *
             * @description
             * registers the config object with all the plugins and core configs'
             *
             * @param {object} config object of a studio module which has to registered
             */
            register: register
        };
    };
};

/*global WM, wm, _*/
/*jslint todo: true */
/*jslint sub: true */

/**
 * @ngdoc service
 * @name wm.common.$BaseService
 * @description
 * The `BaseService` service provides a common contract for all the services of wm.
 */

wm.modules.wmCommon.services.BaseService = [
    "$http",
    "$rootScope",
    "$injector",
    "BaseServiceManager",
    "DialogService",
    "Utils",
    "CONSTANTS",
    "$q",
    function ($http, $rootScope, $injector, BaseServiceManager, DialogService, Utils, CONSTANTS, $q) {
        "use strict";

        var wmLogger,
            wmToaster,
            isUnAuthorized,
        /*to store the failed function calls due to 401 error*/
            errorCallStack = [],
            localeObject,
            serviceCallPatterns = [new RegExp("^services"), new RegExp("j_spring_security_check")],
        /*Function to log actions performed; using the wmLogger*/
            logAction = function (type, message, description) {
                /*Return if wmLogger does not exist*/
                if (!wmLogger) {
                    return;
                }
                /*Invoke appropriate functions of the logger based on the type of action*/
                switch (type) {
                case "debug":
                    wmLogger.debug(message, description);
                    break;
                case "success":
                    wmLogger.success(message, description);
                    break;
                case "failure":
                    wmLogger.error(message, description);
                    break;
                default:
                    break;
                }
            },
        /*Gets the locale object*/
            getLocaleObject = function () {
                return $rootScope.locale || $rootScope.appLocale;
            },
        /*Function to display messages using the wmToaster*/
            displayMessage = function (type, messageTitle, messageDescription) {
                /*Return if wmToaster does not exist*/
                if (!wmToaster) {
                    return;
                }
                /*Invoke appropriate functions of the toaster based on the type of action*/
                switch (type) {
                case "success":
                    wmToaster.show('success', messageTitle, messageDescription);
                    break;
                case "failure":
                    wmToaster.show('error', messageTitle, messageDescription);
                    break;
                default:
                    break;
                }
            },

        /* replace all the parameters from the config service*/
            parseReplace = function (serviceParams) {

                var val, param,
                    config = BaseServiceManager.getConfig(),
                    urlParams = serviceParams.urlParams;

                /*get the config out of baseServiceManager*/
                if (config.hasOwnProperty(serviceParams.target) && config[serviceParams.target].hasOwnProperty(serviceParams.action)) {
                    config = Utils.getClonedObject(config[serviceParams.target][serviceParams.action]);

                    /*To handle dynamic urls, append the serviceParams.config.url with the static url(i.e., config.url)*/
                    if (serviceParams.config) {
                        config.url = (serviceParams.config.url || "") + config.url;
                        config.method = serviceParams.config.method || config.method;
                        config.headers = config.headers || {};
                        WM.forEach(serviceParams.config.headers, function (val, key) {
                            config.headers[key] = val;
                        });
                    }
                    /* check for url parameters to replace the url */
                    if (urlParams) {
                        for (param in urlParams) {
                            if (urlParams.hasOwnProperty(param)) {
                                val = urlParams[param];
                                if (WM.isDefined(val) && val !== null) {
                                    config.url = config.url.replace(new RegExp(":" + param, "g"), val);
                                }
                            }
                        }
                    }

                    config.url = Utils.preventCachingOf(config.url);

                    /* check for data */
                    if (serviceParams.params) {
                        config.params = serviceParams.params;
                    }
                    /* check for data */
                    if (serviceParams.data) {
                        config.data = serviceParams.data;
                    }
                    /* check for data parameters, written to support old service calls (.json calls) */
                    if (serviceParams.dataParams) {
                        config.data.params = serviceParams.dataParams;
                    }
                    /* check for headers */
                    if (serviceParams.headers) {
                        config.headers = serviceParams.headers;
                    }

                    /* set byPassResult flag */
                    config.byPassResult = serviceParams.byPassResult;

                    return config;
                }

                return null;
            },

        /* replace the parameters from service-error message*/
            parseError = function (errorDetails) {
                var errMsg;
                localeObject = localeObject || getLocaleObject();
                /*Check for local resources and code in the resource */
                if (!localeObject || !localeObject[errorDetails.messageKey]) {
                    errMsg = errorDetails.message || (errorDetails.parameters && errorDetails.parameters[0]) || "";
                    return errMsg;
                }

                /*Assigning the error message*/
                errMsg = Utils.getClonedObject(localeObject[errorDetails.messageKey]);
                /*Replace the parameters in the error code with the actual strings.*/
                errMsg = Utils.replace(errMsg, errorDetails.parameters);
                return errMsg;
            },

        /* to return http promise*/
            getHttpPromise = function (params) {
                var config = params;
                config.headers = config.headers || {};
                config.headers['X-Requested-With'] = 'XMLHttpRequest';
                if (params.hasOwnProperty('target') && params.hasOwnProperty('action')) {
                    config = parseReplace(params);
                }
                return $http(config);
            },

            successHandler = function (config, successCallback, response) {
                var returnVal;
                isUnAuthorized = false;
                if (!config.byPassResult && response.data.hasOwnProperty('result')) {
                    Utils.triggerFn(successCallback, response.data.result);
                    returnVal = response.data.result;
                } else {
                    Utils.triggerFn(successCallback, response.data);
                    returnVal = response.data;
                }
                logAction("success", "GOT_RESPONSE_FROM_SERVER", config.url);
                return returnVal;
            },

            failureHandler = function (config, successCallback, failureCallback, error) {
                var errTitle, errMsg, errorDetails, appManager;
                /*if user is unauthorized, then show login dialog*/
                if (error.status === 401 && !error.headers('X-WM-Login-ErrorMessage')) {
                    pushToErrorCallStack(config, successCallback, failureCallback);
                    if (CONSTANTS.isRunMode) {
                        appManager = Utils.getService("AppManager");
                        appManager.handleSessionTimeOut();
                    } else {
                        handleSessionTimeOut();
                    }
                    return;
                }
                isUnAuthorized = false;
                if (error.status === 403) {
                    pushToErrorCallStack(config, successCallback, failureCallback);
                    displayMessage('failure', $rootScope.appLocale.LABEL_ACCESS_DENIED || 'Access Denied', $rootScope.appLocale.LABEL_FORBIDDEN_MESSAGE || 'The requested resource access/action is forbidden.');
                    return;
                }
                /*check if 'locale' resource is loaded*/
                if (localeObject) {
                    /*assigning default error messages */
                    errTitle = localeObject["MESSAGE_ERROR_HTTP_ERROR_TITLE"];
                    errMsg = localeObject["MESSAGE_ERROR_HTTP_STATUS_ERROR_DESC"];
                } else {
                    /*assigning default error messages */

                    errTitle = "Error!";
                    errMsg = "Service call failed";
                }

                /* check for error code in the response */
                if (error.data) {
                    if (error.data.errors) {
                        errMsg = "";
                        errorDetails = error.data.errors;
                        /* If errors is not an array and contains error */
                        if (errorDetails.error) {
                            errorDetails.error.forEach(function (errorDetails, i) {
                                errMsg += parseError(errorDetails) + (i > 0 ? "\n" : "");
                            });
                        }
                    }
                }

                /* check for login failure header */
                if (error.headers('X-WM-Login-ErrorMessage')) {
                    errMsg = error.headers('X-WM-Login-ErrorMessage');
                }

                /*check if failureCallback is defined*/
                if (WM.isFunction(failureCallback)) {
                    Utils.triggerFn(failureCallback, errMsg, errorDetails);
                } else {
                    displayMessage('failure', errTitle, errMsg);
                }

                logAction("failure", "GOT_RESPONSE_FROM_SERVER", config.url + ' as ' + errMsg);
                return error;
            },
            /**
             * Checks whether the given url is a service url or not.
             *
             * @param url
             * @returns {boolean} return true, if url matches with at least one service call pattern.
             */
            isServiceCall = function (url) {
                return _.some(serviceCallPatterns, function (p) {
                    return p.test(url);
                });
            },
        /* wrapper for the $http method*/
            makeCall = function (config, successCallback, failureCallback) {

                logAction("debug", "SEND_REQUEST_TO_SERVER", config.url);

                if (CONSTANTS.isRunMode && $rootScope.isMobileApplicationType && isServiceCall(config.url)) {
                    config.url = $rootScope.project.deployedUrl + "/" + config.url;
                }

                /* get a deferred object used to abort the http request */
                var deferred = $q.defer(),
                    promiseObj;

                config.timeout = deferred.promise;

                /* get the promise object from http request */
                promiseObj = getHttpPromise(config)
                    .then(
                        successHandler.bind(undefined, config, successCallback),
                        failureHandler.bind(undefined, config, successCallback, failureCallback)
                    );

                /* assign abort method to the http request promise object */
                promiseObj.abort = function () {
                    /* resolve the deferred object passed to the http request config to force abort */
                    deferred.resolve();
                };

                /* clearing off the promise object after request is finished */
                promiseObj.finally(function () {
                    promiseObj.abort = WM.noop;
                    deferred = promiseObj = null;
                });

                return promiseObj;
            },

        /* function to send the request to the server*/
            send = function (params, successCallback, failureCallback) {

                var serviceSettings = parseReplace(params);

                /*if service settings are found*/
                if (serviceSettings) {
                    return makeCall(serviceSettings, successCallback, failureCallback);
                }
                localeObject = localeObject || getLocaleObject();
                /* display error */
                displayMessage('failure', localeObject["MESSAGE_ERROR_HTTP_ERROR_TITLE"], localeObject["MESSAGE_ERROR_HTTP_CONFIG_ERROR_DESC"]);
            },

        /* function to execute the action*/
            execute = function (params, successCallback, failureCallback) {
                /*check for the target and action*/
                if (params.hasOwnProperty('target') && params.hasOwnProperty('action')) {
                    return send(params, successCallback, failureCallback);
                }
                Utils.triggerFn(successCallback);
            },

        /*Function to initialize the dependencies required by the service*/
            initializeDependencies = function () {
                try {
                    /*New injector is created for the wmCore module.*/
                    if ($injector.get('wmLogger')) {
                        /*Request wmLogger service from the injector*/
                        wmLogger = $injector.get('wmLogger');
                        /*compile with root scope*/
                        wmLogger.compile($rootScope);
                    }
                } catch (exception) {
                    if (wmLogger) {
                        wmLogger.error('EXCEPTION_CAUSED', ['initializeDependencies in wmService.baseService', exception && exception.message]);
                    }
                }
                try {
                    if ($injector.get('wmToaster')) {
                        /*Request wmToaster service from the injector*/

                        wmToaster = $injector.get('wmToaster');
                        /*compile with root scope*/
                        wmToaster.compile($rootScope);
                    }
                } catch (exception) {
                    if (wmLogger) {
                        wmLogger.error('EXCEPTION_CAUSED', ['initializeDependencies in wmService.baseService', exception && exception.message]);
                    }
                }
            },

        /*function to push server calls to an object-`callstack` */
            pushToErrorCallStack = function (config, success, failure) {
                errorCallStack.push({
                    config: config,
                    success: success,
                    failure: failure
                });
            },

        /*function to execute all the calls in the the callStack object*/
            executeErrorCallStack = function () {
                if (errorCallStack.length) {
                    errorCallStack.forEach(function (call) {
                        if (!call.config) {
                            Utils.triggerFn(call.success);
                        } else {
                            makeCall(call.config, call.success, call.failure);
                        }
                    });
                    errorCallStack.length = 0;
                }
            },

        /*function to handle the session timeout in studio mode*/
            handleSessionTimeOut = function () {
                if (!isUnAuthorized) {
                    var dialogId = CONSTANTS.isStudioMode ? 'sessionTimeOutDialog' : 'CommonLoginDialog';
                    if(!CONSTANTS.isStudioMode) {
                        Utils.triggerFn($rootScope.onSessionTimeout);
                        $rootScope.$emit("on-sessionTimeout");
                    }
                    $rootScope.isStudioDisabled = false;
                    DialogService.closeAllDialogs();
                    DialogService.showDialog(dialogId, {
                        resolve: {
                            OnLogin: function () {
                                return function () {
                                    executeErrorCallStack();
                                    DialogService.hideDialog(dialogId);
                                };

                            }
                        }
                    });
                    isUnAuthorized = true;
                }
            };

        initializeDependencies();

        /* APIs returned by the service.*/
        return {

            /**
             * @ngdoc function
             * @name wm.common.$BaseService#execute
             * @methodOf wm.common.$BaseService
             * @function
             *
             * @description
             * sends the data to the server depending on the method, from execute method.
             *
             * @param {object} serviceSettings for the http post
             * @param {function} function to called on success
             * @param {function} function to called on failure
             */
            execute: execute,

            /**
             * @ngdoc function
             * @name wm.common.$BaseService#send
             * @methodOf wm.common.$BaseService
             * @function
             *
             * @description
             * sends the data to the server depending on the method, without execute method.
             *
             * @param {object} serviceSettings for the http post
             * @param {function} function to called on success
             * @param {function} function to called on failure
             */

            send: send,

            /**
             * @ngdoc function
             * @name wm.common.$BaseService#getHttpPromise
             * @methodOf wm.common.$BaseService
             * @function
             *
             * @description
             * to get the promise object of $http
             *
             * @param {object} serviceSetting for the http post
             * @param {function} function to called on success
             * @param {function} function to called on failure
             *
             * @return {object} $http promise object.
             */

            getHttpPromise: getHttpPromise,

            /**
             * @ngdoc function
             * @name wm.common.$BaseService#pushToCallStack
             * @methodOf wm.common.$BaseService
             * @function
             *
             * @description
             * to add all failed server calls to call stack
             *
             * @param {object} serviceSetting for the http post
             * @param {function} function to called on success
             * @param {function} function to called on failure
             */

            pushToErrorCallStack: pushToErrorCallStack,

            /**
             * @ngdoc function
             * @name wm.common.$BaseService#executeErrorCallStack
             * @methodOf wm.common.$BaseService
             * @function
             *
             * @description
             * to execute all server calls in the call stack
             */

            executeErrorCallStack: executeErrorCallStack,

            /**
             * @ngdoc function
             * @name wm.common.$BaseService#handleSessionTimeOut
             * @methodOf wm.common.$BaseService
             * @function
             *
             * @description
             * to handle session timeout in an app
             */

            handleSessionTimeOut: handleSessionTimeOut,

            /**
             * @ngdoc function
             * @name wm.common.$BaseService#parseError
             * @methodOf wm.common.$BaseService
             * @function
             *
             * @description
             * to parse the error received from the server.
             *
             * @param {object} error details
             *
             * @return {string} errorMsg error message
             */

            parseError: parseError
        };
    }];

/*global WM, wm*/
/*jslint todo: true */
/**
 * @ngdoc service
 * @name wm.common.$FileService
 * @description
 * The `FileService` provides the details about the project apis.
 */

wm.modules.wmCommon.services.FileService = function (BaseService, CONSTANTS) {
    'use strict';

    /* variable holding service target based on the app mode */
    var target = CONSTANTS.isRunMode ? "FILE_RUN" : "FILE";

    /* APIs returned by the FileService.*/
    return {

        /**
         * @ngdoc function
         * @name wm.common.$FileService#read
         * @methodOf wm.common.$FileService
         * @function
         *
         * @description
         * read from the file in a page in the project.
         *
         * @param {object} params contain data of the file to be read
         * @param {function} successCallback to be called on success
         * @param {function} failureCallback to be called on failure
         */
        read: function (params, successCallback, failureCallback) {
            /*initialize url params*/
            var urlParams = {
                filePath: params.path
            };

            /* if in studio mode, append projectID to ural params*/
            if (CONSTANTS.isStudioMode) {
                urlParams.projectID = params.projectID;
            }

            BaseService.execute({
                target: target,
                action: "read",
                urlParams: urlParams
            }, successCallback, failureCallback);
        },

        /**
         * @ngdoc function
         * @name wm.common.$FileService#readDir
         * @methodOf wm.common.$FileService
         * @function
         *
         * @description
         * read from the directory in the project.
         *
         * @param {object} params contain data of the directory to be read
         * @param {function} successCallback to be called on success
         * @param {function} failureCallback to be called on failure
         */
        readDir: function (params, successCallback, failureCallback) {
            /*initialize url params*/
            var urlParams = {
                filePath: params.path
            };

            /* if in studio mode, append projectID to ural params*/
            if (CONSTANTS.isStudioMode) {
                urlParams.projectID = params.projectID;
            }

            BaseService.execute({
                target: target,
                action: "readDir",
                urlParams: urlParams
            }, successCallback, failureCallback);
        }
    };
};
/*global wm, WM, FileTransfer, _, window, FormData, XMLHttpRequest*/
/*jslint sub: true */
/*Service for uploading files to backend server.*/
wm.modules.wmCommon.services.FileUploadService =  ['$rootScope', 'Utils', '$q', 'CONSTANTS', function ($rootScope, Utils, $q, CONSTANTS) {
    'use strict';

    var FILE_UPLOAD_STATUSES = {
        'QUEUED'        : 'queued',
        'IN_PROGRESS'   : 'inprogress',
        'SUCCESS'       : 'success',
        'ERROR'         : 'error',
        'ABORTED'       : 'abort'
    };

    function transformEvent(event) {
        event.target = event.target || {
            status: event.responseCode,
            response: event.response
        };
        return event;
    }

    /* prepares file object */
    function FileTransferObject(file, transferFn, promise, abortFn) {
        this.name = file.name;
        this.size = file.size;
        this.status = FILE_UPLOAD_STATUSES.QUEUED;
        this.start = function () {
            if (this.status === FILE_UPLOAD_STATUSES.QUEUED) {
                this.status = FILE_UPLOAD_STATUSES.IN_PROGRESS;
                Utils.triggerFn(transferFn);
            }
        };
        this.then = function (onSuccess, onError, onProgress) {
            var self = this;
            promise.then(function (event) {
                self.status = FILE_UPLOAD_STATUSES.SUCCESS;
                Utils.triggerFn(onSuccess, event);
            }, function (event) {
                self.status = FILE_UPLOAD_STATUSES.ERROR;
                Utils.triggerFn(onError, event);
            }, function (event) {
                self.progress = Math.round(event.loaded / event.total * 100);
                Utils.triggerFn(onProgress, event);
            });
            return this;
        };
        this.finally = function (onFinal) {
            promise.finally(onFinal);
        };
        /* aborts the file upload */
        this.abort = function () {
            this.status = FILE_UPLOAD_STATUSES.ABORTED;
            Utils.triggerFn(abortFn);
            this.finally();
        };
    }

    /* upload file using fileTransfer */
    function uploadWithFileTransfer(file, url, options) {
        var defer = $q.defer(),
            ft = new FileTransfer(),
            uploadUrl = $rootScope.project.deployedUrl + url,
            ftOptions = {
                'fileKey'   : options.paramName,
                'fileName'  : file.name
            },
            transferFn = function () {
                ft.upload(file.path,
                    uploadUrl,
                    function (event) {
                        defer.resolve(transformEvent(event));
                    },
                    function (event) {
                        defer.reject(transformEvent(event));
                    },
                    ftOptions);
            };
        ft.onprogress = function (event) {
            defer.notify(transformEvent(event));
        };
        return new FileTransferObject(file, transferFn, defer.promise, ft.abort.bind(ft));
    }

    /* upload file with ajax calling */
    function uploadWithAjax(file, url, options) {
        var defer = $q.defer(),
            fd = new FormData(),
            xhr;
        /* append file to form data */
        if (WM.isArray(file)) {
            WM.forEach(file, function (fileObject) {
                if (fileObject.file && fileObject.uploadPath) {
                    fd.append(options.paramName, fileObject.file, fileObject.file.name);
                }
            });
        } else if (WM.isObject(file)) {
            fd.append(options.paramName, file, file.name);
        }
        /* create ajax xmlHttp request */
        xhr = new XMLHttpRequest();
        /* create progress,success,error,aborted event handlers */
        xhr.upload.addEventListener('progress', defer.notify.bind(defer));
        xhr.addEventListener('load', defer.resolve.bind(defer));
        xhr.addEventListener('error', defer.reject.bind(defer));
        xhr.open('POST', url);
        return new FileTransferObject(file, xhr.send.bind(xhr, fd), defer.promise, xhr.abort.bind(xhr));
    }

    /* upload the file - IE9 support */
    function uploadWithIframe(file, url, options) {
        var defer = $q.defer(),
            uploadConfig = {
                url: url,
                formName: options.formName
            },
            transferFn = function () {
                Utils.fileUploadFallback(uploadConfig, function (event) {
                    defer.resolve(event);
                }, function (event) {
                    defer.reject(event);
                });
            };
        return new FileTransferObject(file, transferFn, defer.promise, WM.noop);
    }

    /* upload the next file depending on the status */
    function starNextFileTransfer(fts) {
        var ft = _.find(fts, function (ft) {
                return ft.status === FILE_UPLOAD_STATUSES.QUEUED;
            });
        if (ft) {
            ft.start();
            ft.finally(starNextFileTransfer.bind(undefined, fts));
        }
    }

    /* upload the max no of files at once i.e. two at once based on max*/
    function startFileTransfers(fts, max) {
        var i = 0, len = fts.length;
        while (i < max && i < len) {
            starNextFileTransfer(fts);
            i++;
        }
    }

    /**
     * This function uploads the file to the given url endpoint.
     *
     * @param file file to upload
     * @param url http endpoint to which the file has to be submitted.
     * @param options
     * @returns a promise to listen for success, event, onProgress.
     *  One can also abort the upload by simply calling abort function.
     */
    this.upload = function (files, url, options) {
        var fileTransfers = [];
        options = _.extend({
            'paramName' : 'files'
        }, options);

        if (CONSTANTS.hasCordova) {
            _.forEach(files, function (file) {
                fileTransfers.push(uploadWithFileTransfer(file, url, options));
            });
        } else if (window.FormData) {
            _.forEach(files, function (file) {
                fileTransfers.push(uploadWithAjax(file, url, options));
            });
        } else {
            _.forEach(files, function (file) {
                fileTransfers.push(uploadWithIframe(file, url, options));
            });
        }
        startFileTransfers(fileTransfers, 2);
        return fileTransfers;
    };
}];
/*global WM, wm*/
/*jslint todo: true */
/**
 * @ngdoc service
 * @name wm.common.$ProjectService
 * @description
 * The `ProjectService` provides the details about the project apis.
 */

wm.modules.wmCommon.services.ProjectService = function (BaseService, CONSTANTS, $location, Utils) {
    'use strict';

    function run(details, successCallback, failureCallback) {
        var target = CONSTANTS.isRunMode ? 'Project_Run' : 'Project';
        BaseService.execute({
            target: target,
            action: "inplaceDeploy",
            urlParams: {
                "projectId": details.projectId
            },
            config: details.config
        }, successCallback, failureCallback);
    }

    function getDeployedUrl() {
        var locationUrl,
            lastIndex,
            projectDeployedUrl;

        /*If $location.$$absUrl is of the form http://localhost:8080/WM2c908a52446c435b01446cfdacf50013/#/Main,
         * remove # and the page name to get only the deployed url of the project.*/
        if (CONSTANTS.isRunMode) {
            locationUrl = $location.$$absUrl;
            lastIndex = locationUrl.split("#")[0].lastIndexOf("/");
            projectDeployedUrl = locationUrl.substr(0, lastIndex);
            lastIndex = projectDeployedUrl.lastIndexOf("/");
            if (projectDeployedUrl[lastIndex + 1] === "#") {
                projectDeployedUrl = projectDeployedUrl.substr(0, lastIndex);
            }
            if (projectDeployedUrl.indexOf('http') !== -1) {
                /*Removing the protocol from the url*/
                if (projectDeployedUrl.indexOf('https:') !== -1) {
                    projectDeployedUrl = projectDeployedUrl.substr(6);
                } else {
                    projectDeployedUrl = projectDeployedUrl.substr(5);
                }
            } else if (projectDeployedUrl.indexOf('file') !== -1) {
                /* Set root url */
                Utils.fetchContent(
                    'json',
                    Utils.preventCachingOf('./config.json'),
                    function (response) {
                        if (!response.error) {
                            projectDeployedUrl = response.baseUrl;
                        }
                    },
                    WM.noop,
                    true
                );
            }

            return projectDeployedUrl;
        }
    }

    /**
     * @ngdoc function
     * @name wm.common.$ProjectService#getId
     * @methodOf wm.common.$ProjectService
     * @function
     *
     * @description
     * returns the id of the project service based on the 'mode'.
     *
     */
    function getId() {
        return $location.$$absUrl.split('/')[3];
    }

    /* APIs returned by the ProjectService.*/
    return {

        /**
         * @ngdoc function
         * @name wm.common.$ProjectService#run
         * @methodOf wm.common.$ProjectService
         * @function
         *
         * @description
         * deploy and run the specified project.
         *
         * @param {object} details Details object
         * @param {function} successCallback to called on success
         * @param {function} failureCallback to called on failure
         */
        run: run,
        /**
         * @ngdoc function
         * @name wm.common.$ProjectService#getDeployedUrl
         * @methodOf wm.common.$ProjectService
         * @function
         *
         * @description
         * Returns deployed url
         *
         */
        getDeployedUrl : getDeployedUrl,
        /*
        * Returns project Id
        *
        * */
        getId : getId
    };

};

/*global WM, wm, window, _*/
/*jslint todo: true */
/*jslint sub: true */
/**
 * @ngdoc service
 * @name wm.prefab.$PrefabManager
 * @description
 * The `PrefabManager` service provides the methods for prefab actions.
 */

WM.module('wm.prefabs')
    .service('PrefabManager', [
        '$rootScope',
        '$timeout',
        '$ocLazyLoad',
        'PrefabService',
        'ProjectService',
        'Variables',
        'Utils',
        'wmToaster',
        'CONSTANTS',
        'i18nService',
        '$q',
        '$interval',
        'DialogService',
        'FileService',

        function ($rootScope, $timeout, $ocLazyLoad, PrefabService, ProjectService, Variables, Utils, wmToaster, CONSTANTS, i18nService, $q, $interval, DialogService, FileService) {
            'use strict';

            var studioPrefabNamePropertiesMap,
                studioPrefabNameConfigMap = {},
                appPrefabNamePropertiesMap,
                appPrefabNameConfigMap = {},
                activePrefabConfig,
                pendingTasks = {
                    resources: {}
                },
                projectDetails;

            function getProjectId() {
                if (projectDetails) {
                    return projectDetails.id;
                }

                projectDetails = ProjectService.getDetails();
                return projectDetails && projectDetails.id;
            }

            /*
             * update the studio-prefab properties in studioPrefabNamePropertiesMap
             */
            function onStudioPrefabsLoad(prefabs) {
                prefabs.forEach(function (prefab) {
                    studioPrefabNamePropertiesMap[prefab.name] = prefab;
                });
            }

            /*
             * Get the list of studio-prefabs and update studioPrefabNamePropertiesMap.
             * returns promise.
             */
            function listStudioPrefabs() {
                studioPrefabNamePropertiesMap = {};
                return PrefabService.list().then(onStudioPrefabsLoad);
            }

            /*
             * update the app-prefab properties in appPrefabNamePropertiesMap
             */
            function onAppPrefabsLoad(prefabs) {
                prefabs.forEach(function (prefab) {
                    appPrefabNamePropertiesMap[prefab.name] = prefab;
                });
            }

            /*
             * Get the list of app-prefabs and update appPrefabNamePropertiesMap.
             * This method fetches the app-prefab properties in synchronous way.
             * Triggers the callback on success
             */
            function listAppPrefabs(callback) {

                appPrefabNamePropertiesMap = {};

                Utils.fetchContent(
                    'json',
                    Utils.preventCachingOf('services/projects/' + getProjectId() + '/prefabs'),
                    function (response) {
                        onAppPrefabsLoad(response);
                        Utils.triggerFn(callback);
                    },
                    function () {
                        wmToaster.show('error', $rootScope.locale.MESSAGE_ERROR_TITLE, $rootScope.locale.MESSAGE_ERROR_PROJECT_PREFAB_LIST_FAILED_DESC);
                    },
                    true
                );
            }

            /*
             * Get the config.json of application prefab in synchronous way and trigger the callback with the response.
             */
            function loadAppPrefabConfig(prefabName, callback) {
                var configUrl,
                    config;

                config = appPrefabNameConfigMap[prefabName];

                if (config) {
                    Utils.triggerFn(callback, config);
                } else {
                    configUrl = CONSTANTS.isRunMode
                        ? 'app/prefabs/' + prefabName + '/config.json'
                        : Utils.getProjectResourcePath(getProjectId()) + 'app/prefabs/' + prefabName + '/config.json';

                    Utils.fetchContent(
                        'json',
                        Utils.preventCachingOf(configUrl),
                        function (response) {
                            appPrefabNameConfigMap[prefabName] = response;
                            Utils.triggerFn(callback, response);
                        },
                        function () {
                            wmToaster.show('error', $rootScope.locale.MESSAGE_PREFAB_CONFIG_ERROR_TITLE, $rootScope.locale.MESSAGE_PREFAB_CONFIG_ERROR_DESC);
                        },
                        true
                    );
                }
            }

            /*
             * Get the config.json of studio-prefab in asynchronous way.
             * Returns a promise.
             */
            function loadStudioPrefabConfig(prefabName) {
                var configUrl, deferred = $q.defer();

                configUrl = 'services/prefabs/' + studioPrefabNamePropertiesMap[prefabName].id + '/files/webapp/config.json';

                Utils.fetchContent(
                    'json',
                    Utils.preventCachingOf(configUrl),
                    function (response) {
                        studioPrefabNameConfigMap[prefabName] = response;
                        deferred.resolve(response);
                    },
                    function (error) {
                        delete studioPrefabNamePropertiesMap[prefabName];
                        delete studioPrefabNameConfigMap[prefabName];
                        //wmToaster.show('error', $rootScope.locale.MESSAGE_PREFAB_CONFIG_ERROR_TITLE, $rootScope.locale.MESSAGE_PREFAB_CONFIG_ERROR_DESC);
                        //wmLogger.error("GOT_RESPONSE_FROM_SERVER", "Prefab config file error");
                        deferred.reject(error);
                    }
                );
                return deferred.promise;
            }

            /*
             * Get the config.json of all studio-prefabs.
             * Configs are loaded in asynchronous way.
             * returns a promise
             */
            function getAllStudioPrefabsConfig() {

                var deferred = $q.defer(),
                    prefabNames = Object.keys(studioPrefabNamePropertiesMap),
                    count = prefabNames.length;

                studioPrefabNameConfigMap = {};

                function onConfigLoad() {
                    count -= 1;
                    if (!count) {
                        var content = Utils.getClonedObject(studioPrefabNamePropertiesMap);
                        Object
                            .keys(studioPrefabNameConfigMap)
                            .forEach(function (prefabName) {
                                content[prefabName].config = studioPrefabNameConfigMap[prefabName];
                            });
                        deferred.resolve(content);
                    }
                }

                prefabNames.forEach(function (prefabName) {
                    loadStudioPrefabConfig(prefabName)
                        .finally(onConfigLoad);
                });

                return deferred.promise;
            }

            /*
             * returns true if the version of the studio-prefab is not same as the app-prefab
             */
            function isPrefabVersionMismatch(prefabName) {
                return studioPrefabNamePropertiesMap[prefabName].version !== appPrefabNamePropertiesMap[prefabName].version;
            }

            /*
             * Register the prefab in a synchronous way and trigger the callback on success.
             */
            function doRegistration(prefabName, callback) {

                /* register the prefab & then add the widget to canvas */
                PrefabService.register({
                    projectId: getProjectId(),
                    prefabId: studioPrefabNamePropertiesMap[prefabName].id
                }, function () {
                    appPrefabNamePropertiesMap[prefabName] = Utils.getClonedObject(studioPrefabNamePropertiesMap[prefabName]);
                    appPrefabNameConfigMap[prefabName] = studioPrefabNameConfigMap[prefabName];
                    Utils.triggerFn(callback);
                }, function () {
                    wmToaster.show('error', $rootScope.locale.MESSAGE_ERROR_TITLE, $rootScope.locale.MESSAGE_ERROR_PREFAB_REGISTER_FAILED_DESC);
                });
            }

            /*
             * Show the prefab upgradation dialog.
             */
            function showPrefabUpgradeDialog(prefabName) {
                DialogService
                    .showDialog('upgradePrefabDialog', {
                        'resolve': {
                            'upgradeFn': function () {
                                return function () {
                                    // register the prefab and reload the page
                                    doRegistration(prefabName, function () {
                                        Utils.getService('StudioActions')
                                            .saveProject()
                                            .then(function () {
                                                window.location.reload();
                                            });
                                    });
                                };
                            },
                            'prefabName': function () {
                                return prefabName;
                            }
                        }
                    });
            }

            /*
             * Check whether registration is required or not.
             * Register the prefab if it is never registered with the app.
             * If a legacy version of the prefab is found, show upgrade dialog.
             * Trigger the callback if the registration is not required.
             */
            function validateAndRegister(prefabName, callback) {
                if (!appPrefabNamePropertiesMap[prefabName]) {
                    // prefab never registered.
                    doRegistration(prefabName, callback);
                } else if (isPrefabVersionMismatch(prefabName)) {
                    // prefab is registered but the version of studio-prefab is not same as app-prefab
                    showPrefabUpgradeDialog(prefabName);
                    Utils.triggerFn(callback);
                } else {
                    // registration is not required
                    Utils.triggerFn(callback);
                }
            }

            /*
             * If the app-prefab properties are not available then load them and check for version mismatch
             */
            function registerPrefab(prefabName, callback) {

                if (appPrefabNamePropertiesMap === undefined) {
                    listAppPrefabs(validateAndRegister.bind(undefined, prefabName, callback));
                } else {
                    validateAndRegister(prefabName, callback);
                }
            }

            /* callback function when prefab resource is loaded */
            function OnPrefabResourceLoad(count) {
                this.count = count;

                this.updateCount = function () {
                    this.count -= 1;
                };

                this.getCount = function () {
                    return this.count;
                };
            }

            /* load external scripts required by the prefab */
            function loadScripts(scripts) {
                var deferred = $q.defer(),
                    rand = Date.now(),
                    count = 0,
                    fnName = 'onPrefabResourceLoad' + rand,
                    obj,
                    intervalHandler;

                scripts = scripts.map(function (script) {
                    if (script.indexOf('onPrefabResourceLoad') !== -1) {
                        count += 1;
                        script = script.replace('onPrefabResourceLoad', fnName);
                    }
                    return script;
                });

                function onResourcesReady() {
                    if (!obj.getCount() && intervalHandler) {
                        $interval.cancel(intervalHandler);
                        intervalHandler = null;
                        deferred.resolve();
                    }
                }

                obj = new OnPrefabResourceLoad(count);

                window[fnName] = obj.updateCount.bind(obj);

                if (!scripts || !scripts.length) {
                    deferred.resolve();
                } else {
                    Utils.loadScripts(scripts, function () {
                        // some timeout for the scripts to execute
                        intervalHandler = $interval(onResourcesReady, 50, 10);
                    });
                }

                return deferred.promise;
            }

            /* load the external angular modules required by prefab */
            function loadModules(modules) {
                var deferred = $q.defer();

                if (!modules || !modules.length) {
                    deferred.resolve();
                } else {
                    $ocLazyLoad.load(modules)
                        .then(function () {
                            // Why timeout? give some time for the scripts to execute. then load the modules.
                            $timeout(deferred.resolve, 300, false);
                        });
                }

                return deferred.promise;
            }

            /* loads the script, styles, variables, template of the prefab */
            function loadPrefabMinifiedPage(prefabName) {
                var config = appPrefabNameConfigMap[prefabName], url, deferred = $q.defer();
                url = config.templateUrl.substr(0, config.templateUrl.lastIndexOf('/') + 1) + 'page.min.html';
                /*read the file content*/
                FileService.read({
                    path: 'app/prefabs/' + prefabName + url,
                    projectID: $rootScope.project.id
                }, function (prefabContent) {
                    var pageDom = WM.element("<div>" + prefabContent + "</div>"),
                        htmlMarkup = pageDom.find('script[id="Main.html"]').html() || '';
                    /*load the styles & scripts*/
                    WM.element('head').append(pageDom.find('style, script'));
                    /* append the isPrefab flag to each variable */
                    WM.forEach(window["_MainPage_Variables_"], function (variable) {
                        variable.prefabName = prefabName;
                    });
                    /* set variables in prefab namespace, registration will occur in page directive */
                    Variables.setPageVariables(prefabName, window["_MainPage_Variables_"]);
                    deferred.resolve(htmlMarkup);
                });
                return deferred.promise;
            }

            function getPrefabResourceUrl(resourcePath, resourceBasePath, preventCache) {
                var _url = resourcePath;
                if (!Utils.stringStartsWith(resourcePath, 'http://|https://|//')) {
                    _url = (resourceBasePath + _url).replace('//', '/');
                }
                if (preventCache) {
                    _url = Utils.preventCachingOf(_url);
                }

                return _url;
            }

            function extendAppLocale(root) {
                var localePath = root + (root.lastIndexOf('/') === root.length - 1 ? '' : '/') + 'resources/i18n/';

                if (CONSTANTS.isRunMode) {
                    i18nService.loadComponentLocaleBundle(localePath);
                } else {
                    $rootScope.$emit('load-component-locale-bundle', localePath);
                }
            }

            function loadDependencies(prefabName) {
                var config = appPrefabNameConfigMap[prefabName],
                    resources,
                    resourcePath,
                    scriptFiles,
                    styleFiles,
                    modules,
                    handler,
                    deferred = $q.defer();

                if (!config) {
                    deferred.reject();
                    return deferred.promise;
                }

                resources = config.resources || {};

                resourcePath = CONSTANTS.isRunMode
                                ? 'app/prefabs/' + prefabName + '/'
                                : 'services/projects/' + getProjectId() + '/resources/info/web/app/prefabs/' + prefabName + '/';

                if (pendingTasks.resources[prefabName]) {
                    handler = $rootScope.$on(prefabName + '-dependencies-ready', function (evt, prefabContent) {
                        evt.stopPropagation();
                        deferred.resolve(prefabContent);
                        handler();
                    });
                } else {
                    pendingTasks.resources[prefabName] = true;

                    scriptFiles = resources.scripts || [];
                    styleFiles = resources.styles || [];
                    modules = resources.modules || [];

                    scriptFiles = scriptFiles.map(function (file) {
                        return getPrefabResourceUrl(file, resourcePath, true);
                    });

                    modules = modules.map(function (module) {
                        module.files = module.files.map(function (file) {
                            return getPrefabResourceUrl(file, resourcePath, true);
                        });
                        return module;
                    });

                    styleFiles = styleFiles.map(function (file) {
                        if (!Utils.stringEndsWith(file, '/pages/Main/Main.css')) {
                            return getPrefabResourceUrl(file, resourcePath, true);
                        }
                        return undefined;
                    }).filter(function (file) {
                        return !!file;
                    });

                    Utils.loadStyleSheets(styleFiles);

                    extendAppLocale(resourcePath);

                    loadScripts(scriptFiles)
                        .then(loadModules.bind(undefined, modules))
                        .then(loadPrefabMinifiedPage.bind(undefined, prefabName))
                        .then(function (prefabContent) {
                            pendingTasks.resources[prefabName] = undefined;
                            $rootScope.$emit(prefabName + '-dependencies-ready', prefabContent);
                            deferred.resolve(prefabContent);
                        });
                }

                return deferred.promise;
            }

            function removePrefab(params) {
                return PrefabService.remove(params);
            }

            /*
             * gets active prefab's config from respective config file and stores it in memory for later use
             */
            function getConfig(success, error, reload) {
                /* if config fetched already, return*/
                if (activePrefabConfig && !reload) {
                    Utils.triggerFn(success, activePrefabConfig);
                    return;
                }

                /* unset flag to force reload */
                $rootScope.reloadPrefabConfig = undefined;

                /* read the config from respective file */
                FileService.read({
                    projectID: $rootScope.project.id,
                    path: 'config.json'
                }, function (response) {
                    activePrefabConfig = response;
                    Utils.triggerFn(success, response);
                }, function (response) {
                    Utils.triggerFn(error, response);
                });
            }

            /*
             * saves active prefab's config in memory and in respective config file
             */
            function setConfig(config, success, error) {
                activePrefabConfig = config;
                FileService.write({
                    projectID: $rootScope.project.id,
                    path: 'config.json',
                    content: config
                }, function (response) {
                    Utils.triggerFn(success, response);
                }, function (response) {
                    Utils.triggerFn(error, response);
                });
            }

            return {

                /**
                 * @ngdoc function
                 * @name wm.prefab.$PrefabManager#removePrefab
                 * @methodOf wm.prefab.$PrefabManager
                 * @function
                 *
                 * @description
                 * remove the specified prefab
                 *
                 * @param {object} params specifying the prefabID which needs to be deleted
                 */
                removePrefab: removePrefab,

                /**
                 * @ngdoc function
                 * @name PrefabManager#loadDependencies
                 * @methodOf wm.prefab.$PrefabManager
                 * @description
                 * this function will load the dependencies of the prefab
                 */
                loadDependencies: loadDependencies,

                /**
                 * @ngdoc function
                 * @name PrefabManager#loadScripts
                 * @methodOf wm.prefab.$PrefabManager
                 * @description
                 * this function will load the script resources of the prefab
                 */
                loadScripts: loadScripts,

                /**
                 * @ngdoc function
                 * @name PrefabManager#loadModules
                 * @methodOf wm.prefab.$PrefabManager
                 * @description
                 * this function will load the external angular modules of the prefab
                 */
                loadModules: loadModules,

                /**
                 * @ngdoc function
                 * @name PrefabManager#listStudioPrefabs
                 * @methodOf wm.prefab.$PrefabManager
                 * @description
                 * this function will load the list of prefabs in studio
                 */
                listStudioPrefabs: listStudioPrefabs,

                /**
                 * @ngdoc function
                 * @name PrefabManager#getAllStudioPrefabsConfig
                 * @methodOf wm.prefab.$PrefabManager
                 * @description
                 * this function will load config.json files of all the prefabs in studio
                 */
                getAllStudioPrefabsConfig: getAllStudioPrefabsConfig,

                /**
                 * @ngdoc function
                 * @name PrefabManager#loadModules
                 * @methodOf wm.prefab.$PrefabManager
                 * @description
                 * this function will register a prefab(copy from studio to app/project)
                 */
                registerPrefab: registerPrefab,

                /**
                 * @ngdoc function
                 * @name PrefabManager#loadModules
                 * @methodOf wm.prefab.$PrefabManager
                 * @description
                 * this function will load the config.json of app-prefab
                 */
                loadAppPrefabConfig: loadAppPrefabConfig,

                /**
                 * @ngdoc function
                 * @name PrefabManager#getConfig
                 * @methodOf wm.prefab.$PrefabManager
                 * @description
                 * this function will load the config.json of active prefab project
                 * @param {success} success callback
                 * @param {error} error callback
                 * @param {reload} flag to force reload the config file
                 */
                getConfig: getConfig,

                /**
                 * @ngdoc function
                 * @name PrefabManager#setConfig
                 * @methodOf wm.prefab.$PrefabManager
                 * @description
                 * this function will save the config.json of active prefab project
                 * @param {success} success callback
                 * @param {error} error callback
                 */
                setConfig: setConfig
            };
        }
    ]);

/*global WM, wm*/
/*jslint todo: true */

/*Definition of the Variables Module*/
/**
 * @ngdoc overview
 * @name wm.variables
 * @description
 * The 'wm.variables' module provides variables for access in the studio and the applications.
 */
wm.variables = WM.module('wm.variables', ['base64']);

wm.variables.controllers = {};
wm.variables.services = {};
wm.variables.factories = {};
wm.variables.filters = {};
wm.variables.controller(wm.variables.controllers);
wm.variables.service(wm.variables.services);
wm.variables.factory(wm.variables.factories);
wm.variables.filter(wm.variables.filters);

/* Defining route path constants for wmCoreModule application */
wm.variables.constant('VARIABLE_CONSTANTS', {
    EVENTS: ["onCanUpdate", "onBeforeUpdate", "onBeforeDatasetReady", "onResult", "onSuccess", "onError", 'onClick', 'onHide', "onOk", "onCancel", "onClose", "onTimerFire"],
    EVENT: {
        "CAN_UPDATE": "onCanUpdate",
        "BEFORE_UPDATE": "onBeforeUpdate",
        "PREPARE_SETDATA": "onBeforeDatasetReady",
        "RESULT": "onResult",
        "SUCCESS": "onSuccess",
        "ERROR": "onError",
        'CLICK': 'onClick',
        'HIDE': 'onHide',
        "OK": "onOk",
        "CANCEL": "onCancel",
        "CLOSE": "onClose",
        "TIMER_FIRE": "onTimerFire"
    },
    OWNER: {"APP": "App", "PAGE": "Page"},
    SERVICE_TYPE_JAVA: "JavaService",
    SERVICE_TYPE_REST: "RestService",
    SERVICE_TYPE_SOAP: "SoapService",
    SERVICE_TYPE_FEED: "FeedService",
    SERVICE_TYPE_DATA: "DataService",
    SERVICE_TYPE_SECURITY: "SecurityServiceType",
    SERVICE_NAME_FEED: "FeedService",
    REST_SUPPORTED_SERVICES: ["JavaService", "SoapService", "FeedService", "RestService", "SecurityServiceType", "DataService"],
    PAGINATION_PARAMS: ["page", "size", "sort"],
    DEFAULT_VAR: {
        "NOTIFICATION": "appNotification"
    }
});

wm.variables.constant('VARIABLE_SERVICE_URLS', {
    VariableService : {
        addAppVariables: {
            url: 'services/projects/:projectId/variables',
            method: 'POST'
        },
        addPageVariables: {
            url: 'services/projects/:projectId/pages/:pageName/variables',
            method: 'POST'
        },
        getAppVariables: {
            url: 'services/projects/:projectId/variables',
            method: 'GET'
        },
        getPageVariables: {
            url: 'services/projects/:projectId/pages/:pageName/variables',
            method: 'GET'
        },
        updateAppVariables: {
            url: 'services/projects/:projectId/variables',
            method: 'PUT'
        },
        updatePageVariables: {
            url: 'services/projects/:projectId/pages/:pageName/variables',
            method: 'PUT'
        },
        deleteAppVariables: {
            url: 'services/projects/:projectId/variables?variableNames[]=:deletedNames',
            method: 'DELETE'
        },
        deletePageVariables: {
            url: 'services/projects/:projectId/pages/:pageName/variables?variableNames[]=:deletedNames',
            method: 'DELETE'
        },
        moveAppVariables: {
            url: 'services/projects/:projectId/variables/move?pageName=:toPage',
            method: 'POST'
        },
        movePageVariables: {
            url: 'services/projects/:projectId/pages/:pageName/variables/move',
            method: 'POST'
        }
    }
});
wm.variables.config(function (BaseServiceManagerProvider, VARIABLE_SERVICE_URLS) {
    'use strict';

    BaseServiceManagerProvider.register(VARIABLE_SERVICE_URLS);
});

/*End of Module definition*/
/*global WM, wm, _*/
/*jslint todo: true */
/*jslint sub: true */

/**
 * @ngdoc service
 * @name wm.variables.$BaseVariablePropertyFactory
 * @description
 * The `BaseVariablePropertyFactory` service provides the all the properties for variables.
 */
wm.variables.factories.BaseVariablePropertyFactory = [
    'WIDGET_CONSTANTS',
    'Utils',
    function (WIDGET_CONSTANTS, Utils) {

        "use strict";
        var variableEventOptions = [], /*A copy of the variable to preserve the actual value.*/
            result,
            properties,
            propertyGroups,
            variableMap,
            variableRegex = '^[a-zA-Z_][A-Za-z0-9_-]+$',
            matchModes = Utils.getMatchModes();

        /* make events compatible to select widget options */
        _.forEach(Utils.getClonedObject(WIDGET_CONSTANTS.EVENTS_OPTIONS), function (event) {
            variableEventOptions.push({'name': event, 'type': 'Default'});
        });

        result = {
            "properties": {
                "wm.Variable": {
                    "name": {"type": "string", "required": true, "pattern": variableRegex},
                    "type": {"type": "list", "options": {"string": "LABEL_STRING", "boolean": "LABEL_BOOLEAN", "number": "LABEL_NUMBER", "date": "LABEL_DATE", "entry": "LABEL_ENTRY"}, "value": "string", "required": true},
                    "isList": {"type": "boolean", "value": false},
                    "owner": {"type": "list", "options": {"Page": "LABEL_PAGE", "App": "LABEL_APPLICATION"}, "value": "Page"},
                    "editJson": {"type": "json"},
                    "isBound": {"type": "boolean"},
                    "dataSet": {"type": "string", "value": {dataValue: ""}, "hide": true},
                    "dataBinding": {"type": "list", "value": [{"target": "dataValue", "type": "string"}], "hide": true},
                    "saveInPhonegap": {"type": "boolean", "value": false, "hide": true}
                },
                "wm.ServiceVariable": {
                    "isList": {"hide": true, "required": false},
                    "editJson": {"hide": true, "required": false},
                    "dataSet": {"type": "string", "value": {dataValue: ""}, "hide": true},
                    "type": {"hide": true, "required": false},
                    "firstRow": {"type": "number", "value": 0, "disabled": true, "hide": true},
                    "maxResults": {"type": "number", "value": 20, "disabled": true, "hide": true},
                    "designMaxResults": {"type": "number", "value": 10, "disabled": true, "hide": true},
                    "orderBy": {"type": "string", "placeholder": "e.g: 'field1 asc,field2 desc'"},
                    "service": {"type": "list", "required": true},
                    "operation": {"type": "list", "required": true},
                    "operationType": {"type": "string", "hide": true},
                    "startUpdate": {"type": "boolean", "value": false},
                    "autoUpdate": {"type": "boolean", "value": true},
                    "inFlightBehavior": {"type": "list", "options": {"doNotExecute": "doNotExecute", "executeLast": "executeLast", "executeAll": "executeAll"}, "value": "executeLast"},
                    "transformationRequired": {"type": "boolean-labelfirst", "value": false},
                    "columnField": {"type": "list", "options": {}, "hide": true},
                    "dataField": {"type": "list", "options": {}, "hide": true},
                    "dataBinding": {"type": "list", "value": [], "hide": true},
                    "spinnerContext": {"type": "list", "options": {"": "", "page": "page"}},
                    "spinnerMessage": {"type": "string"},

                    /* Events */
                    "onCanUpdate": {"type": "list", "options": variableEventOptions},
                    "onBeforeUpdate": {"type": "list", "options": variableEventOptions},
                    "onResult": {"type": "list", "options": variableEventOptions},
                    "onBeforeDatasetReady": {"type": "list", "options": variableEventOptions},
                    "onSuccess": {"type": "list", "options": variableEventOptions},
                    "onError": {"type": "list", "options": variableEventOptions}
                },
                "wm.LiveVariable": {
                    "service": {"hide": true, "required": false},
                    "editJson": {"hide": true},
                    "transformationRequired": {"hide": true},
                    "operation": {"options": {"read": "read", "insert": "insert", "update": "update", "delete": "delete"}, "value": "read"},
                    "liveSource": {"type": "list", "required": true},
                    "type": {"hide": false, "options": {}, "required": true},
                    "firstRow": {"disabled": false, "hide": false},
                    "maxResults": {"disabled": false, "hide": false},
                    "designMaxResults": {"disabled": false, "hide": false},
                    "ignoreCase": {"type": "boolean", "value": false},
                    "matchMode": {"type": "list", "options": matchModes, "value": "start"},
                    "orderBy": {"type": "string", "placeholder": "e.g: 'field1 asc,field2 desc'"},
                    "autoUpdate": {"value": true},
                    "startUpdate": {"value": false},
                    "inFlightBehavior": {"type": "list", "options": {"doNotExecute": "doNotExecute", "executeLast": "executeLast", "executeAll": "executeAll"}, "value": "executeLast"}
                },
                "wm.LoginVariable": {
                    "transformationRequired": {"hide": true},
                    "isList": {value: ""},
                    "firstRow": {value: ""},
                    "maxResults": {value: ""},
                    "designMaxResults": {value: ""},
                    "operation": {"hide": true, "required": false},
                    "service": {"hide": true, "required": false},
                    "dataSet": {"value": {username: "", password: ""}},
                    "dataBinding": {"type": "list", "value": [{"target": "username", "type": "string"}, {"target": "password", "type": "string"}], "hide": true},
                    "startUpdate": {"value": false},
                    "autoUpdate": {"value": false},
                    "useDefaultSuccessHandler": {"type": "boolean", "value": true}
                },
                "wm.LogoutVariable": {
                    "transformationRequired": {"hide": true},
                    "isList": {value: ""},
                    "firstRow": {value: ""},
                    "maxResults": {value: ""},
                    "designMaxResults": {value: ""},
                    "operation": {"hide": true, "required": false},
                    "service": {"hide": true, "required": false},
                    "dataSet": {"value": ""},
                    "dataBinding": {"value": ""},
                    "startUpdate": {"hide": true, "value": ""},
                    "autoUpdate": {"hide": true, "value": ""},
                    "redirectTo": {"type": "list", "options": [], value: ""},
                    "useDefaultSuccessHandler": {"type": "boolean", "value": true}
                },
                "wm.NavigationVariable": {
                    "name": {"type": "string", "required": true, "pattern": variableRegex},
                    "owner": {"type": "list", "options": {"Page": "LABEL_PAGE", "App": "LABEL_APPLICATION"}, "value": "Page"},
                    "operation": {"type": "list", "options": {"goToPreviousPage": "goToPreviousPage", "gotoPage": "gotoPage", "gotoView": "gotoView", "gotoTab": "gotoTab", "gotoAccordion": "gotoAccordion"}, "value": "gotoPage"},
                    "dataBinding": {"type": "string", "value": [], "hide": true},
                    "pageTransitions": {"type": "list", "options": {"none": "none", "slide": "slide", "pop": "pop", "fade": "fade", "flip": "flip"}, "value": "none", "hide": true}
                },
                "wm.NotificationVariable": {
                    "name": {"type": "string", "required": true, "pattern": variableRegex},
                    "owner": {"type": "list", "options": {"Page": "LABEL_PAGE", "App": "LABEL_APPLICATION"}, "value": "Page"},
                    "operation": {"type": "list", "options": {"alert": "alert", "confirm": "confirm", "toast": "toast"}, "value": "alert"}, //"prompt", "warnOnce" to be added
                    "onCancel": {"type": "list", "options": variableEventOptions, "disabled": true, "hide": true},
                    "onClose": {"type": "list", "options": variableEventOptions},
                    "onOk": {"type": "list", "options": variableEventOptions},
                    'onHide': {'type': 'list', 'options': variableEventOptions},
                    'onClick': {'type': 'list', 'options': variableEventOptions},
                    "dataBinding": {"type": "string", "value": [], "hide": true}
                },
                "wm.TimerVariable": {
                    "name": {"type": "string", "required": true, "pattern": variableRegex},
                    "owner": {"type": "list", "options": {"Page": "LABEL_PAGE", "App": "LABEL_APPLICATION"}, "value": "Page"},
                    "autoStart": {"type": "boolean", "value": false},
                    "repeating": {"type": "boolean", "value": false},
                    "delay": {"type": "number", "value": 500},
                    "onTimerFire": {"type": "list", "options": variableEventOptions}
                },
                "wm.DeviceVariable" : {
                    "name": {"type": "string", "required": true, "pattern": variableRegex},
                    "owner": {"type": "list", "options": {"Page": "LABEL_PAGE", "App": "LABEL_APPLICATION"}, "value": "Page"},
                    "dataSet": {"type": "string", "value": {dataValue: ""}, "hide": true},
                    "dataBinding": {"type": "object", "value": [], "hide": true},
                    "service": {"type": "list", "options": []},
                    "operation": {"type": "list", "hide": true, "options": []},
                    "autoUpdate": {"type": "boolean", "value": false, "hide": true},
                    "startUpdate": {"type": "boolean", "value": false, "hide": true},
                    /*events*/
                    "onSuccess": {"type": "list", "options": variableEventOptions},
                    "onError": {"type": "list", "options": variableEventOptions}
                }
            },

            "propertyGroups": [
                /* tabs */
                {"name": "properties", "parent": ""},
                {"name": "data", "parent": ""},
                {"name": "events", "parent": ""},

                /* properties under behavior tab */

                {"properties": ["liveSource", "type", "isList"], "parent": "properties"},
                {"name": "service", "properties": ["service", "operation"], "parent": "properties"},
                {"name": "serveroptions", "properties": ["downloadFile", "matchMode", "firstRow", "maxResults", "designMaxResults", "orderBy", "ignoreCase"], "parent": "properties"},
                {"name": "behavior", "properties": ["useDefaultSuccessHandler", "clearDataOnLogout", "autoUpdate", "startUpdate", "inFlightBehavior", "loadingDialog", "saveInCookie", "refireOnDbChange", "redirectTo", "autoStart", "delay", "repeating", "pageTransitions"], "parent": "properties"},
                {"name": "mobile", "properties": ["saveInPhonegap"], "parent": "properties"},
                {"name": "json", "properties": ["editJson"], "parent": "properties"},
                {"name": "Inputs", "properties": ["pageName", "viewName", "tabName", "accordionName", "segmentName", "dataBinding"], "parent": "properties"},
                {"name": "spinner", "properties": ["spinnerContext", "spinnerMessage"], "parent": "properties"},

                /* properties under data tab */
                {"name": "Inputs", "properties": ["dataBinding"], "parent": "data"},
                {"name": "inputfields", "properties": ["dataSet", "dataBinding"], "parent": "data"},
                {"name": "filterfields", "properties": ["dataSet"], "parent": "data"},
                {"name": "bindings", "properties": [], "parent": "data"},
                {"name": "dataTransformation", "properties": ["transformationRequired", "columnField", "dataField"], "parent": "data"},

                /* properties under events tab */
                {"properties": ["onCanUpdate", "onBeforeUpdate", "onResult", "onSuccess", "onError", "onBeforeDatasetReady", 'onClick', 'onHide', "onOk", "onCancel", "onClose", "onTimerFire"], "parent": "events"}
            ]
        };
        properties = result.properties;
        propertyGroups = result.propertyGroups;
        variableMap = {};

        function addNavigationOption(name, label) {
            properties['wm.NavigationVariable'].operation.options[name] = label;
        }
        /*
         If parents array is provided, inject the properties from the parents into variable and return,
         else return only the properties of the widget.
         */
        function getPropertiesOf(variableCategory, parentCategories) {
            /* Variable to hold all the properties of the requested variable category */
            var variablePropertiesObject = {}, tempPropertiesObject;
            /* Condition: Check if parent dependencies are there */
            if (!parentCategories) {
                /* This variableCategory doesn't inherit from other variableCategories.
                 Fetch the properties of only this variableCategory */
                variablePropertiesObject.variableProps = Utils.getClonedObject(properties[variableCategory]);
            } else {
                /* If parent categories are present, add their properties to current variable */
                parentCategories = WM.isArray(parentCategories) ? parentCategories : [parentCategories];
                parentCategories.push(variableCategory);
                tempPropertiesObject = {};

                /* construct the properties object by inheriting from parentCategories */
                WM.forEach(parentCategories, function (parent) {
                    /* Fetch properties of individual dependency */
                    WM.forEach(properties[parent], function (propObj, propName) {
                        /* if property is not present create it */
                        if (!tempPropertiesObject[propName]) {
                            tempPropertiesObject[propName] = {};
                        }
                        /* Populate the fetched properties */
                        WM.forEach(propObj, function (value, key) {
                            tempPropertiesObject[propName][key] = value;
                        });

                    });
                });
                /* Assign the fetched properties to variableProps object for property panel */
                variablePropertiesObject.variableProps = tempPropertiesObject;
            }

            /* bind the properties with variable object */
            WM.forEach(variablePropertiesObject.variableProps, function (propObj, propName) {
                /* Get the previous value if present, else create new property */
                if (!variablePropertiesObject[propName]) {
                    variablePropertiesObject[propName] = (propObj.value === undefined) ? "" : propObj.value;
                }
            });

            /* return the completed object */
            return variablePropertiesObject;
        }

        /*
         * function to register a variable
         */
        function register(category, properties, parentCategories, methods) {
            variableMap[category] = {};

            WM.extend(properties, getPropertiesOf(category, parentCategories));

            variableMap[category].propertyMap = properties.variableProps;
            delete properties.variableProps;
            variableMap[category].properties = properties;

            variableMap[category].methods = methods;
        }

        /*
         * function to get the properties for a variable
         */
        function getProperties(category) {
            return variableMap[category] ? Utils.getClonedObject(variableMap[category].properties) : {};
        }

        /*
         * function to get all the property groups
         */
        function getPropertyGroups() {
            return propertyGroups;
        }

        /*
         * function to get the property map for a variable
         */
        function getPropertyMap(category) {
            return variableMap[category] ? variableMap[category].propertyMap : undefined;
        }

        /* function to invoke the specified method of the specified variable category*/
        function invoke(method, variableType, variable, options, successCallBack, errorCallBack) {
            /*if variable is not valid, call the error callback and return*/
            if (!variableMap[variableType]) {
                Utils.triggerFn(errorCallBack, "variable is not valid");
                return;
            }
            /*Call the specified variable category's method*/
            return variableMap[variableType].methods[method](variable, options, successCallBack, errorCallBack);
        }

        return {
            /**
             * @ngdoc method
             * @name  wm.variables.$BaseVariablePropertyFactory#addNavigationOption
             * @methodOf  wm.variables.$BaseVariablePropertyFactory
             * @description
             * This is a provision to add additional navigational options.
             * @param {string} name of the option or view
             * @param {string} label to display
             */
            addNavigationOption : addNavigationOption,
            /**
             * @ngdoc method
             * @name  wm.variables.$BaseVariablePropertyFactory#getPropertiesOf
             * @methodOf  wm.variables.$BaseVariablePropertyFactory
             * @description
             * gets the properties along with the property map for the variable of a particular type
             */
            getPropertiesOf: getPropertiesOf,

            /**
             * @ngdoc method
             * @name  wm.variables.$BaseVariablePropertyFactory#register
             * @methodOf  wm.variables.$BaseVariablePropertyFactory
             * @description
             * registers a variable type with the variable factory
             */
            register: register,

            /**
             * @ngdoc method
             * @name  wm.variables.$BaseVariablePropertyFactory#getProperties
             * @methodOf wm.variables.$BaseVariablePropertyFactory
             * @description
             * gets the properties of a variable corresponding to a particular category
             */
            getProperties: getProperties,

            /**
             * @ngdoc method
             * @name  wm.variables.$BaseVariablePropertyFactory#getProperties
             * @methodOf  wm.variables.$BaseVariablePropertyFactory
             * @description
             * gets the property groups of all variables
             */
            getPropertyGroups: getPropertyGroups,

            /**
             * @ngdoc method
             * @name  wm.variables.$BaseVariablePropertyFactory#getPropertyMap
             * @methodOf  wm.variables.$BaseVariablePropertyFactory
             * @description
             * gets the property map of a variable corresponding to a particular category
             */
            getPropertyMap: getPropertyMap,

            /**
             * @ngdoc method
             * @name  wm.variables.$BaseVariablePropertyFactory#invoke
             * @methodOf wm.variables.$BaseVariablePropertyFactory
             * @description
             * invokes the specified method of the specified variable category
             * @param {string} method Name of the method to be invoked.
             * @param {string} variableType Type/category of the variable.
             * @param {string} variableName Name of the variable.
             */
            invoke: invoke
        };
    }
];

/*global WM, wm, document, _*/
/*jslint todo: true */
/*jslint sub: true */
/**
 * @ngdoc service
 * @name wm.variables.$Variables
 * @requires $rootScope
 * @requires BaseVariablePropertyFactory
 * @description
 * This is the factory responsible for creating, storing and deleting
 * the variables. It manages Simple, Live and Service variables.
 */
wm.variables.services.Variables = [
    '$rootScope',
    'BaseVariablePropertyFactory',
    "ProjectService",
    "FileService",
    "VariableService",
    "CONSTANTS",
    "VARIABLE_CONSTANTS",
    "DialogService",
    "$timeout",
    "Utils",
    function ($rootScope, BaseVariablePropertyFactory, ProjectService, FileService, VariableService, CONSTANTS, VARIABLE_CONSTANTS, DialogService, $timeout, Utils) {
        "use strict";

        /**
         * Migrates old orderBy expression to new
         * e.g. field1,asc&fied2,desc --> field1 asc,field2 desc
         * @param variable for which migration to be done
         */
        function migrateOrderBy(variable) {
            /* migrate old orderBy properties */
            var orderBy = variable.orderBy || "";
            if (_.includes(orderBy, '&')) {
                orderBy = _.map(variable.orderBy.split('&'), function (clause) {
                    return clause.replace(/,/g, ' ');
                }).join(',');
            }
            variable.orderBy = orderBy;
        }

        /*flag to determine app mode
         true: RUN mode
         false: STUDIO mode
         */
        var runMode = CONSTANTS.isRunMode,
            MAIN_PAGE = 'Main',
            variableConfig = [
                {
                    "collectionType": "call",
                    "category": "wm.NavigationVariable",
                    "labelKey": "LABEL_VARIABLE_NAVIGATION",
                    "defaultName": "navigationVariable"
                },
                {
                    "collectionType": "call",
                    "category": "wm.NotificationVariable",
                    "labelKey": "LABEL_VARIABLE_NOTIFICATION",
                    "defaultName": "notificationVariable"
                },
                {
                    "collectionType": "data",
                    "category": "wm.Variable",
                    "labelKey": "LABEL_VARIABLE_BASIC",
                    "defaultName": "staticVariable"
                },
                {
                    "collectionType": "data",
                    "category": "wm.ServiceVariable",
                    "labelKey": "LABEL_VARIABLE_SERVICE",
                    "defaultName": "serviceVariable"
                },
                {
                    "collectionType": "data",
                    "category": "wm.LiveVariable",
                    "labelKey": "LABEL_VARIABLE_LIVE",
                    "defaultName": "liveVariable"
                },
                {
                    "collectionType": "data",
                    "category": "wm.TimerVariable",
                    "labelKey": "LABEL_VARIABLE_TIMER",
                    "defaultName": "timerVariable"
                },
                {
                    "collectionType": "data",
                    "category": "wm.LoginVariable",
                    "labelKey": "LABEL_VARIABLE_LOGIN",
                    "defaultName": "loginVariable",
                    "appOnly": true
                },
                {
                    "collectionType": "data",
                    "category": "wm.LogoutVariable",
                    "labelKey": "LABEL_VARIABLE_LOGOUT",
                    "defaultName": "logoutVariable",
                    "appOnly": true
                }
            ],

            variableCategoryToNameMap = {},
            self = this,
            /*Initializing a map to store all changes made to variables*/
            CRUDMAP = {
                CREATE : {},
                UPDATE : {},
                DELETE : {},
                MOVE   : {}
            },
            reloadRequired = [],

            returnObject,

            pageScopeMap = {},

        /* active controller's scope, passed by the initializer controller */
            activeScope,

        /* active page, passed by the initializer controller */
            activePage,

        /* array storing the variable binding watchers, required to de-register previous watchers if any */
            watchers = {},

        /*Function to initialize category-to-name map*/
            initVariableNameMap = function () {
                variableCategoryToNameMap = {};
                variableConfig.forEach(function (variable) {
                    variableCategoryToNameMap[variable.category] = variable.defaultName;
                });
            },

        /*Function to set the variable name iterator with the specified value*/
            resetVariableNameIterator = function () {
                self.variableNameIterator = {};
                Object.keys(variableCategoryToNameMap).forEach(function (category) {
                    self.variableNameIterator[category] = 1;
                });
            },

        /*function to reload the variables of current context*/
            reloadVariables = function (success, error) {

                var pageVariablesLoaded = false,
                    appVariablesLoaded  = false;

                function handleSuccess() {
                    /*Executing success if both app and current page variables are reloaded*/
                    if (pageVariablesLoaded && appVariablesLoaded) {
                        updateVariableValues($rootScope.activePageName);
                        Utils.triggerFn(success);
                    }
                }
                reloadRequired.push(VARIABLE_CONSTANTS.OWNER.APP);
                getAppVariables(function (appVariables) {
                    setAppVariables(appVariables);
                    appVariablesLoaded = true;
                    handleSuccess();
                }, error);

                if ($rootScope.activePageName) {
                    reloadRequired.push($rootScope.activePageName);
                    getPageVariables($rootScope.activePageName, function () {
                        pageVariablesLoaded = true;
                        handleSuccess();
                    }, error);
                } else {
                    pageVariablesLoaded = true;
                }
            },

            /* function to update binding of a field of a variable */
            bindVariableField = function (props) {
                var bindingVal = props.bindingVal,
                    param = props.paramName,
                    variable = props.variable,
                    variableName = props.variableName,
                    variableScope = props.scope || {};

                if (Utils.stringStartsWith(bindingVal, "bind:")) {
                    /* if binding is present, watch on the expression */
                    watchers[variableScope.$id][variableName].push(variableScope.$watch(bindingVal.replace("bind:", ""), function (newVal, oldVal) {
                        /* don't perform any action if new value is coming as undefined(data source getting destroyed) */
                        if ((newVal === oldVal && WM.isUndefined(newVal)) || (WM.isUndefined(newVal) && !WM.isUndefined(oldVal))) {
                            return;
                        }
                        if (variable.category === "wm.Variable") {
                            variable.dataSet[param] = newVal;
                        } else if (variable.category === "wm.ServiceVariable") {
                            if (props.parentNode) {
                                variable.dataBinding[props.parentNode][param] = newVal;
                            } else {
                                variable.dataBinding[param] = newVal;
                            }
                            /* if auto-update set for the variable, get its data */
                            if (variable.autoUpdate && !WM.isUndefined(newVal) && WM.isFunction(variable.update)) {
                                variable.update();
                            }
                        } else if (variable.category === "wm.LiveVariable") {
                            if (variable.operation === "read") {
                                variable.filterFields[param] = {
                                    'value': newVal
                                };
                                /* if auto-update set for the variable with read operation only, get its data */
                                if (variable.autoUpdate && !WM.isUndefined(newVal) && WM.isFunction(variable.update)) {
                                    variable.update();
                                }
                            } else {
                                variable.inputFields[param] = newVal;
                                /* if auto-update set for the variable with read operation only, get its data */
                                if (variable.autoUpdate && !WM.isUndefined(newVal)) {
                                    variable[variable.operation + 'Record']();
                                }
                            }
                        } else if (variable.category === "wm.NotificationVariable" || variable.category === "wm.NavigationVariable") {
                            variable.dataBinding[param] = newVal;
                        } else if (variable.category === "wm.LoginVariable") {
                            variable.dataBinding[param] = newVal;
                            /* if auto-update set for the variable, get its data */
                            if (variable.autoUpdate && !WM.isUndefined(newVal)) {
                                variable.login();
                            }
                        } else if (variable.category === "wm.DeviceVariable") {
                            variable[param] = newVal;
                            if (variable.autoUpdate) {
                                variable.invoke();
                            }
                        }
                    }));
                } else if (variable.category === "wm.LiveVariable") {
                    /* binding is not present, apply the value written for binding */
                    if (variable.operation === "read") {
                        variable.filterFields[param] = {
                            'value': bindingVal
                        };
                    } else {
                        variable.inputFields[param] = bindingVal;
                    }
                } else if (variable.category === "wm.Variable") {
                    /* if there is already a value defined in the dataSet, give it preference over value in dataBinding */
                    if (variable.dataBinding[param]) {
                        variable.dataSet[param] = variable.dataSet[param] || variable.dataBinding[param];
                    }
                } else if(variable.category === "wm.DeviceVariable") {
                    variable[param] = bindingVal;
                }
            },

            processVariablePostBindUpdate = function (nodeName, nodeVal, variable, noUpdate) {
                if (variable.category === "wm.LiveVariable") {
                    if (variable.operation === "read") {
                        variable.filterFields[nodeName] = {
                            'value': nodeVal
                        };
                        /* if auto-update set for the variable with read operation only, get its data */
                        if (variable.autoUpdate && !WM.isUndefined(nodeVal) && WM.isFunction(variable.update) && !noUpdate) {
                            variable.update();
                        }
                    } else {
                        variable.inputFields[nodeName] = nodeVal;
                        /* if auto-update set for the variable with read operation only, get its data */
                        if (variable.autoUpdate && !WM.isUndefined(nodeVal) && WM.isFunction(variable[variable.operation + 'Record']) && !noUpdate) {
                            Utils.triggerFn(variable[variable.operation + 'Record']);
                        }
                    }
                } else if (variable.category === "wm.ServiceVariable") {
                    if (variable.autoUpdate && !WM.isUndefined(nodeVal) && WM.isFunction(variable.update) && !noUpdate) {
                        variable.update();
                    }
                } else if (variable.category === "wm.LoginVariable") {
                    if (variable.autoUpdate && !WM.isUndefined(nodeVal) && WM.isFunction(variable.login) && !noUpdate) {
                        variable.login();
                    }
                } else if (variable.category === "wm.DeviceVariable") {
                    variable[nodeName] = nodeVal;
                    if (variable.autoUpdate && !WM.isUndefined(nodeVal) && WM.isFunction(variable.invoke) && !noUpdate) {
                        variable.invoke();
                    }
                }
            },
            /*Function to get array of required variable objects*/
            getVariablesByNames = function (pageName, namesArray) {
                var tempCollection = [],
                    collection = self.variableCollection[pageName];
                _.each(namesArray, function (name) {
                    if (collection[name]) {
                        tempCollection.push(collection[name]);
                    }
                });
                return filterVariables(Utils.getClonedObject(tempCollection));
            },

            /*Function to check if map is empty in provided context*/
            isCrudEmpty = function (map, pageName) {
                return !map.CREATE[pageName].length && !map.UPDATE[pageName].length && !map.DELETE[pageName].length && !map.MOVE[pageName].length;
            },

            /*Function to call respective 'CRUD' service*/
            executeCrudOp = function (pageName, success, error) {
                function handleSuccess(crudMapCopy, pageName) {
                    if (isCrudEmpty(crudMapCopy, pageName)) {
                        /*trigger fn*/
                        Utils.triggerFn(success);
                    }
                }
                if (isCrudEmpty(CRUDMAP, pageName)) {
                    /*triggering success fn if map is empty*/
                    Utils.triggerFn(success);
                } else {
                    var params = {
                            projectId: $rootScope.project.id,
                            pageName : pageName
                        },
                        crudMapCopy = Utils.getClonedObject(CRUDMAP),//Making a cloned copy of crud map and using it in services
                        opTypes = ['CREATE', 'UPDATE'];
                    _.each(opTypes, function (op) {
                        if (crudMapCopy[op][pageName].length) {
                            CRUDMAP[op][pageName] = [];//Emptying array in original map
                            params.data = getVariablesByNames(pageName, crudMapCopy[op][pageName]);
                            VariableService[op.toLowerCase()](params, function () {
                                crudMapCopy[op][pageName] = [];//Emptying array in cloned map
                                handleSuccess(crudMapCopy, pageName);
                            }, function (errMsg) {
                                Utils.triggerFn(error, errMsg);
                            });
                        }
                    });
                    /*Making a call to move variables*/
                    if (crudMapCopy.MOVE[pageName].length) {
                        params.toPage = pageName === VARIABLE_CONSTANTS.OWNER.APP ? $rootScope.activePageName : VARIABLE_CONSTANTS.OWNER.APP;
                        CRUDMAP.MOVE[pageName] = [];//Emptying array in original map
                        params.data = getVariablesByNames(params.toPage, crudMapCopy.MOVE[pageName]);
                        VariableService.move(params, function () {
                            crudMapCopy.MOVE[pageName] = [];//Emptying array in cloned map
                            handleSuccess(crudMapCopy, pageName);
                        }, function (errMsg) {
                            Utils.triggerFn(error, errMsg);
                        });
                    }
                    /*Making a call to delete variables*/
                    if (crudMapCopy.DELETE[pageName].length) {
                        CRUDMAP.DELETE[pageName] = [];//Emptying array in original map
                        params.deletedNames = crudMapCopy.DELETE[pageName].join(',');
                        VariableService.delete(params, function () {
                            crudMapCopy.DELETE[pageName] = [];//Emptying array in cloned map
                            handleSuccess(crudMapCopy, pageName);
                        }, function (errMsg) {
                            Utils.triggerFn(error, errMsg);
                        });
                    }
                }
            },

            /**
             * New Implementation (DataBinding Flat Structure with x-path targets)
             * processes a dataBinding object, if bound to expression, watches over it, else assigns value to the expression
             * @param obj dataBinding object
             * @param scope scope of the variable
             * @param root root node string (dataBinding for all variables, dataSet for static variable)
             * @param variable variable object
             */
            processBindObject = function (obj, scope, root, variable) {
                var target = obj.target,
                    targetObj,
                    targetNodeKey,
                    rootNode = variable[root];

                targetNodeKey = target.split(".").pop();
                target = target.substr(0, target.lastIndexOf('.'));
                if (obj.target === root) {
                    targetObj = variable;
                } else if (target) {
                    targetObj = Utils.findValueOf(rootNode, target, true);
                } else {
                    targetObj = rootNode;
                }
                if (Utils.stringStartsWith(obj.value, "bind:")) {
                    scope.$watch(obj.value.replace("bind:", ""), function (newVal, oldVal) {
                        if ((newVal === oldVal && WM.isUndefined(newVal)) || (WM.isUndefined(newVal) && (!WM.isUndefined(oldVal) || !WM.isUndefined(targetObj[targetNodeKey])))) {
                            return;
                        }
                        /* sanity check, user can bind parent nodes to non-object values, so child node bindings may fail */
                        if (targetObj) {
                            targetObj[targetNodeKey] = newVal;
                            processVariablePostBindUpdate(targetNodeKey, newVal, variable);
                        }
                    }, true);
                } else if (WM.isDefined(obj.value)) {
                    /* sanity check, user can bind parent nodes to non-object values, so child node bindings may fail */
                    if (targetObj) {
                        targetObj[targetNodeKey] = obj.value;
                    }
                    processVariablePostBindUpdate(targetNodeKey, obj.value, variable, true);
                }
            },

            /**
             * Old Implementation (DataBinding Recursive Structure)
             * processes a dataBinding object, if bound to expression, watches over it, else assigns value to the expression
             * @param node binding node object
             * @param parentNode parent object
             * @param scope scope of the variable
             * @param variable variable object
             */
            processBindNode = function (node, parentNode, scope, variable) {
                if (Utils.stringStartsWith(node.value, "bind:")) {
                    scope.$watch(node.value.replace("bind:", ""), function (newVal, oldVal) {
                        if ((newVal === oldVal && WM.isUndefined(newVal)) || (WM.isUndefined(newVal) && (!WM.isUndefined(oldVal) || !WM.isUndefined(parentNode[node.name])))) {
                            return;
                        }
                        parentNode[node.name] = newVal;
                        processVariablePostBindUpdate(node.name, newVal, variable);
                    }, true);
                } else {
                    if (WM.isDefined(node.value)) {
                        parentNode[node.name] =  node.value;
                        if (variable.category === "wm.LiveVariable") {
                            /* binding is not present, apply the value written for binding */
                            if (variable.operation === "read") {
                                variable.filterFields[node.name] = {
                                    'value': node.value
                                };
                            } else {
                                variable.inputFields[node.name] = node.value;
                            }
                        }
                    }
                    if (node.fields && node.fields.length) {
                        parentNode[node.name] = WM.isObject(parentNode[node.name]) ? parentNode[node.name] : {};
                        WM.forEach(node.fields, function (field) {
                            processBindNode(field, parentNode[node.name], scope, variable);
                        });
                    }
                }
            },

            /* function to update the binding for a variable */
            updateVariableBinding = function (variable, name, scope) {

                /* un-register previous watchers, if any */
                watchers[scope.$id][name] = watchers[scope.$id][name] || [];
                watchers[scope.$id][name].forEach(Utils.triggerFn);

                /*
                 * new implementation: dataBinding is a flat array of binding objects with x-path targets
                 * old implementation: dataBinding is a recursive map of binding objects
                 * old implementation: dataBinding is an object map
                 */
                if (WM.isArray(variable.dataBinding)) {
                    var bindMap = variable.dataBinding,
                        root = variable.category === "wm.Variable" ? "dataSet": "dataBinding";
                    variable.dataBinding = {};
                    if (bindMap[0] && WM.isArray(bindMap[0].fields)) {
                        /* old projects(without migration): dataBinding is a recursive map of binding objects */
                        bindMap.forEach(function (node) {
                            processBindNode(node, variable, scope, variable);
                        });
                    } else {
                        /* new projects with flat bind map */
                        bindMap.forEach(function (node) {
                            processBindObject(node, scope, root, variable);
                        });
                    }
                } else {
                    /*
                     * oldest implementation: loop over each variable-binding object to check for bindings
                     * NOTE: Notification Variables still follow this structure, can not be removed
                     */
                    WM.forEach(variable.dataBinding, function (binding, param) {
                        if (typeof binding === 'object' && variable.category === 'wm.ServiceVariable') {
                            WM.forEach(binding, function (subParamBinding, subParam) {
                                bindVariableField({bindingVal: subParamBinding, paramName: subParam, variable: variable, variableName: name, parentNode: param, scope: scope});
                            });
                        }
                        bindVariableField({bindingVal: binding, paramName: param, variable: variable, variableName: name, scope: scope});
                    });
                }
            },

            /*
             * Updates the variables in a context with their latest values
             * context refers to the namespace for the variables collection, like 'app'/page/partial/prefab
             */
            updateContextVariables = function (context, scope) {
                var triggerStartUpdate = true;
                function validateStartUpdateTrigger(variable) {
                    function isBound(binding) {
                        return Utils.stringStartsWith(binding.value, "bind:")
                    }

                    return !(variable.autoUpdate === true && _.some(variable.dataBinding, isBound));
                }
                self.studioCopy[context] = {};

                scope = scope || pageScopeMap[context] || {};
                watchers[scope.$id] = {};

                /* Maintain a copy of the variables in the exposed collection
                 * Primary reason for this:
                 * StudioMode: any update to the dataSet or other properties by variable will not reflect in the actual collection
                 * RunMode: The same collection is used by same partials/prefabs appearing twice in a page */
                self.variableCollection[scope.$id] = Utils.getClonedObject(self.variableCollection[context]);

                scope.Variables = self.variableCollection[scope.$id];

                /* extend scope variables with app variables, in studio mode */
                if (CONSTANTS.isStudioMode && context !== VARIABLE_CONSTANTS.OWNER.APP) {
                    WM.forEach(self.variableCollection[$rootScope.$id], function (variable, name) {
                        Object.defineProperty(scope.Variables, name, {
                            configurable: true,
                            get: function () {
                                return variable;
                            }
                        });
                    });
                }
                WM.forEach(self.variableCollection[scope.$id], function (variable, name) {
                    /* assign variable name to the variable object for later use */
                    variable.name = name;

                    if (runMode) {
                        variable.activeScope = scope;
                        triggerStartUpdate = validateStartUpdateTrigger(variable);
                    } else {
                        /* this copy is used by binding dialog in STUDIO mode */
                        self.studioCopy[context][name] = variable;
                    }

                    /* update variable bindings */
                    updateVariableBinding(variable, name, scope);

                    /*iterating over the collection to update the variables appropriately.*/
                    if (variable.category === "wm.Variable") {
                        /*
                         * Case: a LIST type static variable having only one object
                         * and the object has all fields empty, remove that object
                         */
                        if (CONSTANTS.isRunMode && variable.isList && variable.dataSet.length === 1) {
                            var obj = variable.dataSet[0],
                                keys = Object.keys(obj),
                                isValueEmpty = function (val) {
                                    return obj[val] === "" || WM.isObject(obj[val]);
                                };
                            if (keys.every(isValueEmpty)) {
                                variable.dataSet = [];
                            }
                        }
                    } else if (variable.category === "wm.ServiceVariable") {
                        if (runMode) {
                            variable.canUpdate = true;
                        }
                        if (!runMode || (variable.startUpdate && triggerStartUpdate)) {
                            /* keeping the call in a timeout to wait for the widgets to load first and the binding to take effect */
                            $timeout(function () {
                                if (WM.isFunction(variable.update)) {
                                    variable.update();
                                }
                            }, null, false);
                        }
                    } else if (variable.category === "wm.LiveVariable") {
                        migrateOrderBy(variable);
                        if (runMode) {
                            variable.canUpdate = true;
                        }
                        if (variable.startUpdate) {
                            /*
                            * For variable with operation other than 'read', call respective method in RUN mode
                            * In studio mode, DB and table related data is to be fetched and saved in the variable
                            * So, getData is called in STUDIO mode for liva variables with all types of operations
                            */
                            if (runMode && variable.operation !== 'read') {
                                if (triggerStartUpdate) {
                                    /* keeping the call in a timeout to wait for the widgets to load first and the binding to take effect */
                                    $timeout(function () {
                                        variable[variable.operation + 'Record']();
                                    }, null, false);
                                }
                            } else {
                                /* keeping the call in a timeout to wait for the widgets to load first and the binding to take effect */
                                $timeout(function () {
                                    if (WM.isFunction(variable.update)) {
                                        variable.update();
                                    }
                                }, null, false);
                            }
                        } else if (!runMode) {
                            /*
                             * In studio mode, DB and table related data is to be fetched and saved in the variable
                             * So, getData is called in STUDIO mode for liva variables with all types of operations
                             * since startUpdate is unset, table data is not required, hence skipFetchData flag is set
                             */
                            $timeout(function () {
                                /* keeping the call in a timeout to wait for the widgets to load first and the binding to take effect */
                                if (WM.isFunction(variable.update)) {
                                    variable.update({skipFetchData: true});
                                }
                            }, null, false);
                        }
                    } else if (variable.category === "wm.LoginVariable") {
                        if (runMode && variable.startUpdate && triggerStartUpdate) {
                            /* keeping the call in a timeout to wait for the widgets to load first and the binding to take effect */
                            $timeout(function () {
                                variable.login();
                            }, null, false);
                        }
                    } else if (variable.category === "wm.TimerVariable") {
                        if (runMode && variable.autoStart) {
                            /* keeping the call in a timeout to wait for the widgets to load first and the binding to take effect */
                            $timeout(function () {
                                variable.fire();
                            }, null, false);
                        }
                    } else if (variable.category === "wm.DeviceVariable") {
                        if (runMode && variable.startUpdate) {
                            /* keeping the call in a timeout to wait for the widgets to load first and the binding to take effect */
                            $timeout(function () {
                                variable.invoke();
                            }, null, false);
                        }
                    }
                });
            },

        /* function to update variable values in $rootScope */
            updateVariableValues = function (activePageName, isUpdatePageVariables) {

                /*If the flag to update only page level variables is set, then do not trigger the update function for app-level variables*/
                if (!isUpdatePageVariables) {
                    /* app level variables */
                    updateContextVariables(VARIABLE_CONSTANTS.OWNER.APP);
                }

                /* page level variables */
                if (activePageName) {
                    updateContextVariables(activePageName);
                }
            },

        /* function to set page variables for a specified page*/
            setPageVariables = function (pageName, pageVariables) {
                /* check for existence */
                self.variableCollection = self.variableCollection || {};
                /* set the variables*/
                self.variableCollection[pageName] = pageVariables || {};
            },

            /* function to get page variables for a specified page*/
            getPageVariables = function (pageName, success, error) {
                var requestParams;
                if (!runMode) {
                    /*Initializing map with pageName context*/
                    CRUDMAP.CREATE[pageName] = [];
                    CRUDMAP.DELETE[pageName] = [];
                    CRUDMAP.UPDATE[pageName] = [];
                    CRUDMAP.MOVE[pageName] = [];
                }
                /* check for existence */
                if (self.variableCollection !== null && self.variableCollection[pageName] && (reloadRequired && !_.includes(reloadRequired, pageName))) {
                    Utils.triggerFn(success, self.variableCollection[pageName]);
                    return;
                }

                if (!runMode) {
                    requestParams = {
                        pageName : pageName,
                        projectId : $rootScope.project.id
                    };
                    VariableService.get(requestParams, function (variables) {
                        _.remove(reloadRequired, function (page) {
                            return page === pageName;
                        });
                        if (!WM.isObject(variables)) {
                            variables = {};
                        }

                        setPageVariables(pageName, variables);
                        Utils.triggerFn(success, variables);
                    }, function (errMsg) {
                        setPageVariables(pageName, undefined);
                        Utils.triggerFn(error, errMsg);
                    });
                }
            },

        /* function to set page variables for a specified page*/
            setAppVariables = function (appVariables) {
                /* check for existence */
                self.variableCollection = self.variableCollection || {};
                /* set the variables*/
                self.variableCollection[VARIABLE_CONSTANTS.OWNER.APP] = appVariables;
            },

            /* function to get application variables */
            getAppVariables = function (success, error) {
                /* check for existence */
                if (!runMode) {
                    /*Initializing map with 'APP' context*/
                    CRUDMAP.CREATE[VARIABLE_CONSTANTS.OWNER.APP] = [];
                    CRUDMAP.DELETE[VARIABLE_CONSTANTS.OWNER.APP] = [];
                    CRUDMAP.UPDATE[VARIABLE_CONSTANTS.OWNER.APP] = [];
                    CRUDMAP.MOVE[VARIABLE_CONSTANTS.OWNER.APP] = [];
                }
                if (self.variableCollection !== null && self.variableCollection[VARIABLE_CONSTANTS.OWNER.APP] && (reloadRequired && !_.includes(reloadRequired, 'App'))) {
                    Utils.triggerFn(success, self.variableCollection[VARIABLE_CONSTANTS.OWNER.APP]);
                    return;
                }

                var requestParams = {};
                if (!runMode) {
                    requestParams = {
                        pageName : VARIABLE_CONSTANTS.OWNER.APP,
                        projectId : $rootScope.project.id
                    };
                    VariableService.get(requestParams, function (variables) {
                        if (!WM.isObject(variables)) {
                            variables = {};
                        }
                        _.remove(reloadRequired, function (page) {
                            return page === 'App';
                        });
                        Utils.triggerFn(success, variables, true);
                    }, function (errMsg) {
                        Utils.triggerFn(error, errMsg);
                    });
                } else {
                    /* if in RUN mode append the path to requestParams and using file service */
                    requestParams = {
                        path: "app.variables.json"
                    };
                    FileService.read(requestParams, function (variables) {
                        if (!WM.isObject(variables)) {
                            variables = {};
                        }
                        Utils.triggerFn(success, variables, true);
                    }, function (errMsg) {
                        Utils.triggerFn(error, errMsg);
                    });
                }
            },

            /* Extend each variable in the provided collection with all the properties of that type
            *  The properties are fetched from the baseFactory.
            */
            extendVariables = function (variables) {
                /* extend the variables with all properties not found in the variable */
                WM.forEach(variables, function (variable, name) {
                    variables[name] = WM.extend(BaseVariablePropertyFactory.getProperties(variable.category), variable);
                    /* removing dataSet for live variable */
                    if (!runMode && variable.category === "wm.LiveVariable") {
                        variables[name].dataSet = {"dataValue": ""};
                    }
                });

                return variables;
            },

            /* function to initialize variables for passed page */
            initAppVariables = function (scope, success, error) {
                self.variableCollection = self.variableCollection || {};

                /* get application level variables */
                getAppVariables(function (appVariables, freshVariables) {
                    /*if the file is empty, initialize the collection to empty object*/
                    if (typeof appVariables !== 'object') {
                        appVariables = {};
                    }

                    /* extend and update the app variables only if freshly loaded */
                    if (freshVariables) {
                        appVariables = extendVariables(appVariables);

                        /* store the global variables collection */
                        self.variableCollection[VARIABLE_CONSTANTS.OWNER.APP] = appVariables;
                        pageScopeMap[VARIABLE_CONSTANTS.OWNER.APP] = $rootScope;
                        updateContextVariables(VARIABLE_CONSTANTS.OWNER.APP, $rootScope);

                        /* emit an event to specify app-variables are loaded */
                        $rootScope.$emit('on-app-variables-ready', appVariables);
                    }

                    /* check for sanity of success call back and call it */
                    Utils.triggerFn(success, appVariables);

                }, function (errMsg) {
                    /* initialize the global variables collection to empty */
                    self.variableCollection[VARIABLE_CONSTANTS.OWNER.APP] = {};
                    pageScopeMap[VARIABLE_CONSTANTS.OWNER.APP] = $rootScope;

                    /* check for sanity of error call back and call it */
                    Utils.triggerFn(error, errMsg);
                });
            },

            /* function to initialize variables for passed page */
            initPageVariables = function (pageName, scope, options) {
                /* param sanity check */
                options = options || {};
                options.updateAppVariables = options.updateAppVariables || false;

                /* initialize the scope */
                activeScope = scope;
                activePage = pageName;
                self.variableCollection = self.variableCollection || {};

                /* get page level variables */
                getPageVariables(activePage, function (pageVariables) {

                    /*if the file is empty, initialize the collection to empty object*/
                    if (typeof pageVariables !== 'object') {
                        pageVariables = {};
                    }

                    pageVariables = extendVariables(pageVariables);

                    /* store the page variables collection */
                    self.variableCollection[activePage] = pageVariables;
                    updateVariableValues(activePage, !options.updateAppVariables);

                    /* emit an event to specify variables are loaded */
                    $rootScope.$emit('on-' + activePage + '-variables-ready', pageVariables);

                    /* check for sanity of success call back and call it */
                    Utils.triggerFn(options.success, self.variableCollection);
                }, function (errMsg) {
                    /* initialize the app variables collection to empty */
                    self.variableCollection[activePage] = {};

                    /* check for sanity of error call back and call it */
                    Utils.triggerFn(options.error, errMsg);
                });
            },

            /*function to initialize variable collection*/
            initVariableCollection = function (activeWorkspaceName, scope, success, error, isUpdatePageVariables) {
                /* initialize the scope */
                activeScope = scope;
                activePage = activeWorkspaceName;
                self.variableCollection = self.variableCollection || {};

                /* get application level variables */
                getAppVariables(activePage, function (appVariables, freshVariables) {
                    /*if the file is empty, initialize the collection to empty object*/
                    if (typeof appVariables !== 'object') {
                        appVariables = {};
                    }

                    appVariables = extendVariables(appVariables);

                    /* store the global variables collection */
                    self.variableCollection[VARIABLE_CONSTANTS.OWNER.APP] = appVariables;

                    /* emit an event to specify app-variables are loaded */
                    if (freshVariables) {
                        $rootScope.$emit('on-app-variables-ready', appVariables);
                    }

                    /* get page level variables */
                    getPageVariables(activeWorkspaceName, function (pageVariables) {

                        /*if the file is empty, initialize the collection to empty object*/
                        if (typeof pageVariables !== 'object') {
                            pageVariables = {};
                        }

                        pageVariables = extendVariables(pageVariables);

                        /* store the page variables collection */
                        self.variableCollection[activeWorkspaceName] = pageVariables;
                        updateVariableValues(activeWorkspaceName, isUpdatePageVariables);

                        /* emit an event to specify variables are loaded */
                        $rootScope.$emit('on-' + activeWorkspaceName + '-variables-ready', pageVariables);

                        /* check for sanity of success call back and call it */
                        Utils.triggerFn(success, self.variableCollection);
                    }, function (errMsg) {
                        /* initialize the app variables collection to empty */
                        self.variableCollection[activeWorkspaceName] = {};

                        /* check for sanity of error call back and call it */
                        Utils.triggerFn(error, errMsg);
                    });

                }, function (errMsg) {
                    /* initialize the global variables collection to empty */
                    self.variableCollection[VARIABLE_CONSTANTS.OWNER.APP] = {};

                    /* check for sanity of error call back and call it */
                    Utils.triggerFn(error, errMsg);
                });
            },

            /*function to return a variable object respective to a name*/
            getVariableByName = function (variableName, scope) {
                var variables = self.variableCollection,
                    scopes,
                    i,
                    n;

                /* if scope provided, return the variable in that scope */
                if (scope) {
                    return (variables[scope.$id] && variables[scope.$id][variableName]) || self.variableCollection[$rootScope.$id][variableName];
                }

                /* in Run Mode, find and return the variable against active page or app */
                if (CONSTANTS.isRunMode) {
                    scope = pageScopeMap[$rootScope.activePageName];
                    if (scope && variables[scope.$id][variableName]) {
                        return variables[scope.$id][variableName];
                    }
                    scope = pageScopeMap[VARIABLE_CONSTANTS.OWNER.APP];
                    if (scope && variables[scope.$id][variableName]) {
                        return variables[scope.$id][variableName];
                    }
                    /* case of searching a partial's variable, partial being loaded in a page */
                    for (i = 0, scopes = Object.keys(variables), n = scopes.length; i < n; i += 1) {
                        scope = scopes[i];
                        if (variables[scopes[i]][variableName]) {
                            return variables[scopes[i]][variableName];
                        }
                    }
                }

                /* return the variable against active page or app (In studio mode, this is the writable variable obejct */
                return (variables[$rootScope.activePageName] && variables[$rootScope.activePageName][variableName]) || (variables[VARIABLE_CONSTANTS.OWNER.APP] && variables[VARIABLE_CONSTANTS.OWNER.APP][variableName]) || null;
            },

            /*function to update a variable object*/
            updateVariable = function (variableName, newProperties, isUpdate) {
                var newName = newProperties.name,
                    updated = false,
                    pageName = newProperties.owner === 'App' ? 'App' : ($rootScope.isPrefabTemplate ? MAIN_PAGE : $rootScope.activePageName),
                    oldOwner = pageName === 'App' ? $rootScope.activePageName : 'App',
                    scope = pageScopeMap[pageName];
                /* Condition: Checking for existence of the variable name, updating variable object*/
                if (self.variableCollection[pageName][variableName]) {
                    self.variableCollection[pageName][newName] = newProperties;
                    updated = true;
                    if (!_.includes(CRUDMAP.UPDATE[pageName], newName) && !_.includes(CRUDMAP.CREATE[pageName], newName)) {
                        CRUDMAP.UPDATE[pageName].push(newName);
                    }
                    if (variableName !== newName) {
                        delete self.variableCollection[pageName][variableName];
                        reloadRequired.push(pageName);
                    }
                } else if (self.variableCollection[oldOwner][variableName]) {
                    /*In case of owner change checking for variable existence in old scope and deleting*/
                    self.variableCollection[pageName][newName] = newProperties;
                    /*Removing those variable from old scope*/
                    delete self.variableCollection[oldOwner][variableName];
                    if (!_.includes(CRUDMAP.MOVE[oldOwner], newName)) {
                        CRUDMAP.MOVE[oldOwner].push(newName);
                    }
                    updated = true;
                }
                if (isUpdate) {
                    call('getData', newName, {scope: scope, skipFetchData: true});
                }
                return updated;
            },
            /*function to get the type of the variable by its name*/
            getType = function (name) {
                return getVariableByName(name) && getVariableByName(name).category;
            },

           /* function to return variable category list to populate in filter dropdowns */
            getVariableCategoryList = function (collectionType, getKeysList) {
                var categoryList = {},
                    isPrefabProject = $rootScope.isPrefabTemplate,
                    filteredVariables = [];

                if (!isPrefabProject) {
                    variableConfig.forEach(function (variable) {
                        if (!collectionType || collectionType.toLowerCase() === 'all' || variable.collectionType === collectionType) {
                            filteredVariables.push(variable);
                        }
                    });
                } else {
                    variableConfig.forEach(function (variable) {
                        if (!variable.appOnly && (!collectionType || collectionType.toLowerCase() === 'all' || variable.collectionType === collectionType)) {
                            filteredVariables.push(variable);
                        }
                    });
                }
                _.forEach(_.sortBy(filteredVariables, 'defaultName'), function (variable) {
                    categoryList[variable.category] = variable.labelKey;
                });

                if (getKeysList) {
                    categoryList = Object.keys(categoryList);
                }

                return categoryList;
            },

           /* function to check if variable with specified name exists in the collection*/
            isExists = function (variableName, caseSensitive) {
                var variables = self.variableCollection,
                    arrOfVariables = _.union(_.keys(variables[VARIABLE_CONSTANTS.OWNER.APP]), _.keys(variables[$rootScope.activePageName]));
                return Utils.isDuplicateName(arrOfVariables, variableName, caseSensitive);
            },

            /* function exposed to call method available with a variable */
            call = function (method, name, options, success, error) {
                /* check params sanity */
                options = options || {};

                /* if variable name or method not given, return error */
                if (!name || !method) {
                    Utils.triggerFn(error);
                    return;
                }

                var variable = getVariableByName(name, options.scope),
                    type = variable.category;

                /*invoke the getData method of the specified variable category*/
                return BaseVariablePropertyFactory.invoke(method, type, variable, options, function (data, propertiesMap, pagingOptions) {
                    Utils.triggerFn(success, data, propertiesMap, pagingOptions);
                }, error);
            },

            updateVariableDataSet = function (name, data, propertiesMap, pagingOptions) {
                /* sanity checking */
                if (!returnObject[name]) {
                    return;
                }
                /* if returned data is not object, make it as an object with variableName as key*/
                if (!WM.isObject(data)) {
                    var temp = data;
                    data = {};
                    data['value'] = temp;
                }
                /*Check if propertiesMap exist, then store it. Else, directly store the data*/
                if (propertiesMap) {
                    returnObject[name].dataSet = {
                        "data": data,
                        "propertiesMap": propertiesMap,
                        "pagingOptions": pagingOptions
                    };
                } else {
                    returnObject[name].dataSet = data;
                }
            },

           /* function to create default non-conflicting name for a variable */
            generateUniqueName = function (category, name, overWrite) {
                var defaultName;

                if (name) {
                    defaultName = name;
                } else {
                    defaultName = variableCategoryToNameMap[category] + self.variableNameIterator[category];
                }

                if (!isExists(defaultName, true) || overWrite) {
                    return defaultName;
                }

                /* increment the iterator for the category and look for unique name again*/
                self.variableNameIterator[category] += 1;
                return generateUniqueName(category);
            },

            /* registers a variable collection in the specified namespace */
            register = function (nameSpace, variables, loadValuesInStudio, scope) {
                /* extend the variables with properties from basefactory */
                variables = extendVariables(variables);

                /* store the variables in provided namespace */
                pageScopeMap[nameSpace] = scope;
                self.variableCollection = self.variableCollection || {};
                self.variableCollection[nameSpace] = variables;

                /* update the variable values in RUN mode */
                if (loadValuesInStudio || runMode) {
                    updateContextVariables(nameSpace, scope);
                    /* emit an event to specify variables are loaded */
                    $rootScope.$emit('on-' + nameSpace + '-variables-ready', variables);
                }
            },

            isEventCallbackVariable = function (category) {
                var retVal = false;
                if (category !== "wm.Variable") {
                    retVal = true;
                }
                return retVal;
            },

        /*function to retrieve service and live variables from the collection, other than the variable name provided.*/
            retrieveEventCallbackVariables = function (variableName, namesOnly) {
                var variableArray = [],
                    varCollection = self.variableCollection,
                    contextsVariables = [varCollection[VARIABLE_CONSTANTS.OWNER.APP], varCollection[$rootScope.activePageName]];

                if ($rootScope.isPrefabTemplate) {
                    contextsVariables = [varCollection.Main];
                }
                /*iterating over variable collection*/
                _.forEach(contextsVariables, function (variables) {
                    _.forEach(variables, function (curVariable, curVariableName) {
                        if (isEventCallbackVariable(curVariable.category)) {
                            /*checking if current variable name is not equal to the variable name provided.*/
                            if (!variableName || curVariableName !== variableName) {
                                variableArray.push(namesOnly ? curVariableName : {name: curVariableName, type: curVariable.category});
                            }
                        }
                    });
                });
                return _.uniq(variableArray);
            },
            saveContextVariables = function (context, contextVariables) {
                /*Updating variables using service*/
                _.each(contextVariables, function (varObj, name) {
                    updateVariable(name, varObj);
                });
            },

            /**
             * loops through the binding objects in the provided array, removes the ones with no value
             * @param bindings
             */
            cleanseBindings = function (bindings) {
                _.remove(bindings, function (binding) {
                    return (WM.isUndefined(binding.value) || binding.value === '')
                });
            },

            /**
             * filters the variable collection before pushing into the respective file
             * removes the properties not set by the user
             * removes properties internally used by wm-dev team (starting with '_')
             * removes dataBindings with empty value
             * @param variables list of variables to filter
             */
            filterVariables = function (variables) {
                WM.forEach(variables, function (variable) {
                    WM.forEach(variable, function (propertyValue, propertyName) {
                        if (propertyValue === "" || propertyValue === undefined || (Utils.stringStartsWith(propertyName, '_') && propertyName !== '_id') || propertyName === "$$hashKey") {
                            delete variable[propertyName];
                        }
                    });

                    cleanseBindings(variable.dataBinding);
                });
                return variables;
            },
        /*function to create a variable*/
            create = function (type, options, name, overWrite) {
                /* type sanity checking */
                type = type || "wm.Variable";
                var variableObj = {},
                    defaultName = '';

                options = WM.isObject(options) ? options : {};

                /* if name prefix provided, create another category and iterator for that category*/
                if (name) {
                    defaultName = generateUniqueName(type, name, overWrite);
                } else {
                    defaultName = generateUniqueName(type);
                }

                /* create the variable object with its basic properties and return it */
                WM.extend(variableObj, BaseVariablePropertyFactory.getProperties(type), {name: defaultName}, options);
                return variableObj;
            },
        /*function to store a variable to the collection*/
            store = function (owner, name, variableObj, isUpdate) {
                /* sanity checking */
                if (!variableObj) {
                    return;
                }
                var varCollectionObj = self.variableCollection,
                    scope;
                owner = $rootScope.isPrefabTemplate ? MAIN_PAGE : (owner || VARIABLE_CONSTANTS.OWNER.APP);
                scope = pageScopeMap[owner];

                /* Condition: If type does not exist yet, then create one */
                if (!varCollectionObj.hasOwnProperty(owner) || !varCollectionObj[owner]) {
                    varCollectionObj[owner] = {};
                }

                /* Assign a unique id to the newly created variable */
                variableObj['_id'] = "wm-" + name + "-" + variableObj.category + "-" + (new Date().getTime());

                /* Store variable based on type */
                varCollectionObj[owner][name] = variableObj;
                varCollectionObj[scope.$id][name] = Utils.getClonedObject(variableObj);
                varCollectionObj[scope.$id][name].name = name;
                self.studioCopy[owner][name] = varCollectionObj[scope.$id][name];

                /* if app level variable make it available in the active page scope */
                if (owner === VARIABLE_CONSTANTS.OWNER.APP) {
                    if ($rootScope.activePageName) {
                        Object.defineProperty(pageScopeMap[$rootScope.activePageName].Variables, name, {
                            configurable: true,
                            get: function () {
                                return varCollectionObj[scope.$id][name];
                            }
                        });
                    }
                }
                if (!_.includes(CRUDMAP.CREATE[owner], name)) {
                    CRUDMAP.CREATE[owner].push(name);/*Storing created variable name in map*/
                }
                if (isUpdate) {
                    call('getData', name, {scope: scope, skipFetchData: true});
                }
            },
            initiateCallback = function (event, variable, callBackScope, response) {
                /*checking if event is available and variable has event property and variable event property bound to function*/
                var eventValues = variable[event],
                    retVal,
                    errorVariable;
                callBackScope = variable.activeScope;
                if (eventValues) {
                    _.forEach(eventValues.split(';'), function (eventValue) {
                        /* if event value is javascript, call the function defined in the callback scope of the variable */
                        if (eventValue === 'Javascript') {
                            retVal = Utils.triggerFn(callBackScope[variable.name + event], variable, response);
                        }
                        if (_.includes(eventValue, '.show')) {
                            DialogService.showDialog(eventValue.slice(0, eventValue.indexOf('.show')));
                            return;
                        }
                        if (_.includes(eventValue, '.hide')) {
                            DialogService.hideDialog(eventValue.slice(0, eventValue.indexOf('.hide')));
                            return;
                        }
                        if (_.includes(eventValue, '(')) {
                            retVal = Utils.triggerFn(callBackScope[eventValue.substring(0, eventValue.indexOf('('))], variable, response);
                        }

                        /* invoking the variable in a timeout, so that the current variable dataSet values are updated before invoking */
                        $timeout(function () {
                            $rootScope.$emit("invoke-service", eventValue, {scope: callBackScope});
                            $rootScope.$safeApply(callBackScope);
                        }, null, false);
                    });
                } else if (event === VARIABLE_CONSTANTS.EVENT.ERROR) {
                    /* in case of error, if no event assigned, handle through default notification variable */
                    errorVariable = getVariableByName(VARIABLE_CONSTANTS.DEFAULT_VAR.NOTIFICATION);
                    if (errorVariable) {
                        response = errorVariable.getMessage() || response;
                        $rootScope.$emit("invoke-service", VARIABLE_CONSTANTS.DEFAULT_VAR.NOTIFICATION, {scope: callBackScope, message: response});
                    }
                }
                return retVal;
            },

            /* unloads the variables from the specified namespace */
            unload = function (namespace, scope) {
                /* sanity check */
                if (!namespace) {
                    return;
                }
                self.variableCollection = self.variableCollection || {};

                /*
                 * loop through each variable in the namespace and remove the watchers if any
                 */
                if (watchers[scope.$id]) {
                    WM.forEach(self.variableCollection[namespace], function (variable, name) {
                        if (watchers[scope.$id][name]) {
                            watchers[scope.$id][name].forEach(Utils.triggerFn);
                        }
                    });
                }

                /* remove the variables in namespace from the variable collection*/
                delete self.variableCollection[namespace];
                delete self.variableCollection[scope.$id];
            },

            /* process the requests in the queue for a variable based on the inFlightBehavior flag of the variable */
            processRequestQueue = function (variable, requestQueue, handler) {
                /* process request queue for the variable only if it is not empty */
                if (requestQueue && requestQueue[variable.name] && requestQueue[variable.name].length) {
                    var requestObj;
                    switch (variable.inFlightBehavior) {
                    case 'executeLast':
                        requestObj = requestQueue[variable.name].pop();
                        handler(requestObj.variable, requestObj.options, requestObj.success, requestObj.error);
                        requestQueue[variable.name] = null;
                        break;
                    case 'executeAll':
                        requestObj = requestQueue[variable.name].splice(0, 1).pop();
                        handler(requestObj.variable, requestObj.options, requestObj.success, requestObj.error);
                        break;
                    default:
                        requestQueue[variable.name] = null;
                        break;
                    }
                }
            },

            /*Function to delete the specified variable*/
            deleteVariable = function (name, pageName) {
                var i, pageContext, owner;
                /*Check if pageName is specified*/
                if (pageName) {
                    /*If "name" is specified, delete the specified variable from the page.
                    * Else, delete all the variables of that page.*/
                    if (name && !_.includes(CRUDMAP.DELETE[pageName], name)) {
                        CRUDMAP.DELETE[pageName].push(name);
                        delete self.variableCollection[pageName][name];
                        /* if in studio mode remove the studio copy of variable*/
                        if (CONSTANTS.isStudioMode) {
                            delete returnObject[name];
                            delete self.studioCopy[pageName][name];
                        }
                    } else {
                        _.each(self.variableCollection[pageName], function (variable) {
                            if (!_.includes(CRUDMAP.DELETE[pageName], variable.name)) {
                                CRUDMAP.DELETE[pageName].push(variable.name);
                            }
                        });
                        delete self.variableCollection[pageName];
                        /* if in studio mode remove the studio copy */
                        if (CONSTANTS.isStudioMode) {
                            delete self.studioCopy[pageName];
                        }
                    }
                    return;
                }
                /* Condition: Checking for existence of the variable name inside each category, deleting if found */
                for (i in self.variableCollection) {
                    if (self.variableCollection.hasOwnProperty(i) && self.variableCollection[i].hasOwnProperty(name)) {
                        owner = self.variableCollection[i][name].owner === VARIABLE_CONSTANTS.OWNER.APP ? VARIABLE_CONSTANTS.OWNER.APP : $rootScope.activePageName;
                        if (!_.includes(CRUDMAP.DELETE[owner], name)) {
                            CRUDMAP.DELETE[owner].push(name);
                        }
                        delete self.variableCollection[i][name];
                        /* if in studio mode remove the studio copy of variable*/
                        if (CONSTANTS.isStudioMode && self.studioCopy[i]) {
                            delete self.studioCopy[i][name];
                        }
                        /*if the context is a page and not a scope id, return the page context*/
                        if (ProjectService.getPageNames().indexOf(i) > -1) {
                            pageContext = i;
                        }
                    }
                }

                /*if deleted variable page context is available, return it else, return false*/
                if (pageContext) {
                    return pageContext;
                }
                return false;
            },

        /*function to filter the variable collection based on the object map provided*/
            filterByVariableKeys = function (variableParams, searchAllContexts) {
                var variables = self.variableCollection,
                    currentVariable,
                    variableOwner,
                    variableNames,
                    varParamsArray = _.keys(variableParams),
                    index,
                    varParamCounter,
                    currentVarParam,
                    filteredVariables = [],
                    defaultContextArray = [VARIABLE_CONSTANTS.OWNER.APP, $rootScope.activePageName];

                if (variableParams.owner) {
                    variableOwner = (variableParams.owner === VARIABLE_CONSTANTS.OWNER.APP) ? VARIABLE_CONSTANTS.OWNER.APP : $rootScope.activePageName;
                }

                /*function to find the variables which match the all the keys in the object map provided*/
                function findMatchingVariables(contextVariables, context) {
                    variableNames = _.keys(contextVariables);

                    /*iterating over the variables of a specific context, either app or page*/
                    for (index = 0; index < variableNames.length; index++) {
                        currentVariable = variables[context][variableNames[index]];

                        /*iterating over the filter keys provided and validating if the
                        * current variable's properties match the filter keys provided*/
                        for (varParamCounter = 0; varParamCounter < varParamsArray.length; varParamCounter++) {
                            currentVarParam = varParamsArray[varParamCounter];

                            /*checking if the properties match, if so pushing the param key to the
                            * temp array*/
                            if (currentVariable[currentVarParam] !== variableParams[currentVarParam]) {
                                break;
                            }
                        }
                        /*if all properties have been matched and are validated to true, then push
                         * the current variable to the filtered variables array*/
                        if (varParamCounter === varParamsArray.length) {
                            if (filteredVariables.indexOf(currentVariable) === -1) {
                                currentVariable.name = variableNames[index];
                                filteredVariables.push(currentVariable);
                            }
                        }
                    }
                }

                /*if searchAllContexts is false, use the variable owner if provided, else use the
                * default contexts - app and active-page to filter the variables.*/
                if (!searchAllContexts) {
                    /*if the variable owner is available, then provide the context to filter variables*/
                    if (variableOwner) {
                        findMatchingVariables(variables[variableOwner], variableOwner);
                    } else {
                        /*if no variable owner and searchAllContexts is false, restrict the contexts
                        * to default variable contexts*/
                        defaultContextArray.forEach(function (context) {
                            findMatchingVariables(variables[context], context);
                        });
                    }
                } else {
                    /*if searchAllContext is true, then use each context in the
                     * variable collection for filtering the collection*/
                    Object.keys(variables).forEach(function (context) {
                        /*only filtering the context for app and pages, ignoring scope-id contexts*/
                        if (isNaN(context)) {
                            findMatchingVariables(variables[context], context);
                        }
                    });
                }
                return filteredVariables;
            },

            getBindMap = function (type, parentReference, oldBindings, visitedNodes) {
                var types = $rootScope.dataTypes,
                    curFieldObj;

                oldBindings = oldBindings || {};
                if (!visitedNodes) {
                    visitedNodes = [];
                }
                if (visitedNodes.indexOf(type) !== -1) {
                    return;
                }

                if (types && types[type] && types[type].fields && Object.keys(types[type].fields).length) {
                    visitedNodes.push(type);
                    parentReference.fields = [];
                    WM.forEach(types[type].fields, function (field, fieldName) {
                        curFieldObj = {
                            "name": fieldName,
                            "type": field.type,
                            "isList": field.isList
                        };
                        if (oldBindings[fieldName] && !WM.isObject(oldBindings[fieldName])) {
                            curFieldObj.value = oldBindings[fieldName];
                        }
                        parentReference.fields.push(curFieldObj);
                        getBindMap(field.type, curFieldObj, oldBindings[fieldName], visitedNodes);
                    });
                }
            };

        /*
         * This object is used to collect all the variables and keep them organized
         * based on their nature.
         * This stores the actual collection retrieved from and stored to the variable files
         */
        this.variableCollection = null;

        /*
         * This object has the variable collection along with modified properties
         * such as dataSet (modified in studio mode)
         * This is only required in studio mode.
         */
        this.studioCopy = {};

        /*check the project ID existence in RUN mode*/
        if (runMode) {
            $rootScope.project = {
                id: ProjectService.getId()
            };
        }

        initVariableNameMap();

        /*Initialize the variable name iterator to the default value.*/
        resetVariableNameIterator();

        /*Check for Studio mode.*/
        if (CONSTANTS.isStudioMode) {
            /*Register a listener on the rootScope to update the variable with binding information.*/
            $rootScope.$on('bind-widget-to-variable', function (event, variableName, isBind, scope, bindCount) {
                event.stopPropagation();
                var variable = getVariableByName(variableName, scope),
                    writableVariable = getVariableByName(variableName);
                /*Check for variable if in case, variable is deleted and for live variables.*/
                if (variable && variable.category === 'wm.LiveVariable' && variable.operation === 'read') {
                    /*If a variable has been selected for "binding", increment the bindCount.
                    * Else, if the variable has been selected for "unbinding", decrement the bindCount.*/
                    if (isBind) {
                        if (!variable.startUpdate) {
                            variable.bindCount = ((variable.bindCount || 0) + (bindCount || 1));
                            writableVariable.startUpdate = variable.startUpdate = true;
                            if (WM.isFunction(variable.update)) {
                                variable.update();
                            }
                        }
                    } else {
                        variable.bindCount -= 1;
                        /*When the bindCount becomes 0, set the "startUpdate" flag to false*/
                        if (!variable.bindCount) {
                            writableVariable.startUpdate = variable.startUpdate = false;
                        }
                    }
                    writableVariable.bindCount = variable.bindCount;
                    /*Set the "saveVariables" to true so that when "save"/"run" buttons are clicked, the variables could be saved into the file.*/
                    updateVariable(writableVariable.name, writableVariable);
                    $rootScope.saveVariables = true;
                }
            });
        }

        returnObject = {
            /**
             * @ngdoc method
             * @name $Variables#create
             * @methodOf wm.variables.$Variables
             * @description
             * Creates all kinds of variables (simple, live and service).
             * @param {string} variableType type of the variable to be created
             * @param {object} options contains all the possible configuration values for a variable
             */
            'create': create,

            /**
             * @ngdoc method
             * @name $Variables#store
             * @methodOf wm.variables.$Variables
             * @description
             * Stores a variable instance based on the type of the variable as its key
             * @param {string} type: type of the expected variable
             * @param {object} varObj: object storing the variable attributes
             */
            'store': store,
            /**
             * @ngdoc method
             * @name $Variables#isExists
             * @methodOf wm.variables.$Variables
             * @description
             * Checks whether the variable with specified name exists in store
             * @param {string} variableName name of the variable to be checked for existence
             */
            'isExists': isExists,
            /**
             * @ngdoc method
             * @name $Variables#isNameAvailable
             * @methodOf wm.variables.$Variables
             * @description
             * Checks whether the variable with specified values exists in store
             * @param {object} variableObj object whose values should be checked with existing variables
             */
            'isNameAvailable': function (variableObj) {
                var variableNameAvailable = false,
                    existingVariable = getVariableByName(variableObj.name);

                /* check if the name is available in existing collection*/
                if (variableObj && variableObj['_id'] === existingVariable['_id']) {
                    variableNameAvailable = true;
                }

                return variableNameAvailable;
            },
            /**
             * @ngdoc method
             * @name $Variables#getVariableByName
             * @methodOf wm.variables.$Variables
             * @description
             * Gets a variable instance based on the provided name
             * @param {string} name name of the expected variable
             */
            'getVariableByName': getVariableByName,
            /**
             * @ngdoc method
             * @name $Variables#updateVariable
             * @methodOf wm.variables.$Variables
             * @description
             * Updates a variable instance based on the provided name
             * @param {string} variableName existing name/old name name of the variable to be updated
             * @param {object} newProperties properties of the variable to be updated
             */
            'updateVariable': updateVariable,
            /**
             * @ngdoc method
             * @name $Variables#delete
             * @methodOf wm.variables.$Variables
             * @description
             * Deletes a requested variable
             * @param {string} name name of the variable to be deleted
             */
            'delete': deleteVariable,
            /**
             * @ngdoc method
             * @name $Variables#getAll
             * @methodOf wm.variables.$Variables
             * @description
             * Gets all the variables in store
             */
            'getAll': function () {
                return self.variableCollection;
            },
            /**
             * @ngdoc method
             * @name $Variables#getDuplicateVariables
             * @methodOf wm.variables.$Variables
             * @description
             * Get array of duplicate variable names
             */
            'getDuplicateVariables': function () {
                return _.intersection(_.keys(self.variableCollection[VARIABLE_CONSTANTS.OWNER.APP]), _.keys(self.variableCollection[$rootScope.activePageName]));
            },
            /**
             * @ngdoc method
             * @name $Variables#getStudioCopy
             * @methodOf wm.variables.$Variables
             * @description
             * Gets all the variables in studio along with data inside the dataSet
             */
            'getStudioCopy': function () {
                return self.studioCopy;
            },

            /**
             * @ngdoc method
             * @name $Variables#saveVariables
             * @methodOf wm.variables.$Variables
             * @description
             * Saves global variables in the file "app.variables.json"  and page level variables corresponding to active page separately, and show toaster message on Success/Failure
             * @param {string} activePageName Name of the active page.
             * @param {function} success success callback function.
             * @param {function} error error callback function.
             * @param {object} updateValues flag to update the variable values.
             *
             */
            'saveVariables': function (activePageName, success, error, updateValues) {
                /*activePage will not be there while in java service and db workspace*/
                if ($rootScope.isPrefabTemplate) {
                    activePageName = MAIN_PAGE;
                }
                if (updateValues) {
                    updateVariableValues(activePageName);
                }
                function onSuccess() {
                    if (_.includes(reloadRequired, 'App')) {
                        reloadVariables(success, error);
                    } else if (_.includes(reloadRequired, activePageName)) {
                        getPageVariables(activePageName, success, error);
                    } else {
                        Utils.triggerFn(success);
                    }
                }                /* save app variables */
                executeCrudOp(VARIABLE_CONSTANTS.OWNER.APP, function () {
                    if (activePageName) {
                        /* save page variables */
                        executeCrudOp(activePageName, onSuccess, error);
                    } else {
                        onSuccess();
                    }
                }, error);
            },

            /**
             * @ngdoc method
             * @name $Variables#savePageVariables
             * @methodOf wm.variables.$Variables
             * @description
             * Saves page level variables corresponding to active page separately, and show toaster message on Success/Failure
             * @param {string} activePageName Name of the active page.
             * @param {function} success success callback function.
             * @param {function} error error callback function.
             * @param {object} updateValues flag to update the variable values.
             *
             */
            'savePageVariables': function (activePageName, success, error, updateValues) {
                /* sanity check */
                if (!activePageName) {
                    return;
                }
                if (updateValues) {
                    updateVariableValues(activePageName);
                }
                function onSuccess() {
                    if (_.includes(reloadRequired, activePageName)) {
                        getPageVariables(activePageName, success, error);
                    } else {
                        Utils.triggerFn(success);
                    }
                }
                /* save page variables */
                executeCrudOp(activePageName, onSuccess, error);
            },

            /**
             * @ngdoc method
             * @name $Variables#saveAppVariables
             * @methodOf wm.variables.$Variables
             * @description
             * Saves global variables in the file "app.variables.json" and show toaster message on Success/Failure
             * @param {function} success success callback function.
             * @param {function} error error callback function.
             * @param {object} updateValues flag to update the variable values.
             *
             */
            'saveAppVariables': function (success, error, updateValues) {

                if (updateValues) {
                    updateVariableValues();
                }
                function onSuccess() {
                    if (_.includes(reloadRequired, 'App')) {
                        reloadVariables(success, error);
                    } else {
                        Utils.triggerFn(success);
                    }
                }
                /* save app variables */
                executeCrudOp(VARIABLE_CONSTANTS.OWNER.APP, onSuccess, error);
            },

            /**
             * @ngdoc method
             * @name $Variables#init
             * @methodOf wm.variables.$Variables
             * @description
             * Initializes the variable collection.
             * The app variables and the current page variables are loaded.
             * The values and bindings of each variable is also initialized.
             * @param {function} success callback
             * @param {function} error callback
             *
             */
            'init': initVariableCollection,

            /**
             * @ngdoc method
             * @name $Variables#initAppVariables
             * @methodOf wm.variables.$Variables
             * @description
             * Initialize the app variable collection for the project
             * @param {function} success callback
             * @param {function} error callback
             *
             */
            'initAppVariables': initAppVariables,

            /**
             * @ngdoc method
             * @name $Variables#initPageVariables
             * @methodOf wm.variables.$Variables
             * @description
             * Initialize the variable collection for a page of the project
             * @param {function} success callback
             * @param {function} error callback
             *
             */
            'initPageVariables': initPageVariables,

            /**
             * @ngdoc method
             * @name $Variables#reloadVariables
             * @methodOf wm.variables.$Variables
             * @description
             * Reload the variable collection`
             *
             */
            'reloadVariables': reloadVariables,

            /**
             * @ngdoc method
             * @name $Variables#resetVariables
             * @methodOf wm.variables.$Variables
             * @description
             * Returns the variable category list supported
             * @param {string} collectionType grouping of the variable categories (data, call)
             * return {object} variable categories list
             */
            'getVariableCategoryList': getVariableCategoryList,

            /**
             * @ngdoc method
             * @name $Variables#getType
             * @methodOf wm.variables.$Variables
             * @description
             * Returns type of the variable
             * @param {string} name Name of the variable.
             * @returns {string} type of the variable
             *
             */
            'getType': getType,

            /**
             * @ngdoc method
             * @name $Variables#getVariableNameIterator
             * @methodOf wm.variables.$Variables
             * @description
             * Returns variableNameIterator
             */
            'getVariableNameIterator': function () {
                return self.variableNameIterator;
            },

            /**
             * @ngdoc method
             * @name $Variables#resetVariableNameIterator
             * @methodOf wm.variables.$Variables
             * @description
             * Resets the variableNameIterator
             */
            'resetVariableNameIterator': resetVariableNameIterator,

            /**
             * @ngdoc method
             * @name $Variables#call
             * @methodOf wm.variables.$Variables
             * @description
             * calls the specified method of a variable category
             * @params {string} method method name of variable category to ba called
             * @params {string} name name of variable
             * @params {object} other helper options for the method
             * @params {function} success success callback method
             * @params {function} error error callback method
             */
            'call': call,

            /**
             * @ngdoc method
             * @name $Variables#generateUniqueName
             * @methodOf wm.variables.$Variables
             * @description
             * generates a unique name for a variable
             * @params {string}  category category of the variable
             * @params {string} name name of variable
             * @params {object} other helper options for the method
             * @params {function} success success callback method
             * @params {function} error error callback method
             * @returns {string} unique name of the variable
             */
            generateUniqueName: generateUniqueName,

            /**
             * @ngdoc method
             * @name $Variables#register
             * @methodOf wm.variables.$Variables
             * @description
             * registers a variable collection in the specified namespace
             * @params {string}  category category of the variable
             * @params {string} name name of variable
             * @params {object} other helper options for the method
             * @params {function} success success callback method
             * @params {function} error error callback method
             * @returns {string} unique name of the variable
             */
            register: register,

            /**
             * @ngdoc method
             * @name $Variables#retrieveEventCallbackVariables
             * @methodOf wm.variables.$Variables
             * @description
             * retrieves the service and live variables from the collection
             * @params {string} name of variable to exclude from collection
             * @returns {array} array containing all the service and live variables other than the variable name provided.
             */
            retrieveEventCallbackVariables: retrieveEventCallbackVariables,

            /**
             * @ngdoc method
             * @name $Variables#isEventCallbackVariable
             * @methodOf wm.variables.$Variables
             * @description
             * determines if a variable has event callbacks
             * @params {string} variable category
             * @returns {array} true if variable has event callbacks else false
             */
            isEventCallbackVariable: isEventCallbackVariable,

            /**
             * @ngdoc method
             * @name $Variables#saveContextVariables
             * @methodOf wm.variables.$Variables
             * @description
             * saves the variables based on the context provided
             * @params {string} variable context
             */
            saveContextVariables: saveContextVariables,

            /**
             * @ngdoc method
             * @name $Variables#updateVariableDataSet
             * @methodOf wm.variables.$Variables
             * @description
             * updates the dataSet property of a variable with specified name in the collection
             * @params {string} variable context
             */
            updateVariableDataSet: updateVariableDataSet,

            /**
             * @ngdoc method
             * @name $Variables#createLiveVariable
             * @methodOf wm.variables.$Variables
             * @description
             * creates a live variable based on the specified details
             * @params {object} variable details
             */
            createLiveVariable: function (variableDetails) {
                /* call base service function to create the variable */
                var variableCategory = "wm.LiveVariable",
                    defaultName,
                    createdVariable,
                    variableName,
                    variableOwner;

                defaultName = variableDetails.name || Utils.initCaps(variableDetails.service) + Utils.initCaps(variableDetails.table) + "Data";

                /*If the default variable does not exist, create it.
                * Else, simply return the variable name.*/
                if (!isExists(defaultName)) {

                    createdVariable = create(variableCategory, {owner: variableDetails.owner || "Page", "isList": true}, defaultName);
                    variableName = createdVariable.name;
                    variableOwner = (createdVariable.owner === VARIABLE_CONSTANTS.OWNER.PAGE) ? $rootScope.activePageName : null;

                    /*Set the "liveSource" and "type" properties of the live-variable.*/
                    createdVariable.liveSource = variableDetails.service;
                    createdVariable.type = variableDetails.table;
                    createdVariable.category = variableCategory;
                    createdVariable.isDefault = true;

                    /*adding a property to identify the database-type for the created live-variable*/
                    createdVariable.dbSystem = variableDetails.dbSystem;

                    /* Store the variable in proper category */
                    store(variableOwner, variableName, createdVariable, true);

                    /*Update the tree with the newly added variable under the appropriate category(i.e., basic/service/live variables)*/
                    $rootScope.$emit("update-variables-tree", createdVariable);
                } else {
                    variableName = defaultName;
                }

                /*Return the name of the newly created variable.*/
                return variableName;
            },

            /**
             * @ngdoc method
             * @name $Variables#createServiceVariable
             * @methodOf wm.variables.$Variables
             * @description
             * creates a service variable based on the specified details
             * @params {object} variable details
             */
            createServiceVariable: function (variableDetails, overWrite) {
                /* call base service function to create the variable */
                var variableCategory = "wm.ServiceVariable",
                    defaultName = variableDetails.name || Utils.initCaps(variableDetails.service) + Utils.initCaps(variableDetails.operation),
                    createdVariable,
                    variableName,
                    variableOwner,
                    bindMapCollection;

                /*If the default variable does not exist, create it.
                 * Else, simply return the variable name.*/
                if (!isExists(defaultName) || overWrite) {
                    createdVariable = create(variableCategory, {owner: variableDetails.owner || "Page"}, defaultName, overWrite);
                    variableName = createdVariable.name;
                    variableOwner = (createdVariable.owner === VARIABLE_CONSTANTS.OWNER.PAGE) ? $rootScope.activePageName : null;

                    /*Set the "service" and "operation" properties of the service-variable.*/
                    createdVariable.service = variableDetails.service;
                    createdVariable.operation = variableDetails.operation;
                    createdVariable.operationType = variableDetails.operationType;
                    createdVariable.serviceType = variableDetails.serviceType;
                    createdVariable.category = variableCategory;
                    createdVariable.isDefault = true;
                    createdVariable.type = variableDetails.returnType;

                    if (variableDetails.wmServiceOperationInfo) {
                        createdVariable.wmServiceOperationInfo = variableDetails.wmServiceOperationInfo;
                    }

                    /* insert sample param values if provided */
                    bindMapCollection = createdVariable.dataBinding;
                    WM.forEach(variableDetails.sampleParamValues, function (val, key) {
                        bindMapCollection.push({
                            "target": key,
                            "value": val,
                            "type": "java.lang.String"
                        });
                    });

                    /* Store the variable in proper category */
                    store(variableOwner, variableName, createdVariable, true);

                    /*Update the tree with the newly added variable under the appropriate category(i.e., basic/service/live variables)*/
                    $rootScope.$emit("update-variables-tree", createdVariable);
                } else {
                    variableName = defaultName;
                }

                /*Return the name of the newly created variable.*/
                return variableName;
            },

            /**
             * @ngdoc method
             * @name $Variables#deleteDefaultVariable
             * @methodOf wm.variables.$Variables
             * @description
             * deletes the specified default variable
             * @params {object} variable details
             */
            deleteDefaultVariable: function (variableDetails) {
                /*filter the variable collection by using the provided object map as a filter key*/
                var filteredVariables = filterByVariableKeys(variableDetails, false),
                    owner = VARIABLE_CONSTANTS.OWNER.APP;

                filteredVariables.forEach(function (variable) {
                    /*calling delete variable on each of the matching variables*/
                    if (variable.owner === VARIABLE_CONSTANTS.OWNER.PAGE) {
                        owner = $rootScope.activePageName;
                    }
                    deleteVariable(variable.name, owner);
                });
            },

            /**
             * @ngdoc method
             * @name $Variables#initiateCallback
             * @methodOf wm.variables.$Variables
             * @description
             * handles the triggering of event for a variable in RUN mode
             * @params {event} event to be triggered (onSuccess, onError, etc.)
             * @params {variable} variable details object
             * @params {callBackScope} scope of the callback function (if defined by user)
             * @params {response} response returned by the variable's service
             */
            initiateCallback: initiateCallback,

            /**
             * @ngdoc method
             * @name $Variables#unload
             * @methodOf wm.variables.$Variables
             * @description
             * unloads the variables in specified namespace
             * @params {namespace} the namespace from which the variables are to be unloaded. E.g. the 'page name' for page variables and 'app' for app variables
             */
            unload: unload,

            /**
             * @ngdoc method
             * @name $Variables#getAppVariables
             * @methodOf wm.variables.$Variables
             * @description
             * loads and returns the app variables
             * @params {pageName} event to be triggered (onSuccess, onError, etc.)
             * @params {success} success handler
             * @params {error} error handler
             */
            getAppVariables: getAppVariables,

            /**
             * @ngdoc method
             * @name $Variables#getPageVariables
             * @methodOf wm.variables.$Variables
             * @description
             * reads and returns the variables from specified page name
             * @params {pageName} event to be triggered (onSuccess, onError, etc.)
             * @params {success} success handler
             * @params {error} error handler
             */
            getPageVariables: getPageVariables,

            /**
             * @ngdoc method
             * @name $Variables#setPageVariables
             * @methodOf wm.variables.$Variables
             * @description
             * set the variables for specified page name
             * @params {pageName} name of the page
             * @params {pageVariables} variable object
             */
            setPageVariables: setPageVariables,

            /**
             * @ngdoc method
             * @name $Variables#processRequestQueue
             * @methodOf wm.variables.$Variables
             * @description
             * process the requests in the queue for a variable based on the inFlightBehavior flag of the variable
             * @params {variable} variable object whose request queue is to be processed
             * @params {requestQueue} request queue for the variable
             * @params {handler} handler of the variable request, separate handlers for service and live variables
             */
            processRequestQueue: processRequestQueue,

            /**
             * @ngdoc method
             * @name $Variables#filterByVariableKeys
             * @methodOf wm.variables.$Variables
             * @description
             * filter the variable collection based on the params provided and return the appropriate variable found
             * @params {variableParams} params needed to filter the variable collection and find variable
             */
            filterByVariableKeys: filterByVariableKeys,

            /**
             * @ngdoc method
             * @name $Variables#getBindMap
             * @methodOf wm.variables.$Variables
             * @description
             * gets the bind map structure for a variable based on the type provided
             * @params {type} the type for which the the map is to be prepared
             * @params {parentReference} reference for the target bind map to be prepared at
             */
            getBindMap: getBindMap,
            /**
             * @ngdoc method
             * @name $Variables#addVariableConfig
             * @methodOf wm.variables.$Variables
             * @description
             * adds the variable config to the list.
             * @params config data
             * ex : {
             *          "collectionType": "call", //accepted values are 'call' or 'data'
             *          "category": "wm.NotificationVariable", // category name
             *          "labelKey": "LABEL_VARIABLE_NOTIFICATION", // key to find localed specific display name
             *          "defaultName": "notificationVariable" // default category name
             *      }
             */
            addVariableConfig : function (config) {
                variableConfig.push(config);
                variableCategoryToNameMap[config.category] = config.defaultName;
                self.variableNameIterator[config.category] = 1;
            }
        };

        return returnObject;
    }
];

/*global WM, wm*/
/*jslint todo: true */
/**
 * @ngdoc service
 * @name wm.variables.$VariableService
 * @description
 * The `VariableService` provides the details about the variable based service apis
 */
wm.variables.services.VariableService = function (BaseService) {
    'use strict';
    return {
        /**
         * @ngdoc function
         * @name wm.variables.$VariableService#create
         * @methodOf wm.variables.$VariableService
         * @function
         *
         * @description
         * Takes array of variable objects to be created
         *
         * @param {object} params object containing parameters for the request (else throws an error message)
         * @param {function} successCallback to be called on success
         * @param {function} failureCallback to be called on failure
         */
        create: function (params, successCallback, failureCallback) {
            BaseService.send({
                target: 'VariableService',
                action: params.pageName === 'App' ? 'addAppVariables' : 'addPageVariables',
                urlParams: params,
                data: params.data
            }, successCallback, failureCallback);
        },
        /**
         * @ngdoc function
         * @name wm.variables.$VariableService#get
         * @methodOf wm.variables.$VariableService
         * @function
         *
         * @description
         * get map of variable objects
         *
         * @param {object} params object containing parameters for the request (else throws an error message)
         * @param {function} successCallback to be called on success
         * @param {function} failureCallback to be called on failure
         */
        get: function (params, successCallback, failureCallback) {
            BaseService.send({
                target: 'VariableService',
                action: params.pageName === 'App' ? 'getAppVariables' : 'getPageVariables',
                urlParams: params
            }, successCallback, failureCallback);
        },
        /**
         * @ngdoc function
         * @name wm.variables.$VariableService#update
         * @methodOf wm.variables.$VariableService
         * @function
         *
         * @description
         * Takes array of variable objects to be updated
         *
         * @param {object} params object containing parameters for the request (else throws an error message)
         * @param {function} successCallback to be called on success
         * @param {function} failureCallback to be called on failure
         */
        update: function (params, successCallback, failureCallback) {
            BaseService.send({
                target: 'VariableService',
                action: params.pageName === 'App' ? 'updateAppVariables' : 'updatePageVariables',
                urlParams: params,
                data: params.data
            }, successCallback, failureCallback);
        },
        /**
         * @ngdoc function
         * @name wm.variables.$VariableService#move
         * @methodOf wm.variables.$VariableService
         * @function
         *
         * @description
         * Takes array of variable objects to be moved
         *
         * @param {object} params object containing parameters for the request (else throws an error message)
         * @param {function} successCallback to be called on success
         * @param {function} failureCallback to be called on failure
         */
        move: function (params, successCallback, failureCallback) {
            BaseService.send({
                target: 'VariableService',
                action: params.pageName === 'App' ? 'moveAppVariables' : 'movePageVariables',
                urlParams: params,
                data: params.data
            }, successCallback, failureCallback);
        },
        /**
         * @ngdoc function
         * @name wm.variables.$VariableService#delete
         * @methodOf wm.variables.$VariableService
         * @function
         *
         * @description
         * Takes array of variable names to be deleted
         *
         * @param {object} params object containing parameters for the request (else throws an error message)
         * @param {function} successCallback to be called on success
         * @param {function} failureCallback to be called on failure
         */
        delete: function (params, successCallback, failureCallback) {
            BaseService.send({
                target: 'VariableService',
                action: params.pageName === 'App' ? 'deleteAppVariables' : 'deletePageVariables',
                urlParams: params
            }, successCallback, failureCallback);
        }

    };
};
/*global wm, WM*/
/*jslint sub: true */

/**
 * @ngdoc service
 * @name wm.variables.$BasicVariableService
 * @requires $rootScope
 * @requires $routeParams
 * @requires BaseVariablePropertyFactory
 * @description
 */

wm.variables.services.BasicVariableService = [
    "BaseVariablePropertyFactory",
    "Utils",
    function (BaseVariablePropertyFactory, Utils) {
        "use strict";

        /* properties of a basic variable - should contain methods applicable on this particular object */
        var methods = {
                getData: function (variable, options, success) {
                    /*Invoke the success callback with the data of the variable*/
                    Utils.triggerFn(success, variable.dataSet);
                    /* return the value since it is not an async call */
                    return variable.dataSet;
                },
                setData: function (variable, dataSet) {
                    /* check dataset sanity */
                    if (!dataSet) {
                        return variable.dataSet;
                    }
                    /* check array type dataset for list type variable */
                    if (variable.isList && !WM.isArray(dataSet)) {
                        return variable.dataSet;
                    }

                    /*change the dataSet*/
                    variable.dataSet = dataSet;

                    /* return the value since it is not an async call */
                    return variable.dataSet;
                },
                getValue: function (variable, key, index) {
                    index = index || 0;

                    /* return the value against the specified key */
                    return variable.isList ? variable.dataSet[index][key] : variable.dataSet[key];
                },
                setValue: function (variable, key, value) {
                    /* check param sanity */
                    if (!key || !value || variable.isList) {
                        return variable.dataSet;
                    }

                    /* set the value against the specified key */
                    variable.dataSet[key] = value;

                    /* return the new dataSet */
                    return variable.dataSet;
                },
                getItem: function (variable, index) {
                    /* return the object against the specified index */
                    return variable.isList ? variable.dataSet[index] : variable.dataSet;
                },
                setItem: function (variable, index, value) {
                    /* check param sanity */
                    if (!index || !value || !variable.isList) {
                        return variable.dataSet;
                    }

                    /* set the value against the specified index */
                    variable.dataSet[index] = value;

                    /* return the new dataSet */
                    return variable.dataSet;
                },
                addItem: function (variable, value, index) {
                    /* check param sanity */
                    if (!value || !variable.isList) {
                        return variable.dataSet;
                    }

                    /* check for index sanity */
                    index = index !== undefined ? index : variable.dataSet.length;

                    /* set the value against the specified index */
                    variable.dataSet.splice(index, 0, value);

                    /* return the new dataSet */
                    return variable.dataSet;
                },

                /*'index' can be index value of the element in array or an object with property values which need to be removed*/
                removeItem: function (variable, index, exactMatch) {
                    var indexValue;
                    /* check for index sanity */
                    index = index !== undefined ? index : variable.dataSet.length - 1;

                    if (WM.isObject(index)) {
                        indexValue = _.findIndex(variable.dataSet, index);
                        /*When exactMatch property is set to true delete only when every property values are same*/
                        if (indexValue > -1 && (!exactMatch || (exactMatch && WM.equals(variable.dataSet[indexValue], index)))) {
                            variable.dataSet.splice(indexValue, 1);
                        }
                    } else {
                        /* set the value against the specified index */
                        variable.dataSet.splice(index, 1);
                    }
                    /* return the new dataSet */
                    return variable.dataSet;
                },
                clearData: function (variable) {
                    /* empty the variable dataset */
                    variable.dataSet = variable.isList ? [] : {};

                    /* return the variable dataSet*/
                    return variable.dataSet;
                },
                getCount: function (variable) {
                    /* return the length of dataSet */
                    return variable.isList ? variable.dataSet.length : 1;
                }
            },
            basicVariableObj = {
                getData: function () {
                    return methods.getData(this);
                },
                setData: function (dataSet) {
                    return methods.setData(this, dataSet);
                },
                getValue: function (key, index) {
                    return methods.getValue(this, key, index);
                },
                setValue: function (key, value) {
                    return methods.setValue(this, key, value);
                },
                getItem: function (index) {
                    return methods.getItem(this, index);
                },
                setItem: function (index, value) {
                    return methods.setItem(this, index, value);
                },
                addItem: function (value, index) {
                    return methods.addItem(this, value, index);
                },
                removeItem: function (index, exactMatch) {
                    return methods.removeItem(this, index, exactMatch);
                },
                clearData: function () {
                    return methods.clearData(this);
                },
                getCount: function () {
                    return methods.getCount(this);
                }
            };

        /* register the variable to the base service*/
        BaseVariablePropertyFactory.register('wm.Variable', basicVariableObj, [], methods);

        return {

        };
    }
];

/*global wm, WM, _, moment*/
/*jslint todo: true */
/*jslint sub: true */

/**
 * @ngdoc service
 * @name wm.variables.$liveVariable
 * @requires $rootScope
 * @requires DatabaseService
 * @requires Variables
 * @requires BaseVariablePropertyFactory
 * @requires CONSTANTS
 * @requires Utils
 * @requires VARIABLE_CONSTANTS
 * @requires ProjectService
 * @requires DB_CONSTANTS
 * @description
 * This service is responsible for handling operations related to Live variables.
 * It manages creation, update, data retrieval operations.
 */

wm.variables.services.$liveVariable = [
    "$rootScope",
    "DatabaseService",
    "Variables",
    "BaseVariablePropertyFactory",
    "CONSTANTS",
    "Utils",
    "VARIABLE_CONSTANTS",
    "ProjectService",
    "DB_CONSTANTS",
    "wmToaster",
    "$filter",
    "ServiceFactory",
    function ($rootScope, DatabaseService, Variables, BaseVariablePropertyFactory, CONSTANTS, Utils, VARIABLE_CONSTANTS, ProjectService, DB_CONSTANTS, wmToaster, $filter, ServiceFactory) {
        "use strict";

        /*Set a flag based on whether the project is deployed or not.
         * 1. In the RUN mode, project is deployed.
         * 2. In the STUDIO mode, project has to be explicitly deployed.*/
        var isProjectDeployed = (CONSTANTS.isRunMode),
            DataModelDesignManager = CONSTANTS.isStudioMode && Utils.getService('DataModelDesignManager'),
            isProjectDeployInProgress = false,
            projectDeployReqQueue,
            callbackParams = [],
            requestQueue = {},
            variableActive = {},
            invalidVariables = [],
            isDeployReqSourceChanged,
            packageDetails = {},
            dateTimeFormats = Utils.getDateTimeDefaultFormats(),
            isDateTime = Utils.getDateTimeTypes(),
        /*Function to clear set variables*/
            reset = function () {
                isProjectDeployed = (CONSTANTS.isRunMode);
                /*Set the "isDeployReqSourceChanged" flag to true so that the deploy request queue is populated only when the deploy source changes.*/
                isDeployReqSourceChanged = true;
            },
        /*Function to convert values of date time types into default formats*/
            getDateInDefaultFormat = function (value, type) {
                var formatDate = function (dateValue) {
                    var epoch = moment(dateValue).valueOf();
                    if (type === 'time' && !epoch) {
                        epoch = moment(new Date().toDateString() + ' ' + dateValue).valueOf();
                    }
                    return dateValue && $filter('date')(epoch, dateTimeFormats[type]);
                };
                if (WM.isArray(value)) {
                    return _.map(value, function (val) {
                        return formatDate(val);
                    });
                }
                return formatDate(value);
            },
        /* Function to process the response data if it contains composite keys. */
            processResponse = function (responseData) {
                if (!responseData) {
                    return;
                }
                var formatData = function (rowData) {
                    _.each(rowData, function (value, key) {
                        var tempData;
                        if (WM.isObject(value)) {
                            /*If the table has a composite key, key data will be wrapped in an object with the key "id".
                             * Hence, the data is formatted to remove the extra key and merge it into the content.*/
                            if (key === 'id') {
                                tempData = rowData.id;
                                delete rowData.id;
                                WM.extend(rowData, tempData);
                                return;
                            }
                            /*If the value is an object, check if id object is present in this object*/
                            formatData(value);
                        }
                    });
                };
                responseData.forEach(function (rowData) {
                    formatData(rowData);
                });
            },
            /*function to fetch the column list of a related field*/
            getRelatedColumnsList = function (variable, fieldName) {
                var relatedColumn,
                    colArr = [],
                    targetTables = [],
                    getRelatedCols = function (columns, prefix) {
                        var relatedCols,
                            colName;
                        columns.forEach(function (column) {
                            var variableObject;
                            /*If the column is related, find out the columns of the target table*/
                            if (column.isRelated) {
                                /*Keeping the target tables array to stop the circular reference problems*/
                                if (!_.includes(targetTables, column.targetTable)) {
                                    targetTables.push(column.targetTable);
                                    variableObject = Variables.filterByVariableKeys({'liveSource' : variable.liveSource, 'tableName' : column.targetTable}, true)[0];
                                    relatedCols = variableObject ? variableObject.propertiesMap.columns : [];
                                    if (relatedCols && relatedCols.length) {
                                        getRelatedCols(relatedCols, column.fieldName);
                                    }
                                }
                            } else {
                                colName = prefix ? (prefix + '.' + column.fieldName) : column.fieldName;
                                colArr.push(colName);
                            }
                        });
                    };
                /*Find the related column from the variable properties map*/
                relatedColumn = _.find(variable.propertiesMap.columns, function (col) {
                    return col.fieldName === fieldName;
                });
                if (relatedColumn && relatedColumn.columns) {
                    getRelatedCols(relatedColumn.columns);
                }
                return colArr;
            },
            getHibernateOrSqlType = function (variable, fieldName, type) {
                var columns = variable.propertiesMap.columns,
                    column,
                    relatedCols,
                    relatedCol;
                if (_.includes(fieldName, '.')) {
                    column = _.find(columns, function (col) {
                        return col.fieldName === fieldName.split('.')[0];
                    });
                    relatedCols = column && column.columns;
                    relatedCol = _.find(relatedCols, function (col) {
                        return col.fieldName === fieldName.split('.')[1];
                    });
                    return relatedCol && relatedCol[type];
                }
                column = _.find(columns, function (col) {
                    return col.fieldName === fieldName;
                });
                return column && column[type];
            },
            /*Function to get the hibernateType of the specified field.*/
            getHibernateType = function (variable, fieldName) {
                return getHibernateOrSqlType(variable, fieldName, 'hibernateType');
            },
            /*Function to get the sqlType of the specified field.*/
            getSqlType = function (variable, fieldName) {
                return getHibernateOrSqlType(variable, fieldName, 'type');
            },
            /*Function to check if the specified field has a one-to-many relation or not.*/
            isRelatedFieldMany = function (variable, fieldName) {
                var columns = variable.propertiesMap.columns,
                    columnsCount = columns.length,
                    index,
                    column;
                /*Loop through the columns of the liveVariable*/
                for (index = 0; index < columnsCount; index += 1) {
                    column = columns[index];
                    /*If the specified field is found in the columns of the variable,
                    * then it has a many-to-one relation.*/
                    if (column.fieldName === fieldName) {
                        return false;
                    }
                }
                return true;
            },
            updateVariableDataset = function (variable, data, propertiesMap, pagingOptions) {
                variable.dataSet = {
                    "data": data,
                    "propertiesMap": propertiesMap,
                    "pagingOptions": pagingOptions
                };
            },
            setVariableProp = function (variable, writableVariable, propertyName, propertyValue) {
                variable[propertyName] = propertyValue;
                /*Check for sanity.
                * writableVariable will be null in case of partial page variables.*/
                if (writableVariable && !WM.equals(writableVariable[propertyName], propertyValue)) {
                    /*Set the "saveVariables" to true so that when "save"/"run" buttons are clicked, the variables could be saved into the file.*/
                    $rootScope.saveVariables = true;
                    writableVariable[propertyName] = propertyValue;
                    Variables.updateVariable(writableVariable.name, writableVariable);
                }
            },
        /*Function to fetch the meta data for the table.*/
            getTableMetaData = function (projectID, variable, writableVariable, options, callback, success) {
                var tableDetails = {};

                /*Fetch the type nodes(consisting of the table & column details) for the database*/
                DataModelDesignManager.getDataModel(projectID, variable.liveSource, false, function (database) {
                    var variableTable,
                        variableType,
                        tableNameToEntityNameMap = {},
                        entityNameToTableNameMap = {},
                        getJavaType = function (javaType) {
                            if (DB_CONSTANTS.DATABASE_SECONDARY_DATA_TYPES[javaType]) {
                                return DB_CONSTANTS.DATABASE_DATA_TYPES[DB_CONSTANTS.DATABASE_SECONDARY_DATA_TYPES[javaType].java_type].java_type;
                            }
                            return javaType;
                        };
                    WM.forEach(database.tables, function (table) {
                        tableNameToEntityNameMap[table.name] = table.entityName;
                        entityNameToTableNameMap[table.entityName] = table.name;
                    });
                    variableType = entityNameToTableNameMap[variable.type];

                    /*If the table that the variable associated with; no longer exists (i.e., it has been deleted or the name has been changed),
                    * add the variable name to the list of invalid variables and return.*/
                    if (!variableType) {
                        invalidVariables.push(variable.name);
                        return;
                    }

                    /*Loop through the tables*/
                    WM.forEach(database.tables, function (table) {

                        var tableName = table.name,
                            tablePackageName = database.packageName + "." + table.entityName,
                            primaryKeys = table.primaryKey.columns || [],
                            foreignKeys = [],
                            columnsAdded = [];

                        /*Add the "table-name" as a key to "tableDetails" and initialize "columnNames" and "relations".*/
                        tableDetails[tableName] = {};
                        tableDetails[tableName].columns = [];
                        tableDetails[tableName].primaryFields = [];
                        packageDetails[tablePackageName] = packageDetails[tablePackageName] || {};
                        packageDetails[tablePackageName].primaryFields = [];
                        /*Check if the current table is same as the table associated with the variable.*/
                        if (tableName === variableType) {
                            setVariableProp(variable, writableVariable, "package", tablePackageName);
                            setVariableProp(variable, writableVariable, "tableName", table.name);
                            setVariableProp(variable, writableVariable, "tableType", WM.isDefined(table.type) ? table.type : "TABLE");
                        }
                        /*Order the relations with priority as composite relations and one to one*/
                        table.relations = _.sortBy(table.relations, function (relation) {
                            return [relation.composite === false, relation.cardinality !== "OneToOne"];
                        });
                        /*Loop through the relations and insert the related columns*/
                        WM.forEach(table.relations, function (relation) {
                            if (relation.primary) {
                                var sourceCols = _.map(relation.mappings, function (mapping) {
                                        return mapping.sourceColumn;
                                    }),
                                    isPrimaryKey = _.intersection(sourceCols, primaryKeys).length > 0,
                                    newColumn,
                                    relatedCol,
                                    javaType;
                                /*Find out the foreign keys from the relations*/
                                foreignKeys = foreignKeys.concat(sourceCols);
                                /*Find the related column*/
                                relatedCol = _.find(table.columns, function (col) {
                                    return col.name === sourceCols[0];
                                });
                                javaType = getJavaType(relatedCol.javaType);
                                newColumn = {
                                    'fieldName'          : relation.fieldName,
                                    'type'               : javaType,
                                    'fullyQualifiedType' : javaType,
                                    'columnName'         : sourceCols.join(','),
                                    'isPrimaryKey'       : isPrimaryKey,
                                    'notNull'            : !relatedCol.nullable,
                                    'length'             : relatedCol.length,
                                    'precision'          : relatedCol.precision,
                                    'scale'              : relatedCol.scale,
                                    'generator'          : relatedCol.generator,
                                    'isRelated'          : true,
                                    'defaultValue'       : relatedCol.defaultValue,
                                    'targetTable'        : relation.targetTable
                                };
                                /*If the column is already part of other relation, add readonly flag so that the it is not shown in liveform*/
                                if (_.intersection(columnsAdded, sourceCols).length) {
                                    newColumn.readonly = true;
                                }
                                tableDetails[tableName].columns.push(newColumn);
                                columnsAdded = columnsAdded.concat(sourceCols);
                            }
                        });
                        /*Loop through the table*/
                        WM.forEach(table.columns, function (column) {
                            /*Columns names are present in primary keys. Map the respective field names*/
                            if (_.includes(table.primaryKey.columns, column.name)) {
                                tableDetails[tableName].primaryFields.push(column.fieldName);
                                packageDetails[tablePackageName].primaryFields.push(column.fieldName);
                            }
                            if (!_.includes(columnsAdded, column.name)) {
                                var javaType = getJavaType(column.javaType),
                                    isPrimaryKey = _.includes(primaryKeys, column.name),
                                    isForeignKey = _.includes(foreignKeys, column.name);
                                tableDetails[tableName].columns.push({
                                    "fieldName"         : column.fieldName,
                                    "type"              : javaType,
                                    "fullyQualifiedType": javaType,
                                    "columnName"        : column.name,
                                    "isPrimaryKey"      : isPrimaryKey,
                                    "notNull"           : !column.nullable,
                                    "length"            : column.length,
                                    "precision"         : column.precision,
                                    "scale"             : column.scale,
                                    "generator"         : column.generator,
                                    "isRelated"         : isForeignKey,
                                    "defaultValue"      : column.defaultValue
                                });
                            }
                        });

                        WM.forEach(table.relations, function (relation) {
                            var relatedColumns = [];
                            /*Find out the related columns for the relation*/
                            _.each(relation.mappings, function (mapping) {
                                if (relation.primary) {
                                    relatedColumns.push(mapping.sourceColumn);
                                }
                            });
                            /*Loop through the table's columns*/
                            WM.forEach(tableDetails[tableName].columns, function (column) {

                                var fkColumnName = column.columnName.split(',');
                                /*Check if the column is a foreign-key/related column and it is present in the "relatedColumns" of the current relation.*/
                                if (column.isRelated && _.isEqual(relatedColumns, fkColumnName)) {

                                    /*Check if the current table is same as the table associated with the variable.*/
                                    if (tableName === variableType) {
                                        setVariableProp(variable, writableVariable, "properties", (variable.properties || []));
                                        /*Add the related table name to the variable.properties attribute so that complete data for the table could be fetched.
                                         * Following are the cases handled.
                                         * 1. Add the related table name only if it has not been added already. This case might arise if there are multiple relations
                                         * from Table1 to Table2
                                         * 2. Do not add the related table name if it is same as the current table. This case might arise if there is a relation from TableX to TableX itself(i.e., self-reference).*/

                                        /*Reset the "columnName" to the "relatedType" so that the "relatedType" is used for Display & CRUD operations.*/
                                        /*column.columnName = column.fieldName;
                                        column.fieldName = tableNameToEntityNameMap[relation.relatedType];
                                        column.fieldName = column.fieldName.charAt(0).toLowerCase() + column.fieldName.slice(1);*/
                                        column.relatedTableName = relation.targetTable;
                                        column.relatedEntityName = tableNameToEntityNameMap[relation.targetTable];
                                        if ((WM.element.inArray(relation.fieldName, variable.properties) === -1)) {
                                            variable.properties.push(relation.fieldName);
                                            setVariableProp(variable, writableVariable, "relatedTables", (variable.relatedTables || []));
                                            variable.relatedTables.push({
                                                "columnName": column.fieldName,
                                                "relationName": relation.fieldName,
                                                "type": tableNameToEntityNameMap[relation.targetTable],
                                                "package": tablePackageName,
                                                "watchOn": Utils.initCaps(variable.liveSource) + tableNameToEntityNameMap[relation.targetTable] + "Data"
                                            });
                                        }
                                    }
                                }
                            });
                        });
                    });

                    tableDetails[variableType].entityName = variable.type;
                    tableDetails[variableType].fullyQualifiedName = variable.package;
                    tableDetails[variableType].tableType = variable.tableType;
                    variableTable = tableDetails[variableType];

                    /*Iterate through the columns of the table associated with the variable and fetch all the columns of the related tables.*/
                    WM.forEach(variableTable.columns, function (column) {
                        var columnDef;
                        /*Fetch all the columns of the related table and set them as columns in the related column.*/
                        if (column.isRelated) {
                            /*Since "columns" may contain a reference to itself, "copy" is being used.
                            * This is done because there is a "copy" done in Variables.store.*/
                            column.columns = Utils.getClonedObject(tableDetails[column.relatedTableName].columns);
                            column.relatedFieldName = column.fieldName + "." + tableDetails[column.relatedTableName].primaryFields[0];
                            if ($rootScope.dataTypes[variable.package]) {
                                columnDef = $rootScope.dataTypes[variable.package].fields[column.fieldName];
                                column.isList = columnDef && columnDef.isList;
                            }
                        }
                    });

                    setVariableProp(variable, writableVariable, "propertiesMap", tableDetails[variableType]);

                    Utils.triggerFn(callback, projectID, variable, options, success);
                }, WM.noop);
            },
        /*Function to prepare the options required to read data from the table.*/
            prepareTableOptions = function (variable, options) {
                var filterFields = [],
                    filterOptions = [],
                    orderByFields,
                    orderByOptions = '',
                    getFieldType = function (options) {
                        return options.type || getSqlType(variable, options.fieldName) || 'integer';
                    },
                    getAttributeName = function (fieldName) {
                        var attrName = fieldName;
                        variable.propertiesMap.columns.forEach(function (column) {
                            if (column.fieldName === fieldName && column.isRelated) {
                                attrName = column.relatedFieldName;
                            }
                        });
                        return attrName;
                    },
                    getFilterCondition = function (filterCondition) {
                        if (_.includes(DB_CONSTANTS.DATABASE_RANGE_MATCH_MODES, filterCondition)) {
                            return filterCondition;
                        }
                        return DB_CONSTANTS.DATABASE_MATCH_MODES['exact'];
                    };
                /*get the filter fields from the variable*/
                _.each(variable.filterFields, function (value, key) {
                    value.fieldName = key;
                    if (getFieldType(value) === 'string') {
                        value.filterCondition = DB_CONSTANTS.DATABASE_MATCH_MODES[variable.matchMode];
                    }
                    filterFields.push(value);
                });
                /*get the filter fields from the options*/
                _.each(options.filterFields, function (value, key) {
                    value.fieldName = key;
                    value.filterCondition = DB_CONSTANTS.DATABASE_MATCH_MODES[value.matchMode || options.matchMode];
                    filterFields.push(value);
                });
                if (variable.operation === 'read') {
                    _.each(filterFields, function (fieldOptions) {
                        var attributeName,
                            fieldName       = fieldOptions.fieldName,
                            fieldValue      = fieldOptions.value,
                            fieldType       = getFieldType(fieldOptions),
                            filterCondition = fieldOptions.filterCondition;
                        /* if the field value is an object(complex type), loop over each field inside and push only first level fields */
                        if (WM.isObject(fieldValue) && !WM.isArray(fieldValue)) {
                            WM.forEach(fieldValue, function (subFieldValue, subFieldName) {
                                if (subFieldValue && !WM.isObject(subFieldValue)) {
                                    filterOptions.push(fieldName + '.' + subFieldName + '=' + subFieldValue);
                                }
                            });
                        } else if (WM.isDefined(fieldValue) && fieldValue !== null && fieldValue !== '') {
                            /*Based on the sqlType of the field, format the value & set the filter condition.*/
                            switch (fieldType) {
                            case 'integer':
                                fieldValue = WM.isArray(fieldValue) ? _.map(fieldValue, function (value) {
                                    return parseInt(value, 10);
                                }) : parseInt(fieldValue, 10);
                                filterCondition = getFilterCondition(filterCondition);
                                break;
                            case 'big_decimal':
                            case 'big_integer':
                            case 'character':
                            case 'double':
                            case 'float':
                            case 'boolean':
                            case 'short':
                            case 'byte':
                            case 'time':
                                filterCondition = getFilterCondition(filterCondition);
                                break;
                            case 'date':
                            case 'datetime':
                                fieldValue      = getDateInDefaultFormat(fieldValue, fieldType);
                                filterCondition = getFilterCondition(filterCondition);
                                break;
                            case 'timestamp':
                                fieldValue = WM.isArray(fieldValue) ? _.map(fieldValue, function (value) {
                                    return moment(value).valueOf();
                                }) : moment(fieldValue).valueOf();
                                filterCondition = getFilterCondition(filterCondition);
                                break;
                            case 'string':
                                if (WM.isArray(fieldValue)) {
                                    filterCondition = DB_CONSTANTS.DATABASE_MATCH_MODES['exact'];
                                } else {
                                    filterCondition = filterCondition || DB_CONSTANTS.DATABASE_MATCH_MODES['anywhere'];
                                }
                                break;
                            default:
                                break;
                            }
                            attributeName = getAttributeName(fieldName);
                            filterOptions.push({
                                'attributeName'   : attributeName,
                                'attributeValue'  : fieldValue,
                                'attributeType'   : fieldType.toUpperCase(),
                                'filterCondition' : filterCondition
                            });
                        } else if (_.includes(DB_CONSTANTS.DATABASE_EMPTY_MATCH_MODES, filterCondition)) {
                            attributeName = getAttributeName(fieldName);
                            if (fieldType !== 'string') {
                                filterCondition = DB_CONSTANTS.DATABASE_MATCH_MODES['null'];
                            }
                            filterOptions.push({
                                'attributeName'   : attributeName,
                                'attributeValue'  : '',
                                'attributeType'   : fieldType.toUpperCase(),
                                'filterCondition' : filterCondition
                            });
                        }
                    });
                }

                orderByFields = (!options.orderBy || WM.element.isEmptyObject(options.orderBy)) ? variable.orderBy : options.orderBy;
                orderByOptions = orderByFields ? 'sort=' + orderByFields : '';

                return {
                    'filter': filterOptions,
                    'sort': orderByOptions
                };
            },
        /*Function to initiate the callback and obtain the data for the callback variable.*/
            initiateCallback = Variables.initiateCallback,
            processRequestQueue = Variables.processRequestQueue,
        /*Function to fetch the data for the primary table.*/
            getPrimaryTableData = function (projectID, variable, options, success, error) {

                var tableOptions,
                    dbOperation,
                    callBackScope,
                    variableOwner = variable.owner,
                    promiseObj,
                    preventCall,
                    newDataSet,
                    dataObj = {},
                    handleError = function (response) {
                        /* If in Run mode, initiate error callback for the variable */
                        if (CONSTANTS.isRunMode) {
                            // EVENT: ON_RESULT
                            initiateCallback(VARIABLE_CONSTANTS.EVENT.RESULT, variable, callBackScope, response);
                            // EVENT: ON_ERROR
                            initiateCallback(VARIABLE_CONSTANTS.EVENT.ERROR, variable, callBackScope, response);
                            // EVENT: ON_CAN_UPDATE
                            variable.canUpdate = true;
                            initiateCallback(VARIABLE_CONSTANTS.EVENT.CAN_UPDATE, variable, callBackScope, response);
                        }

                        /* update the dataSet against the variable */
                        updateVariableDataset(variable, [], variable.propertiesMap);

                        /* If callback function is provided, send the data to the callback.
                         * The same callback if triggered in case of error also. The error-handling is done in grid.js*/
                        Utils.triggerFn(error, response);

                        /* process next requests in the queue */
                        if (CONSTANTS.isRunMode) {
                            variableActive[variable.activeScope.$id][variable.name] = false;
                            processRequestQueue(variable, requestQueue[variable.activeScope.$id], deployProjectAndFetchData);
                        }
                    };

                if (CONSTANTS.isRunMode) {
                    // EVENT: ON_BEFORE_UPDATE
                    preventCall = initiateCallback(VARIABLE_CONSTANTS.EVENT.BEFORE_UPDATE, variable, callBackScope, variable.filterFields);
                    if (preventCall === false) {
                        variableActive[variable.activeScope.$id][variable.name] = false;
                        processRequestQueue(variable, requestQueue[variable.activeScope.$id], deployProjectAndFetchData);
                        $rootScope.$emit('toggle-variable-state', variable.name, false);
                        return;
                    }
                    variable.canUpdate = false;
                }

                tableOptions = prepareTableOptions(variable, options);

                dbOperation = (tableOptions.filter && tableOptions.filter.length) ? "searchTableData" : "readTableData";
                /* if it is a prefab variable (used in a normal project), modify the url */
                /*Fetch the table data*/
                promiseObj = DatabaseService[dbOperation]({
                    "projectID": projectID,
                    "service": variable.prefabName ? "" : "services",
                    "dataModelName": variable.liveSource,
                    "entityName": variable.type,
                    "page": options.page || 1,
                    "size": options.pagesize || (CONSTANTS.isRunMode ? (variable.maxResults || 20) : (variable.designMaxResults || 20)),
                    "sort": tableOptions.sort,
                    "data": tableOptions.filter,
                    "url": variable.prefabName ? ($rootScope.project.deployedUrl + "/prefabs/" + variable.prefabName) : $rootScope.project.deployedUrl
                }, function (response) {

                    if ((response && response.error) || !response || !WM.isArray(response.content)) {
                        Utils.triggerFn(handleError, response.error);
                        return;
                    }

                    processResponse(response.content);

                    dataObj.data = response.content;
                    dataObj.pagingOptions = {"dataSize": response ? response.totalElements : null, "maxResults": variable.maxResults};

                    if (!options.skipDataSetUpdate) {
                        /* get the callback scope for the variable based on its owner */
                        if (variableOwner === "App") {
                            /* TODO: to look for a better option to get App/Page the controller's scope */
                            callBackScope = $rootScope || {};
                        } else {
                            if (variable.prefabName) {
                                callBackScope = options.scope || {};
                            } else {
                                callBackScope = (options.scope && options.scope.$$childTail) ? options.scope.$$childTail : {};
                            }
                        }

                        if (CONSTANTS.isRunMode) {
                            // EVENT: ON_RESULT
                            initiateCallback(VARIABLE_CONSTANTS.EVENT.RESULT, variable, callBackScope, dataObj.data);
                            // EVENT: ON_SUCCESS
                            initiateCallback(VARIABLE_CONSTANTS.EVENT.SUCCESS, variable, callBackScope, dataObj.data);
                            // EVENT: ON_PREPARESETDATA
                            newDataSet = initiateCallback(VARIABLE_CONSTANTS.EVENT.PREPARE_SETDATA, variable, callBackScope, dataObj.data);
                            if (newDataSet) {
                                //setting newDataSet as the response to service variable onPrepareSetData
                                dataObj.data = newDataSet;
                            }
                            // EVENT: ON_CAN_UPDATE
                            variable.canUpdate = true;
                            initiateCallback(VARIABLE_CONSTANTS.EVENT.CAN_UPDATE, variable, callBackScope, dataObj.data);
                        }
                        /* update the dataSet against the variable */
                        updateVariableDataset(variable, dataObj.data, variable.propertiesMap, dataObj.pagingOptions);
                    }
                    /* if callback function is provided, send the data to the callback */
                    Utils.triggerFn(success, dataObj.data, variable.propertiesMap, dataObj.pagingOptions);

                    /* process next requests in the queue */
                    if (CONSTANTS.isRunMode) {
                        variableActive[variable.activeScope.$id][variable.name] = false;
                        processRequestQueue(variable, requestQueue[variable.activeScope.$id], deployProjectAndFetchData);
                    }
                }, function (error) {
                    Utils.triggerFn(handleError, error);
                });

                if (CONSTANTS.isRunMode) {
                    variable.promise = promiseObj;
                }
            },
        /*Function to fetch the data for the variable (i.e., primary & related tables data)*/
            getTableData = function (projectID, variable, options, success, error) {
                var variableIndex = WM.element.inArray(variable.name, invalidVariables);
                /*If the variable is present in the list of invalid variables,
                * then do not process it. Simply remove it from the list of invalid variables.*/
                if (variableIndex === -1) {
                    /*Get the data of the primary table*/
                    getPrimaryTableData(projectID, variable, options, success, error);
                } else {
                    invalidVariables.splice(variableIndex, 1);
                }
            },
        /*Function to get variable data from backend service*/
            getDataFromService = function (variable, options, success, error) {
                var projectID = $rootScope.project.id || $rootScope.projectName;

                /* send data calls only for read type live-variables */
                if (variable.operation === 'read') {
                    getTableData(projectID, variable, options, success, error);
                }
            },
        /*Function to deploy the project and then fetch the required data.*/
            deployProjectAndFetchData = function (variable, options, success, error) {
                /*If the project has been deployed at least once OR in run mode, directly call the getDataFromService..
                 * Else, deploy the project before getDataFromService*/
                if (isProjectDeployed) {
                    getDataFromService(variable, options, success, error);
                    return;
                }

                /*If the project deploy is not in progress, invoke the function to deploy it.
                 * Also set the "isProjectDeployInProgress" flag to true.*/
                if (!isProjectDeployInProgress) {
                    isProjectDeployInProgress = true;
                    ProjectService.run({
                        projectId: $rootScope.project.id
                    }, function (result) {
                        /*Save the deployed url of the project in the $rootScope so that it could be used in all calls to services of deployed app*/
                        $rootScope.project.deployedUrl = Utils.removeProtocol(result);

                        /*Check if the project deploy request queue is non-empty.
                        * In that case, process the queue.
                        * Else, simply trigger the callbacks.*/
                        if (projectDeployReqQueue) {
                            /*Set the appropriate flags*/
                            isProjectDeployed = false;
                            isProjectDeployInProgress = false;
                            deployProjectAndFetchData(projectDeployReqQueue.variable, projectDeployReqQueue.options, projectDeployReqQueue.success, projectDeployReqQueue.error);
                            callbackParams.push({
                                "variable": variable,
                                "options": options,
                                "success": success,
                                "error": error
                            });
                            projectDeployReqQueue = undefined;
                        } else {
                            /*Invoke the function to get the data for the variable*/
                            getDataFromService(variable, options, success, error);
                            /*Set the appropriate flags*/
                            isProjectDeployed = true;
                            isProjectDeployInProgress = false;
                            /*Check for sanity*/
                            if (callbackParams.length) {
                                /*Iterate through the "callbackParams" and invoke "getData" for each of them.*/
                                WM.forEach(callbackParams, function (callbackParam) {
                                    deployProjectAndFetchData(callbackParam.variable, callbackParam.options, callbackParam.success, callbackParam.error);
                                });
                                /*Reset the array*/
                                callbackParams = [];
                            }
                            return true;
                        }
                    }, function (error) {
                        wmToaster.show("error", $rootScope.locale["MESSAGE_ERROR_TITLE"], $rootScope.locale["MESSAGE_INFO_DATABASE_DATA_LOADING_FAILED"] + " : " + error);
                        /*In case the project deploy fails, set the "isProjectDeployInProgress" flag to false so that the next time "getData" is invoked,
                        the project could be deployed.*/
                        isProjectDeployInProgress = false;

                        /*Update the variable with empty data so that the widgets reflect the same.*/
                        updateVariableDataset(variable, {'error': true, 'errorMessage': $rootScope.locale["MESSAGE_INFO_DATABASE_DATA_LOADING_FAILED"]}, variable.propertiesMap, {});
                        /*Check for sanity*/
                        if (callbackParams.length) {
                            /*Iterate through the "callbackParams" and set empty data for each of them.*/
                            WM.forEach(callbackParams, function (callbackParam) {
                                /*Update the variable with empty data so that the widgets reflect the same.*/
                                updateVariableDataset(callbackParam.variable, {'error': true, 'errorMessage': $rootScope.locale["MESSAGE_INFO_DATABASE_DATA_LOADING_FAILED"]}, callbackParam.variable.propertiesMap, {});
                            });
                            /*Reset the array*/
                            callbackParams = [];
                        }
                    });
                } else if (isDeployReqSourceChanged && !projectDeployReqQueue) { /*Check if the deploy request source has changed and the deploy request queue is empty.*/
                    projectDeployReqQueue = {
                        "variable": variable,
                        "options": options,
                        "success": success,
                        "error": error
                    };
                    isDeployReqSourceChanged = undefined;
                } else { /*Project deploy is in progress and deploy request queue is not empty.. So just add the successive parameters to "getData" to an array - "callbackParams".*/
                    callbackParams.push({
                        "variable": variable,
                        "options": options,
                        "success": success,
                        "error": error
                    });
                }
            },
        /* Function to check if specified field is of type date*/
            getFieldType = function (fieldName, variable) {
                var fieldType,
                    columns,
                    result;
                if (variable.propertiesMap) {
                    columns = variable.propertiesMap.columns || [];
                    result = _.find(columns, function (obj) {
                        return obj.fieldName === fieldName;
                    });
                    fieldType = result && result.type;
                }
                return fieldType;
            },
        /*Function to perform common database actions through calling DatabaseService methods*/
            performDataAction = function (action, variableDetails, options, success, error) {
                var dbName,
                    compositeId = "",
                    projectID = $rootScope.project.id || $rootScope.projectName,
                    rowObject = {},
                    prevData,
                    callBackScope,
                    promiseObj,
                    primaryKey = variableDetails.getPrimaryKey(),
                    compositeKeysData = {},
                    prevCompositeKeysData = {},
                    id,
                    columnName;
                /* evaluate the callback scope */
                /* get the callback scope for the variable based on its owner */
                if (variableDetails.owner === "App") {
                    /* TODO: to look for a better option to get App/Page the controller's scope */
                    callBackScope = $rootScope || {};
                } else {
                    callBackScope = (options.scope && options.scope.$$childTail) ? options.scope.$$childTail : {};
                }

                // EVENT: ON _BEFORE_UPDATE
                if (CONSTANTS.isRunMode) {
                    var preventCall = initiateCallback(VARIABLE_CONSTANTS.EVENT.BEFORE_UPDATE, variableDetails, callBackScope, variableDetails.inputFields);
                    if (preventCall === false) {
                        variableActive[variableDetails.activeScope.$id][variableDetails.name] = false;
                        processRequestQueue(variableDetails, requestQueue[variableDetails.activeScope.$id], deployProjectAndFetchData);
                        $rootScope.$emit('toggle-variable-state', variableDetails.name, false);
                        return;
                    }
                    variableDetails.canUpdate = false;
                }

                if (options.row) {
                    rowObject = options.row;
                } else {
                    WM.forEach(variableDetails.inputFields, function (fieldValue, fieldName) {
                        var fieldType,
                            primaryKeys = variableDetails.propertiesMap.primaryFields || variableDetails.propertiesMap.primaryKeys;
                        if (WM.isDefined(fieldValue) && fieldValue !== "") {
                            /*For delete action, the inputFields need to be set in the request URL. Hence compositeId is set.
                             * For insert action inputFields need to be set in the request data. Hence rowObject is set.
                             * For update action, both need to be set.*/
                            if (action === "deleteTableData") {
                                compositeId = fieldValue;
                            }
                            if (action === "updateTableData") {
                                primaryKeys.forEach(function (key) {
                                    if (fieldName === key) {
                                        compositeId = fieldValue;
                                    }
                                });
                            }
                            if (action !== "deleteTableData" || variableDetails.isCompositeKey(primaryKey)) {
                                fieldType = getFieldType(fieldName, variableDetails);
                                if (isDateTime[fieldType] && fieldType !== 'timestamp') {
                                    fieldValue = getDateInDefaultFormat(fieldValue, fieldType);
                                }
                                rowObject[fieldName] = fieldValue;
                            }
                        }
                    });
                }

                switch (action) {
                case 'updateTableData':
                case 'updateMultiPartTableData':
                    prevData = options.prevData || {};
                    /*Construct the "requestData" based on whether the table associated with the live-variable has a composite key or not.*/
                    if (variableDetails.isCompositeKey(primaryKey)) {
                        if (variableDetails.isNoPrimaryKey(primaryKey)) {
                            prevCompositeKeysData = prevData || options.rowData || rowObject;
                            compositeKeysData = rowObject;
                        } else {
                            primaryKey.forEach(function (key) {
                                compositeKeysData[key] = rowObject[key];
                                prevCompositeKeysData[key] = prevData[key] || (options.rowData && options.rowData[key]) || rowObject[key];
                            });
                        }
                        options.row = compositeKeysData;
                        options.compositeKeysData = prevCompositeKeysData;
                    } else {
                        primaryKey.forEach(function (key) {
                            if (key.indexOf(".") === -1) {
                                id = prevData[key] || (options.rowData && options.rowData[key]) || rowObject[key];
                            } else {
                                columnName = key.split(".");
                                id = prevData[columnName[0]][columnName[1]];
                            }
                        });
                        options.id = id;
                        options.row = rowObject;
                    }

                    break;
                case 'deleteTableData':
                    /*Construct the "requestData" based on whether the table associated with the live-variable has a composite key or not.*/
                    if (variableDetails.isCompositeKey(primaryKey)) {
                        if (variableDetails.isNoPrimaryKey(primaryKey)) {
                            compositeKeysData = rowObject;
                        } else {
                            primaryKey.forEach(function (key) {
                                compositeKeysData[key] = rowObject[key];
                            });
                        }
                        options.compositeKeysData = compositeKeysData;
                    } else if (!WM.element.isEmptyObject(rowObject)) {
                        primaryKey.forEach(function (key) {
                            if (key.indexOf(".") === -1) {
                                id = rowObject[key];
                            } else {
                                columnName = key.split(".");
                                id = rowObject[columnName[0]][columnName[1]];
                            }
                        });
                        options.id = id;
                    }
                    break;
                default:
                    break;
                }

                /*Check if "options" have the "compositeKeysData" property.*/
                if (options.compositeKeysData) {
                    switch (action) {
                    case "updateTableData":
                        action = "updateCompositeTableData";
                        break;
                    case "deleteTableData":
                        action = "deleteCompositeTableData";
                        break;
                    default:
                        break;
                    }
                    compositeId = '';
                    /* Loop over the "compositeKeysData" and construct the "compositeId".*/
                    WM.forEach(options.compositeKeysData, function (paramValue, paramName) {
                        compositeId += paramName + "=" + encodeURIComponent(paramValue) + "&";
                    });
                    compositeId = compositeId.slice(0, -1);
                }
                dbName = variableDetails.liveSource;

                /*Set the "data" in the request to "undefined" if there is no data.
                * This handles cases such as "Delete" requests where data should not be passed.*/
                if (WM.element.isEmptyObject(rowObject) && action === "deleteTableData") {
                    rowObject = undefined;
                }

                promiseObj = DatabaseService[action]({
                    "projectID": projectID,
                    "service": variableDetails.prefabName ? "" : "services",
                    "dataModelName": dbName,
                    "entityName": variableDetails.type,
                    "id": WM.isDefined(options.id) ? encodeURIComponent(options.id) : compositeId,
                    "data": rowObject,
                    "url": variableDetails.prefabName ? ($rootScope.project.deployedUrl + "/prefabs/" + variableDetails.prefabName) : $rootScope.project.deployedUrl
                }, function (response) {
                    /* if error received on making call, call error callback */
                    if (response && response.error) {
                        /* If in RUN mode trigger error events associated with the variable */
                        if (CONSTANTS.isRunMode) {
                            // EVENT: ON_RESULT
                            initiateCallback(VARIABLE_CONSTANTS.EVENT.RESULT, variableDetails, callBackScope, response);
                            // EVENT: ON_ERROR
                            initiateCallback(VARIABLE_CONSTANTS.EVENT.ERROR, variableDetails, callBackScope, response.error);
                            // EVENT: ON_CAN_UPDATE
                            variableDetails.canUpdate = true;
                            initiateCallback(VARIABLE_CONSTANTS.EVENT.CAN_UPDATE, variableDetails, callBackScope, response.error);
                        }
                        /* trigger error callback */
                        Utils.triggerFn(error, response.error);
                    } else {
                        if (CONSTANTS.isRunMode) {
                            // EVENT: ON_RESULT
                            initiateCallback(VARIABLE_CONSTANTS.EVENT.RESULT, variableDetails, callBackScope, response);
                            // EVENT: ON_SUCCESS
                            initiateCallback(VARIABLE_CONSTANTS.EVENT.SUCCESS, variableDetails, callBackScope, response);
                            // EVENT: ON_CAN_UPDATE
                            variableDetails.canUpdate = true;
                            initiateCallback(VARIABLE_CONSTANTS.EVENT.CAN_UPDATE, variableDetails, callBackScope, response);
                        }
                        Utils.triggerFn(success, response);
                    }
                }, function (response) {
                    /* If in RUN mode trigger error events associated with the variable */
                    if (CONSTANTS.isRunMode) {
                        // EVENT: ON_RESULT
                        initiateCallback(VARIABLE_CONSTANTS.EVENT.RESULT, variableDetails, callBackScope, response);
                        // EVENT: ON_ERROR
                        initiateCallback(VARIABLE_CONSTANTS.EVENT.ERROR, variableDetails, callBackScope, response);
                        // EVENT: ON_CAN_UPDATE
                        variableDetails.canUpdate = true;
                        initiateCallback(VARIABLE_CONSTANTS.EVENT.CAN_UPDATE, variableDetails, callBackScope, response);
                    }
                    Utils.triggerFn(error, response);
                });

                if (CONSTANTS.isRunMode) {
                    variableDetails.promise = promiseObj;
                }
            },
        /* properties of a basic variable - should contain methods applicable on this particular object */
            methods = {
                /*Function to get the primary key of the specified variable.*/
                getPrimaryKey: function (variable) {
                    if (variable.propertiesMap.primaryFields) {
                        return variable.propertiesMap.primaryFields;
                    }
                    /*Old projects do not have primary fields. Get primary key from the columns*/
                    var primaryKey = [];
                    /*Loop through the propertiesMap and get the primary key column.*/
                    WM.element.each(variable.propertiesMap.columns, function (index, column) {
                        if (column.isPrimaryKey) {
                            if (column.isRelated && (WM.element.inArray(column.relatedFieldName, primaryKey) === -1)) {
                                primaryKey.push(column.relatedFieldName);
                            } else if (WM.element.inArray(column.fieldName, primaryKey) === -1) {
                                primaryKey.push(column.fieldName);
                            }
                        }
                    });
                    return primaryKey;
                },
                isCompositeKey: function (variable, primaryKey) {
                    return !primaryKey || (primaryKey && (!primaryKey.length || primaryKey.length > 1));
                },
                /*Function to check whether the table associated with the live-variable bound to the live-form has a primary key or not.*/
                isNoPrimaryKey: function (variable, primaryKey) {
                    return (!primaryKey || (primaryKey && !primaryKey.length));
                },
                /*function to get the data associated with the live variable*/
                getData: function (variable, options, success, error) {
                    var variableName = variable.name,
                        writableVariable,
                        projectID = $rootScope.project.id || $rootScope.projectName;
                    function execute() {
                        /* put the variable name into the variable object */
                        variable.name = variableName;

                        if (CONSTANTS.isRunMode) {
                            variableActive[variable.activeScope.$id] = variableActive[variable.activeScope.$id] || {};
                            if (variableActive[variable.activeScope.$id][variableName]) {
                                requestQueue[variable.activeScope.$id] = requestQueue[variable.activeScope.$id] || {};
                                requestQueue[variable.activeScope.$id][variableName] = requestQueue[variable.activeScope.$id][variableName] || [];
                                requestQueue[variable.activeScope.$id][variableName].push({variable: variable, options: options, success: success, error: error});
                                return;
                            }
                            variableActive[variable.activeScope.$id][variableName] = true;
                        }


                        /*In the "Studio" mode, the entity meta data is read, the properties are updated in the variable;
                         * so that the variables.json file is updated on "save".
                         * 1. In the "Run"/"Application" mode, all the properties are fetched from the variable read from the file itself
                         * (as "getDataModel" call would not work in the "Application" mode).
                         * 2. In case of variables inside imported prefabs, "getDataModel" call would not work
                         * because the data-model would not be present in the project services directly.*/
                        if (!CONSTANTS.isRunMode && !variable.prefabName) {
                            /* get studio copy of variable*/
                            writableVariable = Variables.getVariableByName(variable.name);
                            getTableMetaData(projectID, variable, writableVariable, options, function () {
                                /*For variables of all operations, update the dataSet with the "propertiesMap" only.*/
                                updateVariableDataset(variable, {}, variable.propertiesMap, {});
                                /* if callback function is provided, send the data to the callback */
                                Utils.triggerFn(success, [], variable.propertiesMap, {}, {"dataSize": null, "maxResults": variable.maxResults});
                            });
                        }
                        /*In the Run mode, for variables of insert/update/delete type operation, update the dataSet with the "propertiesMap" only.*/
                        if (CONSTANTS.isRunMode && variable.operation !== 'read') {
                            /* update the dataSet against the variable */
                            updateVariableDataset(variable, {}, variable.propertiesMap, {});
                        }

                        /* Do not make calls to fetch data in case 'skipFetchData' is true, This flag is true when the variable is created for the first time */
                        if (!options.skipFetchData) {
                            deployProjectAndFetchData(variable, options, success, error);
                        }
                    }
                    /*Check for sanity of the "variable".
                     * Studio Mode: Also, invoke the service to get the data of the variable only if the "liveSource" still exists in the project's databases.
                     * If the database has been deleted from the project, then prevent sending of the request.
                     * Run Mode: Invoke the service to get the variable data.*/
                    if (!Utils.isEmptyObject(variable) && (CONSTANTS.isRunMode || variable.prefabName)) {
                        execute();
                    } else if (CONSTANTS.isStudioMode && !Utils.isEmptyObject(variable)) {
                        ServiceFactory.getServicesWithType(function (services) {
                            /*Checking for existence of variable's live source in databases available*/
                            if (_.find(services, {'name': variable.liveSource, 'type' : "DataService"})) {
                                execute();
                            }
                        });
                    }
                },
            /*Function to update the data associated with the related tables of the live variable*/
                updateRelatedData: function (variable, options, success, error) {
                    var projectID = $rootScope.project.id || $rootScope.projectName;

                    /*tableOptions = prepareTableOptions(variable, options);*/

                    /*Return if "relatedFieldName" is not passed in the options OR
                    if the relatedField is a one-to-many relation because this field value will directly be available in the data.
                    Call needs to be made only if a relatedField is a many-to-one relation.*/
                    if (!options.relatedFieldName || !isRelatedFieldMany(variable, options.relatedFieldName)) {
                        return;
                    }

                    /* if it is a prefab variable (used in a normal project), modify the url */
                    /*Fetch the table data*/
                    DatabaseService.readTableRelatedData({
                        "projectID": projectID,
                        "service": variable.prefabName ? "" : "services",
                        "dataModelName": variable.liveSource,
                        "entityName": variable.type,
                        "id": options.id,
                        "relatedFieldName": options.relatedFieldName,
                        "page": options.page || 1,
                        "size": CONSTANTS.isRunMode ? (variable.maxResults || 20) : (variable.designMaxResults || 20),
                        /*"sort": tableOptions.sort,
                        "data": tableOptions.filter,*/
                        "url": variable.prefabName ? ($rootScope.project.deployedUrl + "/prefabs/" + variable.prefabName) : $rootScope.project.deployedUrl
                    }, function (response) {

                        if ((response && response.error) || !response || !WM.isArray(response.content)) {
                            Utils.triggerFn(error, response.error);
                            return;
                        }

                        /*If the table has a composite key, key data will be wrapped in an object with the key "id".
                         * Hence, the data is formatted to remove the extra key and merge it into the content.*/
                        response.content.forEach(function (rowData) {
                            var tempData;
                            /*Check if the value corresponding to the key "id" is an object.*/
                            if (rowData && WM.isObject(rowData.id)) {
                                tempData = rowData.id;
                                delete rowData.id;
                                WM.extend(rowData, tempData);
                            }
                        });

                        /* if callback function is provided, send the data to the callback */
                        Utils.triggerFn(success, response.content, undefined, {}, {"dataSize": response ? response.totalElements : null, "maxResults": variable.maxResults});

                    }, function (error) {
                        Utils.triggerFn(error, error);
                    });
                },
            /*function to delete a row in the data associated with the live variable*/
                deleteRecord: function (variable, options, success, error) {
                    performDataAction('deleteTableData', variable, options, success, error);
                },
            /*function to update a row in the data associated with the live variable*/
                updateRecord: function (variable, options, success, error) {
                    if (options.multipartData) {
                        performDataAction('updateMultiPartTableData', variable, options, success, error);
                    } else {
                        performDataAction('updateTableData', variable, options, success, error);
                    }
                },
            /*function to insert a row into the data associated with the live variable*/
                insertRecord: function (variable, options, success, error) {
                    if (options.multipartData) {
                        performDataAction('insertMultiPartTableData', variable, options, success, error);
                    } else {
                        performDataAction('insertTableData', variable, options, success, error);
                    }
                },
            /*function to set the orderBy property of the live variable*/
                setOrderBy: function (variable, expression) {
                    variable.orderBy = expression;

                    /* update the variable if autoUpdate flag is set */
                    if (variable.autoUpdate) {
                        variable.update();
                    }

                    return variable.orderBy;
                },
                getDataSet: function (variable) {
                    /* return the variable dataSet*/
                    return variable.dataSet;
                },
                clearData: function (variable) {
                    variable.dataSet = {};

                    /* return the variable dataSet*/
                    return variable.dataSet;
                },
                cancel: function (variable) {
                    /* process only if current variable is actually active */
                    if (variableActive[variable.activeScope.$id][variable.name] && variable.promise) {
                        variable.promise.abort();
                    }
                },
                setInput: function (variable, key, val) {
                    var paramObj = {},
                        targetObj = {};
                    if (WM.isObject(key)) {
                        paramObj = key;
                    } else {
                        paramObj[key] = val;
                    }

                    if (!variable.inputFields) {
                        variable.inputFields = {};
                    }
                    targetObj = variable.inputFields;

                    WM.forEach(paramObj, function (paramVal, paramKey) {
                        targetObj[paramKey] = paramVal;
                    });

                    return targetObj;
                },
                setFilter: function (variable, key, val) {
                    var paramObj = {},
                        targetObj = {};
                    if (WM.isObject(key)) {
                        paramObj = key;
                    } else {
                        paramObj[key] = val;
                    }

                    if (!variable.filterFields) {
                        variable.filterFields = {};
                    }
                    targetObj = variable.filterFields;

                    WM.forEach(paramObj, function (paramVal, paramKey) {
                        targetObj[paramKey] = {
                            "value": paramVal
                        };
                    });

                    return targetObj;
                },
                getModifiedFieldName: function (variable, fieldName) {
                    var primaryKey = variable.getPrimaryKey(),
                        modifiedFieldName = fieldName;
                    if (variable.isCompositeKey(primaryKey) && (variable.isNoPrimaryKey(primaryKey) || primaryKey.indexOf(fieldName) !== -1)) {
                        modifiedFieldName = 'id.' + fieldName;
                    }
                    return modifiedFieldName;
                },
                getRelatedTableData: function (variable, columnName, options, success, error) {
                    var projectID = $rootScope.project.id || $rootScope.projectName,
                        resultProperties = {
                            "firstResult": 0,
                            "maxResults": options.maxResults || 100
                        },
                        relatedTable = _.find(variable.relatedTables, function (table) {
                            /*Comparing column name to support the old projects*/
                            return table.relationName === columnName || table.columnName === columnName;
                        });
                    /* if orderBy properties is set, append it to the resultProperties */
                    if (variable.orderBy) {
                        resultProperties.orderBy = variable.orderBy.split(',');
                    }
                    DatabaseService.readTableData({
                        "projectID": projectID,
                        "service": variable.prefabName ? "" : "services",
                        "dataModelName": variable.liveSource,
                        "entityName": relatedTable.type,
                        "page": 1,
                        "size": resultProperties.maxResults,
                        "url": variable.prefabName ? ($rootScope.project.deployedUrl + "/prefabs/" + variable.prefabName) : $rootScope.project.deployedUrl
                    }, function (response) {
                        Utils.triggerFn(success, response.content);
                    }, function (errMsg) {
                        Utils.triggerFn(error, errMsg);
                    });
                },
                getRelatedTablePrimaryKeys: function (variable, columnName, options) {
                    var relatedVariable,
                        relatedTable,
                        primaryKeys;
                    options = options || {};
                    options.scope = options.scope || $rootScope;
                    relatedTable = _.find(variable.relatedTables, function (table) {
                        /*Comparing column name to support the old projects*/
                        return table.relationName === columnName || table.columnName === columnName;
                    });
                    relatedVariable = relatedTable && options.scope.Variables[relatedTable.watchOn];
                    primaryKeys = relatedVariable ? relatedVariable.getPrimaryKey() : [];
                    return primaryKeys;
                }
            },

            liveVariableObj = {
                update: function (options, success, error) {
                    var name = this.name;
                    options = options || {};
                    options.scope = this.activeScope;

                    if (CONSTANTS.isRunMode) {
                        $rootScope.$emit('toggle-variable-state', name, true);
                    }

                    methods.getData(this, options, function (data, propertiesMap, pageOptions) {
                        if (CONSTANTS.isRunMode) {
                            $rootScope.$emit('toggle-variable-state', name, false);
                        }
                        Utils.triggerFn(success, data, propertiesMap, pageOptions);
                    }, function (errMsg) {
                        if (CONSTANTS.isRunMode) {
                            $rootScope.$emit('toggle-variable-state', name, false);
                        }
                        Utils.triggerFn(error, errMsg);
                    });
                },
                updateRecord: function (options, success, error) {
                    var name = this.name;
                    options = options || {};
                    options.scope = this.activeScope;

                    if (CONSTANTS.isRunMode) {
                        $rootScope.$emit('toggle-variable-state', name, true);
                    }

                    methods.updateRecord(this, options, function (response) {
                        if (CONSTANTS.isRunMode) {
                            $rootScope.$emit('toggle-variable-state', name, false);
                        }
                        Utils.triggerFn(success, response);
                    }, function (errMsg) {
                        if (CONSTANTS.isRunMode) {
                            $rootScope.$emit('toggle-variable-state', name, false);
                        }
                        Utils.triggerFn(error, errMsg);
                    });
                },
                insertRecord: function (options, success, error) {
                    var name = this.name;
                    options = options || {};
                    options.scope = this.activeScope;

                    if (CONSTANTS.isRunMode) {
                        $rootScope.$emit('toggle-variable-state', name, true);
                    }

                    methods.insertRecord(this, options, function (response) {
                        if (CONSTANTS.isRunMode) {
                            $rootScope.$emit('toggle-variable-state', name, false);
                        }
                        Utils.triggerFn(success, response);
                    }, function (errMsg) {
                        if (CONSTANTS.isRunMode) {
                            $rootScope.$emit('toggle-variable-state', name, false);
                        }
                        Utils.triggerFn(error, errMsg);
                    });
                },
                deleteRecord: function (options, success, error) {
                    var name = this.name;
                    options = options || {};
                    options.scope = this.activeScope;

                    if (CONSTANTS.isRunMode) {
                        $rootScope.$emit('toggle-variable-state', name, true);
                    }

                    methods.deleteRecord(this, options, function (response) {
                        if (CONSTANTS.isRunMode) {
                            $rootScope.$emit('toggle-variable-state', name, false);
                        }
                        Utils.triggerFn(success, response);
                    }, function (errMsg) {
                        if (CONSTANTS.isRunMode) {
                            $rootScope.$emit('toggle-variable-state', name, false);
                        }
                        Utils.triggerFn(error, errMsg);
                    });
                },
                updateRelatedData: function (options, success, error) {
                    options = options || {};
                    options.scope = this.activeScope;

                    methods.updateRelatedData(this, options, function (data, propertiesMap, pageOptions) {
                        Utils.triggerFn(success, data, propertiesMap, pageOptions);
                    }, function (errMsg) {
                        Utils.triggerFn(error, errMsg);
                    });
                },
                getPrimaryKey: function () {
                    return methods.getPrimaryKey(this);
                },
                isCompositeKey: function (primaryKey) {
                    return methods.isCompositeKey(this, primaryKey);
                },
                isNoPrimaryKey: function (primaryKey) {
                    return methods.isNoPrimaryKey(this, primaryKey);
                },
                setOrderBy: function (expression) {
                    return methods.setOrderBy(this, expression);
                },
                getData: function () {
                    return methods.getDataSet(this);
                },
                clearData: function () {
                    return methods.clearData(this);
                },
                cancel: function () {
                    return methods.cancel(this);
                },
                setInput: function (key, val) {
                    return methods.setInput(this, key, val);
                },
                setFilter: function (key, val) {
                    return methods.setFilter(this, key, val);
                },
                getModifiedFieldName: function (fieldName) {
                    return methods.getModifiedFieldName(this, fieldName);
                },
                getRelatedTableData: function (columnName, options, success, error) {
                    return methods.getRelatedTableData(this, columnName, options, success, error);
                },
                getRelatedTablePrimaryKeys: function (columnName, options) {
                    return methods.getRelatedTablePrimaryKeys(this, columnName, options);
                }
            };

        /* register the variable to the base service*/
        BaseVariablePropertyFactory.register('wm.LiveVariable', liveVariableObj, ['wm.Variable', 'wm.ServiceVariable'], methods);

        return {
            reset: reset,
            processResponse: processResponse,
            /**
             * @ngdoc method
             * @name $Variables#getRelatedColumnsList
             * @methodOf wm.variables.$Variables
             * @description
             * function to fetch the column list of a the related field
             * @param {object} variable variable
             * @param {string} fieldName fieldName of the column
             */
            getRelatedColumnsList: getRelatedColumnsList
        };
    }
];

/*global wm, WM, _*/
/*jslint todo: true */
/*jslint sub: true */


/**
 * @ngdoc service
 * @name wm.variables.$servicevariable
 * @requires $rootScope
 * @requires BaseVariablePropertyFactory
 * @description
 * The '$servicevariable' provides methods to work with service variables
 */

wm.variables.services.$servicevariable = ['Variables',
    'BaseVariablePropertyFactory',
    'WebService',
    'ServiceFactory',
    '$rootScope',
    'CONSTANTS',
    'Utils',
    'ProjectService',
    'VARIABLE_CONSTANTS',
    'WS_CONSTANTS',
    'DatabaseService',
    '$base64',

    function (Variables, BaseVariablePropertyFactory, WebService, ServiceFactory, $rootScope, CONSTANTS, Utils, ProjectService, VARIABLE_CONSTANTS, WS_CONSTANTS, DatabaseService, $base64) {
        "use strict";

        var serviceModel = {},
            requestQueue = {},
            variableActive = {},
            prefabDataTypes = {},
            REST_METHOD_NAME = "executeRestCall",
            REST_SUPPORTED_SERVICES = VARIABLE_CONSTANTS.REST_SUPPORTED_SERVICES,
            SERVICE_TYPE_FEED = VARIABLE_CONSTANTS.SERVICE_TYPE_FEED,
            SERVICE_TYPE_REST = VARIABLE_CONSTANTS.SERVICE_TYPE_REST,
            SERVICE_TYPE_SOAP = VARIABLE_CONSTANTS.SERVICE_TYPE_SOAP,
            SERVICE_TYPE_DATA = VARIABLE_CONSTANTS.SERVICE_TYPE_DATA,
            SERVICE_TYPE_JAVA = VARIABLE_CONSTANTS.SERVICE_TYPE_JAVA,
            AUTH_TYPE_BASIC = "BASIC",
            AUTH_TYPE_NONE = "NONE",
            AUTH_TYPE_OAUTH = "OAUTH",
            supportedOperations = WS_CONSTANTS.HTTP_METHODS.map(function (method) { return method.toLowerCase(); }),
            BASE_PATH_KEY = 'x-WM-BASE_PATH',
            RELATIVE_PATH_KEY = 'x-WM-RELATIVE_PATH',
            CONTROLLER_KEY = 'x-WM-TAG',
            parameterTypeKey = 'in',
            AUTH_HDR_KEY = "Authorization",
            isPrimitiveType = function (type) {
                return (WS_CONSTANTS.PRIMITIVE_DATA_TYPES.indexOf(type) !== -1);
            },
            /* function to prepare the sample model for the service variable */
            prepareServiceModel = function (type, parentNode, startNode, variable, typeChain) {
                var modelTypes = variable.prefabName ? prefabDataTypes[variable.prefabName] : $rootScope.dataTypes;
                /*if startNode variable is provided, skip till the startNode variable is reached*/
                if (startNode) {
                    if (modelTypes[type] && modelTypes[type].fields) {
                        WM.forEach(modelTypes[type].fields, function (field, fieldName) {
                            /*if start node found, start preparing the data*/
                            if (fieldName === startNode) {
                                prepareServiceModel(field.type, parentNode, null, variable);
                            } else {
                                prepareServiceModel(field.type, parentNode, startNode, variable);
                            }
                        });
                    }
                } else if ((type && modelTypes[type]) || isPrimitiveType(type)) {
                    /* case when the data returned from the service is not an object */
                    if ((modelTypes[type] && modelTypes[type].primitiveType) || isPrimitiveType(type)) {
                        if (!variable.isList) {
                            parentNode['value'] = '';
                        }
                        variable._buildTreeFromDataSet = true;
                        return;
                    }
                    typeChain = typeChain || "";
                    var typeChainArr = typeChain.split("~");
                    if (typeChainArr.indexOf(type) !== -1) {
                        return;
                    }
                    typeChain += "~" + type;
                    WM.forEach(modelTypes[type].fields, function (field, fieldName) {
                        /* if the field is of type list and variable is not a service variable, skip it.
                         * skipping as it is resulting in endless recursive loop for DataServices
                         */
                        if ((!field.isList || variable.serviceType === SERVICE_TYPE_SOAP || variable.serviceType === SERVICE_TYPE_FEED || variable.serviceType === SERVICE_TYPE_REST || variable.serviceType === SERVICE_TYPE_JAVA)) {
                            if (modelTypes[field.type] && modelTypes[field.type].fields) {
                                parentNode[fieldName] = field.isList ? [{}] : {};
                                prepareServiceModel(field.type, field.isList ? parentNode[fieldName][0] : parentNode[fieldName], '', variable, typeChain);
                            } else {
                                parentNode[fieldName] = field.isList ? [] : '';
                            }
                        }
                    });
                }
            },
        /*function to initiate the callback and obtain the data for the callback variable.*/
            initiateCallback = Variables.initiateCallback,

            processRequestQueue = Variables.processRequestQueue,

            /*
             * function to transform the service data as according to the variable configuration
             * @param data: data returned from the service
             * @variable: variable object triggering the service
             */
            transformData = function (data, variable) {
                data.wmTransformedData = [];

                var columnsArray = variable.transformationColumns,
                    dataArray = data[variable.dataField] || [],
                    transformedData = data.wmTransformedData;

                WM.forEach(dataArray, function (datum, index) {
                    transformedData[index] = {};
                    WM.forEach(columnsArray, function (column, columnIndex) {
                        transformedData[index][column] = datum[columnIndex];
                    });
                });

                return data;
            },

            /**
             * Simulates file download in an app through creating and submitting a hidden form in DOM.
             * The action will be initiated through a Service Variable
             * @param variable: the variable that is called from user action
             * @param requestParams object consisting the info to construct the XHR request for the service
             */
            simulateFileDownload = function (requestParams) {
                var iFrameElement,
                    IFRAME_NAME = "fileDownloadIFrame",
                    FORM_NAME = "fileDownloadForm",
                    formEl,
                    url = requestParams.url,
                    paramElement,
                    queryParams;

                /* look for existing iframe. If exists, remove it first */
                iFrameElement = $(IFRAME_NAME);
                if (iFrameElement.length) {
                    iFrameElement.first().remove();
                }
                iFrameElement = WM.element('<iframe id="' + IFRAME_NAME +'" name="'+ IFRAME_NAME +'" class="ng-hide"></iframe>');
                formEl = WM.element('<form id="' + FORM_NAME + '" name="' + FORM_NAME + '"></form>'),
                formEl.attr({
                    'target': iFrameElement.attr("name"),
                    'action': url,
                    'method': requestParams.method,
                    'enctype': requestParams.headers['Content-Type']
                });

                /* process query params, append a hidden input element in the form against each param */
                queryParams = url.indexOf('?') !== -1 ? url.substring(url.indexOf('?') + 1) :
                        requestParams.headers['Content-Type'] === WS_CONSTANTS.CONTENT_TYPES.FORM_URL_ENCODED ? requestParams.dataParams : "",
                queryParams = queryParams.split("&");
                queryParams.forEach(function (param) {
                    param = param.split("=");
                    paramElement = WM.element("<input type='hidden'>");
                    paramElement.attr({
                        'name': param[0],
                        'value': param[1]
                    });
                    formEl.append(paramElement);
                });

                /* append form to iFrame and iFrame to the document and submit the form */
                WM.element('body').append(iFrameElement);
                iFrameElement.contents().find('body').append(formEl);
                formEl.submit();
            },

            /* function to process error response from a service */
            processErrorResponse = function (errMsg, variable, callBackScope, error) {
                // EVENT: ON_ERROR
                initiateCallback(VARIABLE_CONSTANTS.EVENT.ERROR, variable, callBackScope, errMsg);

                /* trigger error callback */
                Utils.triggerFn(error, errMsg);

                if (CONSTANTS.isRunMode) {
                    /* process next requests in the queue */
                    variableActive[variable.activeScope.$id][variable.name] = false;
                    variable.canUpdate = true;
                    processRequestQueue(variable, requestQueue[variable.activeScope.$id], getDataInRun);

                    // EVENT: ON_CAN_UPDATE
                    initiateCallback(VARIABLE_CONSTANTS.EVENT.CAN_UPDATE, variable, callBackScope, error);
                }
            },

            /* function to process success response from a service */
            processSuccessResponse = function (response, variable, callBackScope, options, success, error) {
                var newDataSet;

                /* if RestService check statusCode for error, else check 'error' field in response */
                if (response && response.error) {
                    processErrorResponse(response, variable, callBackScope, error);
                    return;
                }

                // EVENT: ON_RESULT
                initiateCallback(VARIABLE_CONSTANTS.EVENT.RESULT, variable, callBackScope, response);

                // EVENT: ON_SUCCESS
                initiateCallback(VARIABLE_CONSTANTS.EVENT.SUCCESS, variable, callBackScope, response);

                /* if dataTransformation enabled, transform the data */
                if (variable.transformationColumns) {
                    response = transformData(response, variable);
                }

                // EVENT: ON_PREPARE_SETDATA
                newDataSet = initiateCallback(VARIABLE_CONSTANTS.EVENT.PREPARE_SETDATA, variable, callBackScope, response);
                if (WM.isDefined(newDataSet)) {
                    //setting newDataSet as the response to service variable onPrepareSetData
                    response = newDataSet;
                }

                /* update the dataset against the variable, if response is non-object, insert the response in 'value' field of dataSet */
                if (!options.forceRunMode) {
                    variable.dataSet = (!WM.isObject(response)) ? {'value': response} : response;
                }

                /* trigger success callback */
                Utils.triggerFn(success, response);

                if (CONSTANTS.isRunMode) {
                    /* process next requests in the queue */
                    variableActive[variable.activeScope.$id][variable.name] = false;
                    variable.canUpdate = true;
                    processRequestQueue(variable, requestQueue[variable.activeScope.$id], getDataInRun);
                }

                // EVENT: ON_CAN_UPDATE
                initiateCallback(VARIABLE_CONSTANTS.EVENT.CAN_UPDATE, variable, callBackScope, response);
            },
        /*function to create the params to invoke the java service. creating the params and the corresponding
        * url to invoke based on the type of the parameter*/
            constructRestRequestParams = function (operationInfo, serviceType, variable) {
                var queryParams = '',
                    endPointRelativePath = operationInfo.relativePath || '/',
                    headers = {},
                    requestBody,
                    url,
                    target,
                    pathParamRex,
                    invokeParams,
                    authType = AUTH_TYPE_NONE,
                    uname,
                    pswd,
                    method,
                    isFormDataSupported = Utils.isFileUploadSupported(),
                    formData,
                    formDataContentType;

                if (isFormDataSupported) {
                    formData = new FormData();
                }
                /* loop through all the parameters */
                WM.forEach(operationInfo.parameters, function (param) {
                    var paramValue = param.sampleValue;
                    if (WM.isDefined(paramValue) && paramValue !== '') {
                        switch (param.parameterType.toUpperCase()) {
                        case 'QUERY':
                            if (!queryParams) {
                                queryParams = "?" + param.name + "=" + encodeURIComponent(paramValue);
                            } else {
                                queryParams += "&" + param.name + "=" + encodeURIComponent(paramValue);
                            }
                            break;
                        case 'AUTH':
                            if (param.name === 'wm_auth_username') {
                                uname = paramValue;
                            } else if (param.name === 'wm_auth_password') {
                                pswd = paramValue;
                            }
                            if (uname && pswd) {
                                headers[AUTH_HDR_KEY] = "Basic " + $base64.encode(uname + ':' + pswd);
                                authType = AUTH_TYPE_BASIC;
                            }
                            break;
                        case 'PATH':
                            /* replacing the path param based on the regular expression in the relative path */
                            pathParamRex = new RegExp("\\s*\\{\\s*" + param.name + "(:\\.\\+)?\\s*\\}\\s*");
                            endPointRelativePath = endPointRelativePath.replace(pathParamRex, paramValue);
                            break;
                        case 'HEADER':
                            headers[param.name] = paramValue;
                            break;
                        case 'BODY':
                            requestBody = paramValue;
                            break;
                        case 'FORMDATA':
                            if (isFormDataSupported) {
                                if (param.type === "file") {
                                    if (WM.isArray(paramValue)) {
                                        WM.forEach(paramValue, function (fileObject) {
                                            formData.append(param.name, fileObject, fileObject.name);
                                        });
                                    } else {
                                        formData.append(param.name, paramValue, paramValue.name);
                                    }
                                } else {
                                    if (WM.isObject(paramValue)) {
                                        paramValue = JSON.stringify(paramValue);
                                        formDataContentType = "application/json";
                                    } else {
                                        formDataContentType = "text/plain";
                                    }
                                    formData.append(param.name, new Blob([paramValue], {type: formDataContentType}));
                                }
                                requestBody = formData;
                            }
                            break;
                        }
                    }
                });

                url = $rootScope.project.deployedUrl;

                if (variable.prefabName && VARIABLE_CONSTANTS.REST_SUPPORTED_SERVICES.indexOf(serviceType) !== -1 && variable.wmServiceOperationInfo) {
                    /* if it is a prefab variable (used in a normal project), modify the url */
                    url += "/prefabs/" + variable.prefabName;
                    target = "invokePrefabRestService";
                }

                method = operationInfo.httpMethod || operationInfo.methodType;
                url += (variable.prefabName ? '' : '/services') + endPointRelativePath;
                /*Based on the formData browser will automatically set the content type to 'multipart/form-data' and webkit boundary*/
                if (operationInfo.consumes && operationInfo.consumes[0] === WS_CONSTANTS.CONTENT_TYPES.MULTIPART_FORMDATA) {
                    headers['Content-Type'] = undefined;
                }

                // if the consumes has application/x-www-form-urlencoded and
                // if the http request of given method type can have body send the queryParams as Form Data
                if (_.includes(operationInfo.consumes, WS_CONSTANTS.CONTENT_TYPES.FORM_URL_ENCODED)
                        && !_.includes(WS_CONSTANTS.NON_BODY_HTTP_METHODS, (method || '').toUpperCase())) {
                    // remove the '?' at the start of the queryParams
                    requestBody = queryParams.substring(1);
                    headers['Content-Type'] = WS_CONSTANTS.CONTENT_TYPES.FORM_URL_ENCODED;
                } else {
                    url += queryParams;
                }

                /*creating the params needed to invoke the service. url is generated from the relative path for the operation*/
                invokeParams = {
                    "projectID": $rootScope.project.id,
                    "url": url,
                    "target": target,
                    "method": method,
                    "headers": headers,
                    "dataParams": requestBody,
                    "authType": authType
                };

                return invokeParams;
            },
        /*function to get variable data in RUN Mode*/
            getDataInRun = function (variable, options, success, error) {
                /* get the service and operation from the variable object */
                var service = variable.service,
                    operation = variable.operation,
                    variableOwner = variable.owner,
                    serviceType = variable.serviceType,
                    dataParams = [],
                    requestMethod,
                    requestParams = "",
                    params,
                    callBackScope,
                    methodInfo;

                /* get the callback scope for the variable based on its owner */
                if (variableOwner === "App") {
                    /* TODO: to look for a better option to get App/Page the controller's scope */
                    callBackScope = $rootScope || {};
                } else {
                    if (variable.prefabName) {
                        callBackScope = options.scope || {};
                    } else {
                        callBackScope = (options.scope && options.scope.$$childTail) ? options.scope.$$childTail : {};
                    }
                }

                // EVENT: ON_BEFORE_UPDATE
                if (CONSTANTS.isRunMode) {
                    var preventCall = initiateCallback(VARIABLE_CONSTANTS.EVENT.BEFORE_UPDATE, variable, callBackScope, variable.dataBinding);
                    if (preventCall === false) {
                        return;
                    }
                    variableActive[variable.activeScope.$id][variable.name] = true;
                    variable.canUpdate = false;
                }

                /* loop over the parameters required for the variable and push them request dataParams */
                WM.forEach(variable.dataBinding, function (param) {
                    dataParams.push(param);
                });

                if (VARIABLE_CONSTANTS.REST_SUPPORTED_SERVICES.indexOf(serviceType) !== -1 && variable.wmServiceOperationInfo) {
                    methodInfo = Utils.getClonedObject(variable.wmServiceOperationInfo);
                    if (methodInfo.parameters) {
                        methodInfo.parameters.forEach(function (param) {
                            param.sampleValue = variable.dataBinding[param.name];
                            /* supporting pagination for query service variable */
                            if (serviceType === SERVICE_TYPE_DATA && VARIABLE_CONSTANTS.PAGINATION_PARAMS.indexOf(param.name) !== -1) {
                                if (param.name === "size") {
                                    param.sampleValue = param.sampleValue || parseInt(variable.maxResults, 10) || 20;
                                } else if (param.name === "page") {
                                    param.sampleValue = options.page || param.sampleValue || 1;
                                } else if (param.name === "sort") {
                                    param.sampleValue = options.orderBy || variable.orderBy || '';
                                }
                            }
                        });
                    }
                    params = constructRestRequestParams(methodInfo, serviceType, variable);
                } else if (serviceType === SERVICE_TYPE_REST) {
                    dataParams = [service, operation, Utils.getClonedObject(variable.dataBinding)];

                    /*prepare request params*/
                    params = {
                        "method": REST_METHOD_NAME,
                        "params": dataParams,
                        "url": $rootScope.project.deployedUrl,
                        "target": "invokeRestService"
                    };
                } else {
                    /*for old projects as a normal java method invocation*/
                    params = {
                        "method": operation,
                        "serviceFile": service + ".json",
                        "params": dataParams,
                        "url": $rootScope.project.deployedUrl
                    };
                }

                if (variable.prefabName && VARIABLE_CONSTANTS.REST_SUPPORTED_SERVICES.indexOf(serviceType) === -1) {
                /* if it is a prefab variable (used in a normal project), modify the url */
                    params.url += "/prefabs/" + variable.prefabName;
                    params.target = "invokePrefabRestService";
                }

                /* get the callback scope for the variable based on its owner */
                if (variableOwner === "App") {
                    /* TODO: to look for a better option to get App/Page the controller's scope */
                    callBackScope = $rootScope || {};
                } else {
                    if (variable.prefabName) {
                        callBackScope = options.scope || {};
                    } else {
                        callBackScope = (options.scope && options.scope.$$childTail) ? options.scope.$$childTail : {};
                    }
                }

                /* if the service produces octet/stream, replicate file download through form submit */
                if (WM.isArray(methodInfo.produces) && _.includes(methodInfo.produces, WS_CONSTANTS.CONTENT_TYPES.OCTET_STREAM)) {
                    simulateFileDownload(params);
                    variableActive[variable.activeScope.$id][variable.name] = false;
                    return;
                }

                if (REST_SUPPORTED_SERVICES.indexOf(serviceType) !== -1 && variable.wmServiceOperationInfo) {
                    /* Here we are invoking JavaService through the new REST api (old classes implementation removed, older projects migrated with new changes for corresponding service variable) */
                    variable.promise = WebService.invokeJavaService(params, function (response) {
                        processSuccessResponse(response, variable, callBackScope, options, success, error);
                    }, function (errorMsg) {
                        processErrorResponse(errorMsg, variable, callBackScope, error);
                    });
                } else if (serviceType === SERVICE_TYPE_REST) {
                    variable.promise = WebService.invokeRestService(params, function (response) {
                        processSuccessResponse(response, variable, callBackScope, options, success, error);
                    }, function (errorMsg) {
                        processErrorResponse(errorMsg, variable, callBackScope, error);
                    });
                } else {
                    /* invoke the service */
                    variable.promise = WebService.invoke(params, function (response) {
                        processSuccessResponse(response, variable, callBackScope, options, success, error);
                    }, function (errMsg) {
                        processErrorResponse(errMsg, variable, callBackScope, error);
                    });
                }
            },
        /*function to get variable data in Studio mode*/
            getDataInStudio = function (variable, startNode, success) {
                /* get the service and operation from the variable object */
                var service = variable.service,
                    operation = variable.operation;

                /* get the data from variable return type information */
                ServiceFactory.getServicesWithType(function () {
                    ServiceFactory.getServiceOperations(service, function () {
                        ServiceFactory.getServiceOperationParams(service, operation, function (response) {
                            var typeRef = response['return'].typeRef,
                                fieldValue = startNode ? startNode.substring(variable.name.length + 1, startNode.length) : startNode;
                            serviceModel = {};

                            variable.type = variable.type || typeRef;
                            variable.isList = response.isList;
                            variable._format = response.returnFormat;
                            /* prepare sample data-structure for the service */
                            prepareServiceModel(variable.type, serviceModel, fieldValue, variable);

                            /* check for transformation columns in variable */
                            if (variable.transformationColumns) {
                                serviceModel['wmTransformedData'] = {};
                                WM.forEach(variable.transformationColumns, function (columnName) {
                                    serviceModel['wmTransformedData'][columnName] = '';
                                });
                            }

                            /* update the dataset */
                            variable.dataSet = serviceModel;
                            /*pass the data prepared to the success callback function*/
                            Utils.triggerFn(success, serviceModel);
                        });
                    });
                });
            },
        /*function to create the service operation info in the variable object, to create the parameter info
        * for the selected operation of the service*/
            getServiceOperationInfo = function (selectedOperation, selectedService, success, error, forceReload, controller) {
                var operationInfo = {};

                /*invoking a service to get the operations that a particular service has and it's
                 * parameters to create a unique url pattern*/
                ServiceFactory.getServiceDef(selectedService, function (response) {
                    /*iterate over the paths received from the service response*/
                    var pathsArr = Object.keys(response.paths),
                        securityDefinitions = response.securityDefinitions,
                        AUTH_TYPE_KEY = 'WM_Rest_Service_Authorization',
                        paramDataType;
                    for (var i= 0, nPaths = pathsArr.length; i <nPaths; i++) {
                        var pathKey = pathsArr[i],
                            path = response.paths[pathKey];
                        for (var j = 0, nOps = supportedOperations.length; j < nOps; j++) {
                            var opType = supportedOperations[j],
                                operation = path[opType];
                            if (operation && operation[WS_CONSTANTS.OPERATION_NAME_KEY] === selectedOperation) {
                                /* if controller is provided, check for controller match as well */
                                if (controller && controller + "Controller" !== path[CONTROLLER_KEY]) {
                                    continue;
                                }
                                operationInfo.httpMethod = opType;
                                operationInfo.name = selectedOperation;
                                operationInfo.relativePath = (path[BASE_PATH_KEY] || "") + path[RELATIVE_PATH_KEY];
                                /*saving the request mime type only if it is explicitly mentioned used in the file upload widget to decide the mime type from swagger path object*/
                                if (operation.consumes && operation.consumes.length) {
                                    operationInfo.consumes = operation.consumes;
                                }
                                /*
                                 * saving the response mime type only if it is explicitly mentioned.
                                 * UseCase: 'download' operation of 'FileService' gives application/octet-stream
                                 * this is used to determine if a download file has to be simulated through form submit(as download not possible through AJAX)
                                 */
                                if (operation.produces && operation.produces.length) {
                                    operationInfo.produces = operation.produces;
                                }
                                operationInfo.parameters = [];

                                if (operation.parameters && operation.parameters.length) {
                                    operation.parameters.forEach(function (parameter) {
                                        if (parameter[parameterTypeKey].toLowerCase() === 'formdata') {
                                            paramDataType = parameter.type === "array" ? (parameter.items && parameter.items.type) || parameter.type : parameter.type;
                                        } else {
                                            paramDataType = parameter.type;
                                        }
                                        operationInfo.parameters.push({
                                            "name": parameter.name || (parameter[parameterTypeKey] && parameter[parameterTypeKey].toLowerCase()),
                                            "parameterType": parameter[parameterTypeKey],
                                            "type": paramDataType
                                        });
                                    });
                                }
                                if (securityDefinitions && securityDefinitions[AUTH_TYPE_KEY] && securityDefinitions[AUTH_TYPE_KEY].type === "basic" && operation.security[0][AUTH_TYPE_KEY]) {
                                    operationInfo.authorization = securityDefinitions[AUTH_TYPE_KEY].type;
                                    operationInfo.parameters.push({
                                        "name": "wm_auth_username",
                                        "parameterType": "auth"
                                    });
                                    operationInfo.parameters.push({
                                        "name": "wm_auth_password",
                                        "parameterType": "auth"
                                    });
                                }
                                break;
                            }
                        }
                        if (j < nOps) {
                            break;
                        }
                    }
                    /*pass the data prepared to the success callback function*/
                    Utils.triggerFn(success, operationInfo);
                }, function (errMsg) {
                    /*handle error response*/
                    Utils.triggerFn(error, errMsg);
                }, forceReload);
            },

        /* properties of a service variable - should contain methods applicable on this particular object */
            methods = {
                getDataSet: function (variable) {
                    /* return the variable dataSet*/
                    return variable.dataSet;
                },
                getData: function (variable, options, success, error) {
                    /* get the variable object from variable collection */
                    var variableName = variable.name,
                        startNode = options.startNode;

                    /* if variable not found return into error callback */
                    if (Utils.isEmptyObject(variable)) {
                        error();
                        return;
                    }

                    /* if in run mode, hit the web service and retrieve data */
                    if (CONSTANTS.isRunMode || options.forceRunMode) {
                        if (CONSTANTS.isRunMode) {
                            variableActive[variable.activeScope.$id] = variableActive[variable.activeScope.$id] || {};
                            requestQueue[variable.activeScope.$id] = requestQueue[variable.activeScope.$id] || {};
                            if (variableActive[variable.activeScope.$id][variableName]) {
                                requestQueue[variable.activeScope.$id][variableName] = requestQueue[variable.activeScope.$id][variableName] || [];
                                requestQueue[variable.activeScope.$id][variableName].push({variable: variable, options: options, success: success, error: error});
                                return;
                            }
                        }
                        if (options.forceRunMode) {
                            /*call run-project service*/
                            ProjectService.run({
                                projectId: $rootScope.project.id
                            }, function (result) {
                                /*Save the deployed url of the project in the $rootScope so that it could be used in all calls to services of deployed app*/
                                $rootScope.project.deployedUrl = Utils.removeProtocol(result);

                                getDataInRun(variable, options, success, error);
                            });
                        } else {
                            getDataInRun(variable, options, success, error);
                        }
                    } else if (variable.prefabName) {
                        var serviceModel = {};
                        if (prefabDataTypes[variable.prefabName]) {
                            /* prepare sample data-structure for the service */
                            prepareServiceModel(variable.type, serviceModel, null, variable);
                            variable.dataSet = serviceModel;
                            Utils.triggerFn(success, serviceModel);
                        } else {
                            WebService.listPrefabTypes({
                                projectID: $rootScope.project.id,
                                prefabName: variable.prefabName
                            }, function (response) {
                                prefabDataTypes[variable.prefabName] = response.types;
                                /* prepare sample data-structure for the service */
                                prepareServiceModel(variable.type, serviceModel, null, variable);
                                variable.dataSet = serviceModel;
                                Utils.triggerFn(success, serviceModel);
                            });
                        }
                    } else {
                        getDataInStudio(variable, startNode, success, error);
                    }
                },
                setService: function (variable, service) {
                    if (service) {
                        variable.service = service;
                    }

                    return variable.service;
                },
                setOperation: function (variable, operation) {
                    if (operation) {
                        variable.operation = operation;
                    }

                    return variable.operation;
                },
                clearData: function (variable) {
                    variable.dataSet = {};

                    /* return the variable dataSet*/
                    return variable.dataSet;
                },
                cancel: function (variable) {
                    /* process only if current variable is actually active */
                    if (variableActive[variable.activeScope.$id][variable.name] && variable.promise) {
                        variable.promise.abort();
                    }
                },
                setInput: function (variable, key, val) {
                    var targetObj = variable.dataBinding,
                        keys,
                        lastKey,
                        paramObj = {};
                    if (WM.isObject(key)) {
                        paramObj = key;
                    } else if (key.indexOf('.') > -1) {
                        keys = key.split('.');
                        lastKey = keys.pop();
                        /*Finding the object based on the key*/
                        targetObj = Utils.findValueOf(targetObj, keys.join('.'), true);
                        key = lastKey;
                        paramObj[key] = val;
                    } else {
                        paramObj[key] = val;
                    }

                    WM.forEach(paramObj, function (paramVal, paramKey) {
                        targetObj[paramKey] = paramVal
                    });
                    return variable.dataBinding;
                }
            },
            serviceVariableObj = {
                update: function (options, success, error) {
                    var name = this.name;
                    options = options || {};
                    options.scope = this.activeScope || options.scope;

                    if (CONSTANTS.isRunMode) {
                        $rootScope.$emit('toggle-variable-state', name, true);
                    }

                    methods.getData(this, options, function (response) {
                        if (CONSTANTS.isRunMode) {
                            $rootScope.$emit('toggle-variable-state', name, false, response);
                        }
                        Utils.triggerFn(success, response);
                    }, function (errMsg) {
                        if (CONSTANTS.isRunMode) {
                            $rootScope.$emit('toggle-variable-state', name, false);
                        }
                        Utils.triggerFn(error, errMsg);
                    });
                },
                setService: function (service) {
                    return methods.setService(this, service);
                },
                setOperation: function (operation) {
                    return methods.setOperation(this, operation);
                },
                getData: function () {
                    return methods.getDataSet(this);
                },
                clearData: function () {
                    return methods.clearData(this);
                },
                cancel: function () {
                    return methods.cancel(this);
                },
                setInput: function (key, val) {
                    return methods.setInput(this, key, val);
                }
            };

        /* register the variable to the base service */
        BaseVariablePropertyFactory.register('wm.ServiceVariable', serviceVariableObj, ['wm.Variable'], methods);

        return {
            getServiceModel: function (params) {
                var model = {};
                prepareServiceModel(params.typeRef, model, null, params.variable);

                return model;
            },
            getServiceOperationInfo: getServiceOperationInfo
        };
    }];
/*global wm, WM*/
/*jslint sub: true */

/**
 * @ngdoc service
 * @name wm.variables.$NavigationVariableService
 * @requires Variables
 * @requires BaseVariablePropertyFactory
 * @requires Utils
 * @description
 * The 'NavigationVariableService' provides methods to work with Navigation variables
 */

wm.variables.services.NavigationVariableService = function ($rootScope, BaseVariablePropertyFactory, Utils, NavigationService) {
    "use strict";


    /* properties of a basic variable - should contain methods applicable on this particular object */
    var methods = {
            navigate: function (variable, options) {
                var pageName,
                    viewName,
                    operation,
                    sourceScope;

                /* sanity checking */
                if (!Utils.isEmptyObject(variable)) {
                    operation = variable.operation;
                    sourceScope = options.scope || $rootScope;
                    pageName = (variable.dataBinding && variable.dataBinding.pageName) || variable.pageName;

                    /*if operation is goToPage, navigate to the pageName*/
                    switch (operation) {
                    case 'goToPreviousPage' :
                        NavigationService.goToPrevious();
                        break;
                    case 'gotoPage':
                        try {
                            NavigationService.goToPage(pageName, variable.pageTransitions);
                            sourceScope.$root.$safeApply(sourceScope);
                        } catch (ignore) {
                        }
                        break;
                    case 'gotoView':
                        viewName = (variable.dataBinding && variable.dataBinding.viewName) || variable.viewName;
                        break;
                    case 'gotoTab':
                        viewName = (variable.dataBinding && variable.dataBinding.tabName) || variable.tabName;
                        break;
                    case 'gotoAccordion':
                        viewName = (variable.dataBinding && variable.dataBinding.accordionName) || variable.accordionName;
                        break;
                    case 'gotoSegment':
                        viewName = (variable.dataBinding && variable.dataBinding.segmentName) || variable.segmentName;
                        break;
                    }

                    /* if view name found, call routine to navigate to it */
                    if (viewName) {
                        NavigationService.goToView(pageName, viewName, variable.pageTransitions);
                    }
                }
            }
        },
        basicVariableObj = {
            navigate: function () {
                methods.navigate(this, {scope: this.activeScope});
            }
        };

    /* register the variable to the base service*/
    BaseVariablePropertyFactory.register('wm.NavigationVariable', basicVariableObj, [], methods);

    return {
        goToView: function (viewName) {
            NavigationService.goToView(undefined, viewName);
        }
    };
};
/*global wm, WM*/
/*jslint sub: true */

/**
 * @ngdoc service
 * @name wm.variables.$NotificationVariableService
 * @requires Variables
 * @requires $rootScope
 * @requires BaseVariablePropertyFactory
 * @requires CONSTANTS
 * @description
 * The 'NotificationVariableService' provides methods to work with Notification variables
 */

wm.variables.services.NotificationVariableService = function (BaseVariablePropertyFactory, DialogService, $rootScope, wmToaster) {
    "use strict";

    /* properties of a basic variable - should contain methods applicable on this particular object */
    var methods = {
            notify: function (variable, options, success, error) {
                var variableName = variable.name,
                    dialogId = "notification" + variable.operation + "dialog",
                    variableOwner = variable.owner,
                    operation = variable.operation,
                    toasterOptions = (WM.element('[toaster-options]').scope() && WM.element('[toaster-options]').scope().config) || {},
                    scope;

                //callback function to execute on click of the custom notification element
                function customNotificationOnClick() {
                    if (_.trim(variable.onClick)) {
                        if (WM.isFunction(scope[variableName + 'onClick'])) {
                            scope[variableName + 'onClick'](variable, null);
                        } else {
                            $rootScope.$emit('invoke-service', variable.onClick, {scope: scope});
                        }
                    }
                }
                //callback function to execute on hide of the custom notification element
                function customNotificationOnHide() {
                    if (_.trim(variable.onHide)) {
                        if (WM.isFunction(scope[variableName + 'onHide'])) {
                            scope[variableName + 'onHide'](variable, null);
                        } else {
                            $rootScope.$emit('invoke-service', variable.onHide, {scope: scope});
                        }
                    }
                }

                if (operation === 'toast') {
                    var type = (options.class || variable.dataBinding.class || "info").toLowerCase(),
                        body = options.message || variable.dataBinding.text,
                        timeout = parseInt(variable.dataBinding.duration),
                        positionClass = "toast-" + (options.position || variable.dataBinding.toasterPosition || 'bottom right').replace(' ', '-'),
                        content = variable.dataBinding.page;
                    toasterOptions.position = positionClass;
                    //check the variable scope and call the callback functions accordingly
                    if (variableOwner === 'Application') {
                        scope = $rootScope || {};
                    } else {
                        scope = options.scope || {};
                    }
                    //check for the older projects not having content property in the variable
                    if (variable.dataBinding.content && variable.dataBinding.content === 'page') {
                        if (content) {
                            wmToaster.createCustomNotification(content, variableName, timeout, positionClass, customNotificationOnClick, customNotificationOnHide);
                        }
                    } else {
                        wmToaster.show(type, "", body, timeout, undefined, customNotificationOnClick, customNotificationOnHide);
                    }
                } else {
                /* get the callback scope for the variable based on its owner */
                    if (variableOwner === "Application") {
                        scope = $rootScope || {};
                    } else {
                        scope = options.scope.$$childTail || {};
                    }

                    DialogService.showDialog(dialogId, {
                        resolve: {
                            dialogParams: function () {
                                return {
                                    notificationDetails: {
                                        'text': variable.dataBinding.text,
                                        'okButtonText': variable.dataBinding.okButtonText,
                                        'cancelButtonText': variable.dataBinding.cancelButtonText,
                                        'alerttype': variable.dataBinding.alerttype,
                                        'onOk': variableName + "onOk",
                                        'onCancel': variableName + "onCancel",
                                        'onClose': variableName + "onClose"
                                    },
                                    onOk: function () {
                                        if (variable.onOk.trim()) {
                                            if (WM.isFunction(scope[variableName + "onOk"])) {
                                                scope[variableName + "onOk"](variable, null);
                                            } else {
                                                $rootScope.$emit('invoke-service', variable.onOk, {scope: scope});
                                            }
                                        }
                                        DialogService.hideDialog(dialogId);
                                    },
                                    onCancel: function () {
                                        if (variable.onCancel.trim()) {
                                            if (WM.isFunction(scope[variableName + "onCancel"])) {
                                                scope[variableName + "onCancel"](variable, null);
                                            } else {
                                                $rootScope.$emit('invoke-service', variable.onCancel, {scope: scope});
                                            }
                                        }
                                        DialogService.hideDialog(dialogId);
                                    },
                                    onClose: function () {
                                        if (variable.onClose.trim()) {
                                            if (WM.isFunction(scope[variableName + "onClose"])) {
                                                scope[variableName + "onClose"](variable, null);
                                            } else {
                                                $rootScope.$emit('invoke-service', variable.onClose, {scope: scope});
                                            }
                                        }
                                        DialogService.hideDialog(dialogId);
                                    }
                                };
                            }
                        },
                        scope: scope
                    });
                }
            },
            getOperation: function (variable) {
                return variable.operation;
            },
            getMessage: function (variable) {
                return variable.dataBinding.text;
            },
            setMessage: function (variable, text) {
                if (typeof text === 'string') {
                    variable.dataBinding.text = text;
                }
                return variable.dataBinding.text;
            },
            getOkButtonText: function (variable) {
                return variable.dataBinding.okButtonText;
            },
            setOkButtonText: function (variable, text) {
                if (typeof text === 'string') {
                    variable.dataBinding.okButtonText = text;
                }
                return variable.dataBinding.okButtonText;
            },

            getToasterDuration: function (variable) {
                return variable.dataBinding.duration;
            },
            setToasterDuration: function (variable, duration) {
                variable.dataBinding.duration = duration;
                return variable.dataBinding.duration;
            },
            getToasterClass: function (variable) {
                return variable.dataBinding.class;
            },
            setToasterClass: function (variable, type) {
                if (typeof type === 'string') {
                    variable.dataBinding.class = type;
                }
                return variable.dataBinding.class;
            },
            getToasterPosition: function (variable) {
                return variable.dataBinding.class;
            },
            setToasterPosition: function (variable, position) {
                if (typeof position === 'string') {
                    variable.dataBinding.position = position;
                }
                return variable.dataBinding.position;
            },

            getAlertType: function (variable) {
                return variable.dataBinding.alerttype;
            },
            setAlertType: function (variable, alerttype) {
                if (typeof alerttype === 'string') {
                    variable.dataBinding.alerttype = alerttype;
                }
                return variable.dataBinding.alerttype;
            },

            getCancelButtonText: function (variable) {
                return variable.dataBinding.cancelButtonText;
            },
            setCancelButtonText: function (variable, text) {
                if (typeof text === 'string') {
                    variable.dataBinding.cancelButtonText = text;
                }
                return variable.dataBinding.cancelButtonText;
            }
        },
        basicVariableObj = {
            notify: function (options) {
                options.scope = this.activeScope;
                methods.notify(this, options);
            },
            getOperation: function () {
                return methods.getOperation(this, {scope: this.activeScope});
            },
            getMessage: function () {
                return methods.getMessage(this);
            },
            setMessage: function (text) {
                return methods.setMessage(this, text);
            },
            getOkButtonText: function () {
                return methods.getOkButtonText(this);
            },
            setOkButtonText: function (text) {
                return methods.setOkButtonText(this, text);
            },
            getToasterDuration: function () {
                return methods.getToasterDuration(this);
            },
            setToasterDuration: function (duration) {
                return methods.setToasterDuration(this, duration);
            },
            getToasterClass: function () {
                return methods.getToasterClass(this);
            },
            setToasterClass: function (type) {
                return methods.setToasterClass(this, type);
            },
            getToasterPosition: function () {
                return methods.getToasterPosition(this);
            },
            setToasterPosition: function (position) {
                return methods.setToasterPosition(this, position);
            },
            getAlertType: function () {
                return methods.getAlertType(this);
            },
            setAlertType: function (alerttype) {
                return methods.setAlertType(this, alerttype);
            },
            getCancelButtonText: function () {
                return methods.getCancelButtonText(this);
            },
            setCancelButtonText: function (text) {
                return methods.setCancelButtonText(this, text);
            }
        };

    /* register the variable to the base service*/
    BaseVariablePropertyFactory.register('wm.NotificationVariable', basicVariableObj, [], methods);

    return {

    };
};

/*global WM, _ */
/*jslint todo: true */
/*Directive for Accordion */
WM.module('wm.layouts.containers')
    .run(['$templateCache', function ($templateCache) {
        'use strict';

        $templateCache.put('template/layout/container/accordion.html', '<div class="app-accordion panel-group" wmtransclude init-widget data-ng-show="show" apply-styles="scrollable-container" data-ng-style="{width:width}"></div>');

        $templateCache.put('template/layout/container/accordion-pane.html',
            '<div class="app-accordion-panel panel panel-default" init-widget wmtransclude data-ng-show="show" wm-navigable-element="true"></div>'
            );

        $templateCache.put('template/layout/container/accordion-header.html',
                '<div class="panel-heading" data-ng-click="pane.togglePane()" init-widget apply-styles="container">' +
                    '<h3 class="panel-title">' +
                        '<a href="javascript:void(0);" class="accordion-toggle" wmtransclude></a>' +
                    '</h3>' +
                    '<div class="panel-actions"><span class="label label-{{badgetype}}">{{badgevalue}}</span><button type="button" class="app-icon glyphicon panel-action" data-ng-class="pane.active ? \'glyphicon-minus\': \'glyphicon-plus\'"></button></div>' +
                '</div>'
            );
        $templateCache.put('template/layout/container/accordion-content.html',
                '<div class="panel-collapse collapse"  data-ng-class="pane.active ? \'collapse in\' : \'collapse\'" init-widget page-container apply-styles="scrollable-container">' +
                    '<div class="panel-body" wmtransclude page-container-target></div>' +
                '</div>'
            );
    }])
    .directive('wmAccordion', ['$templateCache', 'WidgetUtilService', 'PropertiesFactory', 'Utils', function ($templateCache, WidgetUtilService, PropertiesFactory, Utils) {
        'use strict';

        var widgetProps = PropertiesFactory.getPropertiesOf('wm.accordion', ['wm.base',  'wm.containers']);

        return {
            'restrict': 'E',
            'replace': true,
            'scope': {},
            'transclude': true,
            'template': $templateCache.get('template/layout/container/accordion.html'),
            'controller': function ($scope) {
                /* Contains the isolateScopes of accordion-panes. */
                this.panes = [];

                /* save the scope of the accordion-pane */
                this.register = function (paneScope) {
                    this.panes.push(paneScope);
                };

                /* function to collapse the accordion-panes */
                this.closeOthers = function () {
                    /* process the request only when closeothers attribute is present on accordion */
                    if ($scope.closeothers) {
                        WM.forEach(this.panes, function (pane) {
                            if (pane.active) {
                                /* trigger the onCollapse method on the pane which is about to be collapsed */
                                Utils.triggerFn(pane.onCollapse);
                            }
                            /* update the `active` flag of the pane */
                            pane.active = false;
                        });
                    }
                };
            },
            'compile': function () {
                return {
                    'pre': function (scope) {
                        scope.widgetProps = widgetProps;
                    },
                    'post': function (scope, element, attrs, ctrl) {
                        var defaultPane;
                        defaultPane = _.find(ctrl.panes, function (pane) { return pane.isdefaultpane; }) || ctrl.panes[0];
                        defaultPane.expand();

                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }])
    .directive('wmAccordionpane', ['$templateCache', 'WidgetUtilService', 'PropertiesFactory', 'Utils', '$parse', function ($templateCache, WidgetUtilService, PropertiesFactory, Utils, $parse) {
        'use strict';

        var widgetProps = PropertiesFactory.getPropertiesOf('wm.accordionpane', ['wm.base']);

        return {
            'restrict': 'E',
            'replace': true,
            'scope': {},
            'transclude': true,
            'template': $templateCache.get('template/layout/container/accordion-pane.html'),
            'require': '^wmAccordion',
            'controller': function ($scope, $element) {
                /* returns the scope of the accordion pane. accordion-header and accordion-content uses this */
                this.getPaneScope = function () {
                    return $scope;
                };

                this.registerCallback = function (name, value) {
                    if (!name || !value) {
                        return;
                    }

                    var fn = $parse(value);
                    $scope[name] = function (locals) {
                        locals = locals || {};
                        locals.$scope = $scope;
                        return fn($element.scope(), locals);
                    };
                };
            },
            'compile': function () {
                return {
                    'pre': function (scope) {
                        scope.widgetProps = widgetProps;
                    },
                    'post': function (scope, element, attrs, panesCtrl) {

                        /* register accordion-pane with accordion */
                        panesCtrl.register(scope);

                        /* toggle the state of the pane */
                        scope.togglePane = function () {
                            /* flip the active flag */
                            var flag = !scope.active;
                            if (flag) {
                                /* some widgets like charts needs to be redrawn when a accordion pane becomes active for the first time */
                                element.find('.ng-isolate-scope')
                                    .each(function () {
                                        Utils.triggerFn(WM.element(this).isolateScope().redraw);
                                    });
                                // when accordionContent is set to display external page, triggering $lazyLoad on expand of the accordion pane will render the content.
                                Utils.triggerFn(scope.accordionContent.$lazyLoad);
                                /* trigger the onExpand call back */
                                Utils.triggerFn(scope.onExpand);
                                panesCtrl.closeOthers(scope);
                            } else {
                                /* trigger the onCollapse callback */
                                Utils.triggerFn(scope.onCollapse);
                            }

                            scope.active = flag;
                        };

                        /* Expose the method `expand` on pane. Triggering this method will expand the pane. */
                        scope.expand = function () {
                            if (!scope.active) {
                                scope.togglePane();
                            }
                        };

                        /* Expose the method `collapse` on pane. Triggering this method will collapse the pane. */
                        scope.collapse = function () {
                            if (scope.active) {
                                scope.togglePane();
                            }
                        };

                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }])
    .directive('wmAccordionheader', ['$templateCache', 'WidgetUtilService', 'PropertiesFactory', '$compile', 'CONSTANTS', function ($templateCache, WidgetUtilService, PropertiesFactory, $compile, CONSTANTS) {
        'use strict';

        var widgetProps = PropertiesFactory.getPropertiesOf('wm.accordionheader', ['wm.base', 'wm.layouts']);

        return {
            'restrict': 'E',
            'replace': true,
            'scope': {},
            'transclude': true,
            'template': $templateCache.get('template/layout/container/accordion-header.html'),
            'require': '^wmAccordionpane',
            'compile': function () {
                return {
                    'pre': function (scope) {
                        scope.widgetProps = widgetProps;
                        if (scope.widgetProps.show) {
                            delete scope.widgetProps.show;// show property should be handled from pane.
                        }
                    },
                    'post': function (scope, element, attrs, paneCtrl) {
                        var transcludeTarget = element.find('[wmtransclude]'),
                            template;

                        if (transcludeTarget.children().length === 0) { /* if there is no transcluded content, use the default template for the header */
                            template =
                                '<i class="app-icon panel-icon {{iconclass}}" data-ng-show="iconclass"></i>' +
                                '<span class="heading" data-ng-bind-html="heading"></span>' +
                                '<span class="description" data-ng-bind-html="description"></span>';
                            transcludeTarget.append($compile(template)(scope));
                        }
                        scope.pane = paneCtrl.getPaneScope();
                        scope.pane.isdefaultpane = scope.isdefaultpane;

                        if (CONSTANTS.isRunMode) {
                            if (attrs.onExpand) {
                                paneCtrl.registerCallback('onExpand', attrs._onExpand || attrs.onExpand);
                            }

                            if (attrs.onCollapse) {
                                paneCtrl.registerCallback('onCollapse', attrs._onCollapse || attrs.onCollapse);
                            }
                        }

                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]).directive('wmAccordioncontent', ['$templateCache', 'WidgetUtilService', 'PropertiesFactory', 'CONSTANTS', 'Utils', function ($templateCache, WidgetUtilService, PropertiesFactory, CONSTANTS, Utils) {
        'use strict';

        var widgetProps = PropertiesFactory.getPropertiesOf('wm.accordioncontent', ['wm.base', 'wm.layouts',  'wm.containers']);

        return {
            'restrict': 'E',
            'replace': true,
            'scope': {},
            'transclude': true,
            'template': $templateCache.get('template/layout/container/accordion-content.html'),
            'require': '^wmAccordionpane',
            'compile': function () {
                return {
                    'pre': function (iScope) {

                        if (CONSTANTS.isStudioMode) {
                            iScope.widgetProps = Utils.getClonedObject(widgetProps);
                            delete iScope.widgetProps.show;
                        } else {
                            iScope.widgetProps = widgetProps;
                        }

                        // define $lazyLoad method on iScope.
                        // pageContainer widget will override this.
                        iScope.$lazyLoad = WM.noop;
                    },
                    'post': function (iScope, element, attrs, paneCtrl) {
                        iScope.pane = paneCtrl.getPaneScope();

                        // save a reference of accordionContent in accordionPane
                        // accordionPane will use this reference to trigger $lazyLoad method.
                        iScope.pane.accordionContent = iScope;

                        // define isActive property on the iScope of accordion content.
                        // this property will be used by page-container directive.
                        // when content property is set, the page corresponding to the value of content will be loaded on demand.
                        // if the pane is active (i.e, expanded) page will be loaded immediately.
                        Object.defineProperty(iScope, 'isActive', {
                            get: function () {
                                return this.pane.active;
                            }
                        });
                        WidgetUtilService.postWidgetCreate(iScope, element, attrs);
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.layouts.containers.directive:wmAccordion
 * @restrict E
 *
 * @description
 * The `wmAccordion` directive defines accordion widget. <br>
 * wmAccordion can only contain wmAccordionpane widgets. <br>
 * wmAccordion can not be inside wmAccordion. <br>
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires $templateCache
 * @requires WidgetUtilService
 *
 * @param {string=} name
 *                  Name of the accordion.
 * @param {string=} tabindex
 *                  The tabindex attribute specifies the tab order of an element.
 * @param {string=} width
 *                  Width of the accordion.
 * @param {string=} height
 *                  Height of the accordion.
 * @param {boolean=} show
 *                  Show is a bindable property. <br>
 *                  This property will be used to show/hide the accordion on the web page. <br>
 *                  default value: `true`.
 * @param {boolean=} closeothers
 *                  True value for closeothers property will collapse the panes that are expanded on expand of a pane. <br>
 *                  False value for closeothers property will not collapse the expaneded panes on expand of a pane. <br>
 *                  Default value: `true`.
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
                <wm-accordion width="400px" height="400px" closeothers="false" horizontalalign='right'>
                    <wm-accordionpane>
                        <wm-accordionheader heading="pane1"></wm-accordionheader>
                        <wm-accordioncontent>content of the pane1</wm-accordioncontent>
                    </wm-accordionpane>
                    <wm-accordionpane>
                        <wm-accordionheader heading="pane2"></wm-accordionheader>
                        <wm-accordioncontent>content of pane 2</wm-accordioncontent>
                    </wm-accordionpane>
                </wm-accordion>
            </div>
        </file>
        <file name="script.js">
            function Ctrl($scope) {}
        </file>
    </example>
 */


/**
 * @ngdoc directive
 * @name wm.layouts.containers.directive:wmAccordionpane
 * @restrict E
 *
 * @description
 * The `wmAccordionpane` directive defines accordion-pane widget. <br>
 * wmAccordionpane can be used only inside wmAccordion. <br>
 * wmAccordionpane can not be inside wmAccordionpane. <br>
 * accordion-pane can be expanded/collapsed using the scope methods expand/collapse respectively.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires $templateCache
 * @requires WidgetUtilService
 *
 * @param {string=} name
 *                  Name of the accordionpane.
 * @param {boolean=} show
 *                  Show is a bindable property. <br>
 *                  This property will be used to show/hide the accordion on the web page. <br>
 *                  Default value: `true`.
 * @param {string=} on-expand
 *                  Callback function which will be triggered when the pane is expanded.
 * @param {string=} on-collapse
 *                  Callback function which will be triggered when the pane is collapsed.
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
                <wm-accordion>
                    <wm-accordionpane on-expand="expandCallback()" on-collapse="collapseCallback()">
                        <wm-accordionheader heading="pane1"></wm-accordionheader>
                        <wm-accordioncontent>content of the pane1</wm-accordioncontent>
                    </wm-accordionpane>
                    <wm-accordionpane>
                        <wm-accordionheader heading="pane2"></wm-accordionheader>
                        <wm-accordioncontent>content of pane 2</wm-accordioncontent>
                    </wm-accordionpane>
                </wm-accordion>
            </div>
        </file>
        <file name="script.js">
            function Ctrl($scope) {
                $scope.expandCallback = function () {
                    console.log("inside expand callback");
                }
                $scope.collapseCallback = function () {
                    console.log("inside collapse callback");
                }
            }
        </file>
    </example>
 */


/**
 * @ngdoc directive
 * @name wm.layouts.containers.directive:wmAccordionheader
 * @restrict E
 *
 * @description
 * The `wmAccordionheader` directive defines accordion-header widget. <br>
 * wmAccordionheader can be used only inside wmAccordionpane. <br>
 * If there is no transcluded content, default template will be used. <br>
 *
 * Default template:<br>
 * &lt;i class="app-icon" data-ng-show = "iconsource"  data-ng-style ="{backgroundImage:iconsource}"&gt;&nbsp;&lt;/i&gt;
 *  {{heading}} <span class="description" data-ng-if="description"&gt; - { {description} }&lt;/span&gt;
 * &lt; class="app-icon" data-ng-class="pane.active ? panel-open-false: panel-open-true"&gt;&nbsp;&lt;/i&gt;
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires $templateCache
 * @requires WidgetUtilService
 * @requires $compile
 * @requires Utils
 *
 * @param {string=} name
 *                  Name of the accordionheader.
 * @param {string=} heading
 *                  Title of the header. <br>
 *                  This property is bindable. <br>
 *                  Default value: `Heading`. <br>
 *                  This is will be used only when the default template is used.
 * @param {string=} description
 *                  description of the accordion header. <br>
 *                  This is will be used only when the default template is used.
 * @param {string=} iconclass
 *                  Icon which we displayed on the header. <br>
 *                  This property is bindable. <br>
 *                  This is will be used only when the default template is used.
 * @param {boolean=} show
 *                  Show is a bindable property. <br>
 *                  This property will be used to show/hide the accordion on the web page. <br>
 *                  Default value: `true`.
 * @param {string=} horizontalalign
 *                  Align the content of the accordion-header to left/right/center. <br>
 *                  Default value: `left`.
 * @param {boolean=} isdefaultpane
 *                  This is a bindable property. <br>
 *                  It will be used to make one accordion pane open by default. <br>
 *                  Default value: `false`.
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
                <wm-accordion>
                    <wm-accordionpane>
                        <wm-accordionheader heading="{{heading1}}" description="{{description1}}"></wm-accordionheader>
                        <wm-accordioncontent>content of the pane1</wm-accordioncontent>
                    </wm-accordionpane>
                    <wm-accordionpane>
                    <wm-accordionheader><a><i class="default-pane-icon"></i><span>Pane2</span></a></wm-accordionheader>
                        <wm-accordioncontent>content of pane 2</wm-accordioncontent>
                    </wm-accordionpane>
                </wm-accordion>
            </div>
        </file>
        <file name="script.js">
            function Ctrl($scope) {
                $scope.heading1 = "Pane1";
                $scope.description1 = "this is pane1";
            }
        </file>
    </example>
 */


/**
 * @ngdoc directive
 * @name wm.layouts.containers.directive:wmAccordioncontent
 * @restrict E
 *
 * @description
 * The `wmAccordioncontent` directive defines accordion-content widget. <br>
 * wmAccordioncontent can be used only inside wmAccordionpane.
 *
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires $templateCache
 * @requires WidgetUtilService
 * @requires Utils
 *
 * @param {string=} name
 *                  Name of the accordioncontent.
 * @param {boolean=} show
 *                  Show is a bindable property. <br>
 *                  This property will be used to show/hide the accordion on the web page. <br>
 *                  Default value: `true`.
 * @param {string=} horizontalalign
 *                  Align the content of the accordion-content to left/right/center.
 *                  Default value: `left`.
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
                <wm-accordion>
                    <wm-accordionpane>
                        <wm-accordionheader heading="{{heading1}}" description="{{description1}}"></wm-accordionheader>
                        <wm-accordioncontent>
                            This is the content of Pane1
                            <wm-button caption="inside pane1" on-click="f()"></wm-button>
                        </wm-accordioncontent>
                    </wm-accordionpane>
                    <wm-accordionpane>
                        <wm-accordionheader><a><i class="default-pane-icon"></i><span>Pane2</span></a></wm-accordionheader>
                        <wm-accordioncontent>
                            {{pane2content}}
                        </wm-accordioncontent>
                    </wm-accordionpane>
                    <wm-accordionpane show="{{showPane3}}">
                        <wm-accordionheader heading="pane3"></wm-accordionheader>
                        <wm-accordioncontent>
                            this is pane 3
                        </wm-accordioncontent>
                    </wm-accordionpane>
                </wm-accordion>

                <wm-button on-click="toggle()" caption="{{showHidePane}}"></wm-button>
            </div>
        </file>
        <file name="script.js">
            function Ctrl($scope) {
                $scope.heading1 = "Pane1";
                $scope.description1 = "this is pane1";
                $scope.showPane3 = false;
                $scope.showHidePane = "Show Pane 3";

                $scope.f = function () {
                    console.log(" inside function f");
                }

                $scope.toggle = function () {
                    $scope.showPane3 = !$scope.showPane3;
                    if($scope.showPane3) {
                        $scope.showHidePane = "Hide Pane 3";
                    } else {
                        $scope.showHidePane = "Show Pane 3";
                    }
                }

                $scope.pane2content = "Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.";
            }
        </file>
    </example>
 */

/*global WM,_*/

/*Directive for Media List*/

WM.module('wm.layouts.containers')
    .run(['$templateCache', function ($tc) {
        'use strict';
        $tc.put('template/widget/medialist-design.html',
            '<div class="app-medialist" init-widget apply-styles="shell">' +
            '<div wmtransclude></div>' +
            '</div>'
        );
        $tc.put('template/widget/medialist.html',
            '<div class="app-medialist" data-ng-class="{\'singlerow\' : layout == \'Single-row\'}" init-widget>' +
                '<ul class="list-unstyled list-inline app-media-thumbnail" wmtransclude></ul>' +
                    '<div class="app-media-fullscreen" data-ng-show="selectedMediaIndex >= 0" hm-swipe-left="showNext()" hm-swipe-right="showPrev()">' +
                        '<wm-mobile-navbar on-backbtnclick="exitFullScreen();" show-leftnav="false" backbuttoniconclass="fa fa-chevron-left" title= "{{selectedMediaIndex+1}}/{{fieldDefs.length}}"></wm-mobile-navbar>' +
                        '<wm-content>' +
                             '<wm-page-content>' +
                                '<div class="app-content-column">' +
                                        '<div class="image-container">' +
                                            '<img class="center-block" data-ng-src="{{fieldDefs[selectedMediaIndex][mediaurl]}}">' +
                                                '<a class="app-media-fullscreen-nav-control left" data-ng-show="selectedMediaIndex > 0" data-ng-click="showNext()">' +
                                                    '<i class="glyphicon glyphicon-menu-left"></i>' +
                                                '</a>' +
                                                '<a class="app-media-fullscreen-nav-control right" data-ng-show="selectedMediaIndex < fieldDefs.length-1" data-ng-click="showPrev()">' +
                                                    '<i class="glyphicon glyphicon-menu-right"></i>' +
                                                '</a>' +
                                         '</div>' +
                                 '</div>' +
                                '</wm-page-content>' +
                            '</wm-content>' +
                    '</div>' +
            '</div>'
            );
        $tc.put('template/widget/medialist-template.html',
            '<div init-widget data-ng-style="{\'width\': width, \'height\': height}" class="app-medialist-template thumbnail">' +
                '<img class="thumbnail-image-template" data-ng-src="{{imagesource}}">' +
                '<div class="thumbnail-details" wmtransclude></div>' +
            '</div>'
            );

    }])
    .directive('wmMediaList', [
        '$templateCache',
        '$compile',
        'PropertiesFactory',
        'WidgetUtilService',
        'CONSTANTS',
        'Utils',
        function ($templateCache, $compile, PropertiesFactory, WidgetUtilService, CONSTANTS, Utils) {
            'use strict';
            var widgetProps = PropertiesFactory.getPropertiesOf('wm.medialist', ['wm.base', 'wm.base.editors']),
                notifyFor = {
                    'dataset': true
                },
                directiveDefn,
                elementsMarkup =
                    '<li data-ng-repeat="item in fieldDefs" class="app-media-item" data-ng-click="showFullScreen($index)">' +
                        '<div data-ng-style="{\'width\': thumbnailWidth, \'height\': thumbnailHeight}" class="thumbnail">' +
                            '<img class="thumbnail-image" data-ng-src="{{item[thumbnailURL]}}">' +
                            '<div class="thumbnail-details"></div>' +
                        '</div>' +
                    '</li>';

            function controllerFn() {
                var _map = {};

                this.$set = function (key, value) {
                    _map[key] = value;
                };

                this.$get = function (key) {
                    return _map[key];
                };
            }

            // Template function for MediaList
            function templateFn() {
                if (CONSTANTS.isStudioMode) {
                    return $templateCache.get('template/widget/medialist-design.html');
                }
                return $templateCache.get('template/widget/medialist.html');
            }

            function updatePropertyPanelOptions(dataset, propertiesMap, scope) {
                var variableKeys = [],
                    wp = scope.widgetProps;
                if (WM.isObject(dataset)) {
                    variableKeys = WidgetUtilService.extractDataSetFields(dataset, propertiesMap);
                    /*removing keys of null and object type*/
                    variableKeys = variableKeys.filter(function (variableKey) {
                        return (dataset[variableKey] !== null) && !WM.isObject(dataset[variableKey]);
                    });
                }
                wp.thumbnailurl.options = wp.mediaurl.options = [''].concat(variableKeys);
            }

            /** With given data, creates media list items*/
            function updateFieldDefs($is, $el, data) {
                $is.fieldDefs = data;
                if (CONSTANTS.isRunMode) {
                    $is.$mediaScope.fieldDefs = data;
                }
            }

            function getVariable($is, variableName) {

                if (!variableName) {
                    return undefined;
                }

                var variables = $is.Variables || {};
                return variables[variableName];
            }

            function onDataChange($is, $el, nv) {
                if (nv) {
                    if (nv.data) {
                        nv = nv.data;
                    } else {
                        if (!_.includes($is.binddataset, 'bind:Widgets.')) {
                            var boundVariableName = Utils.getVariableName($is),
                                variable = getVariable($is, boundVariableName);
                            // data from the live list must have .data filed
                            if (variable && variable.category === 'wm.LiveVariable') {
                                return;
                            }
                        }
                    }

                    /*If the data is a pageable object, then display the content.*/
                    if (WM.isObject(nv) && Utils.isPageable(nv)) {
                        nv = nv.content;
                    }

                    if (WM.isObject(nv) && !WM.isArray(nv)) {
                        nv = [nv];
                    }
                    if (!$is.binddataset) {
                        if (WM.isString(nv)) {
                            nv = nv.split(',');
                        }
                    }
                    if (WM.isArray(nv)) {
                        updateFieldDefs($is, $el, nv);
                    }
                } else {
                    if (CONSTANTS.isRunMode) {
                        updateFieldDefs($is, $el, []);
                    }
                }
            }

            /** In case of run mode, the field-definitions will be generated from the markup*/
            /* Define the property change handler. This function will be triggered when there is a change in the widget property */
            function propertyChangeHandler($is, $el, attrs, key, nv, ov) {
                if (key === 'dataset') {
                    onDataChange($is, $el, nv);
                    if (CONSTANTS.isStudioMode) {
                        updatePropertyPanelOptions(nv, nv.propertiesMap, $is);
                    }
                }
            }

            // append the template content to the list item wrapper.
            function applyWrapper($tmplContent) {
                var tmpl = WM.element(elementsMarkup);
                tmpl.find('> div > .thumbnail-details').append($tmplContent);
                return tmpl;
            }

            // replace all the bind values and append to the listitem template.
            function prepareMediaListTemplate(tmpl, attrs) {
                var $tmpl = WM.element(tmpl),
                    $div = WM.element('<div></div>').append($tmpl);

                Utils.updateTmplAttrs($div, attrs.dataset);
                $tmpl = applyWrapper($tmpl);

                return $tmpl;
            }

            // pre link function of studio directive
            function preLinkFn($is) {
                $is.widgetProps = CONSTANTS.isStudioMode ? Utils.getClonedObject(widgetProps) : widgetProps;
            }

            // Create child scope out of the isolateScope
            function createChildScope($is, $el, listCtrl) {
                var _scope = $el.scope(), // scop which inherits controller's scope
                    $liScope = _scope.$new(),  // create a new child scope. List Items will be compiled with this scope.
                    thumbnailDim = listCtrl.$get('thumbnailDimensions');

                WM.extend($liScope, {
                    'thumbnailURL'      : $is.thumbnailurl,
                    'thumbnailWidth'    : thumbnailDim.width,
                    'thumbnailHeight'   : thumbnailDim.height
                });

                return $liScope;
            }

            function runMode_postLinkFn($is, $el, attrs, listCtrl) {
                var $mediaTemplate,
                    $mediaScope = createChildScope($is, $el, listCtrl);
                $is.$mediaScope = $mediaScope;
                $mediaTemplate = prepareMediaListTemplate(listCtrl.$get('mediaListTemplate'), attrs);
                $el.find('> ul').append($mediaTemplate);
                $compile($mediaTemplate)($mediaScope);
                $mediaScope.showFullScreen = function (index) {
                    if (index < $mediaScope.fieldDefs.length) {
                        $is.selectedMediaIndex = index;
                    }
                };
                $is.exitFullScreen = function () {
                    $is.selectedMediaIndex = -1;
                };
                $is.showPrev = function () {
                    $mediaScope.showFullScreen($is.selectedMediaIndex + 1);
                };
                $is.showNext = function () {
                    $mediaScope.showFullScreen($is.selectedMediaIndex - 1);
                };
                /* register the property change handler */
                WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, $is, $el, attrs), $is, notifyFor);
                WidgetUtilService.postWidgetCreate($is, $el, attrs);
            }

            // post link function of studio directive
            function studioMode_postLinkFn($is, $el, attrs) {
                WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, $is, $el, attrs), $is, notifyFor);
                WidgetUtilService.postWidgetCreate($is, $el, attrs);
            }

            directiveDefn = {
                'restrict'   : 'E',
                'replace'    : true,
                'scope'      : {},
                'template'   : templateFn,
                'transclude' : true,
                'link': {
                    'pre': preLinkFn
                }
            };

            if (CONSTANTS.isRunMode) {
                directiveDefn.link.post  = runMode_postLinkFn;
                directiveDefn.controller = controllerFn;
            } else {
                directiveDefn.link.post = studioMode_postLinkFn;
            }
            return directiveDefn;
        }
    ])
    .directive('wmMediaTemplate', [
        'PropertiesFactory',
        'WidgetUtilService',
        'CONSTANTS',
        '$templateCache',
        'Utils',

        function (PropertiesFactory, WidgetUtilService, CONSTANTS, $tc, Utils) {
            'use strict';

            var widgetProps,
                directiveDefn = {
                    'restrict'  : 'E',
                    'replace'   : true
                };

            if (CONSTANTS.isStudioMode) {
                widgetProps = PropertiesFactory.getPropertiesOf('wm.layouts.mediatemplate');
            }

            // pre link function of studio directive
            function preLinkFn($is) {
                $is.widgetProps = widgetProps;
            }

            // post link function of studio directive
            function studioMode_postLinkFn($is, $el, attrs) {
                $is.imagesource = Utils.getImageUrl('resources/images/imagelists/default-image.png');
                WidgetUtilService.postWidgetCreate($is, $el, attrs);
            }

            function runMode_preLinkFn($is, $el, attrs, listCtrl) {
                listCtrl.$set('mediaListTemplate', $el.children());
                listCtrl.$set('thumbnailDimensions', {'width': attrs.width, 'height': attrs.height});
                $el.remove();
            }

            if (CONSTANTS.isStudioMode) {
                WM.extend(directiveDefn, {
                    'transclude': true,
                    'scope'     : {},
                    'template'  : $tc.get('template/widget/medialist-template.html'),
                    'link'      : {
                        'pre' : preLinkFn,
                        'post': studioMode_postLinkFn
                    }
                });
            } else {
                WM.extend(directiveDefn, {
                    'terminal': true,
                    'require' : '^wmMediaList',
                    'link'    : {
                        'pre' : runMode_preLinkFn
                    }
                });
            }

            return directiveDefn;
        }
    ]);


/**
 * @ngdoc directive
 * @name wm.layouts.container:wmMediaList
 * @restrict E
 *
 * @description
 * The `wmMedialist` directive defines a Media list widget. <br>
 *
 * @requires PropertiesFactory
 * @requires $templateCache
 * @requires WidgetUtilService
 * @requires $compile
 * @requires CONSTANTS
 * @requires Utils
 *
 * @param {string=} name
 *                  Name of the media list container.
 * @param {string=} width
 *                  Width of the media list container.
 * @param {string=} height
 *                  Height of the media list container.
 * @param {string=} layout
 *                  Sets the layout - single row/ multi row view for the media list.
 * @param {string=} dataset
 *                  Sets the data for the list.<br>
 *                  This is a bindable property.<br>
 *                  When bound to a variable, the data associated with the variable is displayed in the media list.
 * @param {string=} thumbnailurl
 *                  Sets the url to be used for each of the thumbnails shown in the media list. This is a bindable property.
 * @param {string=} mediaurl
 *                  Sets the url to be used for each of the mediaurls shown in the media list. This is a bindable property.
 * @param {boolean=} show
 *                  This is a bindable property. <br>
 *                  This property will be used to show/hide the media list on the web page. <br>
 *                  default value: `true`...
 */

/**
 * @ngdoc directive
 * @name wm.layouts.container:wmMediaTemplate
 * @restrict E
 *
 * @description
 * The `wmMediaTemplate` directive defines the template for Media list widget. <br>
 *
 * @requires PropertiesFactory
 * @requires $templateCache
 * @requires WidgetUtilService
 * @requires CONSTANTS
 * @requires Utils
 *
 * @param {string=} width
 *                  Sets the width of the thumbnail in both design mode and run-mode for the media list.
 * @param {string=} height
 *                  Sets the height of the thumbnail in both design mode and run-mode for the media list.
 *
 */

/*global WM, _*/

WM.module('wm.layouts.containers')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/layout/container/form.html',
                '<form role="form" data-ng-show="show" init-widget class="panel app-form" ng-class="[captionAlignClass, captionPositionClass, formClassName]"' +
                ' autocomplete="autocomplete" apply-styles="shell"' +
                ' ><div class="panel-heading" data-ng-if="title"><h4 class="form-header panel-title">{{title}}</h4></div>' +
                    '<div class="form-body panel-body" apply-styles="inner-shell">' +
                        '<wm-message scopedataset="statusMessage"></wm-message>' +
                        '<div wmtransclude></div>' +
                    '</div>' +
                    '</form>'
            );
    }])
    .directive('wmForm', ['$rootScope', 'PropertiesFactory', 'WidgetUtilService', '$compile', function ($rootScope, PropertiesFactory, WidgetUtilService, $compile) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.layouts.form', ['wm.base', 'wm.layouts', 'wm.base.events.touch']),
            notifyFor = {
                'captionsize': true,
                'novalidate': true,
                'autocomplete': true,
                'submitbutton': true,
                'resetbutton': true,
                'captionalign': true,
                'captionposition': true,
                'method': true,
                'action': true
            },
            submitBtnTemplate = '<wm-button class="form-submit" type="submit" caption="submit"></wm-button>';

        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
        function propertyChangeHandler(scope, element, attrs, key, newVal) {
            var value, resetBtnTemplate;
            switch (key) {
            case 'captionsize':
                element.find('.form-group .app-label.ng-isolate-scope').each(function () {
                    WM.element(this).isolateScope().width = newVal;
                });
                break;
            case 'captionalign':
                scope.captionAlignClass = "align-" + newVal;
                break;
            case 'captionposition':
                scope.captionPositionClass = "position-" + newVal;
                break;
            case 'novalidate':
                if (newVal === true || newVal === 'true') {
                    element.attr('novalidate', '');
                } else {
                    element.removeAttr('novalidate');
                }
                break;
            case 'autocomplete':
                value = (newVal === true || newVal === 'true') ? 'on' : 'off';
                element.attr(key, value);
                break;
            case 'submitbutton':
                if (newVal === true || newVal === 'true') {
                    element.append($compile(submitBtnTemplate)(scope));
                } else {
                    element.find('.form-submit').remove();
                }
                break;
            case 'resetbutton':
                if (newVal === true || newVal === 'true') {
                    resetBtnTemplate = $compile('<wm-button class="reset-submit" type="reset" caption="reset" ' + (!scope.widgetid ? 'on-click="resetForm();"' : '') + ' ></wm-button>')(scope);
                    element.append(resetBtnTemplate);
                } else {
                    element.find('.reset-submit').remove();
                }
                break;
            case 'method':
                scope.widgetProps.enctype.show = newVal === 'post';
                break;
            case 'action':
                attrs.$set('action', newVal);
                break;
            }
        }

        /*Called by users programatically.*/
        function resetForm(element) {
            resetFormFields(element);
        }

        function resetFormFields(element) {
            var eleScope = element.scope();
            element.find('[role="input"]').each(function () {
                WM.element(this).isolateScope().reset();
            });
            $rootScope.$safeApply(eleScope);
        }

        function bindEvents(scope, element) {
            var params,
                formData = {},
                formVariable,
                fieldTarget,
                formWidget;
            element.on('submit', function (event) {
                formVariable = element.scope().Variables[scope.formvariable];
                if (scope.onSubmit || formVariable) {
                    //Get all form fields and prepare form data as key value pairs
                    _.forEach(scope.formFields, function (field) {
                        fieldTarget = field.target.split('.');
                        if (fieldTarget.length === 1) {
                            formData[field.name] = field.value;
                        } else {
                            if (formVariable.category === 'wm.Variable') {
                                formData[fieldTarget[1]] = field.value;
                            } else {
                                formData[fieldTarget[0]] = formData[fieldTarget[0]] || {};
                                formData[fieldTarget[0]][fieldTarget[1]] = field.value;
                            }
                        }
                    });
                    //Form fields wont't contain grid widgets get those using attribute and add to form data
                    element.find('[isFormField="true"]').each(function () {
                        formWidget = WM.element(this).isolateScope();
                        fieldTarget = formWidget.name.split('.');
                        if (fieldTarget.length === 1) {
                            formData[formWidget.name] = formWidget.dataset;
                        } else {
                            formData[fieldTarget[0]] = formData[fieldTarget[0]] || {};
                            formData[fieldTarget[0]][fieldTarget[1]] = formWidget.dataset;
                        }
                    });
                    params = {$event: event, $scope: scope, $formData: scope.formdata};
                    //If on submit is there execute it and if it returns true do service variable invoke else return
                    if (scope.onSubmit && scope.onSubmit(params) === false) {
                        return;
                    }
                    scope.formdata = formData;
                    //If its a service variable call setInput and assign form data and invoke the service
                    if (formVariable && formVariable.category === 'wm.ServiceVariable') {
                        formVariable.setInput(formData);
                        formVariable.update({}, function () {
                            scope.statusMessage = {
                                'type'   : 'success',
                                'caption': scope.postmessage
                            };
                        }, function (errMsg) {
                            scope.statusMessage = {
                                'type'   : 'error',
                                'caption': errMsg
                            };
                        });
                    }
                }
            });
            /*clear the file uploader in the form*/
            element.bind('reset', function () {
                resetFormFields(element);
            });
        }

        return {
            'restrict': 'E',
            'replace': true,
            'scope': {},
            'transclude': true,
            'template': WidgetUtilService.getPreparedTemplate.bind(undefined, 'template/layout/container/form.html'),
            'compile': function () {
                return {
                    'pre': function (scope) {
                        /*Applying widget properties to directive scope*/
                        scope.widgetProps = widgetProps;
                    },
                    'post': function (scope, element, attrs) {
                        scope.statusMessage = undefined;
                        /* register the property change handler */
                        WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, scope, element, attrs), scope, notifyFor);

                        if (!scope.widgetid) {
                            bindEvents(scope, element);
                            scope.resetForm = resetForm.bind(undefined, element);
                        }
                        scope.formFields = element.scope().formFields;
                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.layouts.containers.directive:wmForm
 * @restrict E
 *
 * @description
 * The 'wmForm' directive defines a form in the layout.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 * @requires $compile
 *
 * @param {string=} title
 *                  Title of the form. This property is a bindable property.
 * @param {string=} name
 *                  Name of the form.
 * @param {string=} target
 *                  Defines the target for the form.
 * @param {string=} width
 *                  Width of the form.
 * @param {string=} height
 *                  Height of the form.
 * @param {string=} method
 *                  Defines the method to be used for submission of the form to the server [GET, POST].
 * @param {string=} action
 *                  Defines the action to be performed on successful submission of the form. This property is a bindable property.
 * @param {string=} enctype
 *                  enctype for form submit, i.e, encryption type for data submission, Example:"application/x-www-form-urlencoded", "multipart/form-data", "text/plain"
 * @param {string=} novalidate
 *                  Sets novalidate option for the form
 * @param {string=} autocomplete
 *                  Sets autocomplete for the form.
 * @param {string=} captionalign
 *                  Defines the alignment of the caption elements of widgets inside the form.<br>
 *                  Default value for captionalign is `left`.
 * @param {string=} captionposition
 *                  Defines the position of the caption elements of widgets inside the form.<br>
 *                  Default value for captionposition is `left`.
 * @param {string=} captionsize
 *                  Defines the size of the caption displayed inside the form.<br>
 *                  Default value for captionalign is `left`.
 * @param {string=} horizontalalign
 *                  Align the content of the accordion-content to left/right/center.
 *                  Default value: `left`.
 *                  Default value for autocomplete is `on`.
 * @param {string=} on-swipeup
 *                  Callback function for `swipeup` event.
 * @param {string=} on-swipedown
 *                  Callback function for `swipedown` event.
 * @param {string=} on-swiperight
 *                  Callback function for `swiperight` event.
 * @param {string=} on-swipeleft
 *                  Callback function for `swipeleft` event.
 * @param {string=} on-pinchin
 *                  Callback function for `pinchin` event.
 * @param {string=} on-pinchout
 *                  Callback function for `pinchout` event.
 * @param {string=} on-submit
 *                  Callback function for `submit` event.
 *
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
                <wm-form title="Form" class="panel-default" height="300">
                    <wm-layoutgrid>
                        <wm-gridrow>
                            <wm-gridcolumn>
                                <wm-composite>
                                    <wm-label class="col-md-3" caption="Name"></wm-label>
                                    <wm-container class="col-md-9">
                                        <wm-text tabindex="1" placeholder="Enter Name"></wm-text>
                                    </wm-container>
                                </wm-composite>
                            </wm-gridcolumn>
                        </wm-gridrow>
                        <wm-gridrow>
                            <wm-gridcolumn>
                                <wm-composite>
                                    <wm-label class="col-md-3" caption="Type"></wm-label>
                                    <wm-container class="col-md-9">
                                        <wm-select tabindex="3" dataset="Option 1, Option 2, Option 3" datavalue="Option 3"></wm-select>
                                    </wm-container>
                                </wm-composite>
                            </wm-gridcolumn>
                        </wm-gridrow>
                        <wm-gridrow>
                            <wm-gridcolumn>
                                <wm-composite horizontalalign="left">
                                    <wm-label class="col-md-3" caption="Description"></wm-label>
                                    <wm-container class="col-md-9">
                                        <wm-textarea tabindex="4" placeholder="Enter Description"></wm-textarea>
                                    </wm-container>
                                </wm-composite>
                            </wm-gridcolumn>
                        </wm-gridrow>
                    </wm-layoutgrid>
                    <wm-buttongroup horizontalalign="right" class="form-action col-md-12">
                        <wm-button caption="Reset" type="reset" class="btn-secondary"></wm-button>
                        <wm-button caption="Cancel" type="button" class="btn-warning"></wm-button>
                        <wm-button caption="Save" type="submit" class="btn-primary"></wm-button>
                    </wm-buttongroup>
                </wm-form>
            </div>
        </file>
         <file name="script.js">
             function Ctrl($scope) {}
         </file>
    </example>
 */

/*global WM*/

/*Directive for Layout Grid */

WM.module('wm.layouts.containers')
    .directive('wmLayoutgrid', [
        'PropertiesFactory',
        'WidgetUtilService',
        'CONSTANTS',
        '$rootScope',
        '$compile',

        function (PropertiesFactory, WidgetUtilService, CONSTANTS, $rs, $compile) {
            'use strict';

            var widgetProps = PropertiesFactory.getPropertiesOf('wm.layouts.layoutgrid', ['wm.layouts']),
                notifyFor = CONSTANTS.isStudioMode ? {'columns': true} : undefined;

            /* Applies default width to columns which don't already have their width set. */
            function setDefaultColumnWidth($grid) {

                var $gridRows;

                $gridRows = $grid.children('.app-grid-row');

                $gridRows.each(function () {
                    var $row = WM.element(this),
                        $columns = $row.children('.app-grid-column'),
                        cols = [],
                        defaultWidth,
                        totalColWidth = 12;

                    $columns.each(function () {
                        var $col = WM.element(this),
                            width = $col.attr('columnwidth');
                        if (width) {
                            totalColWidth -= width;
                        } else {
                            cols.push($col);
                        }
                    });

                    if (cols.length) {
                        defaultWidth = parseInt(totalColWidth / cols.length, 10);

                        cols.forEach(function ($col) {
                            $col.isolateScope().columnwidth = defaultWidth;
                        });
                    }

                });
            }

            function propertyChangeHandler($s, $is, $el, key, nv) {

                if (!$is._isInitialized) {
                    return;
                }

                if (key === 'columns') {
                    $rs.$emit('update-layoutgrid-columns', $is.widgetid, +nv, function (markup) {
                        // remove the existing contents.
                        $el.contents().remove();
                        // add the updated markup
                        $el.append(markup);
                        // compile the contents.
                        $compile($el.contents())($s);
                        // update the columnwidth of columns.
                        setDefaultColumnWidth($el);
                    });
                }
            }

            return {
                'restrict': 'E',
                'replace': true,
                'scope': {},
                'transclude': true,
                'template': '<div init-widget class="app-grid-layout clearfix" data-ng-show="show" apply-styles="container" wmtransclude></div>',
                'link': {
                    'pre': function ($is) {
                        /*Applying widget properties to directive scope*/
                        $is.widgetProps = widgetProps;
                    },

                    'post': function ($is, $el, attrs) {

                        setDefaultColumnWidth($el);

                        if (CONSTANTS.isStudioMode) {
                            WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, $el.scope(), $is, $el), $is, notifyFor);
                        }
                        WidgetUtilService.postWidgetCreate($is, $el, attrs);
                    }
                }
            };
        }
    ])
    .directive('wmGridrow', ['PropertiesFactory', 'WidgetUtilService', function (PropertiesFactory, WidgetUtilService) {
        'use strict';

        var widgetProps = PropertiesFactory.getPropertiesOf('wm.layouts.gridrow', ['wm.layouts']),
            notifyFor = {
                'height': true
            };
        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
        function propertyChangeHandler(scope, key) {
            switch (key) {
            case 'height':
                scope.overflow = "auto";
                break;
            }
        }
        return {
            'restrict': 'E',
            'replace': true,
            'scope': {},
            'transclude': true,
            'template': '<div init-widget data-ng-class="show" class="app-grid-row clearfix" apply-styles="container" wmtransclude></div>',
            'compile': function () {
                return {
                    'pre': function (scope) {
                        /*Applying widget properties to directive scope*/
                        scope.widgetProps = widgetProps;
                    },
                    'post': function (scope, element, attrs) {
                        /* register the property change handler */
                        WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, scope), scope, notifyFor);
                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }])
    .directive('wmGridcolumn', ['PropertiesFactory', 'WidgetUtilService', '$rootScope', function (PropertiesFactory, WidgetUtilService, $rootScope) {
        'use strict';

        var widgetProps = PropertiesFactory.getPropertiesOf('wm.layouts.gridcolumn', ['wm.layouts']),
            notifyFor = {
                'columnwidth': true
            },
            prefix = $rootScope.isMobileApplicationType ? 'col-xs-' : 'col-sm-';

        function setColumnWidth(element, nv, ov) {
            element.removeClass(prefix + ov).addClass(prefix + nv);
        }

        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
        function propertyChangeHandler(element, key, newVal, oldVal) {
            switch (key) {
            case 'columnwidth':
                setColumnWidth(element, newVal, oldVal);
                break;
            }
        }

        return {
            'restrict': 'E',
            'replace': true,
            'scope': {},
            'transclude': true,
            'template': '<div init-widget data-ng-class="show" class="app-grid-column" apply-styles="container"><div class="app-ng-transclude" wmtransclude></div></div>',
            'compile': function () {
                return {
                    'pre': function (scope, element, attrs) {
                        /*Applying widget properties to directive scope*/
                        scope.widgetProps = widgetProps;
                        /* If column width is specified, apply it, else layout grid will apply default width. */
                        if (attrs.columnwidth) {
                            setColumnWidth(element, attrs.columnwidth);
                        }
                    },
                    'post': function (scope, element, attrs) {
                        /* register the property change handler */
                        WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, element), scope, notifyFor);

                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]);

/*Directive for Layout Grid */

/**
 * @ngdoc directive
 * @name wm.layouts.containers.directive:wmLayoutgrid
 * @restrict E
 *
 * @description
 * The 'wmLayoutgrid' directive defines a layout for rows and columns.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 * @requires $rootScope
 *
 * @param {string=} name
 *                  Name of the grid.
 * @param {number=} columns
 *                  Defines the number of columns per row. <br>
 *                  When this property is changed in studio mode, grid layout will be re-arranged accordingly. <br>
 * @param {string=} insert
 *                  Inserts a row in the grid.
 * @param {boolean=} width
 *                  Width for the grid.
 * @param {boolean=} height
 *                  Height for the grid.
 * @param {boolean=} horizontalalign
 *                  Align the content of the geid to left/right/center. <br>
 *                  Default value: `left`. <br>
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
                <wm-layoutgrid>
                    <wm-gridrow>
                        <wm-gridcolumn columnwidth="4" height="100" backgroundcolor="#008B8B"></wm-gridcolumn>
                        <wm-gridcolumn columnwidth="4" height="100" backgroundcolor="#FF1493"></wm-gridcolumn>
                        <wm-gridcolumn columnwidth="4" height="100" backgroundcolor="#9932CC"></wm-gridcolumn>
                    </wm-gridrow>
                    <wm-gridrow>
                        <wm-gridcolumn columnwidth="4" height="100" backgroundcolor="#8FBC8F"></wm-gridcolumn>
                        <wm-gridcolumn columnwidth="4" height="100" backgroundcolor="#1E90FF"></wm-gridcolumn>
                        <wm-gridcolumn columnwidth="4" height="100" backgroundcolor="#CD5C5C"></wm-gridcolumn>
                    </wm-gridrow>
                    <wm-gridrow>
                        <wm-gridcolumn columnwidth="4" height="100" backgroundcolor="#ADD8E6"></wm-gridcolumn>
                        <wm-gridcolumn columnwidth="4" height="100" backgroundcolor="#F08080"></wm-gridcolumn>
                        <wm-gridcolumn columnwidth="4" height="100" backgroundcolor="#20B2AA"></wm-gridcolumn>
                    </wm-gridrow>
                </wm-layoutgrid>
            </div>
        </file>
        <file name="script.js">
            function Ctrl($scope) {}
        </file>
    </example>
 */

/**
 * @ngdoc directive
 * @name wm.layouts.containers.directive:wmGridrow
 * @restrict E
 *
 * @description
 * The 'wmGridrow' directive defines a row for a layoutgrid.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 * @requires $rootScope
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
                <wm-layoutgrid>
                    <wm-gridrow>
                        <wm-gridcolumn columnwidth="4" height="100" backgroundcolor="#008B8B"></wm-gridcolumn>
                        <wm-gridcolumn columnwidth="4" height="100" backgroundcolor="#FF1493"></wm-gridcolumn>
                        <wm-gridcolumn columnwidth="4" height="100" backgroundcolor="#9932CC"></wm-gridcolumn>
                    </wm-gridrow>
                    <wm-gridrow>
                        <wm-gridcolumn columnwidth="4" height="100" backgroundcolor="#8FBC8F"></wm-gridcolumn>
                        <wm-gridcolumn columnwidth="4" height="100" backgroundcolor="#1E90FF"></wm-gridcolumn>
                        <wm-gridcolumn columnwidth="4" height="100" backgroundcolor="#CD5C5C"></wm-gridcolumn>
                    </wm-gridrow>
                    <wm-gridrow>
                        <wm-gridcolumn columnwidth="4" height="100" backgroundcolor="#ADD8E6"></wm-gridcolumn>
                        <wm-gridcolumn columnwidth="4" height="100" backgroundcolor="#F08080"></wm-gridcolumn>
                        <wm-gridcolumn columnwidth="4" height="100" backgroundcolor="#20B2AA"></wm-gridcolumn>
                    </wm-gridrow>
                </wm-layoutgrid>
            </div>
        </file>
        <file name="script.js">
            function Ctrl($scope) {}
        </file>
    </example>
 */

 /**
 * @ngdoc directive
 * @name wm.layouts.containers.directive:wmGridcolumn
 * @restrict E
 *
 * @description
 * The 'wmGridcolumn' directive defines a column for rows in layoutgrid.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 * @requires $rootScope
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
                <wm-layoutgrid>
                    <wm-gridrow>
                        <wm-gridcolumn columnwidth="4" height="100" backgroundcolor="#008B8B"></wm-gridcolumn>
                        <wm-gridcolumn columnwidth="4" height="100" backgroundcolor="#FF1493"></wm-gridcolumn>
                        <wm-gridcolumn columnwidth="4" height="100" backgroundcolor="#9932CC"></wm-gridcolumn>
                    </wm-gridrow>
                    <wm-gridrow>
                    <wm-gridcolumn columnwidth="4" height="100" backgroundcolor="#8FBC8F"></wm-gridcolumn>
                        <wm-gridcolumn columnwidth="4" height="100" backgroundcolor="#1E90FF"></wm-gridcolumn>
                        <wm-gridcolumn columnwidth="4" height="100" backgroundcolor="#CD5C5C"></wm-gridcolumn>
                    </wm-gridrow>
                    <wm-gridrow>
                        <wm-gridcolumn columnwidth="4" height="100" backgroundcolor="#ADD8E6"></wm-gridcolumn>
                        <wm-gridcolumn columnwidth="4" height="100" backgroundcolor="#F08080"></wm-gridcolumn>
                        <wm-gridcolumn columnwidth="4" height="100" backgroundcolor="#20B2AA"></wm-gridcolumn>
                    </wm-gridrow>
                </wm-layoutgrid>
            </div>
        </file>
        <file name="script.js">
            function Ctrl($scope) {}
        </file>
    </example>
 */
/*global WM*/
/*Directive for List and ListItem*/

/*Directive for List*/

WM.module('wm.layouts.containers')
    .directive('wmList', ['PropertiesFactory', 'WidgetUtilService', function (PropertiesFactory, WidgetUtilService) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.layouts.list', ['wm.layouts']);

        return {
            'restrict': 'E',
            'replace': true,
            'scope': {},
            'transclude': true,
            'template': '<ul class="app-list" ng-class="[layout]" data-ng-show="show" apply-styles="container" data-element-type="wmList" wmtransclude init-widget has-model ></ul>',
            'compile': function () {
                return {
                    'pre': function (scope) {
                        /*Applying widget properties to directive scope*/
                        scope.widgetProps = widgetProps;
                    },

                    'post': function (scope, element, attrs) {
                        /*Cleaning the widget markup such that the widget wrapper is not cluttered with unnecessary property or
                         * style declarations.*/
                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }])
    .directive('wmListItem', ['PropertiesFactory', 'WidgetUtilService', function (PropertiesFactory, WidgetUtilService) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.layouts.listitem', ['wm.layouts']);

        return {
            'restrict': 'E',
            'replace': true,
            'scope': {},
            'transclude': true,
            'template': '<li init-widget class="app-list-item" apply-styles="container" wmtransclude></li>',
            'compile': function () {
                return {
                    'pre': function (scope) {
                        scope.widgetProps = widgetProps;
                    },

                    'post': function (scope, element, attrs) {
                        /*Cleaning the widget markup such that the widget wrapper is not cluttered with unnecessary property or
                         * style declarations.*/
                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.layouts.containers.directive:wmList
 * @restrict E
 * @element ANY
 * @description
 * The 'wmList' directive defines a dynamic list in the layout.
 * wmList is internally used by wmTopNav.
 *
 * @param {string=} name
 *                  Sets the name of the list.
 * @param {boolean=} height
 *                  Sets the height for the list.
 * @param {boolean=} layout
 *                  Sets the layout for the list.
 * @param {boolean=} show
 *                  Show is a bindable property. <br>
 *                  This property will be used to show/hide the list widget on the web page. <br>
 *                  Default value: `true`.
 * @param {boolean=} horizontalalign
 *                  Align the content of the list to left/right/center. <br>
 *                  Default value: `left`. <br>
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
                <wm-list>
                    <wm-list-item>
                        <wm-button class="btn-default" caption="Users" type="button"></wm-button>
                    </wm-list-item>
                    <wm-list-item>
                        <wm-button class="btn-default" caption="Products" type="button"></wm-button>
                    </wm-list-item>
                    <wm-list-item>
                        <wm-button class="btn-default" caption="Sales" type="button"></wm-button>
                    </wm-list-item>
                </wm-list>
            </div>
        </file>
        <file name="script.js">
            function Ctrl($scope) {}
        </file>
    </example>
 */

/**
 * @ngdoc directive
 * @name wm.layouts.containers.directive:wmListItem
 * @restrict E
 * @element ANY
 * @description
 * The 'wmListItem' directive defines a list item in the layout.
 * wmListItem is internally used by wmList.
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
                <wm-list>
                    <wm-list-item>
                        <wm-button class="btn-default" caption="Users" type="button"></wm-button>
                    </wm-list-item>
                    <wm-list-item>
                        <wm-button class="btn-default" caption="Products" type="button"></wm-button>
                    </wm-list-item>
                    <wm-list-item>
                        <wm-button class="btn-default" caption="Sales" type="button"></wm-button>
                    </wm-list-item>
                </wm-list>
            </div>
        </file>
        <file name="script.js">
            function Ctrl($scope) {}
        </file>
    </example>
 */

/*global WM, _*/
/*Directive for Nav and NavItem*/

/*Directive for Nav*/

WM.module('wm.layouts.containers')
    .directive('wmNav', [
        'Utils',
        'PropertiesFactory',
        'WidgetUtilService',
        '$rootScope',
        '$compile',
        '$timeout',
        '$routeParams',
        'CONSTANTS',

        function (Utils, PropertiesFactory, WidgetUtilService, $rs, $compile, $timeout, $routeParams, CONSTANTS) {
            'use strict';
            var widgetProps = PropertiesFactory.getPropertiesOf('wm.layouts.nav', ['wm.layouts']),
                notifyFor = {
                    'dataset': true,
                    'scopedataset': true,
                    'itemicon': true,
                    'itemlabel': true,
                    'itemlink': true,
                    'itemchildren': true
                };

            function getNodes($is, nv) {
                var nodes = [];
                if (WM.isString(nv)) {
                    nv = _.trim(nv);
                    if (nv) {
                        nodes = nv.split(',').map(function (item) {
                            return {
                                'label': _.trim(item)
                            };
                        });
                    }
                } else if (WM.isArray(nv)) {
                    nodes = nv;
                } else if (WM.isObject(nv)) {
                    nodes = [nv];
                }
                /* re-initialize the property values */
                if ($is.newcolumns) {
                    $is.newcolumns   = false;
                    $is.itemlabel    = '';
                    $is.itemchildren = '';
                    $is.itemicon     = '';
                    $is.itemlink     = '';

                    $rs.$emit('set-markup-attr', $is.widgetid, {
                        'itemlabel'   : $is.itemlabel,
                        'itemchildren': $is.itemchildren,
                        'itemicon'    : $is.itemicon,
                        'itemlink'    : $is.itemlink
                    });
                }
                if ($is.widgetid) { // when the widget is inside canvas
                    $is.keys = _.keys(nodes[0]);
                    /*Changing the properties like labels,children and icons*/
                    $is.widgetProps.itemlabel.options = $is.widgetProps.itemchildren.options = $is.widgetProps.itemicon.options = $is.widgetProps.itemlink.options = $is.keys;
                }
                return nodes;
            }
            function constructNav($el, $is) {
                $el.empty();

                $el.off('.on-select');

                if ($is.nodes && $is.nodes.length) {
                    var iconField     = $is.itemicon     || 'icon',
                        labelField    = $is.itemlabel    || 'label',
                        itemField     = $is.itemlink     || 'link',
                        childrenField = $is.itemchildren || 'children';

                    $is.nodes.forEach(function (node) {
                        var $a           = WM.element('<a class="app-anchor"></a>'),
                            $li          = WM.element('<li class="app-nav-item"></li>').data('node-data', node),
                            $i           = WM.element('<i class="app-nav-icon"></i>'),
                            $caret       = WM.element('<span class="caret"></span>'),
                            itemLabel    = node[labelField],
                            itemClass    = node[iconField],
                            itemLink     = node[itemField],
                            itemChildren = node[childrenField],
                            $ul;

                        if ($routeParams.name === (itemLink && itemLink.substring(1))) {
                            $a.addClass('active');
                        }

                        if (itemChildren && WM.isArray(itemChildren)) {
                            $i.addClass(itemClass);
                            $a.html(itemLabel).attr('uib-dropdown-toggle', '').addClass('app-anchor dropdown-toggle').prepend($i).append($caret);
                            $li.append($a).attr('uib-dropdown', '').addClass('dropdown');
                            $ul = WM.element('<ul uib-dropdown-menu></ul>');
                            itemChildren.forEach(function (child) {
                                var $a_inner  = WM.element('<a class="app-anchor"></a>'),
                                    $li_inner = WM.element('<li class="app-nav-item"></li>').data('node-data', child),
                                    $i_inner  = WM.element('<i class="app-nav-icon"></i>');

                                itemLabel = child[labelField];
                                itemClass = child[iconField];
                                itemLink  = child[itemField];

                                $i_inner.addClass(itemClass);
                                $a_inner.html(itemLabel).attr('href', itemLink).prepend($i_inner);
                                $li_inner.append($a_inner);
                                $ul.append($li_inner);
                            });
                            $li.append($ul);
                            $el.append($li);
                        } else {
                            $i.addClass(itemClass);
                            $a.html(itemLabel).attr('href', itemLink).prepend($i);
                            $li.append($a);
                            $el.append($li);
                        }
                        $compile($li)($is);
                    });

                    $el.on('click.on-select', '.app-anchor', function (e) {
                        var $target = WM.element(this),
                            $li     = $target.closest('.app-nav-item');

                        $rs.$safeApply($is, function () {
                            $is.selecteditem = $li.data('node-data');
                            Utils.triggerFn($is.onSelect, {'$event': e, $scope: $is, '$item': $is.selecteditem});
                        });
                    });
                }
            }

            /* Define the property change handler. This function will be triggered when there is a change in the widget property */
            function propertyChangeHandler($s, $is, $el, key, nv) {
                var variable;

                switch (key) {
                case 'dataset':
                    variable = $s.Variables[Utils.getVariableName($is, $s)];
                    if (variable && variable.category === 'wm.LiveVariable') {
                        nv = nv.data;
                    }

                    if (CONSTANTS.isStudioMode) {
                        if (variable && variable.type) {
                            $is.widgetProps.selecteditem.type = 'object, ' + variable.type;
                        } else {
                            $is.widgetProps.selecteditem.type = 'object';
                        }
                    }
                    // do not break here. continue with the next steps.
                case 'scopedataset':
                    $is.nodes = getNodes($is, nv);
                    constructNav($el, $is);
                    if ($is.widgetid) {
                        $rs.$emit('nav-dataset-modified', {'widgetName': $is.name});
                    }
                    break;
                case 'itemicon':
                case 'itemlabel':
                case 'itemlink':
                case 'itemchildren':
                    constructNav($el, $is);
                    break;
                }
            }

            return {
                'restrict'  : 'E',
                'replace'   : true,
                'scope'     : {'scopedataset': '=?'},
                'transclude': true,
                'template'  : function (tEl, tAttrs) {
                    var cls;
                    if (CONSTANTS.isRunMode) {
                        cls = 'class = "nav app-nav ';
                        switch (tAttrs.type) {
                        case 'pills':
                            cls += 'nav-pills';
                            break;
                        case 'tabs':
                            cls += 'nav-tabs';
                            break;
                        case 'navbar':
                            cls += 'navbar-nav';
                            break;
                        }

                        if (tAttrs.layout) {
                            cls += ' nav-' + tAttrs.layout;
                        }
                        cls +=  '"';
                    } else {
                        cls = 'class="nav app-nav" data-ng-class="{\'nav-pills\': type === \'pills\',' +
                                    '\'nav-tabs\': type === \'tabs\',' +
                                    '\'navbar-nav\': type === \'navbar\',' +
                                    '\'nav-stacked\': layout === \'stacked\',' +
                                    '\'nav-justified\': layout === \'justified\'' +
                                '}"';
                    }

                    return '<ul data-ng-show="show" apply-styles="container" data-element-type="wmNav" wmtransclude init-widget ' + cls + '></ul>';
                },
                'link'      : {
                    'pre': function ($is) {
                        if (CONSTANTS.isStudioMode) {
                            $is.widgetProps = Utils.getClonedObject(widgetProps);
                        } else {
                            $is.widgetProps = widgetProps;
                        }
                    },

                    'post': function ($is, $el, attrs) {
                        var onPropertyChange = propertyChangeHandler.bind(undefined, $el.scope(), $is, $el);

                        WidgetUtilService.registerPropertyChangeListener(onPropertyChange, $is, notifyFor);
                        if (!$is.widgetid && attrs.scopedataset) {
                            $timeout(function () {
                                $is.$watch('scopedataset', function (nv) {
                                    onPropertyChange('scopedataset', nv);
                                });
                            }, 0, true);
                        }
                        WidgetUtilService.postWidgetCreate($is, $el, attrs);
                    }
                }
            };
        }
    ])
    .directive('wmNavItem', [
        'PropertiesFactory',
        'WidgetUtilService',

        function (PropertiesFactory, WidgetUtilService) {
            'use strict';
            var widgetProps = PropertiesFactory.getPropertiesOf('wm.layouts.navitem', ['wm.layouts']);

            return {
                'restrict'  : 'E',
                'replace'   : true,
                'scope'     : {},
                'transclude': true,
                'template'  : '<li init-widget class="app-nav-item" apply-styles="container" wmtransclude></li>',
                'link'      : {
                    'pre': function ($is) {
                        $is.widgetProps = widgetProps;
                    },
                    'post': function ($is, $el, attrs) {
                        WidgetUtilService.postWidgetCreate($is, $el, attrs);
                    }
                }
            };
        }
    ]);

/**
 * @ngdoc directive
 * @name wm.layouts.containers.directive:wmNav
 * @restrict E
 * @element ANY
 * @description
 * The 'wmNav' directive defines a dynamic navigation in the layout.
 * The 'wmNav' directive defines a nav in the layout to contain nav items.
 *
 * * *
 * @param {string=} name
 *                  Name of the nav widget.
 * @param {string=} type
 *                  Type of the nav widget. [Options: navbar, pills, tabs]
 * @param {string=} height
 *                  Height of the nav widget.
 * @param {string=} layout
 *                  This property controls how contained widgets are displayed within this widget container. [Options: Stacked, Justified]
 * @param {string=} scopedatavalue
 *                  This property accepts the value for the nav widget from a variable defined in the controller page. <br>
 * @param {string=} selecteditem
 *                  Gives the selected item of the nav, when the nav widget is bound to a datasource. <br>
 *                  Will be undefined when nav contains wm-nav-items.
 * @param {string=} value
 *                  This property sets a variable to populate the list of values to display. This property is a bindable property.
 * @param {string=} itemicon
 *                  This property defines the value to be used as key for the icon from the list of values bound to the nav widget as an array of objects of different values.
 * @param {string=} itemlabel
 *                  This property defines the value to be used as key for the label from the list of values bound to the nav widget as an array of objects of different values.
 * @param {string=} itemlink
 *                  This property defines the value to be used as key for the link from the list of values bound to the nav widget as an array of objects of different values.
 * @param {string=} itemchildren
 *                  This property specifies the sub-menu items
 * @param {boolean=} show
 *                  Show is a bindable property. <br>
 *                  This property will be used to show/hide the nav widget on the web page. <br>
 *                  Default value: `true`.
 * @param {string=} horizontalalign
 *                  This property aligns the content of the nav to left/right/center.
 *                  Default value: `left`.
 * @param {string=} onSelect
 *                  Callback function which will be triggered when nav item is selected. <br>
 *                  Works only when the nav widget is bound to a datasource.

 * @example
    <example module="wmCore">
        <file name="index.html">
            <div class="wm-app" data-ng-controller="Ctrl">
                <wm-nav scopedataset="items"></wm-nav>
            </div>
        </file>
        <file name="script.js">
            function Ctrl($scope) {
                $scope.items = [
                        {
                            "label": "Home",
                            "icon": "glyphicon glyphicon-home",
                            "link": "#/home"
                        },
                        {
                            "label": "Dropdown",
                            "children": [
                                {
                                    "label": "Action",
                                    "icon": "glyphicon glyphicon-book"
                                },
                                {
                                    "label": "Help",
                                    "icon": "glyphicon glyphicon-question-sign"
                                }
                            ]
                        },
                        {
                            "label": "Others",
                            "icon": "glyphicon glyphicon-shopping-cart",
                            "link": "http://www.example.com"
                        },
                        {
                            "label": "Inventory",
                            "icon": "glyphicon glyphicon-tags"
                        }
                   ];
              };
        </file>
    </example>
 */
/**
 * @ngdoc directive
 * @name wm.layouts.containers.directive:wmNavItem
 * @restrict E
 * @element ANY
 * @description
 * The 'wmNavItem' directive defines a nav item in the layout.
 * wmNavItem is internally used by wmNav.
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div class="wm-app" data-ng-controller="Ctrl">
                <wm-nav>
                    <wm-nav-item>
                        <wm-anchor caption="Dashboard" iconclass="glyphicon glyphicon-dashboard" class="active"></wm-anchor>
                    </wm-nav-item>
                </wm-nav>
            </div>
        </file>
        <file name="script.js">
            function Ctrl($scope) {}
        </file>
    </example>
 */

/*global WM*/
/*Directive for Panel*/

WM.module('wm.layouts.containers')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/layout/container/panel.html',
                '<div page-container init-widget class="app-panel panel" data-ng-class="[helpClass, {\'fullscreen\':fullscreen}]" data-ng-show="show" apply-styles="shell" wm-navigable-element="true">' +
                    '<div class="panel-heading" data-ng-class="helpClass">' +
                        '<h3 class="panel-title">' +
                            '<a href="javascript:void(0)" class="panel-toggle" data-ng-click="expandCollapsePanel()">' +
                                '<i class="app-icon panel-icon {{iconclass}}" data-ng-show="iconclass"></i>' +
                                '<span class="heading">{{title}}</span>' +
                                '<span class="description">{{description}}</span>' +
                            '</a>' +
                            '<div class="panel-actions">' +
                                '<span data-ng-if="badgevalue" class="label label-{{badgetype}}">{{badgevalue}}</span>' +
                                '<wm-menu type="anchor" class="panel-action" scopedataset="actions" iconname="option-vertical" data-ng-if="actions" title="{{::$root.appLocale.LABEL_ACTIONS}}" on-select="onActionsclick({$item:$item})" datafield="{{datafield}}" itemlabel="{{binditemlabel || itemlabel || displayfield}}" menuposition="down,left" itemicon="{{binditemicon || itemicon}}" itemlink="{{binditemlink || itemlink}}" itemchildren="{{binditemchildren || itemchildren}}"></wm-menu>' +
                                '<button type="button" class="app-icon panel-action glyphicon glyphicon-question-sign" title="{{::$root.appLocale.LABEL_HELP}}" data-ng-if="helptext" data-ng-click="toggleHelp()"></button>' +
                                '<button type="button" class="app-icon glyphicon panel-action" data-ng-if="collapsible" title="{{::$root.appLocale.LABEL_COLLAPSE}}/{{::$root.appLocale.LABEL_EXPAND}}" data-ng-class="expanded ? \'glyphicon-minus\': \'glyphicon-plus\'" data-ng-click="expandCollapsePanel($event);"></button>' +
                                '<button type="button" class="app-icon glyphicon panel-action" data-ng-if="enablefullscreen" title="{{::$root.appLocale.LABEL_FULLSCREEN}}/{{::$root.appLocale.LABEL_EXITFULLSCREEN}}" data-ng-class="fullscreen ? \'glyphicon-resize-small\': \'glyphicon-fullscreen\'" data-ng-click="toggleFullScreen($event);"></button>' +
                                '<button type="button" class="app-icon glyphicon panel-action glyphicon-remove" title="{{::$root.appLocale.LABEL_CLOSE}}" data-ng-if="closable" data-ng-click="closePanel();onClose({$event: $event, $scope: this})"></button>' +
                            '</div>' +
                        '</h3>' +
                    '</div>' +
                    '<div class="panel-content" data-ng-show="expanded">' +
                        '<div class="panel-body" data-ng-class="helpClass" wmtransclude page-container-target  apply-styles="inner-shell" ></div>' +
                        '<aside class="panel-help-message" data-ng-class="helpClass"><h5 class="panel-help-header">{{::$root.appLocale.LABEL_HELP}}</h5><div class="panel-help-content" data-ng-bind-html="helptext"></div></aside>' +
                    '</div>' +
                '</div>'
            );
        $templateCache.put('template/layout/container/panel-footer.html', '<div class="app-panel-footer panel-footer" data-ng-show="expanded" wmtransclude></div>');
    }])
    .directive('wmPanel', ['PropertiesFactory', 'WidgetUtilService', 'Utils', 'CONSTANTS', function (PropertiesFactory, WidgetUtilService, Utils, CONSTANTS) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.layouts.panel', ['wm.layouts', 'wm.containers', 'wm.base.events.touch', 'wm.menu.dataProps']),
            notifyFor = {
                'height': true,
                'actions': true
            };
        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
        function propertyChangeHandler(scope, key, newVal) {
            switch (key) {
            case 'height':
                if (newVal && CONSTANTS.isStudioMode) {
                    scope.minheight = 0;
                }
                if(newVal){
                  scope.overflow = "auto";
                }
                break;
            case 'actions':
                if (CONSTANTS.isStudioMode) {
                    WidgetUtilService.updatePropertyPanelOptions(newVal.data || newVal, newVal.propertiesMap, scope);
                    scope.itemlabel = scope.itemlabel || scope.displayfield;
                }
                break;
            }
        }
        return {
            'restrict': 'E',
            'replace': true,
            'scope': {},
            'transclude': true,
            'template': function (tElement, tAttrs) {
                var isWidgetInsideCanvas = tAttrs.hasOwnProperty('widgetid'),
                    template = WM.element(WidgetUtilService.getPreparedTemplate('template/layout/container/panel.html', tElement, tAttrs));

                if (!isWidgetInsideCanvas) {
                    if (tAttrs.hasOwnProperty('onEnterkeypress')) {
                        template.attr('data-ng-keypress', 'onKeypress({$event: $event, $scope: this})');
                    }
                }
                return template[0].outerHTML;
            },
            'controller': function () {
                this.registerFooter = function (footer) {
                    this.footer = footer;
                };
            },
            'compile': function () {
                return {
                    'pre': function (iScope) {
                        if (CONSTANTS.isStudioMode) {
                            iScope.widgetProps = Utils.getClonedObject(widgetProps);
                        } else {
                            iScope.widgetProps = widgetProps;
                        }
                    },
                    'post': function (scope, element, attrs, panelCtrl) {
                        if (scope.expanded === undefined) {
                            scope.expanded = true;
                        }
                        /* Expand Collapse the panel */
                        scope.expandCollapsePanel = function ($event) {
                            if (scope.collapsible && CONSTANTS.isRunMode) {
                                if (scope.expanded) {
                                    if (scope.onCollapse) {
                                        scope.onCollapse({$event: $event, $scope: this});
                                    }
                                } else {
                                    if (scope.onExpand) {
                                        scope.onExpand({$event: $event, $scope: this});
                                    }
                                }
                                /* flip the active flag */
                                scope.expanded = !scope.expanded;
                                if (panelCtrl.footer) {
                                    panelCtrl.footer.isolateScope().expanded = scope.expanded;
                                }
                            }
                        };
                        /* Toggle FullScreen the panel */
                        scope.toggleFullScreen = function ($event) {
                            if (scope.enablefullscreen && CONSTANTS.isRunMode) {
                                if (scope.fullscreen) {
                                    if (scope.onExitfullscreen) {
                                        scope.onExitfullscreen({$event: $event, $scope: this});
                                    }
                                } else {
                                    if (scope.onFullscreen) {
                                        scope.onFullscreen({$event: $event, $scope: this});
                                    }
                                }
                                /* flip the active flag */
                                scope.fullscreen = !scope.fullscreen;
                            }
                        };

                        /* toggle the state of the panel */
                        scope.toggleHelp = function () {
                            if (scope.helptext && CONSTANTS.isRunMode) {
                                /* flip the active flag */
                                scope.helpClass = scope.helpClass ? null : 'show-help';
                            }
                        };
                        /* Close the panel */
                        scope.closePanel = function () {
                            scope.show = false;
                        };

                        /* register the property change handler */
                        WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, scope), scope, notifyFor);
                        WidgetUtilService.postWidgetCreate(scope, element, attrs);

                        if (!scope.widgetid) {
                            scope.onKeypress = function (args) {
                                var action = Utils.getActionFromKey(args.$event);
                                if (action === 'ENTER') {
                                    scope.onEnterkeypress(args);
                                }
                            };
                        }

                        if (panelCtrl.footer) {
                            element.append(panelCtrl.footer);
                        }
                    }
                };
            }
        };
    }])
    .directive('wmPanelFooter', ['$templateCache', function ($templateCache) {
        "use strict";
        return {
            'restrict': 'E',
            'replace': true,
            'scope': {},
            'transclude': true,
            'require': '^wmPanel',
            'template': $templateCache.get('template/layout/container/panel-footer.html'),
            'link': function (scope, element, attrs, panelCtrl) {
                scope.expanded = true;
                panelCtrl.registerFooter(element);
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.layouts.containers.directive:wmPanel
 * @restrict E
 * @element ANY
 * @description
 * The 'wmPanel' directive defines a panel in the page.
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 * @requires Utils
 * @requires CONSTANTS
 *
 * @param {string=} title
 *                  Title of the panel widget. This property is a bindable property.
 * @param {string=} name
 *                  Name of the panel widget.
 * @param {string=} description
 *                  Description for the panel widget. This property is a bindable property.
 * @param {string=} width
 *                  Width of the panel widget.
 * @param {string=} height
 *                  Height of the panel widget.
 * @param {boolean=} showheader
 *                  Show/Hide header of the panel widget.
 * @param {string=} content
 *                  Sets content for the panel widget. <br>
 *                  Page's content will be included in the widget.<br>
 *                  Default value: `Inline Content`. <br>
 * @param {string=} helptext
 *                  To show help text for the panel widget. Help panel on the right is shown only when help text is given. This property is a bindable property.
 * @param {boolean=} show
 *                  Show is a bindable property. <br>
 *                  This property will be used to show/hide the panel widget on the web page. <br>
 *                  Default value: `true`. <br>
 * @param {boolean=} collapsible
 *                  To enable control for collapsing/expanding the panel widget.
 * @param {boolean=} enablefullscreen
 *                  To enable fullscreen view for the panel widget
 * @param {boolean=} closable
 *                  To apply close button in the panel widget.
 * @param {string=} actions
 *                  To set the actions for the panel widget. This property is a bindable property.
 * @param {boolean=} expanded
 *                  To set the default state for the panel widget, whether it is expanded or collapsed.
 * @param {string=} animation
 *                  This property controls the animation of the panel widget. <br>
 *                  The animation is based on the css classes and works only in the run mode. <br>
 *                  Possible values are `bounce`, `flash`, `pulse`, `rubberBand`, `shake`, etc.
 * @param {string=} iconclass
 *                  To define class of icon applied to the button for the panel widget. This property is a bindable property.
 * @param {string=} horizontalalign
 *                  Align the content in the panel to left/right/center.<br>
 * @param {string=} mouseover
 *                  Callback function which will be triggered when the mouse moves over the panel.
 * @param {string=} mouseout
 *                  Callback function which will be triggered when the mouse away from the panel.
 * @param {string=} mouseenter
 *                  Callback function which will be triggered when the mouse enters inside the panel.
 * @param {string=} mouseleave
 *                  Callback function which will be triggered when the mouse leaves the panel.
 * @param {string=} enterkeypress
 *                  Callback function which will be triggered when the user hits the ENTER/Return while the focus is on this editor.
 * @param {string=} swipeup
 *                  Callback function which will be triggered when the panel is swiped up.
 * @param {string=} swipedown
 *                  Callback function which will be triggered when the panel is swiped down.
 * @param {string=} swiperight
 *                  Callback function which will be triggered when the panel is swiped right.
 * @param {string=} swipeleft
 *                  Callback function which will be triggered when the panel is swiped left.
 * @param {string=} pinchin
 *                  Callback function which will be triggered when the panel is pinched in.
 * @param {string=} pinchout
 *                  Callback function which will be triggered when the panel is pinched out.
 * @param {string=} on-close
 *                  Callback function which will be triggered when the panel is closed.
 * @param {string=} on-expand
 *                  Callback function which will be triggered when the panel is expanded.
 * @param {string=} on-collapse
 *                  Callback function which will be triggered when the panel is collapsed.
 * @param {string=} on-actions-click
 *                  Callback function which will be triggered when the action icon is clicked.
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
                <wm-panel class="panel-default" collapsible="true"  enablefullscreen="true" showheader="true" width="400" height="200" backgroundcolor="#dad8d9" title="Personal Info">
                    <wm-panel-footer>
                        <wm-container horizontalalign="right">
                            <wm-button class="btn-secondary" caption="Cancel" type="button"></wm-button>
                            <wm-button class="btn-primary" caption="Update" type="button"></wm-button>
                        </wm-container>
                    </wm-panel-footer>
                    <wm-composite>
                        <wm-label class="col-md-3" caption="First Name:"></wm-label>
                        <wm-container class="col-md-9">
                            <wm-text></wm-text>
                        </wm-container>
                    </wm-composite>
                    <wm-composite>
                        <wm-label class="col-md-3" caption="Last Name:"></wm-label>
                        <wm-container class="col-md-9">
                            <wm-text></wm-text>
                        </wm-container>
                    </wm-composite>
                </wm-panel>
            </div>
        </file>
        <file name="script.js">
            function Ctrl($scope) {}
        </file>
    </example>
 */
/*global WM*/
/* Directive for Container */

WM.module('wm.layouts.containers')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/layout/container/container.html',
            '<div page-container init-widget class="app-container" data-ng-show="show" apply-styles="container" wmtransclude page-container-target></div>'
            );
    }])
    .directive('wmContainer', ['PropertiesFactory', 'WidgetUtilService', 'Utils', 'CONSTANTS', function (PropertiesFactory, WidgetUtilService, Utils, CONSTANTS) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.layouts.container', ['wm.layouts', 'wm.containers', 'wm.base.events.touch']);

        return {
            'restrict': 'E',
            'replace': true,
            'scope': {},
            'transclude': true,
            'template': function (tElement, tAttrs) {
                var isWidgetInsideCanvas = tAttrs.hasOwnProperty('widgetid'),
                    $template = WM.element(WidgetUtilService.getPreparedTemplate('template/layout/container/container.html', tElement, tAttrs));

                if (!isWidgetInsideCanvas) {
                    if (tAttrs.hasOwnProperty('onEnterkeypress')) {
                        $template.attr('data-ng-keypress', 'onKeypress({$event: $event, $scope: this})');
                    }
                }
                return $template[0].outerHTML;
            },
            'compile': function () {
                return {
                    'pre': function (iScope) {
                        if (CONSTANTS.isStudioMode) {
                            iScope.widgetProps = Utils.getClonedObject(widgetProps);
                        } else {
                            iScope.widgetProps = widgetProps;
                        }
                    },
                    'post': function (scope, element, attrs) {
                        WidgetUtilService.postWidgetCreate(scope, element, attrs);

                        if (!scope.widgetid) {
                            scope.onKeypress = function (args) {
                                var action = Utils.getActionFromKey(args.$event);
                                if (action === 'ENTER') {
                                    scope.onEnterkeypress(args);
                                }
                            };
                        }
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.layouts.containers.directive:wmContainer
 * @restrict E
 * @element ANY
 * @description
 * The 'wmContainer' directive defines a container in the page.
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 * @requires Utils
 *
 * @param {string=} name
 *                  Name of the container widget.
 * @param {string=} width
 *                  Width of the container widget.
 * @param {string=} height
 *                  Height of the container widget.
 * @param {string=} content
 *                  Sets content for the container. <br>
 *                  It can be Inline content(incase of html widget) or Page's content(incase of page container widgets) will be included in the widget.<br>
 *                  Default value: `Inline Content`. <br>
 * @param {boolean=} show
 *                  Show is a bindable property. <br>
 *                  This property will be used to show/hide the container widget on the web page. <br>
 *                  Default value: `true`. <br>
 * @param {string=} animation
 *                  This property controls the animation of the container widget. <br>
 *                  The animation is based on the css classes and works only in the run mode. <br>
 *                  Possible values are `bounce`, `flash`, `pulse`, `rubberBand`, `shake`, etc.
 * @param {string=} horizontalalign
 *                  Align the content in the container to left/right/center.<br>
 * @param {string=} click
 *                  Callback function which will be triggered when the container widget is clicked.
 * @param {string=} double-click
 *                  Callback function which will be triggered when the container widget is double clicked.
 * @param {string=} mouse-over
 *                  Callback function which will be triggered when mouse moves over the container widget.
 * @param {string=} mouse-out
 *                  Callback function which will be triggered when mouse moves away from the container widget.
 * @param {string=} mouse-enter
 *                  Callback function which will be triggered when mouse enters inside the container widget.
 * @param {string=} mouse-leave
 *                  Callback function which will be triggered when mouse leaves the container widget.
 * @param {string=} enter-key-press
 *                  Callback function which will be triggered when enter key is pressed.
 * @param {string=} swipeup
 *                  Callback function which will be triggered when the container widget is swiped out.
 * @param {string=} swipedown
 *                  Callback function which will be triggered when the container widget is swiped down.
 * @param {string=} swiperight
 *                  Callback function which will be triggered when the container widget is swiped right.
 * @param {string=} swipeleft
 *                  Callback function which will be triggered when the container widget is swiped left.
 * @param {string=} pinchin
 *                  Callback function which will be triggered when the container widget is pinched in.
 * @param {string=} pinchout
 *                  Callback function which will be triggered when the container widget is pinched out.
 *
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
                <wm-container width="400" height="400" backgroundcolor="#979797" paddingtop="50">
                    <wm-composite>
                        <wm-label class="col-md-3" caption="First Name"></wm-label>
                        <wm-container class="col-md-9">
                            <wm-text></wm-text>
                        </wm-container>
                    </wm-composite>
                    <wm-composite>
                        <wm-label class="col-md-3" caption="Last Name"></wm-label>
                        <wm-container class="col-md-9">
                            <wm-text></wm-text>
                        </wm-container>
                    </wm-composite>
                    <wm-container horizontalalign="right">
                        <wm-button class="btn-secondary" caption="Cancel" type="button"></wm-button>
                        <wm-button class="btn-primary" caption="Save" type="button"></wm-button>
                    </wm-container>
                </wm-container>
            </div>
        </file>
        <file name="script.js">
            function Ctrl($scope) {}
        </file>
    </example>
 */

/*global WM*/
/*Directive for Tile*/

WM.module('wm.layouts.containers')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/layout/tile/tile.html',
            '<div init-widget class="app-tile panel" data-ng-show="show" apply-styles="scrollable-container" data-ng-style="{width:width}" wm-navigable-element="true">' +
                '<div class="app-tile-body panel-body" wmtransclude ></div>' +
            '</div>');
    }])
    .directive('wmTile', ['PropertiesFactory', 'WidgetUtilService', 'Utils', 'CONSTANTS', function (PropertiesFactory, WidgetUtilService, Utils, CONSTANTS) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.layouts.tile', ['wm.layouts', 'wm.containers', 'wm.base.events.touch']);

        return {
            'restrict': 'E',
            'replace': true,
            'scope': {},
            'transclude': true,
            'template': function (tElement, tAttrs) {
                var isWidgetInsideCanvas = tAttrs.hasOwnProperty('widgetid'),
                    $template = WM.element(WidgetUtilService.getPreparedTemplate('template/layout/tile/tile.html', tElement, tAttrs));

                if (!isWidgetInsideCanvas) {
                    if (tAttrs.hasOwnProperty('onEnterkeypress')) {
                        $template.attr('data-ng-keypress', 'onKeypress({$event: $event, $scope: this})');
                    }
                }
                return $template[0].outerHTML;
            },
            'compile': function () {
                return {
                    'pre': function (iScope) {
                        if (CONSTANTS.isStudioMode) {
                            iScope.widgetProps = Utils.getClonedObject(widgetProps);
                        } else {
                            iScope.widgetProps = widgetProps;
                        }
                    },
                    'post': function (scope, element, attrs) {
                        WidgetUtilService.postWidgetCreate(scope, element, attrs);

                        if (!scope.widgetid) {
                            scope.onKeypress = function (args) {
                                var action = Utils.getActionFromKey(args.$event);
                                if (action === 'ENTER') {
                                    scope.onEnterkeypress(args);
                                }
                            };
                        }
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.layouts.containers.directive:wmTile
 * @restrict E
 * @element ANY
 * @description
 * The 'wmTile' directive defines a tile in the page. 'wmTile' and 'wmContainer' are same from UI perspective, but 'wmTile' uses panel classes.
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 * @requires Utils
 *
 * @param {string=} name
 *                  Name of the tile widget.
 * @param {string=} width
 *                  Width of the tile widget.
 * @param {string=} height
 *                  Height of the tile widget.
 * @param {boolean=} Show
 *                  Show is a bindable property. <br>
 *                  This property will be used to show/hide the tile widget on the web page. <br>
 *                  Default value: `true`. <br>
 * @param {string=} animation
 *                  This property controls the animation of the tile widget. <br>
 *                  The animation is based on the css classes and works only in the run mode. <br>
 *                  Possible values are `bounce`, `flash`, `pulse`, `rubberBand`, `shake`, etc.
 * @param {string=} horizontalalign
 *                  Align the content in the tile widget to left/right/center.<br>
 * @param {string=} click
 *                  Callback function which will be triggered when the tile widget is clicked.
 * @param {string=} double-click
 *                  Callback function which will be triggered when the tile widget is double-clicked.
 * @param {string=} mouse-over
 *                  Callback function which will be triggered when the mouse moves over the tile widget.
 * @param {string=} mouse-out
 *                  Callback function which will be triggered when the mouse moves away from the tile widget.
 * @param {string=} mouse-enter
 *                  Callback function which will be triggered when the mouse enters inside the tile widget.
 * @param {string=} mouse-leave
 *                  Callback function which will be triggered when the mouse leaves the tile widget.
 * @param {string=} enter-key-press
 *                  Callback function which will be triggered when the tile enter key is pressed.
 * @param {string=} swipeup
 *                  Callback function which will be triggered when the tile widget is swiped up.
 * @param {string=} swipedown
 *                  Callback function which will be triggered when the tile widget is swiped down.
 * @param {string=} swiperight
 *                  Callback function which will be triggered when the tile widget is swiped right.
 * @param {string=} swipeleft
 *                  Callback function which will be triggered when the tile widget is swiped left.
 * @param {string=} pinchin
 *                  Callback function which will be triggered when the tile widget is pinched in.
 * @param {string=} pinchout
 *                  Callback function which will be triggered when the tile widget is pinched out.
 *
 * @example
 * <example module="wmCore">
 * <file name="index.html">
 *  <div data-ng-controller="Ctrl" class="wm-app">
 *      <br>
 *      <wm-tile width="400" margintop="10" marginright="10" marginleft="10" marginbottom="10" backgroundcolor="#2F80E7" color="#fff"  paddingtop="10" paddingleft="10" paddingbottom="10" paddingright="10">
 *           <wm-icon iconsize="2em" iconclass="glyphicon glyphicon-user"></wm-icon>
 *           <wm-label width="100%" textalign="center" fontsize="3" fontunit="em" fontweight="bold" caption="12680"></wm-label>
 *           <wm-label width="100%" caption="Signups" textalign="center" fontweight="bold"></wm-label>
 *       </wm-tile>
 *  </div>
 * </file>
 * <file name="script.js">
 *   function Ctrl($scope) {}
 * </file>
 * </example>
 */

/*global WM, */
/*jslint todo: true */
/*Directive for tabs */

WM.module('wm.layouts.containers')
    .run(['$templateCache', function ($templateCache) {
        'use strict';

        /* define the template for the tabs directive */
        $templateCache.put('template/layout/container/tabs.html',
                '<div class="app-tabs clearfix" init-widget data-ng-show="show" apply-styles="container" tabindex="-1">' +
                    '<ul class="nav nav-tabs" data-ng-class="{\'nav-stacked\': vertical, \'nav-justified\': justified}"></ul>' +
                    '<div class="tab-content" data-ng-class="{\'tab-stacked\': vertical, \'tab-justified\': justified}" wmtransclude hm-swipe-left="_onSwipeLeft();" hm-swipe-right="_onSwipeRight()"></div>' +
                '</div>'
            );

        /* define the template for the tabpane directive */
        $templateCache.put('template/layout/container/tab-pane.html',
            '<div class="tab-pane" wmtransclude init-widget data-ng-show="show" data-ng-class="{disabled:disabled}" wm-navigable-element="true"></div>');

        /* define the template for the tabheader directive */
        $templateCache.put('template/layout/container/tab-header.html',
            '<li class="tab-header" data-ng-class="{active: tab.isActive, disabled: tab.disabled}" data-ng-show="tab.show" data-tab-id="{{tab.widgetid}}" data-ng-click="tab.select()"  hm-swipe-left="_onHeaderSwipeLeft($event);" hm-swipe-right="_onHeaderSwipeRight($event);" init-widget role="tab" tabindex="-1">' +
                '<a href="javascript:void(0);" wmtransclude apply-styles="container" role="button" tabindex="0"></a>' +
            '</li>');

        /* define the template for the tabcontent directive */
        $templateCache.put('template/layout/container/tab-content.html',
            '<div page-container wmtransclude page-container-target class="tab-body" data-tab-id="{{tab.widgetid}}" init-widget apply-styles  tabindex="0"></div>');

    }])
    .directive('wmTabs', ['PropertiesFactory', '$templateCache', 'WidgetUtilService', 'Utils', 'CONSTANTS', '$rootScope', function (PropertiesFactory, $templateCache, WidgetUtilService, Utils, CONSTANTS, $rootScope) {
        'use strict';

        /* get the properties related to the tabs */
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.tabs', ['wm.base', 'wm.layouts', 'wm.containers']),
            notifyFor = {
                'tabsposition': true
            };

        /*Define the property change handler. This function will be triggered when there is a change in the widget property */
        function propertyChangeHandler(scope, key, newVal) {
            switch (key) {
            case 'tabsposition':
                scope.setTabsPosition(newVal);
                break;
            }
        }

        return {
            'restrict': 'E',
            'scope': {},
            'replace': true,
            'transclude': true,
            'template': $templateCache.get('template/layout/container/tabs.html'),
            /* define the controller for the tabs directive. tabpane directive will use this. */
            'controller': function ($scope, $element) {

                /* array which contains the scopes of the tabpanes */
                $scope.tabs = [];
                /* this method will register a tabpane with the tabs
                 * save the scope of the tabpane in the tabs array
                 */
                this.register = function (tabScope) {
                    $scope.tabs.push(tabScope);
                };

                /*
                 * this method will unregister a tabpane.
                 * remove the scope of the tabpane from the tabs array
                 */
                this.unregister = function (tab) {
                    var i, len = $scope.tabs.length;
                    for (i = 0; i < len; i++) { /* find the tab to be removed using the $id */
                        if ($scope.tabs[i].$id === tab.$id) {
                            break;
                        }
                    }
                    $scope.tabs.splice(i, 1); /* remove the tabpane from the tabs array */
                    /* remove the tabheader and tabcontent elements of the tab which is just removed/unregisterd */
                    $element.find('[data-tab-id="' + tab.widgetid + '"]').remove();
                };

                /*
                 * this method will be triggered by a tab when it is selected using the user click option.
                 * if there is any activeTab, set the active flag on it to false and trigger onDeselect callback of it
                 * trigger the onSelect callback of the selected tab
                 */
                this.selectTab = function (tab, skipOnSelect) {
                    var _tab = $scope.activeTab,
                        i,
                        tabs = $scope.tabs;
                    if (_tab) {
                        Utils.triggerFn(_tab.onDeselect);
                        _tab.isActive = false;
                    }
                    $scope.activeTab = tab;

                    for (i = 0; i < tabs.length; i++) {
                        if ($scope.activeTab.$id === tabs[i].$id) {
                            $scope.activeTabIndex = i;
                            break;
                        }
                    }

                    if (!skipOnSelect) {
                        Utils.triggerFn(tab.onSelect);
                    }

                    if (tab) {
                        tab._animateIn($element.hasClass('has-transition'));
                    }

                    // when tabContent is set to display external page, triggering $lazyLoad on select of the tab will render the content.
                    Utils.triggerFn(tab.tabContent.$lazyLoad);
                };

                /* make selectedTab method available to the isolateScope of the tabs directive. */
                $scope.selectTab = this.selectTab;
            },
            link: {
                'pre': function (scope, element, attrs) {
                    /* save the reference to widgetProps in scope */
                    scope.widgetProps = widgetProps;

                    // In run mode when the tabs position is horizontal and transition is setup add 'has-transition' class
                    if (CONSTANTS.isRunMode && attrs.transition && attrs.transition !== 'none' && (!attrs.tabsposition || attrs.tabsposition === 'top' || attrs.tabsposition === 'bottom')) {
                        element.addClass('has-transition');
                    }

                    if (CONSTANTS.isStudioMode) {
                        // define the _select method. This will be called in studio mode when a tab is selected using tabslist dropdown
                        scope._select = function (el) {
                            if (el.selectedIndex) {
                                $rootScope.$safeApply($rootScope, function () {
                                    //trigger the select method on selected tab.
                                    WM.element(el).children().eq(el.selectedIndex).scope().tab.select();
                                });
                            }
                        };

                        // add the tabs-list element to the root element.
                        element
                            .append('<select class=tabs-list onchange="WM.element(this).scope()._select(this)" title="Select a Tab"><option hidden></option></select>');
                    }
                },
                'post': function (scope, element, attrs) {

                    var tabs = scope.tabs,
                        activeTab,
                        tab,
                        $ul = element.find('> ul');
                    /* find the first tab which has isdefaulttab set and make it active.
                     * mark the other tabs as inactive
                     */
                    tabs.forEach(function (tab) {
                        if (!activeTab) {
                            if (tab.isdefaulttab) {
                                activeTab = tab;
                            }
                        } else {
                            tab.isActive = false;
                        }
                    });

                    /*selects a given tab and executes onBeforeSwitchTab before switching*/
                    function selectTab(tab, onBeforeSwitchTab) {
                        /*trigger onBeforeSwitchTab callback before switching*/
                        Utils.triggerFn(onBeforeSwitchTab);

                        if (tab) {
                            tab.select();
                        }
                    }

                    /* if isdefaulttab is not set on any of the tabs, then set the first tab as active */
                    activeTab = activeTab || tabs[0];
                    /*Set active only if at least one is present*/
                    if (activeTab) {
                        activeTab.select();
                    }
                    /**
                     * @ngdoc function
                     * @name wm.layouts.containers.directive:wmTabs#next
                     * @methodOf wm.layouts.containers.directive:wmTabs
                     * @function
                     *
                     * @description
                     * This methods moves from the current active tabpane to next tabpane
                     *
                     * @param {function} onBeforeSwitchTab
                     *                 Callback function to be triggered before moving to next tab.
                     */
                    /*method exposed to move to next tab from current active tab*/
                    scope.next = function (onBeforeSwitchTab) {
                        selectTab(tabs[scope.activeTabIndex + 1], onBeforeSwitchTab);
                    };

                    /**
                     * @ngdoc function
                     * @name wm.layouts.containers.directive:wmTabs#previous
                     * @methodOf wm.layouts.containers.directive:wmTabs
                     * @function
                     *
                     * @description
                     * This methods moves from the current tabpane to previous tabpane
                     *
                     * @param {function} onBeforeSwitchTab
                     *                 Callback function to be triggered before moving to previous tab.
                     */
                    /*method exposed to move to previous tab from current active tab*/
                    scope.previous = function (onBeforeSwitchTab) {
                        selectTab(tabs[scope.activeTabIndex - 1], onBeforeSwitchTab);
                    };
                    /**
                     * @ngdoc function
                     * @name wm.layouts.containers.directive:wmTabs#goToTab
                     * @methodOf wm.layouts.containers.directive:wmTabs
                     * @function
                     *
                     * @description
                     * This methods moves from the current tabpane to a given tab.
                     *
                     * @param {number} tabNum
                     *                 tabNumber to which the user needs to switch.(starts from 1)
                     * @param {function} onBeforeSwitchTab
                     *                 Callback function to be triggered before moving to given tab.
                     */
                    /*method exposed to move to a particular tab from current active tab*/
                    scope.goToTab = function (tabNum, onBeforeSwitchTab) {
                        /*to go to a particular tab, we need tabScope.
                        * If number is passed, we fetch the tabscope and then select that particular tab, else return*/
                        if (WM.isNumber(tabNum)) {
                            /*tabNum should be more than 0 and less than tabs length*/
                            if (tabNum > 0 && tabNum <= tabs.length) {
                                tab = tabs[tabNum - 1];
                            } else {
                                return;
                            }
                        } else {
                            return;
                        }
                        /*select the tab*/
                        selectTab(tab, onBeforeSwitchTab);
                    };

                    scope.setTabsPosition = function (tabsposition) {
                        var _tabs = element.find('>ul.nav-tabs');
                        element.removeClass('inverted');
                        if (tabsposition === 'bottom' || tabsposition === 'right') {
                            element.addClass('inverted');
                            element.append(_tabs);
                        } else {
                            element.prepend(_tabs);
                        }
                        scope.vertical = (tabsposition === 'left' || tabsposition === 'right');
                    };

                    // function to scroll the header into the viewport
                    function _scrollHeader(delta) {
                        var left = $ul[0].scrollLeft,
                            _delta = -1 * delta;
                        $ul.animate({scrollLeft: left + _delta}, {'duration': 10});
                    }

                    if (CONSTANTS.isRunMode) {

                        // define functions to select next/previous tabs on swipe action
                        if (scope.transition && scope.transition !== 'none') {
                            scope._onSwipeLeft = function () {
                                // select next
                                selectTab(tabs[scope.activeTabIndex + 1]);
                            };

                            scope._onSwipeRight = function () {
                                // select previous
                                selectTab(tabs[scope.activeTabIndex - 1]);
                            };
                        }

                        element.find('> ul').on('mousewheel', function (e) {
                            e.stopPropagation();
                            e.preventDefault();
                            _scrollHeader(e.originalEvent.wheelDelta);
                        });
                    }

                    /* register the property change handler */
                    WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, scope), scope, notifyFor);

                    /* initialize the widget */
                    WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    scope.setTabsPosition(attrs.tabsposition || (attrs.vertical === "true" ? 'left' : 'top'));
                }
            }
        };
    }])
    .directive('wmTabpane', ['PropertiesFactory', '$templateCache', 'WidgetUtilService', 'Utils', '$parse', function (PropertiesFactory, $templateCache, WidgetUtilService, Utils, $parse) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.tabpane', ['wm.base']);
        return {
            'restrict': 'E',
            'scope': {},
            'replace': true,
            'require': '^wmTabs', /* require the controller of the parent directive. i.e, wmTabs */
            'transclude': true,
            'template': $templateCache.get('template/layout/container/tab-pane.html'),
            /*
             * define the controller for this directive so that the childs (tabheader, tabcontent) can use this controller for the communication.
             */
            'controller': function ($scope, $element) {
                /* targetContainer for the tab headers */
                var tabsTarget = $element.closest('.app-tabs').children('.nav-tabs');

                /* this method will be called by the tabheader child */
                this.registerHead = function (scope) {
                    /* append the tab header element to the .nav-tabs container */
                    tabsTarget.append(scope._element); /* scope._element is the reference of the header element */
                    $scope.tabHead = scope;
                    return $scope; /* return the scope of tabpane, so that header will be able to listen to the properties on this */
                };

                /* this method will be called by the tabcontent child */
                this.registerContent = function (scope) {
                    $scope.tabContent = scope;
                    /* return the scope of tabpane, so that content will be able to listen to the properties on this */
                    return $scope;
                };

                this.registerCallback = function (name, value) {
                    if (!name || !value) {
                        return;
                    }

                    var fn = $parse(value);
                    $scope[name] = function (locals) {
                        locals = locals || {};
                        locals.$scope = $scope;
                        return fn($element.scope(), locals);
                    };
                };
            },
            'compile': function () {
                return {
                    'pre': function (scope) {
                        /* save the reference to widgetProps in scope */
                        scope.widgetProps = widgetProps;
                    },
                    'post': function (scope, element, attrs, ctrl) {
                        /* register the tabpane with the tabs */
                        ctrl.register(scope);

                        /* when the scope is destoryed unregister the tabpane with the tabs */
                        scope.$on('$destroy', function () {
                            ctrl.unregister(scope);
                        });

                        /* using this method we will be able to select a tab[i.e, make it active] programatically */
                        scope.select = function () {
                            if (scope.isActive || scope.disabled) {
                                return;
                            }

                            /* some widgets like charts needs to be redrawn when a tab becomes active for the first time */
                            element.find('.ng-isolate-scope')
                                .each(function () {
                                    Utils.triggerFn(WM.element(this).isolateScope().redraw);
                                });
                            scope.isActive = true;
                            ctrl.selectTab(scope);
                        };

                        scope._animateIn = function (hasTransition) {

                            var index = element.index(),
                                $parent = element.parent(),
                                delta,
                                tabHeadEl,
                                ul;

                            // when the transition is setup animate the selected tab into the view.
                            if (hasTransition) {
                                delta = index * $parent.width();

                                $parent.animate({scrollLeft: delta}, {
                                    'duration': 'fast',
                                    'start'   : function () {
                                        element.addClass('active');
                                    },
                                    'complete': function () {
                                        element.siblings('.active').removeClass('active');
                                    }
                                });
                            } else {
                                //when the animation is not present toggle the active class.
                                element.siblings('.active').removeClass('active');
                                element.addClass('active');
                            }

                            tabHeadEl = scope.tabHead._element;
                            ul = tabHeadEl.parent()[0];
                            // move the tabheader into the viewport
                            if (tabHeadEl.index()) {
                                ul.scrollLeft = tabHeadEl.prev()[0].offsetLeft;
                            } else {
                                ul.scrollLeft = 0;
                            }
                        };

                        /* initialize the widget */
                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }])
    .directive('wmTabheader', ['$compile', 'PropertiesFactory', 'WidgetUtilService', '$templateCache', 'CONSTANTS', function ($compile, PropertiesFactory, WidgetUtilService, $templateCache, CONSTANTS) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.tabheader', ['wm.base', 'wm.layouts']);

        return {
            'restrict': 'E',
            'scope': {},
            'replace': true,
            'require': '^wmTabpane', /* require the controller of the parent directive. i.e, wmTabpane */
            'transclude': true,
            'template': $templateCache.get('template/layout/container/tab-header.html'),
            'compile': function () {

                return {
                    'pre': function (scope) {
                        scope.widgetProps = widgetProps;
                        if (scope.widgetProps.show) {
                            delete scope.widgetProps.show;// show property should be handled from pane.
                        }
                    },
                    'post': function (scope, element, attrs, ctrl) {
                        /* find the target element to append the default template of the tabheader */
                        var transcludeTarget = element.children('[wmtransclude]'),
                            template,
                            $opt;

                        /* if the tabheader is not provided with any content[i.e, no transcluded content] use the default template */
                        if (transcludeTarget.children().length === 0) {
                            /* default template for the tabheader */
                            template =
                                    '<div class="tab-heading">' +
                                    '<i class="app-icon {{paneicon}}" data-ng-if="paneicon"></i> ' +
                                        '<span data-ng-bind-html="heading"></span>' +
                                        '<i data-ng-click="tab.onClose();" data-ng-if="tab.closable">&nbsp;</i>' +
                                    '</div>';

                            /* compile the default tempalte and append it to the target */
                            template = WM.element(template);
                            transcludeTarget.append(template);
                            $compile(template)(scope);
                        }

                        /*
                         * save a reference of the tabheader element in the scope. tabpane will use this.
                         * tabpane will append the tabheader element to .nav-tabs
                         */
                        scope._element = element;

                        /*
                         * register the tabheader with the tab pane
                         * save the reference of the tabpane's scope in tabheader's scope
                         */
                        scope.tab = ctrl.registerHead(scope);
                        scope.tab.isdefaulttab = scope.isdefaulttab;

                        function _scrollHeader(delta) {
                            var $ul = element.parent(),
                                left = $ul[0].scrollLeft,
                                _delta = -2 * delta;
                            $ul.animate({scrollLeft: left + _delta}, {'duration': 10});
                        }

                        if (CONSTANTS.isRunMode) {
                            // define the functions to scroll the header into the view port on swipe.
                            scope._onHeaderSwipeLeft = function (e) {
                                _scrollHeader(e.deltaX);
                            };

                            scope._onHeaderSwipeRight = function (e) {
                                _scrollHeader(e.deltaX);
                            };
                        } else {
                            // create an option element and add it to the tabs-list element.
                            $opt = WM.element('<option ng-bind-html="heading"></option>');
                            $opt = $compile($opt)(scope);
                            element.closest('.app-tabs').children('select').append($opt);

                            scope.$on('$destroy', function () {
                                if ($opt) {
                                    $opt.remove();
                                }
                            });
                        }

                        if (CONSTANTS.isRunMode) {
                            if (attrs.onSelect) {
                                ctrl.registerCallback('onSelect', attrs._onSelect || attrs.onSelect);
                            }

                            if (attrs.onDeselect) {
                                ctrl.registerCallback('onDeselect', attrs._onDeselect || attrs.onDeselect);
                            }
                        }

                        /* initialize the widget */
                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }])
    .directive('wmTabcontent', ['PropertiesFactory', 'WidgetUtilService', '$templateCache', 'CONSTANTS', 'Utils', function (PropertiesFactory, WidgetUtilService, $templateCache, CONSTANTS, Utils) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.tabcontent', ['wm.base', 'wm.layouts']);

        return {
            'restrict': 'E',
            'scope': {},
            'replace': true,
            'require': '^wmTabpane', /* require the controller of the parent directive. i.e, wmTabpane */
            'transclude': true,
            'template': $templateCache.get('template/layout/container/tab-content.html'),
            'compile': function () {

                return {
                    'pre': function (iScope) {
                        if (CONSTANTS.isStudioMode) {
                            iScope.widgetProps = Utils.getClonedObject(widgetProps);
                            delete iScope.widgetProps.show;// show property should be handled from pane.
                        } else {
                            iScope.widgetProps = widgetProps;
                        }

                        // define $lazyLoad method on iScope.
                        // pageContainer widget will override this.
                        iScope.$lazyLoad = WM.noop;
                    },
                    'post': function (iScope, element, attrs, ctrl) {
                        /*
                         * register the tabcontent with the tab pane
                         * save the reference of the tabpane's scope in tabcontent's scope
                         */
                        iScope.tab = ctrl.registerContent(iScope);
                        // define isActive property on the iScope of tab content.
                        // this property will be used by page-container directive.
                        // when content property is set, the page corresponding to the value of content will be loaded on demand.
                        // if the tab is active (i.e, selected) page will be loaded immediately.
                        Object.defineProperty(iScope, 'isActive', {
                            get: function () {
                                return this.tab.isActive;
                            }
                        });

                        /* initialize the widget */
                        WidgetUtilService.postWidgetCreate(iScope, element, attrs);
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.layouts.containers.directive:wmTabs
 * @restrict E
 *
 * @description
 * The `wmTabs` directive defines tabs widget. <br>
 * wmTabs can only contain wmTabpane widgets. <br>
 * wmTabs can not be inside wmTabs. <br>
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires $templateCache
 * @requires WidgetUtilService
 *
 * @param {string=} name
 *                  Name of the tabs widget.
 * @param {string=} width
 *                  Width of the tabs widget.
 * @param {string=} height
 *                  Height of the tabs widget.
 * @param {boolean=} tabsposition
 *                  Align the tab headers to left/right/top/bottom of the content. <br>
 *                  Default value: `top`
 * @param {string=} transition
 *                  Possible values are `none`, `slide`. <br>
 *                  When the transition value is other than `none`, animation will be used show the selected tab. <br>
 *                  Default value: `none`
 * @param {boolean=} show
 *                  Show is a bindable property. <br>
 *                  This property will be used to show/hide the tabs on the web page. <br>
 *                  Default value: `true`.
 * @param {string=} horizontalalign
 *                  Align the content of the tab to left/right/center. <br>
 *                  Default value: `left`. <br>
 * @param {string=} taborder
 *                  Set the order of the tabs. <br>
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
                <div>
                    <wm-composite>
                        <wm-label caption="width:"></wm-label>
                        <wm-text scopedatavalue="width"></wm-text>
                    </wm-composite>
                    <wm-composite>
                        <wm-label caption="height:"></wm-label>
                        <wm-text scopedatavalue="height"></wm-text>
                    </wm-composite>
                </div>
                <div>Address1: {{address1}}</div>
                <div>Address2: {{address2}}</div>
                <br>
                <wm-tabs width="{{width}}" height="{{height}}">
                    <wm-tabpane>
                        <wm-tabheader heading="tab1"></wm-tabheader>
                        <wm-tabcontent>
                            Content of tab1:<br>
                            Address1:<br>
                            <wm-composite>
                                <wm-label caption="city:"></wm-label>
                                <wm-text scopedatavalue="address1.city"></wm-text>
                            </wm-composite>
                            <wm-composite>
                                <wm-label caption="state:"></wm-label>
                                <wm-text scopedatavalue="address1.state"></wm-text>
                            </wm-composite>
                            <wm-composite>
                                <wm-label caption="zip:"></wm-label>
                                <wm-text scopedatavalue="address1.zip"></wm-text>
                            </wm-composite>
                        </wm-tabcontent>
                    </wm-tabpane>
                    <wm-tabpane>
                        <wm-tabheader heading="tab2"></wm-tabheader>
                        <wm-tabcontent>
                            Content of tab2:<br>
                            Address2:<br>
                            <wm-composite>
                                <wm-label caption="city:"></wm-label>
                                <wm-text scopedatavalue="address2.city"></wm-text>
                            </wm-composite>
                            <wm-composite>
                                <wm-label caption="state:"></wm-label>
                                <wm-text scopedatavalue="address2.state"></wm-text>
                            </wm-composite>
                            <wm-composite>
                                <wm-label caption="zip:"></wm-label>
                                <wm-text scopedatavalue="address2.zip"></wm-text>
                            </wm-composite>
                        </wm-tabcontent>
                    </wm-tabpane>
                </wm-tabs>
            </div>
        </file>
        <file name="script.js">
            function Ctrl($scope) {
                // set the default values
                $scope.tabsposition = "top";
                $scope.width = 300;
                $scope.height = 300;
            }
        </file>
    </example>
 */

/**
 * @ngdoc directive
 * @name wm.layouts.containers.directive:wmTabpane
 * @restrict E
 *
 * @description
 * The `wmTabpane` directive defines tab-pane widget. <br>
 * wmTabpane can be used only inside wmTabs. <br>
 * wmTabpane can not be inside wmTabpane. <br>
 * A tab can be selected using the scope method `select`.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires $templateCache
 * @requires WidgetUtilService
 *
 * @param {string=} name
 *                  Name of the tabpane.
 * @param {boolean=} show
 *                  Show is a bindable property. <br>
 *                  This property will be used to show/hide the tab on the web page. <br>
 *                  Default value: `true`.
 * @param {string=} on-select
 *                  Callback function which will be triggered when the tab is selected.
 * @param {string=} on-deselect
 *                  Callback function which will be triggered when the tab is deselected.
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
                <div>
                    tab1 selected {{tab1count}} times.
                </div>
                <div>
                    tab2 selected {{tab2count}} times.
                </div>
                <br>
                <wm-tabs>
                    <wm-tabpane on-select="onTab1Select()" on-deselect="onTab1Deselect()">
                        <wm-tabheader heading="tab1"></wm-tabheader>
                        <wm-tabcontent>
                            Content of tab1:<br>
                        </wm-tabcontent>
                    </wm-tabpane>
                    <wm-tabpane on-select="onTab2Select()">
                        <wm-tabheader heading="tab2"></wm-tabheader>
                        <wm-tabcontent>
                            Content of tab2:<br>
                        </wm-tabcontent>
                    </wm-tabpane>
                </wm-tabs>
            </div>
        </file>
        <file name="script.js">
            function Ctrl($scope) {
               $scope.tab1count = 0;
               $scope.tab2count = 0;
               $scope.onTab1Select = function () {
                   console.log("inside tab1select");
                   $scope.tab1count++;
               }
               $scope.onTab1Deselect = function () {
                   console.log("inside tab1 Deselect");
               }
               $scope.onTab2Select = function() {
                   console.log("inside tab2select");
                   $scope.tab2count++;
               }
            }
        </file>
    </example>
 */

/**
 * @ngdoc directive
 * @name wm.layouts.containers.directive:wmTabheader
 * @restrict E
 *
 * @description
 * The `wmTabheader` directive defines tab-header widget. <br>
 * wmTabheader can be used only inside wmTabpane. <br>
 * If there is no transcluded content, default template will be used. <br>
 *
 * Default template:<br>
 * &lt;div class='tab-heading'&gt; <br>
 * &lt;i class='app-icon' data-ng-show='iconsource' data-ng-style ='{backgroundImage:iconsource}'&gt;&nbsp;&lt;/i&gt; <br> { {heading} } <br>
 * &lt;i data-ng-click='tab.onClose();' data-ng-if='tab.closable'&gt;&nbsp;&lt;/i&gt; <br>
 * &lt;/div&gt;
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires $templateCache
 * @requires WidgetUtilService
 * @requires $compile
 * @requires Utils
 *
 * @param {string=} name
 *                  Name of the tabheader.
 * @param {string=} heading
 *                  Title of the header. <br>
 *                  This property is bindable. <br>
 *                  Default value: `Tab Title`. <br>
 *                  This is will be used only when the default template is used.
 * @param {string=} paneicon
 *                  Icon which we displayed on the tab-header. <br>
 *                  This property is bindable. <br>
 *                  This is will be used only when the default template is used.
 * @param {boolean=} show
 *                  Show is a bindable property. <br>
 *                  This property will be used to show/hide the tab on the web page. <br>
 *                  Default value: `true`.
 * @param {boolean=} isdefaulttab
 *                  isdefaulttab is a bindable property. <br>
 *                  First tab with `isdefaulttab = true` will be displayed by default.<br>
 *                  Default value: `false`.
 * @param {string=} horizontalalign
 *                  Align the content of the tab-header to left/right/center. <br>
 *                  Default value: `left`.
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
                <br>
                <wm-tabs>
                    <wm-tabpane>
                        <wm-tabheader heading="{{tab1heading}}"></wm-tabheader>
                        <wm-tabcontent>
                            Content of tab1:<br>
                        </wm-tabcontent>
                    </wm-tabpane>
                    <wm-tabpane>
                        <wm-tabheader isdefaulttab="true"><a><wm-label caption="tab2"><wm-label></a></wm-tabheader>
                        <wm-tabcontent>
                            Content of tab2:<br>
                        </wm-tabcontent>
                    </wm-tabpane>
                </wm-tabs>
            </div>
        </file>
        <file name="script.js">
            function Ctrl($scope) {
               $scope.tab1heading = "Tab1";
            }
        </file>
    </example>
 */

/**
 * @ngdoc directive
 * @name wm.layouts.containers.directive:wmTabcontent
 * @restrict E
 *
 * @description
 * The `wmTabcontent` directive defines tab-content widget. <br>
 * wmTabcontent can be used only inside wmTabpane.
 *
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires $templateCache
 * @requires WidgetUtilService
 *
 * @param {string=} name
 *                  Name of the tabs widget.
 * @param {string=} width
 *                  Width of the tabs widget.
 * @param {string=} height
 *                  Height of the tabs widget.
 * @param {boolean=} show
 *                  Show is a bindable property. <br>
 *                  This property will be used to show/hide the tabs on the web page. <br>
 *                  Default value: `true`.
 * @param {string=} horizontalalign
 *                  Align the content of the tab to left/right/center. <br>
 *                  Default value: `left`. <br>
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
                <br>
                <wm-tabs>
                    <wm-tabpane>
                        <wm-tabheader heading="{{tab1heading}}"></wm-tabheader>
                        <wm-tabcontent>
                            Content of tab1:<br>
                        </wm-tabcontent>
                    </wm-tabpane>
                    <wm-tabpane>
                        <wm-tabheader isdefaulttab="true"><a><wm-label caption="tab2"></wm-label></a></wm-tabheader>
                        <wm-tabcontent>
                            Content of tab2:<br>
                        </wm-tabcontent>
                    </wm-tabpane>
                </wm-tabs>
            </div>
        </file>
        <file name="script.js">
            function Ctrl($scope) {
               $scope.tab1heading = "Tab1";
            }
        </file>
    </example>
 */
/*global WM*/

/**
 * @ngdoc service
 * @name wm.layouts.page.$ViewService
 * @description
 * The `ViewService` provides methods for showing and hiding a particular view.
 */

WM.module('wm.layouts.page')
    .service('ViewService', [function () {
        'use strict';
        var viewsScope = [],
        /*used internally to hide all views in a viewGroup*/
            hideActiveView = function (viewGroup) {
                var i;
                for (i = 0; i < viewsScope.length; i += 1) {
                    if (viewsScope[i].show && (viewsScope[i].viewgroup === viewGroup)) {
                        viewsScope[i].show = false;
                    }
                }
            },

        /*used internally to show a given view in a viewGroup*/
            goToView = function (viewGroup, viewName) {
                var i;
                for (i = 0; i < viewsScope.length; i += 1) {
                    if (viewsScope[i].viewgroup === viewGroup && viewsScope[i].name === viewName) {
                        /*hide all views of that viewgroup */
                        hideActiveView(viewGroup);
                        /*show the given view*/
                        viewsScope[i].show = true;
                        viewsScope[i].initialize();
                        break;
                    }
                }
            },

        /**
         * @ngdoc function
         * @name wm.layouts.page.$ViewService#registerView
         * @methodOf wm.layouts.page.$ViewService
         * @function
         *
         * @description
         * registers a view
         *
         * @param {object} scope of the view to be registered
         */
            registerView = function (scope) {
                viewsScope.push(scope);
            },

            /**
             * @ngdoc function
             * @name wm.layouts.page.$ViewService#unregisterView
             * @methodOf wm.layouts.page.$ViewService
             * @function
             *
             * @description
             * unregister a view
             *
             * @param {object} scope of the view to be unregistered
             */
            unregisterView = function (scope) {
                viewsScope.splice(viewsScope.indexOf(scope), 1);
            },

        /**
         * @ngdoc function
         * @name wm.layouts.page.$ViewService#showView
         * @methodOf wm.layouts.page.$ViewService
         * @function
         *
         * @description
         * shows a given view
         *
         * @param {string} name of the view to be shown
         */
            showView = function (name) {
                var view = WM.element("[name=" + name + "]"),
                    parentViews = view.parents(".app-view"),
                    i;
                /*in case a child view has to be shown, its parent also needs to be shown*/
                for (i = 0; i < parentViews.length; i += 1) {
                    /*the default viewgroup is default*/
                    goToView(parentViews.attr("viewgroup") || "default", parentViews.attr("name"));
                }
                if (view.length > 0) {
                    goToView(view.isolateScope().viewgroup, name);
                }
            },
        /**
         * @ngdoc function
         * @name wm.layouts.page.$ViewService#hideView
         * @methodOf wm.layouts.page.$ViewService
         * @function
         *
         * @description
         * shows a given view
         *
         * @param {string} name of the view to be hidden
         */
            hideView = function (name) {
                hideActiveView(WM.element("[name=" + name + "]").isolateScope().viewgroup);
            },

        /**
         * @ngdoc function
         * @name wm.layouts.page.$ViewService#getViews
         * @methodOf wm.layouts.page.$ViewService
         * @function
         *
         * @description
         * returns all the view of project
         *
         */
            getViews = function () {
                return viewsScope;
            },
        /**
         * @ngdoc function
         * @name wm.layouts.page.$ViewService#clearViews
         * @methodOf wm.layouts.page.$ViewService
         * @function
         *
         * @description
         * clear the viewScope variable
         *
         */
            clearViews = function () {
                viewsScope = [];
            };
        return {
            registerView: registerView,
            unregisterView: unregisterView,
            hideView: hideView,
            showView: showView,
            getViews: getViews,
            clearViews: clearViews
        };
    }]);


/*global WM*/

WM.module('wm.layouts.page')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/layout/page/column.html',
                '<div init-widget class="app-column" apply-styles="container"><div class="app-ng-transclude" wmtransclude></div></div>'
            );
    }])
    .directive('wmColumn', ['PropertiesFactory', 'WidgetUtilService', function (PropertiesFactory, WidgetUtilService) {
        'use strict';

        var widgetProps = PropertiesFactory.getPropertiesOf('wm.layouts.column', ['wm.layouts', 'wm.base.events.touch']),
            notifyFor = {
                'columnwidth': true
            };

        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
        function propertyChangeHandler(element, key, newVal, oldVal) {
            switch (key) {
            case 'columnwidth':
                /*If columnwidth is passed set the appropriate class*/
                element.removeClass('col-md-' + oldVal + ' col-sm-' + oldVal).addClass('col-md-' + newVal + ' col-sm-' + newVal);
                break;
            }
        }

        return {
            'restrict': 'E',
            'replace': true,
            'scope': {},
            'transclude': true,
            /* horizontalalign also bound to textAlign for similar function. horizontalalign overrides textalign */
            'template': WidgetUtilService.getPreparedTemplate.bind(undefined, 'template/layout/page/column.html'),
            'compile': function () {
                return {
                    'pre': function (scope) {
                        /*Applying widget properties to directive scope*/
                        scope.widgetProps = widgetProps;
                    },

                    'post': function (scope, element, attrs) {
                        /*If columnwidth is passed set the appropriate class*/

                        if (scope.columnwidth) {
                            WM.element(element).addClass('col-md-' + scope.columnwidth + ' col-sm-' + scope.columnwidth);
                        }

                        /* register the property change handler */
                        WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, element), scope, notifyFor);
                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.layouts.page.directive:wmColumn
 * @restrict E
 *
 * @description
 * The 'wmColumn' directive defines a column in the layout.
 * wmColumn is internally used by wmRow.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 *
 * @param {string=} columnWidth Sets the width of the column, it varies between 1 and 12.<br>
 *                  columnWidth is restricted to a range, to suit bootstrap fluid grid system
 * @param {string=} horizontalalign
 *                  Align the content in the right panel to left/right/center.<br>
 *                  Default value for horizontalalign is `left`.
 * @param {string=} on-swipeup
 *                  Callback function for `swipeup` event.
 * @param {string=} on-swipedown
 *                  Callback function for `swipedown` event.
 * @param {string=} on-swiperight
 *                  Callback function for `swiperight` event.
 * @param {string=} on-swipeleft
 *                  Callback function for `swipeleft` event.
 * @param {string=} on-pinchin
 *                  Callback function for `pinchin` event.
 * @param {string=} on-pinchdown
 *                  Callback function for `pinchdown` event.
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
                <div style="padding:10px">
                    <input type="number" min="1" max="12" step="1" data-ng-model="colWidth" style="width: 100px; height: 35px;padding-left:10px;font-size:1.2em">
                    <div style="margin-top:10px">
                        <wm-column columnwidth="{{colWidth}}" style="background-color:teal; height: 100px"></wm-column>
                    </div>
                </div>
            </div>
        </file>
        <file name="script.js">
            function Ctrl($scope) {
                $scope.colWidth = 6;
            }
        </file>
    </example>
 */

/*global WM*/

WM.module('wm.layouts.page')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/layout/page/pagecontent.html',
            '<div init-widget class="app-page-content app-content-column" apply-styles="container"><div class="app-ng-transclude" wmtransclude></div></div>'
            );
    }])
    .directive('wmPageContent', ['PropertiesFactory', 'WidgetUtilService', 'CONSTANTS', 'Utils', function (PropertiesFactory, WidgetUtilService, CONSTANTS, Utils) {
        'use strict';

        var widgetProps = PropertiesFactory.getPropertiesOf('wm.layouts.pagecontent', ['wm.layouts', 'wm.base.events.touch']),
            notifyFor = {
                'columnwidth': true
            };

        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
        function propertyChangeHandler(element, key, newVal, oldVal) {
            switch (key) {
            case 'columnwidth':
                /*If columnwidth is passed set the appropriate class*/
                element.removeClass('col-md-' + oldVal + ' col-sm-' + oldVal).addClass('col-md-' + newVal + ' col-sm-' + newVal);
                break;
            }
        }

        return {
            'restrict': 'E',
            'replace': true,
            'scope': {},
            'transclude': true,
            /* horizontalalign also bound to textAlign for similar function. horizontalalign overrides textalign */
            'template': WidgetUtilService.getPreparedTemplate.bind(undefined, 'template/layout/page/pagecontent.html'),
            'compile': function () {
                return {
                    'pre': function (scope, element) {
                        /*Applying widget properties to directive scope*/
                        scope.widgetProps = widgetProps;
                        if (CONSTANTS.isRunMode) {
                            Utils.triggerFn(element.scope().registerPagePart);
                            scope.loadmode = 'after-delay';
                            scope.loaddelay = 100;
                            scope.__onTransclude = function () {
                                Utils.triggerFn(element.scope().onPagePartLoad);
                            };
                        }
                    },

                    'post': function (scope, element, attrs) {
                        /*If columnwidth is passed set the appropriate class*/

                        if (scope.columnwidth) {
                            WM.element(element).addClass('col-md-' + scope.columnwidth + ' col-sm-' + scope.columnwidth);
                        }

                        /* register the property change handler */
                        WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, element), scope, notifyFor);
                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.layouts.page.directive:wmPageContent
 * @restrict E
 *
 * @description
 * The 'wmPageContent' directive defines a pagecontent in the layout.
 * wmPageContent is internally used by wmRow.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 *
 * @param {string=} columnWidth Sets the width of the pagecontent, it varies between 1 and 12.<br>
 *                  columnWidth is restricted to a range, to suit bootstrap fluid grid system
 * @param {string=} horizontalalign
 *                  Align the content in the right panel to left/right/center.<br>
 *                  Default value for horizontalalign is `left`.
 * @param {string=} on-swipeup
 *                  Callback function for `swipeup` event.
 * @param {string=} on-swipedown
 *                  Callback function for `swipedown` event.
 * @param {string=} on-swiperight
 *                  Callback function for `swiperight` event.
 * @param {string=} on-swipeleft
 *                  Callback function for `swipeleft` event.
 * @param {string=} on-pinchin
 *                  Callback function for `pinchin` event.
 * @param {string=} on-pinchdown
 *                  Callback function for `pinchdown` event.
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div class="wm-app">
                <wm-page data-ng-controller="MainPageController">
                    <wm-header height="50" backgroundcolor="teal">Content of Header</wm-header>
                    <wm-top-nav height="30" backgroundcolor="tomato">Content of TopNav</wm-top-nav>
                    <wm-content>
                        <wm-left-panel columnwidth="2" backgroundcolor="#fd4c70">Content of LeftNav</wm-left-panel>
                        <wm-page-content columnwidth="8" backgroundcolor="#0097a4">Content of Page</wm-page-content>
                        <wm-right-panel columnwidth="2" backgroundcolor="#934cfd">Content of RightNav</wm-right-panel>
                    </wm-content>
                <wm-footer backgroundcolor="#f66f8a">Content of Footer</wm-footer>
                </wm-page>
            </div>
        </file>
        <file name="script.js">
            function MainPageController($scope) {}
        </file>
    </example>
 */

/*global WM*/

WM.module('wm.layouts.page')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/layout/page/content.html',
                '<main  data-role="page-content" init-widget class="app-content clearfix" apply-styles>' +
                    '<div class="row app-content-row clearfix" wmtransclude>' + '</div>' +
                '</main>'
            );
    }])
    .directive('wmContent', ['PropertiesFactory', 'WidgetUtilService', function (PropertiesFactory, WidgetUtilService) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.layouts.content', ['wm.layouts', 'wm.base.events.touch']);

        return {
            'restrict': 'E',
            'replace': true,
            'transclude': true,
            'scope': {},
            'template': WidgetUtilService.getPreparedTemplate.bind(undefined, 'template/layout/page/content.html'),
            'compile': function () {
                return {
                    'pre': function (scope) {
                        /*Applying widget properties to directive scope*/
                        scope.widgetProps = widgetProps;
                    },

                    'post': function (scope, element, attrs) {
                        /*Cleaning the widget markup such that the widget wrapper is not cluttered with unnecessary property or
                         * style declarations.*/
                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.layouts.page.directive:wmContent
 * @restrict E
 *
 * @description
 * The 'wmContent' directive defines a content container in the layout. It contains rows, which in turn contain columns.
 * wmContent is internally used by wmPage.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 *
 * @param {string=} height
 *                  Height of the content.
 * @param {string=} horizontalalign
 *                  Align the elements in the content to left/right/center.<br>
 *                  Default value for horizontalalign is `left`.
 * @param {string=} on-swipeup
 *                  Callback function for `swipeup` event.
 * @param {string=} on-swipedown
 *                  Callback function for `swipedown` event.
 * @param {string=} on-swiperight
 *                  Callback function for `swiperight` event.
 * @param {string=} on-swipeleft
 *                  Callback function for `swipeleft` event.
 * @param {string=} on-pinchin
 *                  Callback function for `pinchin` event.
 * @param {string=} on-pinchdown
 *                  Callback function for `pinchdown` event.
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div class="wm-app">
                <wm-page data-ng-controller="MainPageController">
                    <wm-header height="50" backgroundcolor="teal">Content of Header</wm-header>
                    <wm-top-nav height="30" backgroundcolor="tomato">Content of TopNav</wm-top-nav>
                    <wm-content>
                        <wm-left-panel columnwidth="2" backgroundcolor="#fd4c70">Content of LeftNav</wm-left-panel>
                        <wm-page-content columnwidth="8" backgroundcolor="#0097a4">Content of Page</wm-page-content>
                        <wm-right-panel columnwidth="2" backgroundcolor="#934cfd">Content of RightNav</wm-right-panel>
                    </wm-content>
                    <wm-footer backgroundcolor="#f66f8a">Content of Footer</wm-footer>
                </wm-page>
            </div>
         </file>
         <file name="script.js">
             function MainPageController($scope) {}
         </file>
    </example>
 */

/*global WM*/

WM.module('wm.layouts.page')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/layout/page/footer.html',
                '<footer data-role="page-footer" page-container page-container-target init-widget class="app-footer clearfix" apply-styles="container" wmtransclude></footer>'
            );
    }])
    .directive('wmFooter', ['PropertiesFactory', 'WidgetUtilService', 'CONSTANTS', 'Utils',  function (PropertiesFactory, WidgetUtilService, CONSTANTS, Utils) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.layouts.footer', ['wm.layouts', 'wm.base.events.touch']);

        return {
            'restrict': 'E',
            'replace': true,
            'scope': {},
            'transclude': true,
            'template': WidgetUtilService.getPreparedTemplate.bind(undefined, 'template/layout/page/footer.html'),
            'compile': function () {
                return {
                    'pre': function (iScope, element) {
                        if (CONSTANTS.isStudioMode) {
                            iScope.widgetProps = Utils.getClonedObject(widgetProps);
                        } else {
                            iScope.widgetProps = widgetProps;
                            // this flag is used to change the layout of the mobile view accordingly
                            element.scope().layout.footer = true;
                        }
                    },

                    'post': function (scope, element, attrs) {
                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.layouts.page.directive:wmFooter
 * @restrict E
 *
 * @description
 * The 'wmFooter' directive defines a footer in the layout.
 * wmFooter is internally used by wmPage.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 * @requires CONSTANTS
 *
 * @param {string=} height
 *                  Height of the footer.
 * @param {string=} horizontalalign
 *                  Align the content in the footer to left/right/center.<br>
 *                  Default value for horizontalalign is `left`.
 * @param {string=} on-swipeup
 *                  Callback function for `swipeup` event.
 * @param {string=} on-swipedown
 *                  Callback function for `swipedown` event.
 * @param {string=} on-swiperight
 *                  Callback function for `swiperight` event.
 * @param {string=} on-swipeleft
 *                  Callback function for `swipeleft` event.
 * @param {string=} on-pinchin
 *                  Callback function for `pinchin` event.
 * @param {string=} on-pinchdown
 *                  Callback function for `pinchdown` event.
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div class="wm-app">
                <wm-page data-ng-controller="MainPageController">
                    <wm-header height="50" backgroundcolor="teal">Content of Header</wm-header>
                    <wm-top-nav height="30" backgroundcolor="tomato">Content of TopNav</wm-top-nav>
                    <wm-content>
                        <wm-left-panel columnwidth="2" backgroundcolor="#fd4c70">Content of LeftNav</wm-left-panel>
                        <wm-page-content columnwidth="8" backgroundcolor="#0097a4">Content of Page</wm-page-content>
                        <wm-right-panel columnwidth="2" backgroundcolor="#934cfd">Content of RightNav</wm-right-panel>
                    </wm-content>
                    <wm-footer backgroundcolor="#f66f8a">Content of Footer</wm-footer>
                </wm-page>
            </div>
        </file>
        <file name="script.js">
            function MainPageController($scope) {}
        </file>
    </example>
 */
/*global WM*/

WM.module('wm.layouts.page')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/layout/page/header.html',
                '<header data-role="page-header"  page-container init-widget class="app-header clearfix" apply-styles="container">' +
                    '<div class="visible-xs-inline-block" data-role="page-left-panel-icon"><a class="app-header-action glyphicon glyphicon-menu-hamburger"></a></div>' +
                    '<div class="app-header-container" wmtransclude page-container-target></div>' +
                '</header>'
            );
    }])
    .directive('wmHeader', ['PropertiesFactory', 'WidgetUtilService', 'CONSTANTS', 'Utils', function (PropertiesFactory, WidgetUtilService, CONSTANTS, Utils) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.layouts.header', ['wm.layouts', 'wm.base.events.touch']);

        return {
            'restrict': 'E',
            'replace': true,
            'scope': {},
            'transclude': true,
            'template': WidgetUtilService.getPreparedTemplate.bind(undefined, 'template/layout/page/header.html'),
            'compile': function () {
                return {
                    'pre': function (iScope, element) {
                        if (CONSTANTS.isStudioMode) {
                            iScope.widgetProps = Utils.getClonedObject(widgetProps);
                        } else {
                            iScope.widgetProps = widgetProps;
                            element.scope().layout.header = true;
                        }
                    },
                    'post': function (scope, element, attrs) {
                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]);


/**
 * @ngdoc directive
 * @name wm.layouts.page.directive:wmHeader
 * @restrict E
 *
 * @description
 * The 'wmHeader' directive defines a header in the layout.
 * wmHeader is internally used by wmPage.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 * @requires CONSTANTS
 *
 * @param {string=} height
 *                  Height of the header.
 * @param {string=} horizontalalign
 *                  Align the content in the header to left/right/center.<br>
 *                  Default value for horizontalalign is `left`.
 * @param {string=} on-swipeup
 *                  Callback function for `swipeup` event.
 * @param {string=} on-swipedown
 *                  Callback function for `swipedown` event.
 * @param {string=} on-swiperight
 *                  Callback function for `swiperight` event.
 * @param {string=} on-swipeleft
 *                  Callback function for `swipeleft` event.
 * @param {string=} on-pinchin
 *                  Callback function for `pinchin` event.
 * @param {string=} on-pinchdown
 *                  Callback function for `pinchdown` event.
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div class="wm-app">
                <wm-page data-ng-controller="MainPageController">
                    <wm-header height="50" backgroundcolor="teal">Content of Header</wm-header>
                    <wm-top-nav height="30" backgroundcolor="tomato">Content of TopNav</wm-top-nav>
                    <wm-content>
                        <wm-left-panel columnwidth="2" backgroundcolor="#fd4c70">Content of LeftNav</wm-left-panel>
                        <wm-page-content columnwidth="8" backgroundcolor="#0097a4">Content of Page</wm-page-content>
                        <wm-right-panel columnwidth="2" backgroundcolor="#934cfd">Content of RightNav</wm-right-panel>
                    </wm-content>
                    <wm-footer backgroundcolor="#f66f8a">Content of Footer</wm-footer>
                 </wm-page>
            </div>
        </file>
        <file name="script.js">
            function MainPageController($scope) {}
        </file>
    </example>
 */

/*global WM*/

WM.module('wm.layouts.page')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/layout/page/leftpanel.html',
                '<aside data-role="page-left-panel" page-container init-widget class="app-left-panel" hm-swipe-left="collapse();" data-ng-class="animation" apply-styles="container">' +
                    '<div class="app-ng-transclude" wmtransclude page-container-target></div>' +
                '</aside>'
            );
    }])
    .directive('wmLeftPanel', ['PropertiesFactory', 'WidgetUtilService', '$rootScope', '$timeout', 'CONSTANTS', 'Utils', function (PropertiesFactory, WidgetUtilService, $rootScope, $timeout, CONSTANTS, Utils) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.layouts.leftpanel', ['wm.layouts', 'wm.base.events.touch']),
            notifyFor = {
                'columnwidth': true,
                'animation': true
            };

        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
        function propertyChangeHandler(element, key, newVal, oldVal) {
            switch (key) {
            case 'columnwidth':
                /*If columnwidth is passed set the appropriate class*/
                element.removeClass('col-md-' + oldVal + ' col-sm-' + oldVal).addClass('col-md-' + newVal + ' col-sm-' + newVal);
                break;
            case 'animation':
                var appPage = element.closest('.app-page');
                if (newVal === 'slide-in') {
                    appPage.addClass('slide-in-left-panel-container');
                } else {
                    appPage.removeClass('slide-in-left-panel-container');
                }
                break;
            }
        }

        return {
            'restrict': 'E',
            'replace': true,
            'scope': {},
            'transclude': true,
            'template': function (tElement, tAttrs) {
                var isWidgetInsideCanvas = tAttrs.hasOwnProperty('widgetid'),
                    template = WM.element(WidgetUtilService.getPreparedTemplate('template/layout/page/leftpanel.html', tElement, tAttrs));

                if (!isWidgetInsideCanvas) {
                    /*** fix for old projects ***/
                    if (!tAttrs.columnwidth) {
                        template.attr('columnwidth', '2');
                    }
                }
                return template[0].outerHTML;
            },
            'compile': function () {
                return {
                    'pre': function (iScope) {
                        if (CONSTANTS.isStudioMode) {
                            iScope.widgetProps = Utils.getClonedObject(widgetProps);
                        } else {
                            iScope.widgetProps = widgetProps;
                        }
                    },

                    'post': function (scope, element, attrs) {
                        /*If columnwidth is passed set the appropriate class*/
                        if (scope.columnwidth) {
                            WM.element(element).addClass('col-md-' + scope.columnwidth + ' col-sm-' + scope.columnwidth);
                        }
                        var eventName = 'click.leftNavToggle';
                        scope.toggle = function () {
                            if (element.hasClass('visible')) {
                                scope.collapse();
                            } else {
                                scope.expand();
                            }
                        };
                        scope.expand = function () {
                            var appPage = element.closest('.app-page'),
                                skipEvent = true;
                            element.addClass('visible');
                            if (scope.animation === 'slide-in') {
                                appPage.addClass('slide-in-left-panel-container slide-left');
                            }
                            element.on(eventName, function () {
                                skipEvent = true;
                            });
                            appPage.on(eventName, function () {
                                if (!skipEvent) {
                                    scope.collapse();
                                }
                                skipEvent = false;
                            });
                        };
                        scope.collapse = function () {
                            var appPage = element.closest('.app-page');
                            element.removeClass('visible');
                            element.off(eventName);
                            appPage.off(eventName);
                            if (scope.animation === 'slide-in') {
                                appPage.removeClass('slide-left');
                                //Remove the container class after the animation completion.
                                $timeout(function () {
                                    appPage.removeClass('slide-in-left-panel-container');
                                }, 600);
                            }
                        };
                        /* register the property change handler */
                        WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, element), scope, notifyFor);
                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                        scope.collapse();
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.layouts.page.directive:wmLeftPanel
 * @restrict E
 *
 * @description
 * The 'wmLeftPanel' directive defines a left panel in the layout.
 * wmLeftPanel is internally used by wmContent.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 *
 * @param {string=} horizontalalign
 *                  Align the content in the left panel to left/right/center.<br>
 *                  Default value for horizontalalign is `left`.
 * @param {string=} on-swipeup
 *                  Callback function for `swipeup` event.
 * @param {string=} on-swipedown
 *                  Callback function for `swipedown` event.
 * @param {string=} on-swiperight
 *                  Callback function for `swiperight` event.
 * @param {string=} on-swipeleft
 *                  Callback function for `swipeleft` event.
 * @param {string=} on-pinchin
 *                  Callback function for `pinchin` event.
 * @param {string=} on-pinchdown
 *                  Callback function for `pinchdown` event.
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div class="wm-app">
                <wm-page data-ng-controller="MainPageController">
                    <wm-header height="50" backgroundcolor="teal">Content of Header</wm-header>
                    <wm-top-nav height="30" backgroundcolor="tomato">Content of TopNav</wm-top-nav>
                    <wm-content>
                        <wm-left-panel columnwidth="2" backgroundcolor="#fd4c70">Content of LeftNav</wm-left-panel>
                        <wm-page-content columnwidth="8" backgroundcolor="#0097a4">Content of Page</wm-page-content>
                        <wm-right-panel columnwidth="2" backgroundcolor="#934cfd">Content of RightNav</wm-right-panel>
                    </wm-content>
                    <wm-footer backgroundcolor="#f66f8a">Content of Footer</wm-footer>
                </wm-page>
            </div>
        </file>
        <file name="script.js">
            function MainPageController($scope) {}
        </file>
    </example>
 */


/*global WM, _, document*/

WM.module('wm.layouts.page')
    .directive('wmPage', ['DeviceViewService', 'CONSTANTS', '$rootScope', '$routeParams', 'Utils', '$timeout', 'Variables', 'NavigationVariableService', function (DeviceViewService, CONSTANTS, $rootScope, $routeParams, Utils, $timeout, Variables, NavigationVariableService) {
        'use strict';

        var extendVariables = function (scope, variables) {
            WM.forEach(variables, function (variable, name) {
                if (!scope.Variables.hasOwnProperty(name)) {
                    Object.defineProperty(scope.Variables, name, {
                        configurable: true,
                        get: function () {
                            return variable;
                        }
                    });
                }
            });
        };

        return {
            'restrict': 'E',
            'replace': true,
            'transclude': true,
            'template': '<div data-role="pageContainer" class="app-page container" data-ng-class="layoutClass" wmtransclude></div>',
            'compile': function () {
                return {
                    'pre': function (scope, element, attrs) {
                        var pageName = (!$rootScope.isPrefabTemplate && scope.prefabname) || ($rootScope.isPrefabTemplate && "Main") || attrs.ngController.replace('PageController', ''),
                            variableScope = CONSTANTS.isStudioMode && !scope.prefabname && !scope.$parent.partialname ? $rootScope.domScope : scope,
                            containerScope,
                            count,
                            subView;

                        if (CONSTANTS.isRunMode) {
                            scope.Variables = {};
                            scope.Widgets = {};
                            /* only expose the widgets of the active page to rootScope */
                            if (!scope.$parent.partialname && !scope.prefabname) {
                                $rootScope.Widgets = scope.Widgets;
                                $rootScope.$activePageEl = element;
                            }
                            if (scope.$parent.partialname) {
                                /* get partial page container's scope */
                                containerScope = scope.$parent.Widgets && scope.$parent.Widgets[scope.$parent.partialcontainername];

                                /* expose partial's Widgets to its container's scope (to be visible to parent) */
                                if (containerScope) {
                                    containerScope.Widgets = scope.Widgets;
                                }
                            }

                            if ($routeParams.name === $rootScope.activePageName) {
                                document.title = attrs.pagetitle || $rootScope.activePageName + ' - ' + $rootScope.projectName;
                            }
                        }

                        if (CONSTANTS.isStudioMode) {
                            containerScope = scope.$parent.Widgets && scope.$parent.Widgets[scope.$parent.partialcontainername];
                            if (containerScope && WM.isDefined(containerScope.Widgets)) {
                                scope.Widgets = {};
                                containerScope.Widgets = scope.Widgets;
                            }
                        }
                        // define registerPageContainer and onPageContainerLoad methods in Run Mode.
                        if (!scope.registerPageContainer && CONSTANTS.isRunMode) {
                            count = 0;

                            scope.layout = {
                                'leftSection': false,
                                'rightSection': false,
                                'header': false,
                                'footer': false,
                                'search': false
                            };

                            scope.onPageLoad = function () {
                                // if the count is zero(means the page is ready), trigger update method of DeviceViewService
                                if (!count) {
                                    //trigger the onPageReady method
                                    if (scope.hasOwnProperty('onPageReady')) {
                                        Utils.triggerFn(scope.onPageReady);
                                    }

                                    /* if subview element names found (appended with page-name after a '.'), navigate to the view element */
                                    if ($routeParams && $routeParams.name) {
                                        subView = $routeParams.name.split(".");
                                        if (subView.length > 1) {
                                            NavigationVariableService.goToView(subView.pop());
                                        }
                                    }

                                    /* update layout after the page is rendered */

                                    scope.layout.search = element.find('[data-role="page-header"] .app-search');
                                    scope.layout.leftSection = element.find('[data-role="page-left-panel"]').length > 0;
                                    scope.layout.rightSection = element.find('[data-role="page-right-panel"]').length > 0;
                                    // update the device after some delay
                                    $timeout(function () {
                                        DeviceViewService.update(element, scope.layout.leftSection, scope.layout.rightSection, scope.layout.search);
                                        $rootScope.$emit('page-ready');
                                    });
                                }
                            };

                            // increment the counter when a pageContainer is registered
                            scope.registerPagePart = function () {
                                count++;
                            };

                            scope.onPagePartLoad = function () {
                                --count; // decrement the counter when the a pageContainer is ready
                                scope.onPageLoad();
                            };

                            /* if specified, call handle route function in the page.js */
                            if (WM.isFunction(scope.handleRoute)) {
                                /*gather all the routeParams, send them as arguments to the fn except first element, as first element is pageName */
                                scope.handleRoute.apply(undefined, _.values($routeParams).slice(1));
                            }
                        }

                        /* register the page variables */
                        Variables.getPageVariables(pageName, function (variables) {
                            Variables.register(pageName, variables, true, variableScope);

                            /* expose partial page's Variabes to its container's scope (to be visible to parent) */
                            if (containerScope) {
                                containerScope.Variables = scope.Variables;
                            }

                            /* if app variables loaded, extend page variables with them */
                            if ($rootScope.Variables) {
                                extendVariables(variableScope, $rootScope.Variables);
                                /* if specified, call page variables ready function in the page.js */
                                Utils.triggerFn(scope.onPageVariablesReady);
                            } else {
                                /* listen to the page-variables-ready event */
                                element.on('$destroy', $rootScope.$on('on-app-variables-ready', function (event, appVariables) {
                                    extendVariables(variableScope, $rootScope.Variables);
                                    /* if specified, call app variables ready function in the app.js */
                                    Utils.triggerFn(scope.$root.onAppVariablesReady, appVariables);
                                    /* if specified, call page variables ready function in the page.js */
                                    Utils.triggerFn(scope.onPageVariablesReady);
                                }));
                            }
                        });
                    },
                    'post': function (scope, element, attrs) {
                        var handlers = [];
                        //check if the view is run mode then initialize the mobile behavior
                        if (CONSTANTS.isRunMode) {
                            /* register session timeout handler */
                            handlers.push($rootScope.$on("on-sessionTimeout", function () {
                                Utils.triggerFn(scope.onSessionTimeout);
                            }));

                            Utils.triggerFn(scope.onPageLoad);
                            element.on('$destroy', function () {
                                /*destroy variables*/
                                Variables.unload(attrs.ngController.replace('PageController', ''), scope);
                                handlers.forEach(Utils.triggerFn);
                            });
                        }
                    }
                };
            }
        };
    }])
    .directive('wmPartial', ['CONSTANTS', '$rootScope', 'Utils', 'Variables', function (CONSTANTS, $rootScope, Utils, Variables) {
        'use strict';

        var extendVariables = function (scope, variables) {
            WM.forEach(variables, function (variable, name) {
                if (!scope.Variables.hasOwnProperty(name)) {
                    Object.defineProperty(scope.Variables, name, {
                        configurable: true,
                        get: function () {
                            return variable;
                        }
                    });
                }
            });
        };


        return {
            'restrict': 'E',
            'replace': true,
            'transclude': true,
            'template': '<section  data-role="partial" class="app-partial clearfix" wmtransclude></section>',
            'compile': function () {
                return {
                    'pre': function (scope, element, attrs) {
                        var pageName = attrs.ngController.replace('PageController', ''),
                            variableScope = CONSTANTS.isStudioMode && !scope.prefabname && !scope.$parent.partialname ? $rootScope.domScope : scope,
                            containerScope;
                        if (CONSTANTS.isRunMode) {
                            scope.Widgets = {};
                            scope.Variables = {};

                            /* get partial container's scope */
                            containerScope = scope.$parent.Widgets && scope.$parent.Widgets[scope.$parent.partialcontainername];

                            /* expose partial's Widgets to its container's scope (to be visible to parent) */
                            if (containerScope) {
                                containerScope.Widgets = scope.Widgets;
                            }
                        }

                        if (CONSTANTS.isStudioMode) {
                            containerScope = scope.$parent.Widgets && scope.$parent.Widgets[scope.$parent.partialcontainername];
                            if (containerScope && WM.isDefined(containerScope.Widgets)) {
                                scope.Widgets = {};
                                containerScope.Widgets = scope.Widgets;
                            }
                        }

                        Variables.getPageVariables(pageName, function (variables) {
                            Variables.register(pageName, variables, true, variableScope);

                            /* expose partial's Variables to its container's scope (to be visible to parent) */
                            if (CONSTANTS.isRunMode && containerScope) {
                                containerScope.Variables = scope.Variables;
                            }

                            if ($rootScope.Variables) {
                                extendVariables(scope, $rootScope.Variables);
                                if (CONSTANTS.isRunMode && scope.hasOwnProperty('onPageVariablesReady')) {
                                    Utils.triggerFn(scope.onPageVariablesReady, scope.Variables);
                                }
                            } else {
                                /* listen to the page-variables-ready event */
                                element.on('$destroy', $rootScope.$on('on-app-variables-ready', function (event, appVariables) {
                                    extendVariables(scope, $rootScope.Variables);
                                    /* if specified, call app variables ready function in the app.js */
                                    Utils.triggerFn(scope.$root.onAppVariablesReady, appVariables);
                                    if (CONSTANTS.isRunMode && scope.hasOwnProperty('onPageVariablesReady')) {
                                        Utils.triggerFn(scope.$root.onAppVariablesReady, appVariables);
                                        Utils.triggerFn(scope.onPageVariablesReady);
                                    }
                                }));
                            }
                        });
                    },
                    'post': function (scope, element, attrs) {

                        var handlers = [];
                        //check if the view is run mode then initialize the mobile behavior
                        if (CONSTANTS.isRunMode) {
                            /* register session timeout handler */
                            handlers.push($rootScope.$on("on-sessionTimeout", function () {
                                Utils.triggerFn(scope.onSessionTimeout);
                            }));
                            // trigger onPageReady method if it is defined in the controller of partial
                            if (scope.hasOwnProperty('onPageReady')) {
                                Utils.triggerFn(scope.onPageReady);
                            }
                            /* canvasTree will listen for this event and will hide itself upon occurrence of it */
                            element.on('$destroy', function () {
                                /* destroy loaded variables */
                                Variables.unload(attrs.ngController.replace('PageController', ''), scope);
                                handlers.forEach(Utils.triggerFn);
                            });
                        }
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.layouts.page.directive:wmPage
 * @restrict E
 *
 * @description
 * The 'wmPage' directive defines a page in the layout.
 * It is the main container which encloses the layout elements (Header, Nav bar, Content, Footer, Left and Right Panel).
 * It can optionally have views as child containers (As in case of a dialog).
 * It contains the layout definition (One column, two column etc).
 *
 * @requires DeviceViewService
 *
 * @param {string=} layouttype
 *                  Type of the layout.
 * @param {string=} columns
 *                  Number of columns in the content, this is required for dom manipulation in mobile view.<br>
 * @param {string=} data-ng-controller
 *                  The name of the controller for the page.
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div class="wm-app">
                <wm-page data-ng-controller="MainPageController">
                    <wm-header height="50" backgroundcolor="teal">Content of Header</wm-header>
                     <wm-top-nav height="30" backgroundcolor="tomato">Content of TopNav</wm-top-nav>
                     <wm-content>
                         <wm-left-panel columnwidth="2" backgroundcolor="#fd4c70">Content of LeftNav</wm-left-panel>
                         <wm-page-content columnwidth="8" backgroundcolor="#0097a4">Content of Page</wm-page-content>
                         <wm-right-panel columnwidth="2" backgroundcolor="#934cfd">Content of RightNav</wm-right-panel>
                     </wm-content>
                     <wm-footer backgroundcolor="#f66f8a">Content of Footer</wm-footer>
                </wm-page>
            </div>
        </file>
        <file name="script.js">
            function MainPageController($scope) {}
        </file>
    </example>
 */


/**
 * @ngdoc directive
 * @name wm.layouts.page.directive:wmPartial
 * @restrict E
 *
 * @description
 * The 'wmPartial' directive defines a part of a page in the layout. <br>
 * Page container widgets(eg, header, footer etc) can include wmPartials.
 *
 *
 * @param {string=} data-ng-controller
 *                  The name of the controller for the page.
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div class="wm-app">
                <wm-partial data-ng-controller="MainPageController">
                    <wm-button caption="button1" backgroundcolor="cadetblue"></wm-button>
                </wm-partial>
            </div>
        </file>
        <file name="script.js">
            function MainPageController ($scope) {}
        </file>
    </example>
 */

/*global WM, window, _*/

WM.module('wm.layouts.page')
    .run(['$templateCache', function ($templateCache) {
        'use strict';

        $templateCache.put('template/defaults/header.html', '<h1>HEADER</h1>');

        $templateCache.put('template/defaults/topnav.html',
                '<div class="navbar navbar-default">' +
                    '<div class="container-fluid">' +
                        '<div class="collapse navbar-collapse">' +
                            '<ul class="nav navbar-nav">' +
                                '<li class="active"><a href="#">ACTIVE</a></li>' +
                                '<li><a href="#">LINK</a></li>' +
                            '</ul>' +
                        '</div>' +
                    '</div>' +
                '</div>'
            );

        $templateCache.put('template/defaults/leftnav.html',
                '<ul class="nav app-nav nav-pills nav-stacked">' +
                    '<li class="active"><a href="#" class="active">Active</a></li>' +
                    '<li><a href="#">Link</a></li>' +
                '</ul>'
            );

        $templateCache.put('template/defaults/rightnav.html',
                '<ul class="nav app-nav nav-pills nav-stacked">' +
                    '<li class="active"><a href="#" class="active">Active</a></li>' +
                    '<li><a href="#">Link</a></li>' +
                '</ul>'
            );

        $templateCache.put('template/defaults/footer.html', '<h3>FOOTER</h3>');

        $templateCache.put('template/layouts/template.html',
                '<div data-role="template" class="app-template app-page container" init-widget>' +
                    '<header data-role="page-header" class="app-header clearfix" wm-template-container="{{header}}"></header>' +
                    '<section data-role="page-topnav" class="app-top-nav" wm-template-container="{{topnav}}"></section>' +
                    '<main  data-role="page-content" class="app-content clearfix">' +
                        '<div class="row app-content-row clearfix">' +
                            '<aside data-role="page-left-panel" class="app-left-panel col-md-2 col-sm-2" wm-template-container="{{leftnav}}"></aside>' +
                            '<div class="app-page-content app-content-column">' +
                                '<div class="app-ng-transclude" wmtransclude></div>' +
                            '</div>' +
                            '<aside data-role="page-right-panel" class="app-right-panel col-md-2 col-sm-2" wm-template-container="{{rightnav}}"></aside>' +
                        '</div>' +
                    '</main>' +
                    '<footer data-role="page-footer" class="app-footer clearfix" wm-template-container="{{footer}}"></footer>' +
                '</div>'
            );
    }])
    .directive('wmTemplate', [
        '$templateCache',
        'PropertiesFactory',
        'WidgetUtilService',
        'CONSTANTS',
        '$compile',
        '$rootScope',

        function ($templateCache, PropertiesFactory, WidgetUtilService, CONSTANTS, $compile, $rootScope) {
            'use strict';

            var widgetProps = PropertiesFactory.getPropertiesOf('wm.template', []),
                templateShowCaseRendered = false;

            return {
                'restrict': 'E',
                'replace': true,
                'transclude': true,
                'scope': {},
                'template': $templateCache.get('template/layouts/template.html'),
                'compile': function () {
                    return {
                        'pre': function (scope) {
                            scope.widgetProps = widgetProps;
                        },
                        'post': function (scope, element, attrs) {
                            WidgetUtilService.postWidgetCreate(scope, element, attrs);

                            if (CONSTANTS.isRunMode && !templateShowCaseRendered) {
                                templateShowCaseRendered = true;
                                $compile('<wm-template-showcase></wm-template-showcase>')(scope.$root);
                            }
                            $rootScope.$emit('template-ready');
                        }
                    };
                }
            };
        }
    ])
    .directive('wmTemplateShowcase', [
        '$location',
        'Utils',
        '$routeParams',
        '$timeout',

        function ($location, Utils, $routeParams, $timeout) {
            'use strict';

            var MSGS = {
                'HIDE_TEMPLATES_SHOW_CASE': 'hide-templates-show-case',
                'SHOW_TEMPLATES_SHOW_CASE': 'show-templates-show-case',
                'UPDATE_LOCATION'         : 'update-location-path',
                'SELECT_TEMPLATE'         : 'select-template',
                'TEMPLATEBUNDLE_CONFIG'   : 'template-bundle-config',
                'ON_LOAD'                 : 'on-load'
            };

            function postMessage(content) {
                window.top.postMessage(Utils.isIE9() ? JSON.stringify(content) : content, '*');
            }

            return {
                'restrict': 'E',
                'scope': {},
                'link': function (scope, element) {

                    var pageName = $routeParams.name;

                    scope.showAll = true;
                    Utils.fetchContent(
                        'json',
                        Utils.preventCachingOf('./config.json'),
                        function (response) {
                            scope.templates = [];
                            if (!response.error) {
                                scope.templates = response.templates;
                                postMessage({'key': MSGS.TEMPLATEBUNDLE_CONFIG, 'config': response});
                            }
                        },
                        WM.noop,
                        true
                    );

                    scope.prev = function () {
                        var i = --scope.activeTemplateIndex;
                        i = i < 0 ? 0 : i;
                        scope.showTemplate(i);
                    };

                    scope.next = function () {
                        var i = ++scope.activeTemplateIndex,
                            len = scope.templates.length;
                        i = i >= len ? len - 1 : i;
                        scope.showTemplate(i);
                    };

                    scope.showTemplate = function (idx) {
                        var template = scope.templates[idx];
                        scope.activeTemplateIndex = idx;
                        $location.path(template.id);
                    };

                    scope.activeTemplateIndex = 0;

                    if (pageName) {
                        scope.templates.some(function (template, idx) {
                            if (pageName === template.id) {
                                scope.activeTemplateIndex = idx;
                                return true;
                            }
                        });
                    }

                    WM.element('html > body:first').append(element);

                    window.onmessage = function (msg) {
                        var msgData = null, key;

                        msgData = Utils.isIE9() ? JSON.parse(msg.data) : msg.data;

                        if (!WM.isObject(msgData)) {
                            return;
                        }

                        key = msgData.key;

                        switch (key) {
                        case MSGS.HIDE_TEMPLATES_SHOW_CASE:
                            scope.hideShowCase = true;
                            break;
                        case MSGS.SELECT_TEMPLATE:
                            scope.showTemplate(msgData.templateIndex);
                            break;
                        }

                        scope.$root.$safeApply(scope);
                    };

                    scope.$root.$on('$routeChangeSuccess', function () {
                        postMessage({'key': MSGS.UPDATE_LOCATION, 'location': $location.absUrl()});
                    });

                    $timeout(function () {
                        postMessage({'key': MSGS.ON_LOAD});
                    });
                }
            };
        }
    ])
    .directive('wmTemplateContainer', function (FileService, CONSTANTS, $rootScope, Utils, $compile, $templateCache) {
        'use strict';

        var ERROR_CONTENT = '<div class="app-partial-info"><div class="partial-message">Content for the container is unavailable.</div></div>',
            ROLE_DEFAULTCONTENTURL_MAP = {
                'page-header'     : 'template/defaults/header.html',
                'page-topnav'     : 'template/defaults/topnav.html',
                'page-left-panel' : 'template/defaults/leftnav.html',
                'page-right-panel': 'template/defaults/rightnav.html',
                'page-footer'     : 'template/defaults/footer.html'
            };

        function hideContent($el) {
            $el.html('').hide();
        }

        function getTemplatePath(templateName) {
            var templatePath = 'pages/' + templateName + '/page.min.html';
            return CONSTANTS.isStudioMode ? '../../../' + templatePath : templatePath;
        }

        function displayDefaultContent(element) {
            var key = element.attr('data-role'),
                url = ROLE_DEFAULTCONTENTURL_MAP[key],
                content = $templateCache.get(url);

            element.html(content).show();
        }

        function compileTemplate(scope, element, content) {
            var $content = WM.element(content),
                _scope = scope.$new();

            $content = $content.contents();
            _scope.Widgets = {};

            $compile($content)(_scope);
            element.append($content).show();
        }

        function loadTemplate(scope, element, templateName) {

            var pageContent;

            FileService.read({
                path: getTemplatePath(templateName),
                projectID : $rootScope.project.id
            }, function (response) {
                pageContent = Utils.parseCombinedPageContent(response, templateName);
                compileTemplate(scope, element, pageContent.html);
            }, function () {
                element.html(ERROR_CONTENT);
            });
        }

        return {
            'link': function (scope, element, attrs) {

                if (attrs.wmTemplateContainer) {
                    attrs.$observe('wmTemplateContainer', function (nv) {
                        if (nv) {
                            if (nv === '_nocontent') {
                                hideContent(element);
                            } else if (nv === '_defaultcontent') {
                                displayDefaultContent(element);
                            } else {
                                loadTemplate(scope, element, nv);
                            }
                        } else {
                            hideContent(element);
                        }
                    });
                }
            }
        };
    });


/*global WM*/

WM.module('wm.layouts.page')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/layout/page/rightpanel.html',
                '<aside  data-role="page-right-panel" page-container init-widget class="app-right-panel" apply-styles="container">' +
                    '<div class="app-ng-transclude" wmtransclude page-container-target></div>' +
                '</aside>'
            );
    }])
    .directive('wmRightPanel', ['PropertiesFactory', 'WidgetUtilService', 'CONSTANTS', 'Utils', function (PropertiesFactory, WidgetUtilService, CONSTANTS, Utils) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.layouts.rightpanel', ['wm.layouts', 'wm.base.events.touch']),
            notifyFor = {
                'columnwidth': true
            };

        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
        function propertyChangeHandler(scope, element, key, newVal, oldVal) {
            switch (key) {
            case 'columnwidth':
                /*If columnwidth is passed set the appropriate class*/
                element.removeClass('col-md-' + oldVal + ' col-sm-' + oldVal).addClass('col-md-' + newVal + ' col-sm-' + newVal);
                break;
            }
        }

        return {
            'restrict': 'E',
            'replace': true,
            'scope': {},
            'transclude': true,
            'template': function (tElement, tAttrs) {
                var isWidgetInsideCanvas = tAttrs.hasOwnProperty('widgetid'),
                    template = WM.element(WidgetUtilService.getPreparedTemplate('template/layout/page/rightpanel.html', tElement, tAttrs));

                if (!isWidgetInsideCanvas) {
                    /*** fix for old projects ***/
                    if (!tAttrs.columnwidth) {
                        template.attr('columnwidth', '2');
                    }
                }
                return template[0].outerHTML;
            },
            'compile': function () {
                return {
                    'pre': function (iScope) {
                        if (CONSTANTS.isStudioMode) {
                            iScope.widgetProps = Utils.getClonedObject(widgetProps);
                        } else {
                            iScope.widgetProps = widgetProps;
                        }
                    },
                    'post': function (scope, element, attrs) {
                        /*If columnwidth is passed set the appropriate class*/

                        if (scope.columnwidth) {
                            WM.element(element).addClass('col-md-' + scope.columnwidth + ' col-sm-' + scope.columnwidth);
                        }
                        /* register the property change handler */
                        WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, scope, element), scope, notifyFor);
                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.layouts.page.directive:wmRightPanel
 * @restrict E
 *
 * @description
 * The 'wmRightPanel' directive defines a right panel in the layout.
 * wmRightPanel is internally used by wmContent.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 *
 * @param {string=} horizontalalign
 *                  Align the content in the right panel to left/right/center.<br>
 *                  Default value for horizontalalign is `left`.
 * @param {string=} on-swipeup
 *                  Callback function for `swipeup` event.
 * @param {string=} on-swipedown
 *                  Callback function for `swipedown` event.
 * @param {string=} on-swiperight
 *                  Callback function for `swiperight` event.
 * @param {string=} on-swipeleft
 *                  Callback function for `swipeleft` event.
 * @param {string=} on-pinchin
 *                  Callback function for `pinchin` event.
 * @param {string=} on-pinchdown
 *                  Callback function for `pinchdown` event.
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div class="wm-app">
                <wm-page data-ng-controller="MainPageController">
                    <wm-header height="50" backgroundcolor="teal">Content of Header</wm-header>
                    <wm-top-nav height="30" backgroundcolor="tomato">Content of TopNav</wm-top-nav>
                    <wm-content>
                        <wm-left-panel columnwidth="2" backgroundcolor="#fd4c70">Content of LeftNav</wm-left-panel>
                        <wm-page-content columnwidth="8" backgroundcolor="#0097a4">Content of Page</wm-page-content>
                        <wm-right-panel columnwidth="2" backgroundcolor="#934cfd">Content of RightNav</wm-right-panel>
                    </wm-content>
                    <wm-footer backgroundcolor="#f66f8a">Content of Footer</wm-footer>
                </wm-page>
            </div>
        </file>
        <file name="script.js">
            function MainPageController($scope) {}
        </file>
    </example>
 */
/*global WM*/

WM.module('wm.layouts.page')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/layout/page/row.html',
                '<div init-widget class="row app-row clearfix" data-ng-show="show" apply-styles wmtransclude></div>'
            );
    }])
    .directive('wmRow', ['PropertiesFactory', 'WidgetUtilService', function (PropertiesFactory, WidgetUtilService) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.layouts.row', ['wm.layouts', 'wm.base.events.touch']);

        return {
            'restrict': 'E',
            'replace': true,
            'scope': {},
            'transclude': true,
            'template': WidgetUtilService.getPreparedTemplate.bind(undefined, 'template/layout/page/row.html'),
            'compile': function () {
                return {
                    'pre': function (scope) {
                        /*Applying widget properties to directive scope*/
                        scope.widgetProps = widgetProps;
                    },
                    'post': function (scope, element, attrs) {
                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]);


/**
 * @ngdoc directive
 * @name wm.layouts.page.directive:wmRow
 * @restrict E
 *
 * @description
 * The 'wmRow' directive defines a row in the layout.
 * wmRow is internally used by wmContent.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 *
 * @param {string=} height
 *                  Height of the row.
 * @param {string=} horizontalalign
 *                  Align the content in the right panel to left/right/center.<br>
 *                  Default value for horizontalalign is `left`.
 * @param {string=} on-swipeup
 *                  Callback function for `swipeup` event.
 * @param {string=} on-swipedown
 *                  Callback function for `swipedown` event.
 * @param {string=} on-swiperight
 *                  Callback function for `swiperight` event.
 * @param {string=} on-swipeleft
 *                  Callback function for `swipeleft` event.
 * @param {string=} on-pinchin
 *                  Callback function for `pinchin` event.
 * @param {string=} on-pinchdown
 *                  Callback function for `pinchdown` event.
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div class="wm-app" data-ng-controller="Ctrl">
                <wm-row style="height:200px">
                    <wm-column columnWidth="10" backgroundcolor="teal" style="height:100%"></wm-column>
                    <wm-column columnWidth="2" backgroundcolor="tomato" style="height:100%"></wm-column>
                </wm-row>
            </div>
        </file>
        <file name="script.js">
            function Ctrl($scope) {}
        </file>
    </example>
 */

/*global WM*/

WM.module('wm.layouts.page')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/layout/page/topnav.html',
                '<section data-role="page-topnav" page-container init-widget class="app-top-nav" apply-styles wmtransclude page-container-target></section>'
            );
    }])
    .directive('wmTopNav', ['PropertiesFactory', 'WidgetUtilService', 'CONSTANTS', 'Utils', function (PropertiesFactory, WidgetUtilService, CONSTANTS, Utils) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.layouts.topnav', ['wm.layouts', 'wm.base.events.touch']);

        return {
            'restrict': 'E',
            'replace': true,
            'scope': {},
            'transclude': true,
            'template': WidgetUtilService.getPreparedTemplate.bind(undefined, 'template/layout/page/topnav.html'),
            'compile': function () {
                return {
                    'pre': function (iScope, element) {
                        if (CONSTANTS.isStudioMode) {
                            iScope.widgetProps = Utils.getClonedObject(widgetProps);
                        } else {
                            iScope.widgetProps = widgetProps;
                            element.scope().layout.navigationBar = true;
                        }
                    },
                    'post': function (scope, element, attrs) {
                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.layouts.page.directive:wmTopNav
 * @restrict E
 *
 * @description
 * The 'wmTopNav' directive defines a navigation bar in the layout.
 * wmTopNav is internally used by wmPage.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 * @requires CONSTANTS
 *
 * @param {string=} height
 *                  Height of the top nav.
 * @param {string=} horizontalalign
 *                  Align the elements in the top nav to left/right/center.<br>
 *                  Default value for horizontalalign is `left`.
 * @param {string=} on-swipeup
 *                  Callback function for `swipeup` event.
 * @param {string=} on-swipedown
 *                  Callback function for `swipedown` event.
 * @param {string=} on-swiperight
 *                  Callback function for `swiperight` event.
 * @param {string=} on-swipeleft
 *                  Callback function for `swipeleft` event.
 * @param {string=} on-pinchin
 *                  Callback function for `pinchin` event.
 * @param {string=} on-pinchdown
 *                  Callback function for `pinchdown` event.
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div class="wm-app">
                <wm-page data-ng-controller="MainPageController">
                    <wm-header height="50" backgroundcolor="teal">Content of Header</wm-header>
                    <wm-top-nav height="30" backgroundcolor="tomato">Content of TopNav</wm-top-nav>
                    <wm-content>
                        <wm-left-panel columnwidth="2" backgroundcolor="#fd4c70">Content of LeftNav</wm-left-panel>
                        <wm-page-content columnwidth="8" backgroundcolor="#0097a4">Content of Page</wm-page-content>
                        <wm-right-panel columnwidth="2" backgroundcolor="#934cfd">Content of RightNav</wm-right-panel>
                    </wm-content>
                    <wm-footer backgroundcolor="#f66f8a">Content of Footer</wm-footer>
                </wm-page>
            </div>
        </file>
        <file name="script.js">
            function MainPageController($scope) {}
        </file>
    </example>
 */
/*global WM*/

WM.module('wm.layouts.page')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/layout/page/view.html',
                '<div init-widget class="app-view clearfix" data-ng-show="show" apply-styles="container" wmtransclude wm-navigable-element="true"> </div>'
            );
    }])
    .directive('wmView', ['PropertiesFactory', 'WidgetUtilService', 'CONSTANTS', 'ViewService', 'Utils', function (PropertiesFactory, WidgetUtilService, CONSTANTS, ViewService, Utils) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.layouts.view', ['wm.layouts', 'wm.base.events.touch']);

        return {
            'restrict': 'E',
            'replace': true,
            'scope': {},
            'transclude': true,
            'template': WidgetUtilService.getPreparedTemplate.bind(undefined, 'template/layout/page/view.html'),
            'compile': function () {
                return {
                    'pre': function (scope) {
                        /*Applying widget properties to directive scope*/
                        scope.widgetProps = widgetProps;
                    },
                    'post': function (scope, element, attrs) {
                        ViewService.registerView(scope);
                        scope.setActive = function () {
                            ViewService.showView(scope.name);
                        };
                        var isDialogView = element.hasClass('dialog-view');
                        if (isDialogView) {
                            if (CONSTANTS.isStudioMode) {
                                /* dialog view is meant to have the dialog only, widgets should not be dropped on the same,
                                 * so making the dialog-view non-droppable
                                 * */

                                element.attr('wm-droppable', false);
                            }

                            if (CONSTANTS.isRunMode) {
                                /* hiding the dialog-view in run mode, just opening the dialog*/
                                scope.show = false;
                            }
                        }
                        scope.initialize = function () {
                            element.find('.ng-isolate-scope')
                                .each(function () {
                                    Utils.triggerFn(WM.element(this).isolateScope().redraw);
                                });
                        };

                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                        element.on('$destroy', function () {
                            ViewService.unregisterView(scope);
                        });
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.layouts.page.directive:wmView
 * @restrict E
 *
 * @description
 * The 'wmView' directive defines a view in the layout.
 * View is a container which can be added onto some specific containers (example - page, column).
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 * @requires CONSTANTS
 * @requires ViewService
 *
 * @param {string=} horizontalalign
 *                  Align the content in the right panel to left/right/center.<br>
 *                  Default value for horizontalalign is `left`.
 * @param {string=} on-swipeup
 *                  Callback function for `swipeup` event.
 * @param {string=} on-swipedown
 *                  Callback function for `swipedown` event.
 * @param {string=} on-swiperight
 *                  Callback function for `swiperight` event.
 * @param {string=} on-swipeleft
 *                  Callback function for `swipeleft` event.
 * @param {string=} on-pinchin
 *                  Callback function for `pinchin` event.
 * @param {string=} on-pinchdown
 *                  Callback function for `pinchdown` event.
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div class="wm-app" data-ng-controller="Ctrl">
                <button data-ng-click="showView = true">Show View</button>
                <button data-ng-click="showView = false">Hide View</button>
                <wm-container>
                    <wm-view show="{{showView}}" backgroundcolor="teal"> Content of View </wm-view>
                </wm-container>
            </div>
        </file>
        <file name="script.js">
            function Ctrl($scope) {}
        </file>
    </example>
 */


/*global WM, document, window, _ */
/*jslint todo: true */

/* adding events and event options as constants*/
WM.module('wm.widgets.base', [])
    .constant('WIDGET_CONSTANTS', {
        EVENTS_OPTIONS: ["No Event", "Javascript", "New ServiceVariable", "New LiveVariable", "New NavigationCall", "New NotificationCall"]
    })

    /**
     * @ngdoc service
     * @name wm.widgets.$PropertiesFactory
     * @description
     * The `PropertiesFactory` contains properties of all the widgets in the studio and
     * provides utility methods for getting a specific widget's property
     */
    .factory('PropertiesFactory', ['WIDGET_CONSTANTS', 'CONSTANTS', 'Utils', function (WIDGET_CONSTANTS, CONSTANTS, Utils) {
        "use strict";
        /**
         * TODO: fetch the properties from the config-properties.json
         */

        var widgetEventOptions = Utils.getClonedObject(WIDGET_CONSTANTS.EVENTS_OPTIONS), /*A copy of the variable to preserve the actual value.*/
            showInDeviceOptions = [{
                'name': 'All',
                'value': 'all'
            }, {
                'name': 'Extra Small',
                'value': 'xs'
            }, {
                'name': 'Small',
                'value': 'sm'
            }, {
                'name': 'Medium',
                'value': 'md'
            }, {
                'name': 'Large',
                'value': 'lg'
            }],
            daysOptions    = Utils.getDaysOptions(),
            nameRegex      = '^[a-zA-Z_][A-Za-z0-9_]+$',
            numberRegex    = '(^$|[0-9]+$)',
            classRegex     = '(^$|^-?[_a-zA-Z ]+[_a-zA-Z0-9- ]*)$',
            dimensionRegex = '(^$|^(auto|0)$|^[+-]?[0-9]+.?([0-9]+)?(em|ex|%|px|cm|mm|in|pt|pc|ch|rem|vh|vw|vmin|vmax)?$)',
            zindexRegex    = '(^$|auto|initial|inherit|^[0-9]+$)',
            maxRatingRegex = '^(?:10|[1-9])$|^bind.*$',
            roles = [],
            dateOptions = [
                {
                    "name" : "Date",
                    "groupOptions" : {
                        "%x" : "Date(%m/%d/%Y)",
                        "%c" : "Date and Time"
                    }
                },
                {
                    "name" : "Time",
                    "groupOptions" : {
                        "%X" : "Time(%H:%M:%S)",
                        "%H" : "In 24 hours",
                        "%I" : "In 12 hours",
                        "%M" : "Mintues",
                        "%S" : "Seconds",
                        "%L" : "MilliSeconds",
                        "%p" : "AM or PM",
                        "%Z" : "Time zone offset"
                    }
                },
                {
                    "name" : "Day",
                    "groupOptions" : {
                        "%d" : "Zero padded day of month",
                        "%e" : "Space padded day of month",
                        "%j" : "Day of the year"
                    }
                },
                {
                    "name" : "Week",
                    "groupOptions" : {
                        "%a" : "Abbreviated weekday name",
                        "%A" : "Full weekday name",
                        "%U" : "Week number of the year(Sunday first day)",
                        "%W" : "Week number of the year(Monday first day)",
                        "%w" : "Week day[0(Sunday),6]"
                    }
                },
                {
                    "name" : "Month",
                    "groupOptions" : {
                        "%b" : "Abbreviated month name",
                        "%B" : "Full month name",
                        "%m" : "Month number"
                    }
                },
                {
                    "name" : "Year",
                    "groupOptions" : {
                        "%y" : "without century",
                        "%Y" : "with century"
                    }
                }
            ],
            PLATFORM_TYPE = {
                WEB      :   'WEB',
                MOBILE   :   'MOBILE',
                DEFAULT  :   'DEFAULT'
            },
            animationOptions = [" ", "bounce", "bounceIn", "bounceInDown", "bounceInLeft", "bounceInRight", "bounceInUp", "bounceOut", "bounceOutDown", "bounceOutLeft", "bounceOutRight", "bounceOutUp", "fadeIn", "fadeInDown", "fadeInDownBig", "fadeInLeft", "fadeInLeftBig", "fadeInRight", "fadeInRightBig", "fadeInUp", "fadeInUpBig", "fadeOut", "fadeOutDown", "fadeOutDownBig", "fadeOutLeft", "fadeOutLeftBig", "fadeOutRight", "fadeOutRightBig", "fadeOutUp", "fadeOutUpBig", "flash", "flipInX", "flipInY", "flipOutX", "flipOutY", "hinge", "lightSpeedIn", "lightSpeedOut", "pulse", "rollIn", "rollOut", "rotateIn", "rotateInDownLeft", "rotateInDownRight", "rotateInUpLeft", "rotateInUpRight", "rotateOut", "rotateOutDownLeft", "rotateOutDownRight", "rotateOutUpLeft", "rotateOutUpRight", "rubberBand", "shake", "slideInDown", "slideInLeft", "slideInRight", "slideInUp", "slideOutDown", "slideOutLeft", "slideOutRight", "slideOutUp", "swing", "tada", "wobble", "zoomIn", "zoomInDown", "zoomInLeft", "zoomInRight", "zoomInUp", "zoomOut", "zoomOutDown", "zoomOutLeft", "zoomOutRight", "zoomOutUp"],
            spinnerAnimationOptions = [" ", "bounce", "fadeIn", "fadeOut", "flash", "flipInX", "flipInY", "pulse", "shake", "spin", "swing", "tada", "wobble", "zoomIn", "zoomOut"],
            visibilityOptions = ["collapse", "hidden", "initial", "inherit", "visible"],
            displayOptions = ["block", "flex", "inherit", "initial", "inline", "inline-block", "inline-flex", "inline-table", "list-item", "run-in", "table", "table-caption", "table-cell", "table-column", "table-column-group", "table-header-group", "table-footer-group", "table-row", "table-row-group", "none"],
            EVERYONE = "Everyone",
            result = {
                "properties": {
                    "wm.base": {
                        "name": {"type": "string", "pattern": nameRegex, "maxlength": 32},
                        "hint": {"type": "string", "bindable": "in-bound"},
                        "show": {"type": "boolean", "value": true, "bindable": "in-bound"},
                        "class": {"type": "string", "pattern": classRegex},
                        "accessroles": {"type": "accessrolesselect", "options": roles, "value": EVERYONE},
                        "showindevice": {"type": "selectall", "options": showInDeviceOptions, "value": "all", "displaytype": 'block'}
                    },

                    "wm.base.editors": {
                        "width": {"type": "string", "pattern": dimensionRegex},
                        "height": {"type": "string", "pattern": dimensionRegex},

                        /* ---- styles ----*/
                        "border": {"type": "string", "widget": "box"},
                        "borderunit": {"type": "string", "options": ["em", "px"], "value": "px", "widget": "icons_radio"},
                        "bordertop": {"type": "string", "pattern": numberRegex},
                        "borderright": {"type": "string", "pattern": numberRegex},
                        "borderbottom": {"type": "string", "pattern": numberRegex},
                        "borderleft": {"type": "string", "pattern": numberRegex},
                        "borderwidth": {"type": "string"},
                        "borderstyle": {"type": "string", "options": ["dashed", "dotted", "none", "solid"], "widget": "borderstyle"},
                        "bordercolor": {"type": "string", "widget": "color"},
                        "padding": {"type": "string", "widget": "box"},
                        "paddingunit": {"type": "string", "options": ["%", "em", "px"], "value": "px", "widget": "icons_radio"},
                        "paddingtop": {"type": "string", "pattern": numberRegex},
                        "paddingright": {"type": "string", "pattern": numberRegex},
                        "paddingbottom": {"type": "string", "pattern": numberRegex},
                        "paddingleft": {"type": "string", "pattern": numberRegex},
                        "margin": {"type": "string", "widget": "box"},
                        "marginunit": {"type": "string", "options": ["%", "em", "px"], "value": "px", "widget": "icons_radio"},
                        "margintop": {"type": "string", "pattern": numberRegex},
                        "marginbottom": {"type": "string", "pattern": numberRegex},
                        "marginright": {"type": "string", "pattern": numberRegex},
                        "marginleft": {"type": "string", "pattern": numberRegex},
                        "backgroundcolor": {"type": "string", "widget": "color"},
                        "backgroundgradient": {"type": "string"},
                        "backgroundimage": {"type": "string", "bindable": "in-bound"},
                        "backgroundrepeat": {"type": "list", "options": ["no-repeat", "repeat", "repeat-x", "repeat-y"]},
                        "backgroundsize": {"type": "string", "hint": "width, height"},
                        "backgroundposition": {"type": "string", "hint": "left, top"},
                        "backgroundattachment": {"type": "list", "options": ["fixed", "local", "scroll"]},
                        "color": {"type": "string", "hidelabel": true, "widget": "color"},
                        "fontweight": {"type": "string", "options": ["bold"], "hidelabel": true, "widget": "icons_checkbox"},
                        "fontsize": {"type": "number", "hidelabel": true, "hint": "Font size", "pattern": numberRegex},
                        "fontunit": {"type": "string", "options": ["em", "px"], "value": "px", "hidelabel": true, "widget": "icons_radio"},
                        "textalign": {"type": "string", "options": ["left", "center", "right"], "hidelabel": true, "widget": "icons_radio"},
                        "textdecoration": {"type": "string", "options": ["underline"], "hidelabel": true, "widget": "icons_checkbox"},
                        "fontstyle": {"type": "string", "options": ["italic"], "hidelabel": true, "widget": "icons_checkbox"},
                        "fontVariant": {"type": "list", "options": ["normal", "small-caps"]},
                        "fontfamily": {"type": "string", "hidelabel": true, "hint": "Arial, Geneva"},
                        "misc": {"type": "string"},
                        "whitespace": {"type": "list", "options": [" ", "normal", "nowrap", "pre", "pre-line", "pre-wrap"], "value": " "},
                        "wordbreak": {"type": "list", "options": ["break-word", "normal"]},
                        "opacity": {"type": "string", "widget": "slider"},
                        "cursor": {"type": "list", "options": ["crosshair", "default", "e-resize", "help", "move", "n-resize", "ne-resize", "nw-resize", "pointer", "progress", "s-resize", "se-resize", "sw-resize", "text", "wait", "w-resize"]},
                        "zindex": {"type": "string", "pattern": zindexRegex},
                        "visibility": {"type": "list", "options": visibilityOptions},
                        "display": {"type": "list", "options": displayOptions}
                    },
                    "wm.base.editors.abstracteditors": {
                        "disabled": {"type": "boolean", "bindable": "in-bound"},
                        "required": {"type": "boolean", "bindable": "in-bound"},
                        "tabindex": {"type": "string", "value": "0"},
                        "onClick": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onTap": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onMouseenter": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onMouseleave": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onFocus": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onBlur": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onChange": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"}
                    },
                    "wm.base.editors.captionproperties": {
                        "caption": {"type": "string", "value": "_unset_", "bindable": "in-bound", "maxlength": 256 },
                        "captionsize": {"type": "string"},
                        "paddingtop": {"value": "0"},
                        "paddingright": {"value": "0"},
                        "paddingbottom": {"value": "0"},
                        "paddingleft": {"value": "0"},
                        "bordertop": {"value": "0"},
                        "borderright": {"value": "0"},
                        "borderbottom": {"value": "0"},
                        "borderleft": {"value": "0"}
                    },

                    "wm.base.editors.dataseteditors": {
                        "startupdate": {"type": "boolean"},
                        "scopedataset": {"type": "list", "options": []},
                        "datafield": {"type": "list", "options": ["All Fields"]},
                        "displayfield": {"type": "list", "options": [""]},
                        "displayexpression": {"type": "string", "bindable": "in-bound", "bindonly": "expression"},
                        "displaytype": {"type": "list", "options": ["Currency", "Date", "Number", "Text", "Time"]}
                    },

                    "wm.base.events": {
                        "onTap": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onDoubletap": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onClick": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onDblclick": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onMouseenter": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onMouseleave": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"}
                    },

                    "wm.base.events.touch": {
                        "onSwipeup": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onSwipedown": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onSwipeleft": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onSwiperight": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onPinchin": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onPinchout": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"}
                    },

                    "wm.base.events.keyboard": {
                        "onKeypress": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onKeydown": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onKeyup": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"}
                    },
                    "wm.base.events.focus": {
                        "onFocus": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onBlur": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"}
                    },

                    "wm.base.events.change": {
                        "onChange": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"}
                    },

                    "wm.base.events.successerror": {
                        "onSuccess": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onError": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"}
                    },

                    "wm.abstractinput": {
                        "type": {"type": "string", "value": "text"}
                    },

                    "wm.html": {
                        "content": {"type": "string", "bindable": "in-out-bound", "widget": "textarea"},
                        "autoscroll": {"type": "boolean"},
                        "height": {"type": "string", "pattern": dimensionRegex}
                    },
                    "wm.icon": {
                        "title": {"type": "string", "bindable": "in-out-bound"},
                        "iconclass": {"type": "string", "value": "glyphicon glyphicon-star-empty", "widget": "selecticon", "bindable": "in-out-bound", "pattern": classRegex},
                        "iconsize": {"type": "string", "pattern": dimensionRegex},
                        "animation": {"type": "list", "options": animationOptions},
                        "color": {"type": "string", "widget": "color"},
                        "opacity": {"type": "string", "widget": "slider"}
                    },
                    "wm.iframe": {
                        "iframesrc": {"type": "string", "bindable": "in-bound", "widget": "string"},
                        "width": {"type": "string", "value": '300px', "pattern": dimensionRegex},
                        "height": {"type": "string", "value": '150px', "pattern": dimensionRegex},
                        "showindevice": {"type": "selectall", "options": showInDeviceOptions, "value": "all"}
                    },
                    "wm.button": {
                        "iconclass": {"type": "string", "widget": "selecticon", "bindable": "in-out-bound", "pattern": classRegex},
                        "badgevalue": {"type": "string", "bindable": "in-out-bound"},
                        "caption": {"type": "string", "bindable": "in-out-bound", "maxlength": 256},
                        "iconurl": {"type": "string", "bindable": "in-bound"},
                        "iconwidth": {"type": "string", "pattern": dimensionRegex},
                        "iconheight": {"type": "string", "pattern": dimensionRegex},
                        "iconmargin": {"type": "string", "pattern": dimensionRegex},
                        "iconposition": {"type": "list", "options": ["left", "top", "right"]},
                        "disabled": {"type": "boolean", "bindable": "in-bound"},
                        "type": {"type": "list", "options": ["button", "reset", "submit"], "value" : "button"},
                        "tabindex": {"type": "string", "value": "0"},
                        "showindevice": {"type": "selectall", "options": showInDeviceOptions, "value": "all", "displaytype": 'inline-block'},
                        "animation": {"type": "list", "options": animationOptions},
                        "shortcutkey": {"type": "string"},
                        "class": {"type": "string", "pattern": classRegex, "widget": "list-picker", "value": "btn-default", "options": ["btn-primary", "btn-info", "btn-warning", "btn-success", "btn-danger", "btn-lg", "btn-sm", "btn-xs", "btn-raised", "btn-fab", "btn-link", "btn-transparent", "jumbotron"]}
                    },
                    "wm.rating": {
                        "maxvalue": {"type": "number", "value": 5, "pattern": maxRatingRegex, "bindable": "in-bound"},
                        "readonly": {"type": "boolean", "value": false, "bindable": "in-bound"},
                        "scopedatavalue": {"type": "string"},
                        "datavalue": {"type": "number", "value": "", "bindable": "in-out-bound"},
                        "caption": {"type": "string", "bindable": "in-out-bound", "maxlength": 256, "show": false},
                        "iconsize": {"type": "string", "pattern": dimensionRegex},
                        "onChange": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "width": {"type": "string", "pattern": dimensionRegex, "show": false},
                        "height": {"type": "string", "pattern": dimensionRegex, "show": false},
                        "tabindex": {"type": "string", "value": "0"},
                        "iconcolor": {"type": "string", "widget": "color"},
                        "scopedataset": {"type": "string"},
                        "dataset": {"type": "array, object", "bindable": "in-bound", "widget": "string"},
                        "datafield": {"type": "list", "options": [""], "value": ""},
                        "displayfield": {"type": "list", "options": [""]},
                        "displayexpression": {"type": "string", "bindable": "in-bound", "bindonly": "expression"},
                        "showcaptions": {"type": "boolean", "value": true}
                    },
                    "wm.camera": {
                        "capturetype": {"type": "list", "options": ["IMAGE", "VIDEO"], "value" : "IMAGE"},
                        "datavalue": {"type": "string", "value": "", "bindable": "in-out-bound"},
                        "title": {"type": "string", "bindable": "in-out-bound"},
                        "iconclass": {"type": "string", "value": "glyphicon glyphicon-camera", "widget": "selecticon", "bindable": "in-out-bound", "pattern": classRegex},
                        "iconsize": {"type": "string", "pattern": dimensionRegex, "value" : "2em"},
                        /* capture picture options*/
                        "imagequality": {"type": "number", "value": 80},
                        "imageencodingtype": {"type": "list", "options": [ "JPEG", "PNG"], "value" : "JPEG"},
                        "savetogallery": {"type": "boolean", "value" : false},
                        "allowedit": {"type": "boolean", "value" : false},
                        "imagetargetwidth": {"type": "number"},
                        "imagetargetheight": {"type": "number"},
                        /* Events */
                        "onSuccess": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"}
                    },
                    "wm.barcodescanner": {
                        "datavalue": {"type": "string", "bindable": "in-out-bound"},
                        "caption": {"type": "string", "value": "", "bindable": "in-bound", "maxlength": 256 },
                        "iconclass": {"type": "string", "value": "glyphicon glyphicon-barcode", "widget": "selecticon", "bindable": "in-out-bound", "pattern": classRegex},
                        "iconsize": {"type": "string", "pattern": dimensionRegex, "value" : "2em"},
                        /* Events */
                        "onSuccess": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"}
                    },
                    "wm.buttongroup": {
                        "vertical": {"type": "boolean"},
                        "class": {"type": "string", "pattern": classRegex, "widget": "list-picker", "options": ["btn-group-lg", "btn-group-sm", "btn-group-xs", "btn-group-raised", "btn-toolbar", "btn-group-vertical"]}
                    },
                    "wm.switch": {
                        "width": {"type": "string", "pattern": dimensionRegex},
                        "height": {"type": "string", "pattern": dimensionRegex},
                        "datavalue": {"type": "string, object", "bindable": "in-out-bound", "widget": "string"},
                        "scopedatavalue": {"type": "string"},
                        "dataset": {"type": "array, string", "bindable": "in-bound", "widget": "string", "value": "yes, no, maybe"},
                        "scopedataset": {"type": "string"},
                        "datafield": {"type": "list", "options": ["All Fields"], "value": "All Fields"},
                        "displayfield": {"type": "list", "options": [""], "value": ""},
                        "tabindex": {"type": "string", "value": "0"}
                    },
                    "wm.menu": {
                        "name": {"type": "string", "pattern": nameRegex, "maxlength": 32},
                        "hint": {"type": "string", "bindable": "in-bound"},
                        "show": {"type": "boolean", "value": true, "bindable": "in-bound"},
                        "accessroles": {"type": "accessrolesselect", "options": roles, "value": EVERYONE},
                        "scopedataset": {"type": "string"},
                        "dataset": {"type": "array, object", "bindable": "in-bound", "widget": "string", "value": "Menu Item 1, Menu Item 2, Menu Item 3"},
                        "caption": {"type": "string", "bindable": "in-out-bound", "maxlength": 256},
                        "menulayout": {"type": "list", "options": ["vertical", "horizontal"]},
                        "menuclass": {"type": "string", "pattern": classRegex, "widget": "list-picker", "options": ["btn-default", "btn-primary", "btn-info", "btn-danger", "btn-warning", "btn-success", "btn-lg", "btn-sm", "btn-xs", "btn-link", "btn-transparent", "jumbotron"]},
                        "iconclass": {"type": "string", "widget": "selecticon", "bindable": "in-out-bound", "pattern": classRegex},
                        "menuposition": {"type": "list", "options": ["", "down,right", "down,left", "up,right", "up,left", "inline"], "value": ""},
                        "onSelect": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "linktarget": {"type": "list", "options": ["_blank", "_parent", "_self", "_top"], "value": "_blank", "widget": "datalist"},
                        "tabindex": {"type": "string", "value": "0"},
                        "shortcutkey": {"type": "string"}
                    },

                    "wm.menu.dataProps": {
                        "itemlabel": {"type": "string", "widget": "list", "options": [""], "bindable": "in-bound", "bindonly": "expression"},
                        "itemlink": {"type": "string", "widget": "list", "options": [""], "bindable": "in-bound", "bindonly": "expression"},
                        "itemicon": {"type": "string", "widget": "list", "options": [""], "bindable": "in-bound", "bindonly": "expression"},
                        "itemchildren": {"type": "string", "widget": "list", "options": [""], "bindable": "in-bound", "bindonly": "expression"}
                    },

                    "wm.tree": {
                        "scopedataset": {"type": "string"},
                        "dataset": {"type": "object, array", "bindable": "in-bound", "widget": "string", "value": "node1, node2, node3"},
                        "onSelect": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "selecteditem": {"type": "object", "bindable": "in-out-bound", "show": false, "widget": "string"},
                        "class": {"type": "string"},
                        "treeicons": {"type": "list", "widget": "list", "options": ["folder", "plus-minus", "circle-plus-minus", "chevron", "menu", "triangle", "expand-collapse"]},
                        "nodelabel": {"type": "list", "widget": "list"},
                        "nodeicon": {"type": "list", "widget": "list"},
                        "nodechildren": {"type": "list", "widget": "list"},
                        "tabindex": {"type": "string", "value": "0"},
                        "levels": {"type": "number", "value": 0, "min": "0", "max": "10", "step": "1"},
                        "datavalue": {"type": "string", "bindable": "in-bound", "ignoreGetterSetters": true, "widget": "tree-datavalue"}
                    },

                    "wm.text": {
                        "autofocus": {"type": "boolean"},
                        "autocomplete": {"type": "boolean", "value": true},
                        "readonly": {"type": "boolean", "bindable": "in-bound"},
                        "updateon": {"type": "list", "value": "blur", "widget": "updateon"},
                        "updatedelay": {"type": "number", "value": 0},
                        "type": {"type": "list", "options": ["color", "date", "datetime-local", "email", "month", "number", "password", "search", "tel", "text", "time", "url", "week"], "value": "text"},
                        "accept": {"type": "datalist", "options": ["image/*", "audio/*", "video/*"], "show": false},
                        "datavalue": {"type": "string", value: "", "bindable": "in-out-bound"},
                        "scopedatavalue": {"type": "string"},
                        "class": {"type": "string", "pattern": classRegex, "widget": "list-picker", "options": ["input-lg", "input-sm"]},

                        /* Properties: Validation */
                        "regexp": {"type": "string", "value": ".*"},

                        /* Properties: help */
                        "placeholder": {"type": "string", "value": "Enter text"},

                        /* Properties: Behavior */
                        "maxchars": {"type": "number", "bindable": "in-bound"},

                        /*  ---Events---  */
                        "changeOnkey": {"type": "boolean"},

                        /* Number properties */
                        "minvalue": {"type": "string", "bindable": "in-bound"},
                        "maxvalue": {"type": "string", "bindable": "in-bound"},
                        "step": {"type": "number"},
                        "shortcutkey": {"type": "string"}
                    },

                    "wm.currency": {
                        "datavalue": {"type": "number", "bindable": "in-out-bound"},
                        "scopedatavalue": {"type": "string"},
                        "minvalue": {"type": "number", "bindable": "in-bound"},
                        "maxvalue": {"type": "number", "bindable": "in-bound"},
                        "readonly": {"type": "boolean", "bindable": "in-bound"},
                        "currency": {"type": "list", "value": "USD", "options": ["AED", "AFN", "ALL", "AMD", "ARS", "AUD", "AZN", "BAM", "BDT", "BGN", "BHD", "BIF", "BND", "BOB", "BRL", "BWP", "BYR", "BZD", "CAD", "CDF", "CHF", "CLP", "CNY", "COP", "CRC", "CVE", "CZK", "DJF", "DKK", "DOP", "DZD", "EEK", "EGP", "ERN", "ETB", "EUR", "GBP", "GEL", "GHS", "GNF", "GTQ", "HKD", "HNL", "HRK", "HUF", "IDR", "ILS", "INR", "IQD", "IRR", "ISK", "JMD", "JOD", "JPY", "KES", "KHR", "KMF", "KRW", "KWD", "KZT", "LBP", "LKR", "LTL", "LVL", "LYD", "MAD", "MDL", "MGA", "MKD", "MMK", "MOP", "MUR", "MXN", "MYR", "MZN", "NAD", "NGN", "NIO", "NOK", "NPR", "NZD", "OMR", "PAB", "PEN", "PHP", "PKR", "PLN", "PYG", "QAR", "RON", "RSD", "RUB", "RWF", "SAR", "SDG", "SEK", "SGD", "SOS", "SYP", "THB", "TND", "TOP", "TRY", "TTD", "TWD", "TZS", "UAH", "UGX", "USD", "UYU", "UZS", "VEF", "VND", "XAF", "XOF", "YER", "ZAR", "ZMK"]},
                        /* Properties: help */
                        "placeholder": {"type": "string", "value": "Enter value"},
                        /* Style: Basic */
                        "width": {"type": "string", "pattern": dimensionRegex},
                        "height": {"type": "string", "pattern": dimensionRegex},
                        "backgroundcolor": {"type": "string", "widget": "color"},
                        "backgroundgradient": {"type": "string"},
                        "backgroundimage": {"type": "string", "bindable": "in-bound"},
                        "backgroundrepeat": {"type": "list", "options": ["no-repeat", "repeat", "repeat-x", "repeat-y"]},
                        "backgroundsize": {"type": "string", "hint": "width, height"},
                        "backgroundposition": {"type": "string", "hint": "top, left"},
                        "backgroundattachment": {"type": "list", "options": ["fixed", "local", "scroll"]},
                        "color": {"type": "string", "hidelabel": true, "widget": "color"},
                        "fontweight": {"type": "string", "options": ["bold"], "hidelabel": true, "widget": "icons_checkbox"},
                        "fontsize": {"type": "number", "hidelabel": true, "hint": "Font size", "pattern": numberRegex},
                        "fontunit": {"type": "string", "options": ["em", "px"], "value": "px", "hidelabel": true, "widget": "icons_radio"},
                        "textalign": {"type": "string", "options": ["left", "center", "right"], "hidelabel": true, "widget": "icons_radio"},
                        "textdecoration": {"type": "string", "options": ["underline"], "hidelabel": true, "widget": "icons_checkbox"},
                        "fontstyle": {"type": "string", "options": ["italic"], "hidelabel": true, "widget": "icons_checkbox"},
                        "fontfamily": {"type": "string", "hidelabel": true, "hint": "Arial, Geneva"},
                        "whitespace": {"type": "list", "options": [" ", "normal", "nowrap", "pre", "pre-line", "pre-wrap"], "value": " "},
                        "wordbreak": {"type": "list", "options": ["break-word", "normal"]},
                        "misc": {"type": "string"},
                        "opacity": {"type": "string", "widget": "slider"},
                        "cursor": {"type": "list", "options": ["crosshair", "default", "e-resize", "help", "move", "n-resize", "ne-resize", "nw-resize", "pointer", "progress", "s-resize", "se-resize", "sw-resize", "text", "wait", "w-resize"]},
                        "zindex": {"type": "string", "pattern": zindexRegex},
                        "shortcutkey": {"type": "string"},
                        "class": {"type": "string", "pattern": classRegex, "widget": "list-picker", "options": ["input-group-sm", "input-group-lg"]}
                    },
                    "wm.base.datetime": {
                        "datavalue": {"type": "string", "bindable": "in-out-bound"},
                        "scopedatavalue": {"type": "string"},
                        "tabindex": {"type": "string", "value": "0"},
                        /* ---- styles ----*/
                        "border": {"type": "string", "widget": "box"},
                        "borderunit": {"type": "string", "options": ["em", "px"], "value": "px", "widget": "icons_radio"},
                        "bordertop": {"type": "string", "pattern": numberRegex},
                        "borderright": {"type": "string", "pattern": numberRegex},
                        "borderbottom": {"type": "string", "pattern": numberRegex},
                        "borderleft": {"type": "string", "pattern": numberRegex},
                        "borderwidth": {"type": "string"},
                        "borderstyle": {"type": "string", "options": ["dashed", "dotted", "none", "solid"], "widget": "borderstyle"},
                        "bordercolor": {"type": "string", "widget": "color"},
                        "padding": {"type": "string", "widget": "box"},
                        "paddingunit": {"type": "string", "options": ["%", "em", "px"], "value": "px", "widget": "icons_radio"},
                        "paddingtop": {"type": "string", "pattern": numberRegex},
                        "paddingright": {"type": "string", "pattern": numberRegex},
                        "paddingbottom": {"type": "string", "pattern": numberRegex},
                        "paddingleft": {"type": "string", "pattern": numberRegex},
                        "margin": {"type": "string", "widget": "box"},
                        "marginunit": {"type": "string", "options": ["%", "em", "px"], "value": "px", "widget": "icons_radio"},
                        "margintop": {"type": "string", "pattern": numberRegex},
                        "marginbottom": {"type": "string", "pattern": numberRegex},
                        "marginright": {"type": "string", "pattern": numberRegex},
                        "marginleft": {"type": "string", "pattern": numberRegex},
                        "color": {"type": "string", "hidelabel": true, "widget": "color"},
                        "fontweight": {"type": "string", "options": ["bold"], "hidelabel": true, "widget": "icons_checkbox"},
                        "fontsize": {"type": "number", "hidelabel": true, "hint": "Font size", "pattern": numberRegex},
                        "fontunit": {"type": "string", "options": ["em", "px"], "value": "px", "hidelabel": true, "widget": "icons_radio"},
                        "textalign": {"type": "string", "options": ["left", "center", "right"], "hidelabel": true, "widget": "icons_radio"},
                        "textdecoration": {"type": "string", "options": ["underline"], "hidelabel": true, "widget": "icons_checkbox"},
                        "fontstyle": {"type": "string", "options": ["italic"], "hidelabel": true, "widget": "icons_checkbox"},
                        "fontVariant": {"type": "list", "options": ["normal", "small-caps"]},
                        "fontfamily": {"type": "string", "hidelabel": true, "hint": "Arial, Geneva"},
                        "opacity": {"type": "string", "widget": "slider"},
                        "cursor": {"type": "list", "options": ["crosshair", "default", "e-resize", "help", "move", "n-resize", "ne-resize", "nw-resize", "pointer", "progress", "s-resize", "se-resize", "sw-resize", "text", "wait", "w-resize"]},
                        "zindex": {"type": "string", "pattern": zindexRegex}
                    },
                    "wm.date": {
                        "placeholder": {"type": "string", "value": "Select date"},
                        "width": {"type": "string", "pattern": dimensionRegex},
                        "autofocus": {"type": "boolean"},
                        "showweeks": {"type": "boolean", "value": false, "bindable": "in-bound"},
                        "readonly": {"type": "boolean", "bindable": "in-bound"},
                        "disabled": {"type": "boolean", "bindable": "in-bound"},
                        "mindate": {"type": "string", "bindable": "in-bound", "hint": "yyyy-MM-dd"},
                        "maxdate": {"type": "string", "bindable": "in-bound", "hint": "yyyy-MM-dd"},
                        "datepattern": {"value": "yyyy-MM-dd", "type": "list", "options": [], "widget": "datetimepatterns"},
                        "outputformat": {"value": "yyyy-MM-dd", "type": "list", "options": [], "widget": "datetimepatterns"},
                        "datavalue": {"type": "date, datetime, timestamp, string, number", "widget": "string", "bindable": "in-out-bound", "hint": "yyyy-MM-dd"},
                        "timestamp": {"type": "date, datetime, timestamp, string, number", "widget": "string", "show": "false", "bindable": "out-bound"},
                        "excludedays": {"type": "selectall", "options": daysOptions, "displaytype": "block", "value": " "},
                        "excludedates": {"type": "datetime, timestamp, date, array, string", "bindable": "in-bound", "widget": "string", "hint": "yyyy-MM-dd"},
                        "tabindex": {"type": "string", "value": "0"},
                        "shortcutkey": {"type": "string"},
                        "class": {"type": "string", "pattern": classRegex, "widget": "list-picker", "options": ["input-group-sm", "input-group-lg"]}
                    },
                    "wm.calendar": {
                        "backgroundcolor": {"type": "string", "widget": "color"},
                        "width": {"type": "string", "pattern": dimensionRegex},
                        "height": {"type": "string", "pattern": dimensionRegex},
                        "dataset": {"type": "array, object", "bindable": "in-bound", "widget": "string"},
                        "scopedataset": {"type": "string"},
                        "multiselect": {"type": "boolean"},
                        "selecteddates": {"type": "object", "widget": "string", "bindable": "in-out-bound"},
                        "currentview": {"type": "object", "widget": "string", "bindable": "in-out-bound"},
                        "calendartype": {"type": "list", "options": ["basic", "agenda"], "value": "basic"},
                        "view": {"type": "list", "options": ["month", "week", "day"], "value": "month"},
                        "controls": {"type": "list", "options": ["navigation", "today", "month", "week", "day"], "value": "navigation, today, month, week, day", "widget": "selectall"},
                        "onViewrender": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onSelect": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onEventdrop": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onEventresize": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onEventclick": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onEventrender": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "tabindex": {"type": "string", "value": "0"}
                    },
                    "wm.time": {
                        "placeholder": {"type": "string", "value": "Select time"},
                        "autofocus": {"type": "boolean"},
                        "readonly": {"type": "boolean", "bindable": "in-bound"},
                        "disabled": {"type": "boolean", "bindable": "in-bound"},
                        "hourstep": {"type": "number", "value": 1},
                        "timepattern": {"value": "hh:mm a", "type": "list", "options": [], "widget": "timepatterns"},
                        "minutestep": {"type": "number", "value": 15},
                        "outputformat": {"value": "HH:mm:ss", "type": "list", "options": [], "widget": "timepatterns"},
                        "required": {"type": "boolean"},
                        "datavalue": {"type": "time, date, string, number", "widget": "string", "bindable": "in-out-bound", hint: "HH:mm"},
                        "timestamp": {"type": "time, date, string, number", "widget": "string", "show": "false", "bindable": "out-bound"},
                        "tabindex": {"type": "string", "value": "0"},
                        "shortcutkey": {"type": "string"},
                        "class": {"type": "string", "pattern": classRegex, "widget": "list-picker", "options": ["input-group-sm", "input-group-lg"]}
                    },
                    "wm.datetime": {
                        "placeholder": {"type": "string", "value": "Select date time"},
                        "width": {"type": "string", "pattern": dimensionRegex},
                        "autofocus": {"type": "boolean"},
                        "showweeks": {"type": "boolean", "value": false},
                        "readonly": {"type": "boolean", "bindable": "in-bound"},
                        "disabled": {"type": "boolean", "bindable": "in-bound"},
                        "hourstep": {"type": "number", "value": 1},
                        "minutestep": {"type": "number", "value": 15},
                        "mindate": {"type": "string",  "bindable": "in-bound", "hint": "yyyy-MM-dd"},
                        "maxdate": {"type": "string",  "bindable": "in-bound", "hint": "yyyy-MM-dd"},
                        "datepattern": {"value": "yyyy-MM-dd hh:mm:ss a", "type": "list", "options": [], "widget": "datetimepatterns"},
                        "outputformat": {"value": "timestamp", "type": "list", "options": [], "widget": "datetimepatterns"},
                        "datavalue": {"type": "timestamp, date, time, datetime, string, number", "widget": "string", "bindable": "in-out-bound", "hint": "yyyy-MM-dd HH:mm:ss"},
                        "timestamp": {"type": "timestamp, date, time, datetime, string, number", "widget": "string", "show": "false", "bindable": "out-bound"},
                        "excludedays": {"type": "selectall", "options": daysOptions, "displaytype": "block", "value": " "},
                        "excludedates": {"type": "datetime, timestamp, date, array, string", "bindable": "in-bound", "widget": "string", "hint": "yyyy-MM-dd"},
                        "tabindex": {"type": "string", "value": "0"},
                        "shortcutkey": {"type": "string"},
                        "class": {"type": "string", "pattern": classRegex, "widget": "list-picker", "options": ["input-group-sm", "input-group-lg"]}
                    },
                    "wm.message": {
                        "type": {"type": "string", "options": ["error", "info", "loading", "success", "warning"], "value": "success", "bindable": "in-out-bound", "widget": "list"},
                        "caption": {"type": "string", "value": "Message", "bindable": "in-out-bound", "maxlength": 256},
                        "onClose": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "animation": {"type": "list", "options": animationOptions},
                        "width": {"type": "string", "pattern": dimensionRegex},
                        "height": {"type": "string", "pattern": dimensionRegex},
                        "hideclose": {"type": "boolean", "value": false}
                    },

                    "wm.composite": {
                        "captionposition": {"type": "list", "options": ["left", "right", "top"]},
                        "required": {"type": "boolean"},
                        "margin": {"type": "string", "widget": "box"},
                        "marginunit": {"type": "string", "options": ["%", "em", "px"], "value": "px", "widget": "icons_radio"},
                        "margintop": {"type": "string", "pattern": numberRegex},
                        "marginbottom": {"type": "string", "pattern": numberRegex},
                        "marginright": {"type": "string", "pattern": numberRegex},
                        "marginleft": {"type": "string", "pattern": numberRegex}
                    },

                    "wm.booleaneditors": {
                        "width": {"type": "string", "pattern": dimensionRegex},
                        "height": {"type": "string", "pattern": dimensionRegex},
                        /* ---- styles ----*/
                        "padding": {"type": "string", "widget": "box"},
                        "paddingunit": {"type": "string", "options": ["%", "em", "px"], "value": "px", "widget": "icons_radio"},
                        "paddingtop": {"type": "string", "pattern": numberRegex},
                        "paddingright": {"type": "string", "pattern": numberRegex},
                        "paddingbottom": {"type": "string", "pattern": numberRegex},
                        "paddingleft": {"type": "string", "pattern": numberRegex},
                        "margin": {"type": "string", "widget": "box"},
                        "marginunit": {"type": "string", "options": ["%", "em", "px"], "value": "px", "widget": "icons_radio"},
                        "margintop": {"type": "string", "pattern": numberRegex},
                        "marginbottom": {"type": "string", "pattern": numberRegex},
                        "marginright": {"type": "string", "pattern": numberRegex},
                        "marginleft": {"type": "string", "pattern": numberRegex},
                        "opacity": {"type": "string", "widget": "slider"},
                        "cursor": {"type": "list", "options": ["crosshair", "default", "e-resize", "help", "move", "n-resize", "ne-resize", "nw-resize", "pointer", "progress", "s-resize", "se-resize", "sw-resize", "text", "wait", "w-resize"]},
                        "zindex": {"type": "string", "pattern": zindexRegex}
                    },
                    "wm.radio": {
                        //"readonly": {"type": "boolean", "value": false}, //commenting this property temporarily as it is not working
                        "autofocus": {"type": "boolean"},
                        "disabled": {"value": false, "bindable": "in-bound"},
                        "scopedatavalue": {"type": "string"},
                        "datavalue": {"type": "string", "bindable": "in-out-bound"},
                        "checkedvalue": {"type": "string"},
                        "radiogroup": {"type": "string"},
                        "caption": {"type": "string", "bindable": "in-out-bound", "maxlength": 256},
                        "shortcutkey": {"type": "string"}
                    },
                    "wm.radioset": {
                        "tabindex": {"type": "string", "value": "0"},
                        "disabled": {"type": "boolean", "value": false, "bindable": "in-bound"},
                        "readonly": {"type": "boolean", "value": false, "bindable": "in-bound"},
                        "layout":  {"type": "list", "options": ["", "inline", "stacked"]},
                        "itemclass": {"type": "string", "pattern": classRegex, "widget": "list-picker", "options": ["list-group", "media-list"]},
                        "listclass": {"type": "string", "pattern": classRegex, "widget": "list-picker", "options": ["list-group-item", "media"]},
                        /* ---- events ---- */

                        "onClick": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onTap": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onMouseenter": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onMouseleave": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onFocus": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onBlur": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onChange": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},

                        "datavalue": {"type": "string", "bindable": "in-out-bound", "show": false},
                        "scopedatavalue": {"type": "string"},
                        "dataset": {"type": "array, object", "bindable": "in-bound", "widget": "string", "value": "Option 1, Option 2, Option 3"},
                        "scopedataset": {"type": "string"},
                        "datafield": {"type": "list", "options": ["All Fields"], "value": "All Fields"},
                        "displayfield": {"type": "list", "options": [""], "value": ""},
                        "displayexpression": {"type": "string", "bindable": "in-bound", "bindonly": "expression"},
                        "usekeys": {"type": "boolean"},
                        "selectedvalue": {"type": "string, number, boolean, date, time, object", "widget": "string", "value": "", "bindable": "in-bound"}
                    },
                    "wm.colorpicker": {
                        "readonly": {"type": "boolean", "value": false, "bindable": "in-bound"},
                        "disabled": {"type": "boolean", "value": false, "bindable": "in-bound"},
                        "datavalue": {"type": "string", "bindable": "in-out-bound"},
                        "scopedatavalue": {"type": "string"},
                        "placeholder": {"type": "string", "value": "Select Color"},
                        "tabindex": {"type": "string", "value": "0"},
                        "shortcutkey": {"type": "string"},
                        "class": {"type": "string", "pattern": classRegex, "widget": "list-picker", "options": ["input-group-sm", "input-group-lg"]}
                    },

                    "wm.inputcolorpicker": {
                        "defaultcolor": {"value": "#fff"}
                    },

                    "wm.inputslider": {
                        "caption": {"value": "slider", "maxlength": 256}
                    },

                    "wm.slider": {
                        "readonly": {"type": "boolean", "value": false, "bindable": "in-bound"},
                        "disabled": {"type": "boolean", "value": false, "bindable": "in-bound"},
                        "minvalue": {"type": "number", "bindable": "in-out-bound"},
                        "maxvalue": {"type": "number", "bindable": "in-out-bound"},
                        "step": {"type": "number"},
                        "datavalue": {"type": "string", "bindable": "in-out-bound"},
                        "scopedatavalue": {"type": "string"},
                        "tabindex": {"type": "string", "value": "0"},
                        "shortcutkey": {"type": "string"}
                    },

                    "wm.checkbox": {
                        "datavalue": {"type": "boolean, string", "bindable": "in-out-bound", "widget": "string"},
                        "checkedvalue": {"type": "string"},
                        "uncheckedvalue": {"type": "string"},
                        "scopedatavalue": {"type": "string"},
                        "caption": {"type": "string", "bindable": "in-out-bound", "maxlength": 256},
                        "shortcutkey": {"type": "string"}
                    },
                    "wm.checkboxset": {
                        "tabindex": {"type": "string", "value": "0"},
                        "disabled": {"type": "boolean", "value": false, "bindable": "in-bound"},
                        "readonly": {"type": "boolean", "value": false, "bindable": "in-bound"},
                        "layout":  {"type": "list", "options": ["", "inline", "stacked"]},
                        "itemclass": {"type": "string", "pattern": classRegex, "widget": "list-picker", "options": ["list-group", "media-list"]},
                        "listclass": {"type": "string", "pattern": classRegex, "widget": "list-picker", "options": ["list-group-item", "media"]},

                        /* ---- events ---- */

                        "onClick": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onTap": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onMouseenter": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onMouseleave": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onFocus": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onBlur": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onChange": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},

                        "datavalue": {"type": "string, array", "bindable": "in-out-bound", "show": false, "widget": "string"},
                        "scopedatavalue": {"type": "string"},
                        "dataset": {"type": "array, object", "bindable": "in-bound", "widget": "string", "value": "Option 1, Option 2, Option 3"},
                        "scopedataset": {"type": "string"},
                        "usekeys": {"type": "boolean"},
                        "datafield": {"type": "list", "options": ["All Fields"], "value": "All Fields"},
                        "displayfield": {"type": "list", "options": [""], "value": ""},
                        "displayexpression": {"type": "string", "bindable": "in-bound", "bindonly": "expression"},
                        "selectedvalues": {"type": "string, object", "bindable": "in-bound", "widget": "string"},
                        "onReady": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"}
                    },

                    "wm.select": {
                        "autofocus": {"type": "boolean"},
                        "readonly": {"type": "boolean", "value": false, "bindable": "in-bound"},
                        "scopedatavalue": {"type": "string"},
                        "datavalue": {"type": "string, number, boolean, date, time, object", "bindable": "in-out-bound", "widget": "string"},
                        "scopedataset": {"type": "string"},
                        "dataset": {"type": "array, object", "bindable": "in-bound", "widget": "string"},
                        "allownone": {"type": "boolean"},
                        "hasdownarrow": {"type": "boolean", "value": true},
                        "restrictvalues": {"type": "boolean", "value": true},
                        "disabled": {"value": false, "bindable": "in-bound"},
                        "multiple": {"type": "boolean", "value": false},
                        "placeholder": {"type": "string", "value": ""},
                        "shortcutkey": {"type": "string"},
                        "class": {"type": "string", "pattern": classRegex, "widget": "list-picker", "options": ["input-lg", "input-sm"]}
                    },

                    "wm.marquee": {
                        "height": {"type": "string", "pattern": dimensionRegex},
                        "width": {"type": "string", "pattern": dimensionRegex},
                        "direction": {"type": "list", "options": ["up", "down", "left", "right"]},
                        "behavior": {"type": "list", "options": ["scroll", "slide", "alternate"]},
                        "scrolldelay": {"type": "number"},
                        "scrollamount": {"type": "number"}
                    },

                    "wm.label": {
                        "caption": {"type": "date, string, number", "widget": "string", "value": "Label", "bindable": "in-out-bound", "maxlength": 256},
                        "required": {"type": "boolean"},
                        "showindevice": {"type": "selectall", "options": showInDeviceOptions, "value": "all", "displaytype": 'inline-block'},
                        "animation": {"type": "list", "options": animationOptions},
                        "class": {"type": "string", "pattern": classRegex, "widget": "list-picker", "options": [ "h1", "h2", "h3", "h4", "h5", "h6", "text-left", "text-right", "text-center", "text-muted", "text-primary", "text-success", "text-info", "text-warning", "text-danger", "label-default", "label-primary", "label-success", "label-info", "label-warning", "label-danger", "lead", "badge"]}
                    },

                    "wm.picture": {
                        "picturesource": {"type": "string", "value": "resources/images/imagelists/default-image.png", "bindable": "in-out-bound"},
                        "pictureaspect": {"type": "list", "options": ["Both", "H", "None", "V"], "value": "None"},
                        "disabled": {"type": "boolean", "bindable": "in-bound"},
                        "tabindex": {"type": "string", "value": "0"},
                        "shape":  {"type": "list", "options": ["", "rounded", "circle", "thumbnail"]},
                        "showindevice": {"type": "selectall", "options": showInDeviceOptions, "value": "all", "displaytype": 'inline-block'},
                        "animation": {"type": "list", "options": animationOptions},
                        "class": {"type": "string", "pattern": classRegex, "widget": "list-picker", "options": ["img-responsive"]}
                    },

                    "wm.textarea": {
                        "autofocus": {"type": "boolean"},
                        "readonly": {"type": "boolean", "bindable": "in-bound"},
                        "datavalue": {"type": "string", "bindable": "in-out-bound"},
                        "scopedatavalue": {"type": "string"},
                        "placeholder": {"type": "string", "value": "Place your text"},
                        "maxchars": {"type": "number"},
                        "updateon": {"type": "list", "value": "blur", "widget": "updateon"},
                        "updatedelay": {"type": "number", "value": 0},
                        "shortcutkey": {"type": "string"},
                        "class": {"type": "string", "pattern": classRegex, "widget": "list-picker", "options": ["input-lg", "input-sm"]}
                    },

                    "wm.basicdialog": {
                        "show": {"type": "boolean", "show": false },
                        "height": {"type": "string", "pattern": dimensionRegex},
                        "width": {"type": "string", "pattern": dimensionRegex},
                        "onClose": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onOpened": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "animation": {"type": "list", "options": animationOptions},
                        "tabindex": {"type": "string", "value": "0"}
                    },
                    "wm.dialog.dialogheader": {
                        "caption": {"type": "string", "maxlength": 256, "bindable": "in-bound"},
                        "iconclass": {"type": "string", "widget": "selecticon", "bindable": "in-out-bound", "pattern": classRegex},
                        "iconwidth": {"type": "string", "pattern": dimensionRegex},
                        "iconheight": {"type": "string", "pattern": dimensionRegex},
                        "iconmargin": {"type": "string", "pattern": dimensionRegex},
                        "closable": {"type": "boolean", "show": false}
                    },
                    "wm.dialog.onOk": {
                        "onOk": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"}
                    },

                    "wm.alertdialog": {
                        "title": {"type": "string", "value": "Alert", "bindable": "in-bound"},
                        "oktext": {"type": "string", "value": "OK", "bindable": "in-bound"},
                        "iconclass": {"type": "string", "widget": "selecticon", "bindable": "in-out-bound", "value": "glyphicon glyphicon-warning-sign", "pattern": classRegex},
                        "message": {"type": "string", "value": "I am an alert box!", "bindable": "in-bound"},
                        "alerttype": {"type": "list", "options": ["error", "information", "success", "warning"], "value": "error"}
                    },
                    "wm.confirmdialog": {
                        "title": {"type": "string", "value": "Confirm", "bindable": "in-bound"},
                        "canceltext": {"type": "string", "value": "CANCEL", "bindable": "in-bound"},
                        "oktext": {"type": "string", "value": "OK", "bindable": "in-bound"},
                        "iconclass": {"type": "string", "widget": "selecticon", "bindable": "in-out-bound", "value": "glyphicon glyphicon-ok", "pattern": classRegex},
                        "message": {"type": "string", "value": "I am confirm box!", "bindable": "in-bound"},
                        "onCancel": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"}
                    },
                    "wm.iframedialog": {
                        "title": {"type": "string", "value": "External Content", "bindable": "in-bound"},
                        "url": {"type": "string", "value": "http://www.wavemaker.com", "bindable": "in-out-bound"},
                        "height": {"type": "string", "value": "400", "pattern": dimensionRegex},
                        "iconclass": {"type": "string", "widget": "selecticon", "bindable": "in-out-bound", "value": "glyphicon glyphicon-globe", "pattern": classRegex},
                        "oktext": {"type": "string", "value": "OK", "bindable": "in-bound"},
                        "closable": {"type": "boolean", "value": true}
                    },
                    "wm.pagedialog": {
                        "title": {"type": "string", "value": "Page Content", "bindable": "in-bound"},
                        "oktext": {"type": "string", "value": "OK", "bindable": "in-bound"},
                        "iconclass": {"type": "string", "widget": "selecticon", "bindable": "in-out-bound", "value" : "glyphicon glyphicon-file", "pattern": classRegex},
                        "closable": {"type": "boolean", "value": true}
                    },
                    "wm.logindialog": {
                        "height": {"type": "string", "show": false, "pattern": dimensionRegex},
                        "closable": {"type": "boolean", "value": true},
                        "modal": {"type": "boolean", "value": true}
                    },
                    "wm.designdialog": {
                        "modal": {"type": "boolean", "value": false},
                        "closable": {"type": "boolean", "value": true},
                        "title": {"type": "string", "show": false} //for backward compatibility
                    },
                    "wm.spinner": {
                        "show": {"type": "boolean", "value": false},
                        "caption": {"type": "string", "value": "Loading...", "maxlength": 256},
                        "servicevariabletotrack": {"type": "list", "options": []},
                        "iconclass": {"type": "string", value: "fa fa-spinner", "widget": "selecticon", "bindable": "in-out-bound", "pattern": classRegex},
                        "iconsize": {"type": "string", "pattern": dimensionRegex},
                        "image": {"type": "string", "bindable": "in-bound"},
                        "imagewidth": {"type": "string"},
                        "imageheight": {"type": "string"},
                        "animation" : {"type": "list", value: "spin", "options": spinnerAnimationOptions},
                        "backgroundcolor": {"type": "string", "widget": "color"},
                        "backgroundgradient": {"type": "string"},
                        "backgroundimage": {"type": "string", "bindable": "in-bound"},
                        "backgroundrepeat": {"type": "list", "options": ["no-repeat", "repeat", "repeat-x", "repeat-y"]},
                        "backgroundsize": {"type": "string", "hint": "width, height"},
                        "backgroundposition": {"type": "string", "hint": "top, left"},
                        "backgroundattachment": {"type": "list", "options": ["fixed", "local", "scroll"]},
                        "color": {"type": "string", "hidelabel": true, "widget": "color"},
                        "fontweight": {"type": "string", "options": ["bold"], "hidelabel": true, "widget": "icons_checkbox"},
                        "fontsize": {"type": "number", "hidelabel": true, "hint": "Font size", "pattern": numberRegex},
                        "fontunit": {"type": "string", "options": ["em", "px"], "value": "px", "hidelabel": true, "widget": "icons_radio"},
                        "textdecoration": {"type": "string", "options": ["underline"], "hidelabel": true, "widget": "icons_checkbox"},
                        "fontstyle": {"type": "string", "options": ["italic"], "hidelabel": true, "widget": "icons_checkbox"},
                        "fontVariant": {"type": "list", "options": ["normal", "small-caps"]},
                        "fontfamily": {"type": "string", "hidelabel": true, "hint": "Arial, Geneva"},
                        "misc": {"type": "string"},
                        "opacity": {"type": "string", "widget": "slider"},
                        "zindex": {"type": "string", "pattern": zindexRegex}
                    },

                    'wm.layouts': {

                        "hint": {"type": "string", "bindable": "in-bound"},
                        "name": {"type": "string", "pattern": nameRegex, "maxlength": 32},
                        "class": {"type": "string", "pattern": classRegex},
                        "border": {"type": "string", "widget": "box"},
                        "borderunit": {"type": "string", "options": ["em", "px"], "value": "px", "widget": "icons_radio"},
                        "bordertop": {"type": "string", "pattern": numberRegex},
                        "borderright": {"type": "string", "pattern": numberRegex},
                        "borderbottom": {"type": "string", "pattern": numberRegex},
                        "borderleft": {"type": "string", "pattern": numberRegex},
                        "borderwidth": {"type": "string"},
                        "borderstyle": {"type": "string", "options": ["dashed", "dotted", "none", "solid"], "widget": "borderstyle"},
                        "bordercolor": {"type": "string", "widget": "color"},
                        "padding": {"type": "string", "widget": "box"},
                        "paddingunit": {"type": "string", "options": ["%", "em", "px"], "value": "px", "widget": "icons_radio"},
                        "paddingtop": {"type": "string", "pattern": numberRegex},
                        "paddingright": {"type": "string", "pattern": numberRegex},
                        "paddingbottom": {"type": "string", "pattern": numberRegex},
                        "paddingleft": {"type": "string", "pattern": numberRegex},
                        "backgroundcolor": {"type": "string", "widget": "color"},
                        "backgroundgradient": {"type": "string"},
                        "backgroundimage": {"type": "string", "bindable": "in-bound"},
                        "backgroundrepeat": {"type": "list", "options": ["no-repeat", "repeat", "repeat-x", "repeat-y"]},
                        "backgroundsize": {"type": "string", "hint": "width, height"},
                        "backgroundposition": {"type": "string", "hint": "top, left"},
                        "backgroundattachment": {"type": "list", "options": ["fixed", "local", "scroll"]},
                        "color": {"type": "string", "hidelabel": true, "widget": "color"},
                        "text": {"type": "string"},
                        "fontweight": {"type": "string", "options": ["bold"], "hidelabel": true, "widget": "icons_checkbox"},
                        "fontsize": {"type": "number", "hidelabel": true, "hint": "Font size", "pattern": numberRegex},
                        "fontunit": {"type": "string", "options": ["em", "px"], "value": "px", "hidelabel": true, "widget": "icons_radio"},
                        "horizontalalign": {"type": "string", "options": ["left", "center", "right"], "widget": "icons_radio"},
                        "textdecoration": {"type": "string", "options": ["underline"], "hidelabel": true, "widget": "icons_checkbox"},
                        "fontstyle": {"type": "string", "options": ["italic"], "hidelabel": true, "widget": "icons_checkbox"},
                        "fontVariant": {"type": "list", "options": ["normal", "small-caps"]},
                        "fontfamily": {"type": "string", "hidelabel": true, "hint": "Arial, Geneva"},
                        "misc": {"type": "string"},
                        "whitespace": {"type": "list", "options": [" ", "normal", "nowrap", "pre", "pre-line", "pre-wrap"], "value": " "},
                        "wordbreak": {"type": "list", "options": ["break-word", "normal"]},
                        "opacity": {"type": "string", "widget": "slider"},
                        "overflow": {"type": "list", "options": ["visible", "hidden", "scroll", "auto", "initial", "inherit"]},
                        "cursor": {"type": "list", "options": ["crosshair", "default", "e-resize", "help", "move", "n-resize", "ne-resize", "nw-resize", "pointer", "progress", "s-resize", "se-resize", "sw-resize", "text", "wait", "w-resize"]},
                        "zindex": {"type": "string", "pattern": zindexRegex},
                        "accessroles": {"type": "accessrolesselect", "options": roles, "value": EVERYONE}
                    },
                    'wm.containers': {
                        "class": {"type": "string", "pattern": classRegex},
                        "show": {"type": "boolean", "value": true, "bindable": "in-bound"},
                        "height": {"type": "string", "pattern": dimensionRegex},
                        "width": {"type": "string", "pattern": dimensionRegex},
                        "accessroles": {"type": "accessrolesselect", "options": roles, "value": EVERYONE},
                        "overflow": {"type": "list", "options": ["visible", "hidden", "scroll", "auto", "initial", "inherit"]},
                        "visibility": {"type": "list", "options": visibilityOptions},
                        "display": {"type": "list", "options": displayOptions},
                        "showindevice": {"type": "selectall", "options": showInDeviceOptions, "value": "all", "displaytype": 'block'}
                    },

                    'wm.containers.lazy' : {
                        "loadmode" : {"type" : "list", "options" : ["", "after-select", "after-delay"], "value" : ""},
                        "loaddelay" : {"type" : "number", "min": "10", "value" : "10"},
                        "onReady" : {"type" : "event", "options": widgetEventOptions, "widget": "eventlist"}
                    },

                    'wm.layouts.header': {
                        "height": {"type": "string", "pattern": dimensionRegex}
                    },
                    'wm.layouts.list': {
                        "height": {"type": "string", "pattern": dimensionRegex},
                        "show": {"type": "boolean", "value": true, "bindable": "in-out-bound"},
                        "layout":  {"type": "list", "options": ["inline", "vertical"], "value": "vertical"},
                        "showindevice": {"type": "selectall", "options": showInDeviceOptions, "value": "all", "displaytype": 'block'},
                        "class": {"type": "string", "pattern": classRegex, "widget": "list-picker", "options": ["well", "alert", "alert-success", "alert-info", "alert-warning", "alert-danger"]}
                    },
                    'wm.layouts.breadcrumb': {
                        "height": {"type": "string", "pattern": dimensionRegex},
                        "show": {"type": "boolean", "value": true, "bindable": "in-out-bound"},
                        "dataset": {"type": "array, object", "bindable": "in-bound", "widget": "string"},
                        "scopedataset": {"type": "string"},
                        "itemicon": {"type": "list", "options": [""]},
                        "itemlabel": {"type": "list", "options": [""]},
                        "itemlink": {"type": "list", "options": [""]}
                    },
                    'wm.layouts.nav': {
                        "height": {"type": "string", "pattern": dimensionRegex},
                        "show": {"type": "boolean", "value": true, "bindable": "in-out-bound"},
                        "layout":  {"type": "list", "options": ["", "stacked", "justified"]},
                        "dataset": {"type": "array, object", "bindable": "in-bound", "widget": "string"},
                        "scopedataset": {"type": "string"},
                        "type":  {"type": "list", "options": ["navbar", "pills", "tabs"]},
                        "itemicon": {"type": "list", "options": [""]},
                        "itemlabel": {"type": "list", "options": [""]},
                        "itemlink": {"type": "list", "options": [""]},
                        "itemchildren": {"type": "list", "options": [""]},
                        "addchild": {"hidelabel": true, "options": [{'label': 'Anchor', 'widgettype': 'wm-anchor', 'defaults': {'wm-anchor': {'iconclass': 'glyphicon glyphicon-file', 'type': 'anchor'} } }, {'label': 'Menu', 'widgettype': 'wm-menu', 'defaults': {'wm-menu': {'iconclass': 'glyphicon glyphicon-file'} } }, {'label': 'Popover', 'widgettype': 'wm-popover', 'defaults': {'wm-popover': {'iconclass': 'glyphicon glyphicon-file'} } }, {'label': 'Button', 'widgettype': 'wm-button', 'defaults': {'wm-button': {'iconclass': 'glyphicon glyphicon-file'} } }], "widget": "add-widget"},
                        "selecteditem": {"type": "object", "bindable": "in-out-bound", "show": false, "widget": "string"},
                        "onSelect": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "class": {"type": "string", "pattern": classRegex, "widget": "list-picker", "options": ["nav-justified", "nav-tabs-justified"]}
                    },
                    'wm.layouts.navbar': {
                        "height": {"type": "string", "pattern": dimensionRegex},
                        "show": {"type": "boolean", "value": true, "bindable": "in-out-bound"},
                        "title": {"type": "string", "bindable": "in-bound"},
                        "imgsrc": {"type": "string", "bindable": "in-bound"},
                        "class": {"type": "string", "pattern": classRegex, "widget": "list-picker", "options": ["navbar-inverse", "navbar-header", "navbar-right", "navbar-left", "navbar-fixed-top", "navbar-fixed-bottom", "navbar-static-top"]}
                    },
                    'wm.layouts.mobile.navbar': {
                        "height": {"type": "string", "pattern": dimensionRegex},
                        "show": {"type": "boolean", "value": true, "bindable": "in-out-bound"},
                        "title": {"type": "string", "bindable": "in-bound"},
                        "leftnavpaneliconclass": {"type": "string", "widget": "selecticon", "pattern": classRegex, "value": "glyphicon glyphicon-menu-hamburger"},
                        "backbutton":  {"type": "boolean", "value": true},
                        "backbuttoniconclass": {"type": "string", "widget": "selecticon", "pattern": classRegex, "value": "glyphicon glyphicon-menu-left"},
                        "backbuttonlabel":  {"type": "string"},
                        "searchbutton":  {"type": "boolean", "value": false},
                        "searchbuttoniconclass": {"type": "string", "widget": "selecticon", "pattern": classRegex, "value": "glyphicon glyphicon-search", "show": false},
                        "searchbuttonlabel":  {"type": "string", "show": false},
                        "searchplaceholder": {"type": "string", "value": "Search", "show": false},
                        "onSearch": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onBackbtnclick": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "imgsrc": {"type": "string", "bindable": "in-bound"},
                        "scopedatavalue": {"type": "string"},
                        "datavalue": {"type": "string, object", "widget": "string", "bindable": "in-out-bound"},
                        "scopedataset": {"type": "string"},
                        "dataset": {"type": "array, object", "bindable": "in-bound", "widget": "string"},
                        "searchkey": {"type": "list", "options": [""]},
                        "displaylabel": {"type": "list", "options": [""]},
                        "displayimagesrc": {"type": "list", "options": [""]},
                        "datafield": {"type": "list", "options": ["All Fields"], "value": "All Fields"},
                        "defaultview": {"type": "selectByObject", "options": [{"label": "action-view", "value": "actionview"}, {"label": "search-view", "value": "searchview"}], "value": "actionview", "displayfield": "label", "datafield": "value" },
                        "query": {"type": "string", "bindable": "in-out-bound", "value": ""},
                        "addchild": {"hidelabel": true, "options": [{"label": "Anchor", "widgettype": "wm-anchor", "defaults": {"iconclass": "fa fa-plus", "caption": ""}}, {"label": "Menu", "widgettype": "wm-menu", "defaults": {"iconclass": "fa fa-plus", "type": "anchor", "caption": ""}}, {"label": "Popover", "widgettype": "wm-popover", "defaults": {"iconclass": "fa fa-plus", "caption": ""}}, {"label": "Button", "widgettype": "wm-button", "defaults": {"iconclass": "fa fa-plus", "class": "navbar-btn btn-primary", "caption": ""}}], "widget": "add-widget"}
                    },
                    'wm.layouts.listtemplate': {
                        "height": {"type": "string", "pattern": dimensionRegex},
                        "width": {"type": "string", "pattern": dimensionRegex},
                        "class": {"type": "string", "show": false, "pattern": classRegex}
                    },
                    'wm.layouts.mediatemplate': {
                        "width": {"type": "string", "pattern": dimensionRegex, "value": 100},
                        "height": {"type": "string", "pattern": dimensionRegex, "value": 100}
                    },
                    'wm.layouts.listitem': {
                        "height": {"type": "string", "pattern": dimensionRegex},
                        "width": {"type": "string", "pattern": dimensionRegex},
                        "margin": {"type": "string", "widget": "box"},
                        "marginunit": {"type": "string", "options": ["%", "em", "px"], "value": "px", "widget": "icons_radio"},
                        "margintop": {"type": "string", "pattern": numberRegex},
                        "marginbottom": {"type": "string", "pattern": numberRegex},
                        "marginright": {"type": "string", "pattern": numberRegex},
                        "marginleft": {"type": "string", "pattern": numberRegex}
                    },
                    'wm.layouts.topnav': {
                        "height": {"type": "string", "pattern": dimensionRegex}
                    },
                    'wm.layouts.leftpanel': {
                        "columnwidth": {"type": "list", "options": ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"], "value": "2"},
                        "animation" : {"type": "list", "options": ["slide-in", "slide-over"], "value" : "slide-in"}
                    },
                    'wm.layouts.rightpanel': {
                        "columnwidth": {"type": "list", "options": ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"], "value": "2"}
                    },
                    'wm.layouts.content': {
                        "height": {"type": "string", "pattern": dimensionRegex}
                    },
                    'wm.layouts.panel': {
                        "title": {"type": "string", "value": "Title", "bindable": "in-bound"},
                        "description": {"type": "string", "bindable": "in-bound", "widget": "textarea"},
                        "iconclass": {"type": "string", "widget": "selecticon", "bindable": "in-out-bound", "pattern": classRegex},
                        "collapsible": {"type": "boolean"},
                        "enablefullscreen": {"type": "boolean"},
                        "expanded": {"type": "boolean", "value": true},
                        "closable": {"type": "boolean"},
                        "helptext": {"type": "string", "bindable": "in-out-bound", "widget": "textarea"},
                        "actions": {"type": "array, object", "bindable": "in-bound", "widget": "string"},
                        "badgevalue": {"type": "string", "bindable": "in-out-bound"},
                        "badgetype": {"type": "list", "options": ["default", "primary", "success", "info", "warning", "danger"], "value": "default", "bindable": "in-out-bound"},
                        "marginunit": {"type": "string", "options": ["%", "em", "px"], "value": "px", "widget": "icons_radio"},
                        "margin": {"type": "string", "widget": "box"},
                        "margintop": {"type": "string", "pattern": numberRegex},
                        "marginbottom": {"type": "string", "pattern": numberRegex},
                        "marginright": {"type": "string", "pattern": numberRegex},
                        "marginleft": {"type": "string", "pattern": numberRegex},
                        /*Events*/
                        "onEnterkeypress": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onMouseenter": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onMouseleave": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onMouseout": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onMouseover": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onClose": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onExpand": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onCollapse": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onFullscreen": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onExitfullscreen": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onActionsclick": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "animation": {"type": "list", "options": animationOptions},
                        "class": {"type": "string", "pattern": classRegex, "widget": "list-picker", "value": "panel-default", "options": ["panel-primary", "panel-success", "panel-info", "panel-warning", "panel-danger"]}
                    },
                    'wm.layouts.container': {
                        "marginunit": {"type": "string", "options": ["%", "em", "px"], "value": "px", "widget": "icons_radio"},
                        "margin": {"type": "string", "widget": "box"},
                        "margintop": {"type": "string", "pattern": numberRegex},
                        "marginbottom": {"type": "string", "pattern": numberRegex},
                        "marginright": {"type": "string", "pattern": numberRegex},
                        "marginleft": {"type": "string", "pattern": numberRegex},
                        /*Events*/
                        "onEnterkeypress": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onClick": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onDblclick": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onTap": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onDoubletap": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onMouseenter": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onMouseleave": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onMouseout": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onMouseover": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "animation": {"type": "list", "options": animationOptions},
                        "class": {"type": "string", "pattern": classRegex, "widget": "list-picker", "options": ["well", "alert", "alert-success", "alert-info", "alert-warning", "alert-danger"]}
                    },
                    'wm.layouts.tile': {
                        "width": {"type": "string", "pattern": dimensionRegex},
                        "height": {"type": "string", "pattern": dimensionRegex},
                        "marginunit": {"type": "string", "options": ["%", "em", "px"], "value": "px", "widget": "icons_radio"},
                        "margin": {"type": "string", "widget": "box"},
                        "margintop": {"type": "string", "pattern": numberRegex},
                        "marginbottom": {"type": "string", "pattern": numberRegex},
                        "marginright": {"type": "string", "pattern": numberRegex},
                        "marginleft": {"type": "string", "pattern": numberRegex},
                        /*Events*/
                        "onEnterkeypress": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onClick": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onDblclick": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onTap": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onDoubletap": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onMouseenter": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onMouseleave": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onMouseout": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onMouseover": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "animation": {"type": "list", "options": animationOptions},
                        "class": {"type": "string", "pattern": classRegex, "widget": "list-picker", "options": ["card", "well", "alert", "alert-success", "alert-info", "alert-warning", "alert-danger"]}
                    },
                    'wm.layouts.footer': {
                        "height": {"type": "string", "pattern": dimensionRegex},
                        "class": {"type": "string", "pattern": classRegex, "widget": "list-picker", "options": ["card-footer"]}
                    },
                    'wm.layouts.layoutgrid': {
                        "name": {"type": "string", "pattern": nameRegex, "maxlength": 32},
                        "height": {"type": "string", "pattern": dimensionRegex},
                        "width": {"type": "string", "value": '100%', "pattern": dimensionRegex},
                        "marginunit": {"type": "string", "options": ["%", "em", "px"], "value": "px", "widget": "icons_radio"},
                        "margin": {"type": "string", "widget": "box"},
                        "margintop": {"type": "string", "pattern": numberRegex},
                        "marginbottom": {"type": "string", "pattern": numberRegex},
                        "marginright": {"type": "string", "pattern": numberRegex},
                        "marginleft": {"type": "string", "pattern": numberRegex},
                        "show": {"type": "boolean", "value": true, "bindable": "in-bound"},
                        "insert": {"type": "toolbar", "actions": [{'action': 'addrow', 'label': 'LABEL_PROPERTY_ADDROW', 'icon': 'add-row'}]},
                        "columns": {"type": "list", "options": ["1", "2", "3", "4", "6", "12"]}
                    },
                    'wm.layouts.gridcolumn': {
                        "height": {"type": "string", "pattern": dimensionRegex},
                        "columnwidth": {"type": "list", "options": ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"]},
                        "insert": {"type": "toolbar", "actions": [{'action': 'addcolumnleft', 'label': 'LABEL_PROPERTY_ADDCOLUMNLEFT', 'icon': 'add-column-left'}, {'action': 'addcolumnright', 'label': 'LABEL_PROPERTY_ADDCOLUMNRIGHT', 'icon': 'add-column-right'}]}
                    },
                    'wm.layouts.gridrow': {
                        "height": {"type": "string", "pattern": dimensionRegex},
                        "insert": {"type": "toolbar", "actions": [{'action': 'addrowbelow', 'label': 'LABEL_PROPERTY_ADDROWBELOW', 'icon': 'add-row-below'}, {'action': 'addrowabove', 'label': 'LABEL_PROPERTY_ADDROWABOVE', 'icon': 'add-row-above'}, {'action': 'addcolumn', 'label': 'LABEL_PROPERTY_ADDCOLUMN', 'icon': 'add-column'}]}
                    },
                    'wm.layouts.column': {
                        "columnwidth": {"type": "list", "options": ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"]}
                    },
                    'wm.layouts.pagecontent': {
                        "columnwidth": {"type": "list", "options": ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"]}
                    },
                    'wm.layouts.row': {
                        "show": {"type": "boolean", "value": true}
                    },
                    'wm.layouts.view': {
                        "show": {"type": "boolean", "value": true, "bindable" : "in-out-bound"},
                        "viewgroup": {"type": "string", "value": "default"},
                        "animation": {"type": "list", "options": animationOptions}
                    },
                    'wm.layouts.form': {
                        "title": {"type": "string",  "bindable": "in-bound"},
                        "novalidate": {"type": "boolean", "value": false},
                        "autocomplete": {"type": "boolean", "value": true},
                        "action": {"type": "string", "bindable": "in-bound"},
                        "target": {"type": "list", "options": ["_blank", "_parent", "_self", "_top"], "value": "", "widget": "datalist"},
                        "margin": {"type": "string", "widget": "box"},
                        "marginunit": {"type": "string", "options": ["%", "em", "px"], "value": "px", "widget": "icons_radio"},
                        "margintop": {"type": "string", "pattern": numberRegex},
                        "marginbottom": {"type": "string", "pattern": numberRegex},
                        "marginright": {"type": "string", "pattern": numberRegex},
                        "marginleft": {"type": "string", "pattern": numberRegex},
                        "method": {"type": "list", "options": ["post", "put", "delete"]},
                        "height": {"type": "string", "pattern": dimensionRegex},
                        "width": {"type": "string", "pattern": dimensionRegex},
                        "captionsize": {"type": "string"},
                        "formdata": {"type": "object", "show": false, "bindable": "out-bound", "widget": "string"},
                        "postmessage": {"type": "string", "value": "Data posted successfully", "bindable": "in-out-bound"},
                        "captionalign": {"type": "list", "options": ["left", "center", "right"], "value": "left"},
                        "enctype": {"type": "list", "options": ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]},
                        "captionposition": {"type": "list", "options": ["left", "right", "top"], "value": "left"},
                        "onSubmit": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "tabindex": {"type": "string", "value": "0"},
                        "class": {"type": "string", "pattern": classRegex, "widget": "list-picker", "options": ["panel-primary", "panel-success", "panel-info", "panel-warning", "panel-danger"]}
                    },
                    'wm.layouts.liveform': {
                        "title": {"type": "string",  "bindable": "in-bound"},
                        "formlayout": {"type": "switch", "options":  [{"label": "INLINE", "value": "inline"}, {"label": "PAGE", "value": "page"}], "value": "inline", "show" : false, "displayfield": "label", "datafield": "value"},
                        "autocomplete": {"type": "boolean", "value": true, "showindesigner": true},
                        "captionsize": {"type": "string", "value": "", "showindesigner": true},
                        "captionalign": {"type": "string", "options": ["left", "center", "right"], "value": "left", "showindesigner": true, "widget": "icons_radio"},
                        "captionposition": {"type": "string", "options": ["left", "right", "top"], "value": "left", "showindesigner": true, "widget": "icons_radio", "prefix": "position-"},
                        "dataset": {"type": "array, object", "bindable": "in-bound", "widget": "string"},
                        "advancedsettings": {"type": "button", "hidelabel": true, "disabled": true, "iconclass": "settings"},
                        "height": {"type": "string", "pattern": dimensionRegex},
                        "rowdata": {"type": "string"},
                        "formdata": {"type": "object", "bindable": "in-bound", "widget": "string"},
                        "dataoutput": {"type": "object", "bindable": "out-bound", "widget": "string"},
                        "name": {"type": "string", "pattern": nameRegex, "maxlength": 32},
                        "novalidate": {"type": "boolean", "value": true, "showindesigner": true},
                        "show": {"type": "boolean", "value": true},
                        "iconclass": {"type": "string", "widget": "selecticon", "bindable": "in-bound", "pattern": classRegex},
                        "horizontalalign": {"type": "string", "options": ["left", "center", "right"], "widget": "icons_radio", "show": false},
                        "defaultmode": {"type": "switch", "options": [{"label": "READ ONLY", "value": "View"}, {"label": "EDITABLE", "value": "Edit"}], "value": "View", "showindesigner": true, "displayfield": "label", "datafield": "value"},
                        "width": {"type": "string", "pattern": dimensionRegex},
                        "messagelayout": {"type": "list", "options": ["Inline", "Toaster"], "value": "Toaster", "showindesigner": true},
                        "insertmessage": {"type": "string", "value": "Record added successfully", "bindable": "in-out-bound", "showindesigner": true},
                        "updatemessage": {"type": "string", "value": "Record updated successfully", "bindable": "in-out-bound", "showindesigner": true},
                        "deletemessage": {"type": "string", "value": "Record deleted successfully", "bindable": "in-out-bound", "showindesigner": true},
                        "errormessage": {"type": "string", "value": "An error occured. Please try again!", "bindable": "in-out-bound", "showindesigner": true},
                        /*Events*/
                        "onBeforeservicecall": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onResult": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onError": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onSuccess": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "tabindex": {"type": "string", "value": "0"},
                        // property specific to mobile with formlayout page
                        "onBackbtnclick": {"type": "event", "options": widgetEventOptions, "widget": "eventlist", "show": false},
                        "class": {"type": "string", "pattern": classRegex, "widget": "list-picker", "options": ["panel-default", "panel-primary", "panel-success", "panel-info", "panel-warning", "panel-danger"]}
                    },
                    "wm.layouts.segmentedcontrol" : {
                        "onBeforeSegmentChange": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onSegmentChange": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "width": {"show": false},
                        "height": {"pattern": dimensionRegex},
                        "tabindex": {"type": "string", "value": "0"}
                    },
                    "wm.layouts.segmentcontent" : {
                        "caption": {"type": "string", "bindable": "in-out-bound", "maxlength": 256},
                        "iconclass": {"type": "string", "widget": "selecticon", "bindable": "in-out-bound", "pattern": classRegex}
                    },
                    'wm.grid': {
                        "width": {"value": "100%", "pattern": dimensionRegex},
                        "height": {"value": "200px", "pattern": dimensionRegex},
                        "dataset": {"type": "array, object", "bindable": "in-bound", "widget": "string"},
                        "scopedataset": {"type": "string"},
                        "pagesize": {"type": "number"},
                        "advancedsettings": {"type": "button", "hidelabel": true, "iconclass": "settings"},
                        "gridfirstrowselect": {"type": "boolean", "showindesigner": true},
                        "confirmdelete": {"type": "string", "value": "Are you sure you want to delete this?", "bindable": "in-out-bound", "show": false, "showindesigner": false},
                        "deleterow": {"type": "boolean", "bindable": "in-out-bound", "showindesigner": true},
                        "updaterow": {"type": "boolean", "bindable": "in-out-bound", "showindesigner": true},
                        "showheader": {"type": "boolean", "value": true, "showindesigner": true},
                        "gridsearch": {"type": "boolean", "showindesigner": true},
                        "searchlabel": {"type": "string", "value": "Search", "bindable": "in-out-bound", "show": false, "showindesigner": false, "alignright": true},
                        "enablesort": {"type": "boolean", "value": true, "showindesigner": true},
                        "showrowindex": {"type": "boolean", "showindesigner": true},
                        "multiselect": {"type": "boolean", "showindesigner": true},
                        "radioselect": {"type": "boolean", "showindesigner": true},
                        "insertrow": {"type": "boolean", "bindable": "in-out-bound", "showindesigner": true},
                        "readonlygrid": {"type": "boolean", "value": true, "show": false, "bindable": "in-bound"},
                        "showrecordcount": {"type": "boolean", "show": false, "showindesigner": true},
                        "shownavigation": {"type": "boolean", "value": true, "showindesigner": true},
                        "filternullrecords": {"type": "boolean", "value": true},
                        "nodatamessage": {"type": "string", "value": "No data found.", "bindable": "in-out-bound", "showindesigner": true},
                        "loadingdatamsg": {"type": "string", "value": "Loading...", "bindable": "in-out-bound", "showindesigner": true},
                        "deletemessage": {"type": "string", "value": "Record deleted successfully", "bindable": "in-out-bound", "show": false, "showindesigner": false},
                        "selecteditem": {"type": "object", "bindable": "in-out-bound", "show": false, "widget": "string"},
                        "title": {"type": "string", "bindable": "in-bound"},
                        "spacing": {"type": "list", "options": ["normal", "condensed"], "value": "normal"},

                        /* Events */
                        "onClick": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onTap": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onSelect": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onDeselect": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onSort": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onHeaderclick": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onShow": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onHide": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onRowdeleted": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onBeforerowinsert": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onRowinsert": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onRowclick": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onColumnselect": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onColumndeselect": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onEnterkeypress": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onSetrecord": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},

                        /* Styles */
                        "gridclass": {"type": "string", "value": "table-bordered table-striped table-hover", "pattern": classRegex, "widget": "list-picker", "options": ["table-hover", "table-bordered", "table-striped"]},
                        "tabindex": {"type": "string", "value": "0"}
                    },
                    'wm.livegrid': {
                        'formlayout': {"type": "list", "options": ["inline", "dialog"], "value": "inline"}
                    },
                    'wm.fileupload': {
                        "service": {"type": "list", "widget": "list"},
                        "operation": {"type": "list", "widget": "list"},
                        "multiple": {"type": "boolean", "value": false},
                        "contenttype": {"type": "list", "widget" : "list-picker", "options": ["image/*", "audio/*", "video/*", ".txt", ".zip", ".rar", ".js", ".json", ".xls", ".xlsx", ".pdf", ".csv", ".xml", ".doc", ".docx", ".log", ".rtf", ".bmp", ".gif", ".jpe", ".jpg", ".jpeg", ".tif", ".tiff", ".pbm", ".png", ".ico", "mp3", ".ogg", ".webm", ".wma", ".3gp", ".wav", "mp4", ".ogg", ".webm", ".wmv", ".mpeg", ".mpg", ".avi"]},
                        "fileuploadmessage": {"type": "string", "bindable": "in-out-bound", "value": "You can also browse for files"},
                        "tabindex": {"type": "string", "value": "0"},
                        "uploadedFiles": {"type": "array", "bindable": "in-out-bound"},
                        "selectedFiles": {"type": "array, file", "bindable": "in-out-bound", "show" : "false"},
                        "mode": {"type": "list", "options": ["Upload", "Select"], "value": "Upload"},
                        "destination": {"type": "string", "widget": "fileupload-relativepath", "bindable": "in-out-bound", "value": "", "info": "/resources/uploads/"},
                        "maxfilesize": {"type": "string", "widget": "fileupload-relativepath", "value": "",  "info": "size in MB"},
                        "caption": {"type": "string", "value": "Upload", "bindable": "in-out-bound", "maxlength": 256},
                        "disabled": {"type": "boolean", "value": false, "bindable": "in-bound"},
                        "iconclass": {"type": "string", "widget": "selecticon", "bindable": "in-out-bound", "value" : "glyphicon glyphicon-upload", "pattern": classRegex},

                        /* ---- events ---- */
                        "onSelect": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onProgress": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onAbort": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"}
                    },
                    'wm.youtube': {
                        "width": { "value": "800px", "pattern": dimensionRegex},
                        "height": {"value": "125px", "pattern": dimensionRegex},
                        "uploadpath": {"type": "string"}
                    },
                    "wm.anchor": {
                        "iconclass": {"type": "string", "widget": "selecticon", "bindable": "in-out-bound", "pattern": classRegex},
                        "iconurl": {"type": "string", "bindable": "in-bound"},
                        "iconwidth": {"type": "string", "pattern": dimensionRegex},
                        "iconheight": {"type": "string", "pattern": dimensionRegex},
                        "iconmargin": {"type": "string", "pattern": dimensionRegex},
                        "iconposition": {"type": "list", "options": ["left", "top", "right"]},
                        "caption": {"type": "string", "value": "Link", "bindable": "in-out-bound", "maxlength": 256},
                        "badgevalue": {"type": "string", "bindable": "in-out-bound"},
                        "hyperlink": {"type": "string", "bindable": "in-out-bound"},
                        "target": {"type": "list", "options": ["_blank", "_parent", "_self", "_top"], "value": "_self", "widget": "datalist"},
                        "tabindex": {"type": "string", "value": "0"},
                        "whitespace": {"type": "list", "options": [" ", "normal", "nowrap", "pre", "pre-line", "pre-wrap"], "value": " "},
                        "wordbreak": {"type": "list", "options": ["break-word", "normal"]},
                        "misc": {"type": "string"},
                        "opacity": {"type": "string", "widget": "slider"},
                        "cursor": {"type": "list", "options": ["crosshair", "default", "e-resize", "help", "move", "n-resize", "ne-resize", "nw-resize", "pointer", "progress", "s-resize", "se-resize", "sw-resize", "text", "wait", "w-resize"]},
                        "zindex": {"type": "string", "pattern": zindexRegex},
                        "showindevice": {"type": "selectall", "options": showInDeviceOptions, "value": "all", "displaytype": 'inline'},
                        "animation": {"type": "list", "options": animationOptions},
                        "shortcutkey": {"type": "string"},
                        "class": {"type": "string", "pattern": classRegex, "widget": "list-picker", "options": ["h1", "h2", "h3", "h4", "h5", "h6", "btn-primary", "btn-success", "btn-info", "btn-warning", "btn-danger", "btn-lg", "btn-sm", "btn-xs", "btn-link", "text-left", "text-right", "text-center", "text-muted", "text-primary", "text-success", "text-info", "text-warning", "text-danger", "lead", "badge"]}
                    },
                    "wm.popover": {
                        "contentsource": {"type": "list", "options": ['inline', 'partial'], value: "partial"},
                        "content": {"type": "list", "options": [], "widget": "pages-list", value: "", "bindable": "in-bound"},
                        "inlinecontent": {"type": "string", "widget": "textarea"},
                        "hyperlink": {"type": "string", "value": "", "show": false},
                        "target": {"type": "string", "value" : "", "show": false},
                        "popoverwidth" :  {"type": "string"},
                        "popoverheight" :  {"type": "string"},
                        "popoverarrow" :  {"type": "boolean", "value" : true},
                        "popoverautoclose": {"type": "boolean", "value" : true},
                        "popoverplacement": {"type": "list", "options": ["bottom", "left", "right", "top"], "value": "bottom"},
                        "title": {"type": "string", "bindable": "in-bound"},
                        "onShow": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onHide": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"}
                    },
                    "wm.prefabs": {
                        "margin": {"type": "string", "widget": "box"},
                        "debugurl": {"type": "string", "show": false},
                        "marginunit": {"type": "string", "options": ["%", "em", "px"], "value": "px", "widget": "icons_radio"},
                        "width": {"type": "string", "pattern": dimensionRegex},
                        "height": {"type": "string", "pattern": dimensionRegex},
                        "onLoad": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onDestroy": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "animation": {"type": "list", "options": animationOptions},
                        "tabindex": {"type": "string", "value": "0"}
                    },

                    "wm.accordion": {
                        "addchild": {"hidelabel": true, "options": [{"label": "Accordion pane", "widgettype": "wm-accordionpane"}], "widget": "add-widget"},
                        "closeothers": { "type": "boolean", "value": true},
                        "height": {"type": "string", "pattern": dimensionRegex},
                        "width": {"type": "string", "pattern": dimensionRegex},
                        "tabindex": {"type": "string", "value": "0"}
                    },

                    "wm.accordionpane": {
                        "class": {"type": "string", "pattern": classRegex, "widget": "list-picker", "options": ["panel-primary", "panel-success", "panel-info", "panel-warning", "panel-danger"]},
                        "onExpand": {"type": "event", "options": widgetEventOptions, "widget": "eventlist", "show": false},
                        "onCollapse": {"type": "event", "options": widgetEventOptions, "widget": "eventlist", "show": false}
                    },
                    "wm.accordionheader": {
                        "heading": {"type": "string", "value": "Heading", "bindable": "in-bound"},
                        "description": {"type": "string", "bindable": "in-bound", "widget": "textarea"},
                        "iconclass": {"type": "string", "widget": "selecticon", "bindable": "in-out-bound", "pattern": classRegex},
                        "badgevalue": {"type": "string", "bindable": "in-out-bound"},
                        "badgetype": {"type": "list", "options": ["default", "primary", "success", "info", "warning", "danger"], "value": "default", "bindable": "in-out-bound"},
                        "tabindex": {"type": "string", "value": "0"},
                        "isdefaultpane": {"type": "boolean", "bindable": "in-bound"},
                        "onExpand": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onCollapse": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"}
                    },

                    "wm.richtexteditor": {
                        "show": {"type": "boolean", "value": true},
                        "readonly": {"type": "boolean", "bindable": "in-bound"},
                        "overflow": {"type": "list", "options": ["visible", "hidden", "scroll", "auto", "initial", "inherit"]},
                        "datavalue": {"type": "string", value: "", "bindable": "in-out-bound"},
                        "showpreview": {"type": "boolean", "value": false},
                        "placeholder": {"type": "string"},
                        "tabindex": {"type": "string", "value": "0"},
                        "scopedatavalue": {"type": "string"},
                        "onChange": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"}
                    },

                    "wm.tabs": {
                        "addchild": {"hidelabel": true, "options": [{"label": "Tab pane", "widgettype": "wm-tabpane"}], "widget": "add-widget"},
                        "tabsposition": {"type": "list",  "options": ["left", "top", "right", "bottom"], "value": "top"},
                        "taborder": {"type": "list", "widget": "tabordering", "dataset": []},
                        "transition": {"type": "list", "options": ["none", "slide"], "value": "none"}
                    },

                    "wm.tab": {
                        "heading": {"type": "string", "bindable": "in-bound"}
                    },
                    "wm.tabpane": {
                        "disabled": {"type": "boolean", "bindable": "in-bound"},
                        "onSelect": {"type": "event", "options": widgetEventOptions, "widget": "eventlist", "show": false},
                        "onDeselect": {"type": "event", "options": widgetEventOptions, "widget": "eventlist", "show": false}
                    },
                    "wm.tabheader": {
                        "heading": {"type": "string", "value": "Tab Title", "bindable": "in-bound"},
                        "paneicon": {"type": "string", "widget": "selecticon", "bindable": "in-bound", "pattern": classRegex},
                        "isdefaulttab": {"type": "boolean", "bindable": "in-bound"},
                        "tabindex": {"type": "string", "value": "0"},
                        "onSelect": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onDeselect": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"}
                    },
                    "wm.carousel" : {
                        "addchild": {"hidelabel": true, "options": [{"label": "Carousel", "widgettype": "wm-carousel-content"}], "widget": "add-widget"},
                        "dataset": {"type": "array, object", "bindable": "in-bound", "widget": "string", "show": false},
                        "animationinterval" : {"type" : "number", "value" : "3"},
                        "type" : {"type" : "string", "show" : false}
                    },
                    "wm.tabbar" : {
                        "dataset": {"type": "array, object", "bindable": "in-bound", "widget": "string"},
                        "dropposition": {"type": "list", "options": ["down", "up"], "value": "up"},
                        "onSelect": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "morebuttoniconclass": {"type": "string", "widget": "selecticon", "pattern": classRegex, "value": "glyphicon glyphicon-option-horizontal"},
                        "morebuttonlabel":  {"type": "string", "value": "more"}
                    },
                    "wm.tabbar.dataProps": {
                        "itemlabel": {"type": "string", "widget": "list", "options": [""], "bindable": "in-bound", "bindonly": "expression"},
                        "itemlink": {"type": "string", "widget": "list", "options": [""], "bindable": "in-bound", "bindonly": "expression"},
                        "itemicon": {"type": "string", "widget": "list", "options": [""], "bindable": "in-bound", "bindonly": "expression"}
                    },
                    "wm.livelist": {
                        "name": {"type": "string", "pattern": nameRegex, "maxlength": 32},
                        "title": {"type": "string", "bindable": "in-bound"},
                        "show": {"type": "boolean", "value": true, "bindable": "in-bound"},
                        "enablereorder": {"type": "boolean"},
                        "accessroles": {"type": "accessrolesselect", "options": roles, "value": EVERYONE},
                        "onSelectionlimitexceed" : {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onReorder" : {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "pagesize": {"type": "number"},
                        "dataset": {"type": "array, object", "bindable": "in-bound", "widget": "string"},
                        "scopedataset": {"type": "string"},
                        "selectionlimit": {"type": "number", "bindable": "in-bound"},
                        "itemsperrow": {"type": "list", "options": ["1", "2", "3", "4", "6", "12"], "value": "1"},
                        "selecteditem": {"type": "object", "bindable": "in-out-bound", "show": false, "widget": "string"},
                        "onEnterkeypress": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onSetrecord": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "itemclass": {"type": "string", "pattern": classRegex, "widget": "list-picker", "options": ["list-group-item", "media"]},
                        "listclass": {"type": "string", "pattern": classRegex, "widget": "list-picker", "options": ["list-group", "list-inline", "media-list"]},
                        "iconclass": {"type": "string", "widget": "selecticon", "bindable": "in-bound", "value": "", "pattern": classRegex},
                        "navigation": {"type": "list", "options": ["None", "Basic", "Advanced", "Scroll"], "value": "None"},
                        "selectfirstitem": {"type": "boolean", "value": false, "bindable": "in-out-bound"},
                        "tabindex": {"type": "string", "value": "0"},
                        "class": {"type": "string", "pattern": classRegex, "widget": "list-picker", "options": ["panel-default","panel-primary", "panel-success", "panel-info", "panel-warning", "panel-danger"]}
                    },
                    "wm.medialist": {
                        "dataset": {"type": "array, object", "bindable": "in-bound", "widget": "string"},
                        "thumbnailurl": {"type": "list", "options": ["All Fields"], "value": "All Fields"},
                        "mediaurl": {"type": "list", "options": ["All Fields"], "value": "All Fields"},
                        "layout": {"type": "list", "options": ["Single-row", "Multi-row"], "value": "Single-row"},
                        "tabindex": {"type": "string", "value": "0"}
                    },
                    "wm.livefilter": {
                        "title": {"type": "string"},
                        "autocomplete": {"type": "boolean", "value": true, "showindesigner": true},
                        "captionsize": {"type": "string", "value": "", "showindesigner": true},
                        "captionalign": {"type": "string", "options": ["left", "center", "right"], "value": "left", "showindesigner": true, "widget": "icons_radio"},
                        "captionposition": {"type": "string", "options": ["left", "right", "top"], "value": "left", "showindesigner": true, "widget": "icons_radio", "prefix": "position-"},
                        "dataset": {"type": "array, object", "bindable": "in-bound", "widget": "string"},
                        "scopedataset": {"type": "string"},
                        "advancedsettings": {"type": "button", "hidelabel": true, "disabled": true, "iconclass": "settings"},
                        "result": {"type": "object", "bindable": "out-bound", "widget": "string", "show": "false"},
                        "pagesize": {"type": "number", "value": 20},
                        "horizontalalign": {"type": "string", "options": ["left", "center", "right"], "widget": "icons_radio", "show": false},
                        "iconclass": {"type": "string", "widget": "selecticon", "bindable": "in-bound", "value": "glyphicon glyphicon-filter", "pattern": classRegex},
                        /* Events */
                        "onBeforeservicecall": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onError": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onSuccess": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "tabindex": {"type": "string", "value": "0"},
                        "collapsible": {"type": "boolean", "showindesigner": true},
                        "expanded": {"type": "boolean", "value": true, "showindesigner": true},
                        "enableemptyfilter": {"type": "selectall", "options": ["null", "empty"], "displaytype": "block", "value": " ", "showindesigner": true},
                        "class": {"type": "string", "pattern": classRegex, "widget": "list-picker", "options": ["panel-default", "panel-primary", "panel-success", "panel-info", "panel-warning", "panel-danger"]}
                    },
                    "wm.search": {
                        "scopedatavalue": {"type": "string"},
                        "datavalue": {"type": "string, object", "widget": "string", "bindable": "in-out-bound"},
                        "scopedataset": {"type": "string"},
                        "query": {"type": "string", "bindable": "out-bound"},
                        "searchkey": {"type": "list", "options": [""]},
                        "displaylabel": {"type": "list", "options": [""]},
                        "displayimagesrc": {"type": "list", "options": [""]},
                        "datafield": {"type": "list", "options": ["All Fields"], "value": "All Fields"},
                        "dataset": {"type": "array, object", "bindable": "in-bound", "widget": "string"},
                        "limit": {"type": "number", "value": 5},
                        "placeholder": {"type": "string", "value": "Search"},
                        "onSubmit": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "show": {"type": "boolean", "value": true, "bindable": "in-out-bound"},
                        "tabindex": {"type": "string", "value": "0"},
                        "showindevice": {"type": "selectall", "options": showInDeviceOptions, "value": "all", "displaytype": 'inline-block'},
                        "width": {"type": "string", "value": '100%', "pattern": dimensionRegex},
                        "shortcutkey": {"type": "string"},
                        "class": {"type": "string", "pattern": classRegex, "widget": "list-picker", "options": ["input-group-sm", "input-group-lg"]},
                        "casesensitive": {"type": "boolean", "show": "false", "value": false},
                        /* searchbar in mobile-navbar*/
                        "navsearchbar": {"type": "string", "show": "false"}
                    },
                    "wm.chart": {
                        "height": {"type": "string", value: "210px", "pattern": dimensionRegex},
                        "width": {"type": "string", "pattern": dimensionRegex},
                        "type": {"type": "string", "widget": "list", "options": ["Column", "Line", "Area", "Cumulative Line", "Bar", "Pie", "Donut", "Bubble"], "bindable": "in-out-bound"},
                        "scopedataset": {"type": "string"},
                        "dataset": {"type": "array, object", "bindable": "in-bound", "widget": "string"},
                        "xaxisdatakey": {"type": "list", "widget": "list"},
                        "xaxislabel": {"type": "string"},
                        "xunits": {"type": "string"},
                        "xnumberformat": {"type": "list", "show": false, "options": ["Decimal Digits", "Precision", "Exponential", "Percentage", "Round", "Round Percentage", "Round to Thousand", "Round to Million", "Round to Billion"]},
                        "xdigits": {"type": "number", "show": false, "value": 1},
                        "xdateformat": {"type": "listGroup", "show": false, "options": dateOptions, "value": "%x"},
                        "yaxisdatakey": {"type": "list", "widget": "multiselect"},
                        "yaxislabel": {"type": "string"},
                        "yunits": {"type": "string"},
                        "ynumberformat": {"type": "list", "show": false, "options": ["Decimal Digits", "Precision", "Exponential", "Percentage", "Round", "Round Percentage", "Round to Thousand", "Round to Million", "Round to Billion"]},
                        "ydigits": {"type": "number", "show": false, "value": 1},
                        "ydateformat": {"type": "listGroup", "show": false, "options": dateOptions, "value": "%x"},
                        "bubblesize": {"type": "string", "widget": "list"},
                        "shape": {"type": "string", "widget": "list", "options": ["circle", "square", "diamond", "cross", "triangle-up", "triangle-down", "random"], value: "circle"},
                        "show": {"type": "boolean", "value": true, "bindable": "in-out-bound"},
                        "highlightpoints": {"type": "boolean"},
                        "linethickness": {"type": "string"},
                        "tooltips": {"type": "boolean", "value": true},
                        "showlegend": {"type": "boolean", "value": true},
                        "captions": {"type": "boolean", "value": true},
                        "showxaxis": {"type": "boolean", "value": true},
                        "showyaxis": {"type": "boolean", "value": true},
                        "legendposition": {"type": "list", "options": ["Top", "Bottom"], "value": "Top", "disabled": false},
                        "legendtype": {"type": "list", "options": ["furious", "classic"], "value": "furious", "disabled": false},
                        "showvalues": {"type": "boolean", "value": false},
                        "showlabels": {"type": "boolean", "value": true},
                        "showcontrols": {"type": "boolean", "value": false},
                        "useinteractiveguideline": {"type": "boolean", "value": false},
                        "staggerlabels": {"type": "boolean", "value": false},
                        "reducexticks": {"type": "boolean", "value": true},
                        "labeltype": {"type": "list", "options": ["key", "value", "percent"], "value": "percent"},
                        "offset": {"type": "string", "widget": "box"},
                        "offsettop": {"type": "number", "value": 25, "pattern": numberRegex},
                        "offsetbottom": {"type": "number", "value": 55, "pattern": numberRegex},
                        "offsetleft": {"type": "number", "value": 75, "pattern": numberRegex},
                        "offsetright": {"type": "number", "value": 25, "pattern": numberRegex},
                        "barspacing": {"type": "number", "value": 0.5, "min": "0.1", "max": "0.9", "step": "0.1"},
                        "donutratio": {"type": "number", "value": 0.6, "min": "0.1", "max": "1", "step": "0.1"},
                        "title": {"type": "string", "bindable": "in-out-bound"},
                        "showlabelsoutside": {"type": "boolean", "value": true},
                        "xaxislabeldistance": {"type": "number", "value": 12, "show": false},
                        "yaxislabeldistance": {"type": "number", "value": 12, "show": false},
                        "showxdistance": {"type": "boolean", "value": false},
                        "showydistance": {"type": "boolean", "value": false},
                        "aggregation": {"type": "list", "options": ["average", "count", "maximum", "minimum", "none", "sum"], "value": "none"},
                        "aggregationcolumn": {"type": "list", "widget": "list"},
                        "groupby": {"type": "list", "widget": "multiselect"},
                        "orderby": {"type": "list", "widget": "order-by"},
                        "theme": {"type": "list", "options": ["Terrestrial", "Annabelle", "Azure", "Retro", "Mellow", "Orient", "GrayScale", "Flyer", "Luminosity"]},
                        "customcolors": {"type": "array", "bindable": "in-bound", "widget": "string"},
                        "nodatamessage": {"type": "string", "value": "No Data Available.", "bindable": "in-out-bound"},
                        "xdomain" : {"type": "list", "options": ["Default", "Min"], "value": "Default"},
                        "ydomain" : {"type": "list", "options": ["Default", "Min"], "value": "Default"},
                        /**Style**/
                        "border": {"type": "string", "widget": "box"},
                        "borderunit": {"type": "string", "options": ["em", "px"], "value": "px", "widget": "icons_radio"},
                        "bordertop": {"type": "string", "pattern": numberRegex},
                        "borderright": {"type": "string", "pattern": numberRegex},
                        "borderbottom": {"type": "string", "pattern": numberRegex},
                        "borderleft": {"type": "string", "pattern": numberRegex},
                        "borderwidth": {"type": "string"},
                        "borderstyle": {"type": "string", "options": ["dashed", "dotted", "none", "solid"], "widget": "borderstyle"},
                        "bordercolor": {"type": "string", "widget": "color"},
                        "padding": {"type": "string", "widget": "box"},
                        "paddingunit": {"type": "string", "options": ["%", "em", "px"], "value": "px", "widget": "icons_radio"},
                        "paddingtop": {"type": "string", "pattern": numberRegex},
                        "paddingright": {"type": "string", "pattern": numberRegex},
                        "paddingbottom": {"type": "string", "pattern": numberRegex},
                        "paddingleft": {"type": "string", "pattern": numberRegex},
                        "margin": {"type": "string", "widget": "box"},
                        "marginunit": {"type": "string", "options": ["%", "em", "px"], "value": "px", "widget": "icons_radio"},
                        "margintop": {"type": "string", "pattern": numberRegex},
                        "marginbottom": {"type": "string", "pattern": numberRegex},
                        "marginright": {"type": "string", "pattern": numberRegex},
                        "marginleft": {"type": "string", "pattern": numberRegex},
                        "backgroundcolor": {"type": "string", "widget": "color"},
                        "backgroundimage": {"type": "string", "bindable": "in-bound"},
                        "color": {"type": "string", "hidelabel": true, "widget": "color"},
                        "fontweight": {"type": "string", "options": ["bold"], "hidelabel": true, "widget": "icons_checkbox"},
                        "fontsize": {"type": "number", "hidelabel": true, "hint": "Font size", "value": 12, "pattern": numberRegex},
                        "fontunit": {"type": "string", "options": ["em", "px"], "value": "px", "hidelabel": true, "widget": "icons_radio"},
                        "textdecoration": {"type": "string", "options": ["underline"], "hidelabel": true, "widget": "icons_checkbox"},
                        "fontstyle": {"type": "string", "options": ["italic"], "hidelabel": true, "widget": "icons_checkbox"},
                        "fontfamily": {"type": "string", "hidelabel": true, "hint": "Arial, Geneva"},
                        "opacity": {"type": "string", "widget": "slider"},
                        "cursor": {"type": "list", "options": ["crosshair", "default", "e-resize", "help", "move", "n-resize", "ne-resize", "nw-resize", "pointer", "progress", "s-resize", "se-resize", "sw-resize", "text", "wait", "w-resize"]},
                        "zindex": {"type": "string", "pattern": zindexRegex},
                        "selecteditem": {"type": "object", "bindable": "out-bound", "widget": "string"},
                        "onTransform": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onSelect": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "tabindex": {"type": "string", "value": "0"}
                    },
                    "wm.datanavigator": {
                        "show": {"type": "boolean", "value": true, "bindable": "in-bound"},
                        "dataset": {"type": "array, object", "bindable": "in-bound", "widget": "string"},
                        "showrecordcount": {"type": "boolean", "value": false},
                        "result": {"type": "object", "bindable": "out-bound", "widget": "string", "show": "false"},
                        "onSetrecord": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "tabindex": {"type": "string", "value": "0"},
                        "class": {"type": "string", "pattern": classRegex, "widget": "list-picker", "options": ["pagination-sm", "pagination-lg"]}
                    },
                    "wm.login": {
                        "show": {"type": "boolean", "value": true, "bindable": "in-bound"},
                        "errormessage": {"type": "string"},
                        "onSubmit": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"}
                    },
                    "wm.pagecontainer": {
                        "content": {"type": "list", "options": [], "widget": "pages-list", value: "", "bindable": "in-bound"}
                    },
                    "wm.video": {
                        "mp4format": {"type": "string", "value": "", "bindable": "in-out-bound"},
                        "oggformat": {"type": "string", "value": "", "bindable": "in-out-bound"},
                        "webmformat": {"type": "string", "value": "", "bindable": "in-out-bound"},
                        "subtitlelang": {"type": "string", "value": "en", "bindable": "in-out-bound"},
                        "subtitlesource": {"type": "string", "value": "", "bindable": "in-out-bound"},
                        "videoposter": {"type": "string", "value": "resources/images/imagelists/default-image.png", "bindable": "in-out-bound"},
                        "controls":  {"type": "boolean"},
                        "videosupportmessage":  {"type": "string", "value": "Your browser does not support the video tag."},
                        "autoplay": {"type": "boolean"},
                        "loop": {"type": "boolean"},
                        "muted": {"type": "boolean"},
                        "videopreload": {"type": "list", "options": ["none", "metadata", "auto"], "value": "none"},
                        "tabindex": {"type": "string", "value": "0"},
                        "showindevice": {"type": "selectall", "options": showInDeviceOptions, "value": "all", "displaytype": 'inline-block'}
                    },
                    "wm.audio": {
                        "mp3format": {"type": "string", "value": "", "bindable": "in-out-bound"},
                        "controls": {"type": "boolean"},
                        "audiosupportmessage": {"type": "string", "value": "Your browser does not support the audio tag."},
                        "autoplay": {"type": "boolean"},
                        "loop": {"type": "boolean"},
                        "muted": {"type": "boolean", "value": false},
                        "audiopreload": {"type": "list", "options": ["none", "metadata", "auto"], "value": "none"},
                        "tabindex": {"type": "string", "value": "0"},
                        "showindevice": {"type": "selectall", "options": showInDeviceOptions, "value": "all", "displaytype": 'inline-block'}
                    },
                    "wm.progress": {
                        "minvalue": {"type": "number", "value": 0, "bindable": "in-bound"},
                        "maxvalue": {"type": "number", "value": 100, "bindable": "in-bound"},
                        "datavalue": {"type": "number, string, array", "value": 30, "bindable": "in-out-bound", "widget": "string"},
                        "dataset": {"type": "array, object", "bindable": "in-bound", "widget": "string"},
                        "pollinterval": {"type": "number"},
                        "displayformat": {"type": "list", "options": ["percentage", "absolute"], "value": "percentage"},
                        "type": {"type": "list", "options": ["default", "default-striped", "success", "success-striped", "info", "info-striped", "warning", "warning-striped", "danger", "danger-striped"], "value": "default"},

                        "width": {"type": "string", "pattern": dimensionRegex},
                        "height": {"type": "string", "pattern": dimensionRegex},
                        "onStart": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onComplete": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},
                        "onBeforeupdate": {"type": "event", "options": widgetEventOptions, "widget": "eventlist"},

                        /* ---- styles ----*/
                        "padding": {"type": "string", "widget": "box"},
                        "paddingunit": {"type": "string", "options": ["%", "em", "px"], "value": "px", "widget": "icons_radio"},
                        "paddingtop": {"type": "string", "pattern": numberRegex},
                        "paddingright": {"type": "string", "pattern": numberRegex},
                        "paddingbottom": {"type": "string", "pattern": numberRegex},
                        "paddingleft": {"type": "string", "pattern": numberRegex},
                        "margin": {"type": "string", "widget": "box"},
                        "marginunit": {"type": "string", "options": ["%", "em", "px"], "value": "px", "widget": "icons_radio"},
                        "margintop": {"type": "string", "pattern": numberRegex},
                        "marginbottom": {"type": "string", "pattern": numberRegex},
                        "marginright": {"type": "string", "pattern": numberRegex},
                        "marginleft": {"type": "string", "pattern": numberRegex},
                        "opacity": {"type": "string", "widget": "slider"},
                        "cursor": {"type": "list", "options": ["crosshair", "default", "e-resize", "help", "move", "n-resize", "ne-resize", "nw-resize", "pointer", "progress", "s-resize", "se-resize", "sw-resize", "text", "wait", "w-resize"]},
                        "zindex": {"type": "string", "pattern": zindexRegex},
                        "tabindex": {"type": "string", "value": "0"}
                    },
                    "wm.template": {
                        "header": {"type": "list", "options": [], "widget": "templates-list", value: "_nocontent"},
                        "topnav": {"type": "list", "options": [], "widget": "templates-list", value: "_nocontent"},
                        "leftnav": {"type": "list", "options": [], "widget": "templates-list", value: "_nocontent"},
                        "rightnav": {"type": "list", "options": [], "widget": "templates-list", value: "_nocontent"},
                        "footer": {"type": "list", "options": [], "widget": "templates-list", value: "_nocontent"}
                    }
                }
            },
            properties,
            propertyGroups;

        if (CONSTANTS.isStudioMode) {
            result.propertyGroups = [
                {"name": "properties", "parent": "", "show": true, "feature": "project.editor.design.basic"},
                {"name": "styles", "parent": "", "show": true, "feature": "project.editor.design.style"},
                {"name": "events", "parent": "", "show": true, "feature": "project.editor.design.events"},
                {"name": "mobile", "parent": "", "show": true, "feature": "project.editor.design.mobile"},
                {"name": "security", "parent": "", "show": true, "feature": "project.editor.design.security"},
                {"properties": ["widget", "caption", "gridcaption", "title", "displayname", "heading", "name", "debugurl", "type", "inputtype", "accept", "filetype", "extensions", "placeholder", "currency",  "hint", "tabindex", "target",  "description", "message", "oktext", "canceltext", "servicevariabletotrack", "valuetype", "alerttype", "iframesrc", "insert", "dropposition", "spacing", "advancedsettings"], "parent": "properties"},
                {"name": "layout", "properties": ["width", "height", "treeicons", "menulayout", "menuposition", "levels", "pictureaspect", "imgsrc", "shape", "layoutkind", "columns", "layout", "navtype", "stacked", "justified", "formlayout", "itemsperrow", "showheader", "header", "topnav", "leftnav", "rightnav", "footer", "offset", "addrow", "addcolumn", "popoverwidth", "popoverheight", "tabsposition", "addchild", "gridsearch", "searchlabel"], "parent": "properties"},
                {"name": "image", "properties": ["image", "imagewidth", "imageheight"], "parent": "properties"},
                {"name": "video", "properties": ["videoposter", "mp4format", "oggformat", "webmformat", "videopreload", "videosupportmessage", "subtitlesource", "subtitlelang"], "parent": "properties"},
                {"name": "audio", "properties": ["mp3format", "audiopreload", "audiosupportmessage"], "parent": "properties"},
                {"name": "content", "properties": ["contentsource", "content", "inlinecontent", "url"], "parent": "properties"},
                {"name": "display", "properties": ["picturesource", "modal", "vertical"], "parent": "properties"},
                {"name": "values", "properties": [ "scopedatavalue", "datavalue", "defaultvalue", "minvalue", "maxvalue", "displayformat", "updateon", "updatedelay", "formdata", "selectedvalue", "selectedvalues", "discretevalues", "integervalues", "minimum", "maximum", "step", "defaultcolor", "checkedvalue", "uncheckedvalue"], "parent": "properties"},
                {"name": "valuedisplay", "properties": ["datepattern", "timepattern", "hourstep", "minutestep", "limit"], "parent": "properties"},
                {"name": "output", "properties": ["outputformat"], "parent": "properties"},
                {"name": "dataset", "properties": ["service", "operation", "scopedataset", "dataset", "options",  "hyperlink", "formfield", "method", "action", "enctype", "searchkey", "displaylabel", "displayimagesrc", "usekeys", "actions",  "datafield", "itemlabel", "itemicon", "itemlink", "itemchildren", "displayfield", "displayexpression", "groupby", "aggregation", "aggregationcolumn", "orderby", "orderbycolumn", "nodelabel", "nodeicon", "nodechildren",  "badgevalue",  "badgetype", "thumbnailurl", "mediaurl"], "parent": "properties"},
                {"name": "xaxis", "properties": ["xaxisdatakey", "xaxislabel", "xunits", "xnumberformat", "xdigits", "xdateformat", "xaxislabeldistance"], "parent": "properties"},
                {"name": "yaxis", "properties": ["yaxisdatakey", "yaxislabel", "yunits", "ynumberformat", "ydigits", "ydateformat", "yaxislabeldistance"], "parent": "properties"},
                {"name": "zaxis", "properties": ["bubblesize"], "parent": "properties"},
                {"name": "validation", "properties": ["required", "regexp", "mindate", "maxdate", "excludedays", "excludedates", "novalidate", "maxchars"], "parent": "properties"},
                {"name": "help", "properties": ["helptext"], "parent": "properties"},
                {"name": "behavior", "properties": ["defaultview", "defaultmode", "navigation", "pollinterval", "radiogroup", "viewgroup", "showweeks", "autofocus", "readonly", "ignoreparentreadonly", "readonlygrid", "scrolldelay", "scrollamount", "direction",
                    "multiple", "enablereorder", "fileuploadmessage", "mode", "show", "hideclose", "calendartype", "controls", "view", "disabled", "pagesize", "dynamicslider", "selectionclick", "closeothers", "collapsible", "enablefullscreen",
                    "lock", "freeze", "autoscroll", "closable", "expanded",  "destroyable", "showDirtyFlag", "link", "linktarget",
                    "uploadpath", "contenttype", "origin", "destination", "maxfilesize", "isdefaulttab", "isdefaultpane", "autocomplete", "showpreview", "tooltips", "showlegend", "legendposition", "legendtype", "captions", "showxaxis", "showyaxis", "xdomain", "ydomain", "showvalues",
                    "showlabels", "showcontrols", "useinteractiveguideline", "staggerlabels", "highlightpoints", "linethickness", "reducexticks", "barspacing", "labeltype", "autoplay", "loop", "muted", "donutratio", "showlabelsoutside",
                    "showxdistance", "showydistance", "xpadding", "ypadding", "popoverplacement", "popoverarrow", "popoverautoclose", "transition", "animation", "animationinterval", "leftnavpaneliconclass", "backbutton", "backbuttoniconclass", "backbuttonlabel", "searchbutton",
                    "morebuttoniconclass", "morebuttonlabel", "capturetype", "loadmode", "loaddelay", "selectionlimit", "shortcutkey", "showcaptions", "multiselect", "radioselect", "enablesort", "gridfirstrowselect", "selectfirstitem", "enableemptyfilter"], "parent": "properties"},
                {"name": "searchproperties", "properties": ["searchbuttoniconclass", "searchbuttonlabel", "searchplaceholder"], "parent": "properties"},
                {"name": "datagrid", "properties": ["showrowindex"], "parent": "properties"},
                {"name": "caption", "properties": ["captionalign", "captionposition", "captionsize", "mineditorwidth"], "parent": "properties"},
                {"name": "graphics", "properties": ["imagelist", "imageindex", "paneicon", "iconclass", "iconsize", "iconurl", "iconwidth", "iconheight", "iconmargin", "iconposition"], "parent": "properties"},
                {"name": "format", "properties": [ "showtooltip", "horizontalalign", "verticalalign", "columnwidth", "taborder"], "parent": "properties"},
                {"name": "selection", "properties": ["selectionmode"], "parent": "properties"},
                {"name": "operations", "properties": ["insertrow", "deleterow", "updaterow", "submitbutton", "resetbutton"], "parent": "properties"},
                {"name": "navigation", "properties": ["shownavigation", "showrecordcount"], "parent": "properties"},
                {"name": "message", "properties": ["messagelayout", "errormessage", "insertmessage", "updatemessage", "confirmdelete", "deletemessage", "nodatamessage", "loadingdatamsg", "postmessage"], "parent": "properties"},
                {"properties": [ "class", "menuclass", "listclass", "itemclass", "gridclass",  "theme", "customcolors"], "parent": "styles"},
                {"name": "textstyle", "properties": [ "fontsize", "fontunit", "fontfamily", "color", "fontweight", "fontstyle", "textdecoration", "textalign", "whitespace"], "parent": "styles"},
                {"name": "backgroundstyle", "properties": ["backgroundcolor", "backgroundimage", "backgroundrepeat", "backgroundposition", "backgroundsize", "backgroundattachment"], "parent": "styles"},
                {"name": "border", "properties": ["bordercolor", "borderstyle", "border", "borderunit"], "parent": "styles"},
                {"name": "displaystyle", "properties": ["iconcolor", "padding", "paddingunit", "margin", "marginunit", "opacity", "overflow", "cursor", "zindex", "visibility", "display"], "parent": "styles"},
                {"name": "prefablifecycleevents", "properties": ["onLoad", "onDestroy"], "parent": "events"},
                {"name": "event", "properties": ["onChange",  "onFocus", "onBlur"], "parent": "events"},
                {"name": "mouseevents", "properties": ["onClick", "onDblclick", "onMousedown", "onMouseup", "onMouseover", "onMouseout", "onMousemove", "onMouseenter", "onMouseleave"], "parent": "events", "platforms": [PLATFORM_TYPE.WEB, PLATFORM_TYPE.DEFAULT]},
                {"name": "touchevents", "properties": ["onTap", "onDoubletap", "onSwipeup", "onSwipedown", "onSwipeleft", "onSwiperight", "onPinchin", "onPinchout"], "parent": "events"},
                {"name": "keyboardevents", "properties": ["onKeydown", "onKeypress", "onKeyup", "onEnterkeypress"], "parent": "events"},
                {"name": "callbackevents", "properties": ["onReady", "onStart", "onComplete", "onBeforeupdate", "onShow", "onHide", "onSuccess", "onError", "onOk", "onSubmit", "onCancel", "onClose", "onOpened", "onExpand", "onCollapse", "onSelect", "onDeselect", "onViewrender",
                    "onProgress", "onTransform", "onAbort", "onSort", "onGridbuttonclick", "onHeaderclick", "onRowclick", "onColumnselect", "onColumndeselect", "onRowdeleted", "onBeforerowinsert", "onRowinsert", "onResult", "onBeforeservicecall", "onSetrecord", "onActionsclick",
                    "onBeforeSegmentChange", "onSegmentChange", "onSearch", "onBackbtnclick", "onEventdrop", "onEventresize", "onEventclick", "onEventrender", "onReorder", "onSelectionlimitexceed", "onFullscreen", "onExitfullscreen"], "parent": "events"},
                {"name": "security", "properties": ["accessroles"], "parent": "security"},
                {"name": "devicesize", "properties": ["showindevice"], "parent": "mobile"},
                {"name": "imageproperties", "properties": ["imagetargetwidth", "imagetargetheight", "imagequality", "imageencodingtype", "correctorientation", "sourcetype", "savetogallery", "allowedit"], "parent": "properties"}
            ];
        }
        properties = result.properties;
        propertyGroups = result.propertyGroups;

        /**
         * @ngdoc function
         * @name wm.widgets.$PropertiesFactory#getPropertiesOf
         * @methodOf wm.widgets.$PropertiesFactory
         * @function
         *
         * @description
         * This method returns a widget's properties.
         * If parents array is provided, injects the properties of the parents into widget,
         * else returns only the properties of the widget.
         * @param {String} widget Name of the widget for which the properties are to be returned
         * @param {Array} parents Name of the widgets, the given widget inherits properties from.
         * @returns {Object} widget with its properties.
         */

        /*
         If parents array is provided, inject the properties of from the parents into widget and return,
         else return only the properties of the widget.
         */
        function getPropertiesOf(widget, parents) {
            var widgetProps, parentsArr;

            if (!parents) {
                /* This widget doesn't inherit from other widgets. Fetch the properties of only this widget */
                widgetProps = Utils.getClonedObject(properties[widget]);
            } else {
                parentsArr = WM.isArray(parents) ? parents : [parents];
                parentsArr.push(widget);
                widgetProps = {};

                /* construct the properties object by inheriting from parents*/
                parentsArr.forEach(function (parent) {
                    if (!WM.isObject(properties[parent])) {
                        return;
                    }
                    _.keys(properties[parent])
                        .forEach(function (propName) {
                            var propObj = properties[parent][propName];
                            if (!widgetProps[propName]) {
                                widgetProps[propName] = {};
                            }
                            Object.keys(propObj).forEach(function (key) {
                                widgetProps[propName][key] = propObj[key];
                            });
                        });
                });
            }

            /* Inject show and disabled fields into each property object */
            if (CONSTANTS.isStudioMode) {
                _.keys(widgetProps)
                    .forEach(function (key) {
                        var property = widgetProps[key];
                        if (!property.hasOwnProperty('show')) {
                            property.show = true;
                        }
                        property.disabled = property.disabled || false;
                    });
            } else {
                _.keys(widgetProps).forEach(function (propName) {
                    var propDetails = widgetProps[propName];
                    widgetProps[propName] = _.pick(propDetails, ['type', 'value', 'bindable', 'displaytype']);
                });
            }

            return widgetProps;
        }

        function getPropertyGroups() {
            return propertyGroups;
        }

        function getPrimaryPropertyGroups() {
            var primaryPropertyGroups = [];
            propertyGroups.forEach(function (propertyGroup) {
                /*Check for groups that do not have parents to get primary groups.*/
                if (!propertyGroup.parent) {
                    primaryPropertyGroups.push(propertyGroup);
                }
            });
            return primaryPropertyGroups;
        }

        function getGroupProperties(group) {
            var groupProperties = [];
            propertyGroups.forEach(function (propertyGroup) {
                /*Check for the property groups that have the specified group as the parent.*/
                if (propertyGroup.parent === group) {
                    groupProperties = groupProperties.concat(propertyGroup.properties);
                }
            });
            return groupProperties;
        }

        function getPropertyGroup(name) {
            return _.find(propertyGroups, function (group) { return group.name === name; });
        }

        function setRoles(pRoles) {
            /* reset the existing roles array (keeping the actual reference to the roles array)*/
            roles.length = 0;

            /* push the provided roles into the existing roles */
            if (WM.isArray(pRoles)) {
                pRoles.forEach(function (pRole) {
                    roles.push(pRole);
                });
            }
        }

        /* function to return the access-roles */
        function getRoles() {
            /* return the roles array */
            return roles || [];
        }

        return {
            getPropertiesOf          : getPropertiesOf,
            getPropertyGroups        : getPropertyGroups,
            getPrimaryPropertyGroups : getPrimaryPropertyGroups,
            getGroupProperties       : getGroupProperties,
            getPropertyGroup         : getPropertyGroup,
            getRoles                 : getRoles,
            setRoles                 : setRoles
        };
    }])

    .directive('ngController', function ($rootScope, CONSTANTS) {
        'use strict';

        if (CONSTANTS.isRunMode) {
            $rootScope.Widgets = {};
        }

        return {
            'restrict': 'A',
            'compile': function () {
                return {
                    'pre': function (scope) {
                        scope.ctrlScope = scope;
                    }
                };
            }
        };
    })

    /*directive to handle on-change event for file input */
    .directive('onFileChange', function () {
        'use strict';
        return {
            link: function (scope, element, attrs) {
                element[0].onchange = function () {
                    scope[attrs.onFileChange](element[0]);
                };
            }
        };
    })

    /**
     * @ngdoc directive
     * @name wm.widgets.directive:wmtransclude
     * @restrict A
     * @element ANY
     *
     * @description
     * When this attribute directive is applied on an element, the elements transcluded content is processed and appended to the element.
     */
    .directive('wmtransclude', ['CONSTANTS', '$timeout', function (CONSTANTS, $timeout) {
        "use strict";

        return {
            "restrict": "A",
            "link": function (scope, element, attrs, nullCtrl, transcludeFn) {

                /*
                 * add data-droptarget-for attribute on the element.
                 * this attribute is useful in studio. it is used to find out the droptarget on an element.
                 */
                if (scope.widgetid) {
                    element.attr("data-droptarget-for", scope.widgettype);
                }

                var eleScope = element.scope(),
                    onTranscludeFn = scope.__onTransclude || WM.noop;

                if (eleScope.hasOwnProperty('$$isolateBindings') && !eleScope.__compileWithIScope) {
                    eleScope = eleScope.$parent;
                }
                scope.__load = WM.noop;
                if (CONSTANTS.isRunMode && scope.loadmode === 'after-select') {
                    scope.__load = function () {
                        transcludeFn(eleScope, function (clone) {
                            element.append(clone);
                            scope.__load = WM.noop;
                            $timeout(onTranscludeFn, undefined, false);
                        });
                    };
                } else if (CONSTANTS.isRunMode &&  scope.loadmode === 'after-delay') {
                    $timeout(function () {
                        transcludeFn(eleScope, function (clone) {
                            element.append(clone);
                            $timeout(onTranscludeFn, undefined, false);
                        });
                    }, scope.loaddelay);
                } else {
                    transcludeFn(eleScope, function (clone) {
                        element.append(clone);
                        onTranscludeFn();
                    });
                }
            }
        };
    }])
    /**
     * @ngdoc directive
     * @name wm.widgets.directive:roles
     * @restrict A
     * @element ANY
     * @requires CONSTANTS
     * @requires $rootScope
     * @requires $compile
     * @description
     * This directive is for the widgets having 'roles' attribute in their raw markup.
     * It comes into action when security is enabled in the application being designed through studio.
     * It matches the roles associated with the widget with the roles of the user currently logged in.
     * If match is satisfied, the widget is properly compiled and displayed in the UI
     * Else the element is cleared from the DOM
     */
    .directive('accessroles', function (CONSTANTS, $rootScope, $compile) {
        "use strict";
        var directive = {};

        function matchRoles(widgetRoles, userRoles) {
            return widgetRoles.some(function (item) {
                return _.includes(userRoles, item);
            });
        }

        /*Decides whether the current logged in user has access to widget or not*/
        function hasAccessToWidget(widgetRoles, userRoles) {
            /* access the widget when 'Everyone' is chosen */
            if (_.includes(widgetRoles, 'Everyone')) {
                return true;
            }

            /* access the widget when 'Anonymous' is chosen and user is not authenticated */
            if (_.includes(widgetRoles, 'Anonymous') && !$rootScope.isUserAuthenticated) {
                return true;
            }

            /* access the widget when 'Only Authenticated Users' is chosen and user is authenticated */
            if (_.includes(widgetRoles, 'Authenticated') && $rootScope.isUserAuthenticated) {
                return true;
            }

            /* access the widget when widget role and logged in user role matches */
            /* TODO(Vineela): to remove isUserAuthenticated check and clean userRoles from $rs on logout */
            return $rootScope.isUserAuthenticated && matchRoles(widgetRoles, userRoles);
        }

        /* the directive is required only in RUN mode and when security is enabled */
        if (CONSTANTS.isRunMode && $rootScope.isSecurityEnabled) {
            directive = {
                "restrict": "A",
                "priority": 10000,
                "terminal": true,
                "link": {
                    "pre": function (scope, element, attrs) {
                        var userRoles = $rootScope.userRoles || [],
                            widgetRoles = attrs.accessroles ? attrs.accessroles.split(",") : [],
                            clonedElement;

                        if (hasAccessToWidget(widgetRoles, userRoles)) {
                            clonedElement = element.clone();
                            clonedElement.removeAttr("accessroles");
                            element.replaceWith(clonedElement);
                            $compile(clonedElement)(scope);
                        } else {
                            element.remove();
                        }
                    }
                }
            };
        }

        return directive;
    })

    /**
     * @ngdoc service
     * @name wm.widgets.$WidgetUtilService
     * @description
     * The `WidgetUtilService` provides utility methods for the widgets
     */
    .service('WidgetUtilService', ['$parse', '$rootScope', 'CONSTANTS', 'Utils', '$templateCache',
        function ($parse, $rootScope, CONSTANTS, Utils, $templateCache) {
            "use strict";

            var deviceSizeArray = {
                "all": {
                    "class": '',
                    "classToRemove": ["visible-xs-", "visible-sm-", "visible-md-", "visible-lg-"]
                },
                "xs": {
                    "class": "visible-xs-"
                },
                "sm": {
                    "class": "visible-sm-"
                },
                "md": {
                    "class": "visible-md-"
                },
                "lg": {
                    "class": "visible-lg-"
                }
            },
                EventsMap = {
                    'onClick':          {'name': 'data-ng-click',       'value': 'onClick({$event: $event, $scope: this})'},
                    'onDblclick':       {'name': 'data-ng-dblclick',    'value': 'onDblclick({$event: $event, $scope: this})'},
                    'onMouseenter':     {'name': 'data-ng-mouseenter',  'value': 'onMouseenter({$event: $event, $scope: this})'},
                    'onMouseleave':     {'name': 'data-ng-mouseleave',  'value': 'onMouseleave({$event: $event, $scope: this})'},
                    'onMouseover':      {'name': 'data-ng-mouseover',   'value': 'onMouseover({$event: $event, $scope: this})'},
                    'onMouseout':       {'name': 'data-ng-mouseout',    'value': 'onMouseout({$event: $event, $scope: this})'},

                    'onFocus':          {'name': 'data-ng-focus',       'value': 'onFocus({$event: $event, $scope: this})'},
                    'onBlur':           {'name': 'data-ng-blur',        'value': 'onBlur({$event: $event, $scope: this})'},

                    'onKeypress':       {'name': 'data-ng-keypress',    'value': 'onKeypress({$event: $event, $scope: this})'},
                    'onKeydown':        {'name': 'data-ng-keydown',     'value': 'onKeydown({$event: $event, $scope: this})'},
                    'onKeyup':          {'name': 'data-ng-keyup',       'value': 'onKeyup({$event: $event, $scope: this})'},

                    'onSwipeup':        {'name': 'hm-swipe-up',         'value': 'onSwipeup({$event: $event, $scope: this})'},
                    'onSwipedown':      {'name': 'hm-swipe-down',       'value': 'onSwipedown({$event: $event, $scope: this})'},
                    'onSwipeleft':      {'name': 'hm-swipe-left',       'value': 'onSwipeleft({$event: $event, $scope: this})'},
                    'onSwiperight':     {'name': 'hm-swipe-right',      'value': 'onSwiperight({$event: $event, $scope: this})'},
                    'onPinchin':        {'name': 'hm-pinch-in',         'value': 'onPinchin({$event: $event, $scope: this})'},
                    'onPinchout':       {'name': 'hm-pinch-out',        'value': 'onPinchout({$event: $event, $scope: this})'},
                    'onTap':            {'name': 'data-ng-click',       'value': 'onTap({$event: $event, $scope: this})'},
                    'onDoubletap':      {'name': 'data-ng-dblclick',    'value': 'onDoubletap({$event: $event, $scope: this})'}

                },
                triggerFn,
                attrsToBeRemoved;

            attrsToBeRemoved =
                ' data-ng-style data-ng-change data-ng-click data-ng-dblclick data-ng-mouseout data-ng-mouseover data-ng-blur data-ng-focus' +
                ' data-ng-show data-ng-hide data-ng-readonly data-ng-disabled data-ng-required data-ng-attr-placeholder ng-attr-name' +
                ' on-change on-focus on-blur on-click on-dblclick on-mouseover on-mouseout on-rowclick on-columnselect on-columndeselect ' +
                ' backgroundattachment backgroundcolor backgroundgradient backgroundposition backgroundrepeat backgroundsize bordercolor borderradius ' +
                ' borderstyle color cursor display fontfamily fontstyle fontvariant fontweight horizontalalign lineheight ' +
                ' opacity overflow paddingbottom paddingleft paddingright paddingtop picturesource textalign textdecoration verticalalign visibility ' +
                ' whitespace wordbreak zindex bordertop borderright borderbottom borderleft borderunit paddingtop paddingright paddingbottom paddingleft' +
                ' paddingunit margintop marginright marginbottom marginleft marginunit fontsize fontunit show hint caption animation backgroundimage iconposition iconclass';

            function cleanupMarkup(element) {
                element.removeAttr(attrsToBeRemoved);
            }

            function updatePropertyPanelOptions(dataset, propertiesMap, scope) {
                var variableKeys = [],
                    wp = scope.widgetProps;

                wp.itemlabel.options = wp.itemicon.options = wp.itemlink.options = [];
                if (wp.itemchildren) {
                    wp.itemchildren.options = [];
                }

                /* re-initialize the property values */
                if (scope.newcolumns) {
                    scope.newcolumns = false;
                    scope.itemlabel = scope.itemicon = scope.itemlink = scope.itemchildren = '';
                    $rootScope.$emit('set-markup-attr', scope.widgetid, {'itemlabel': scope.itemlabel, 'itemicon': scope.itemicon, 'itemlink': scope.itemlink, 'itemchildren': scope.itemchildren});
                }

                if (WM.isString(dataset)) {
                    return;
                }

                /* on binding of data*/
                if (WM.isArray(dataset)) {
                    dataset = dataset[0] || dataset;
                    variableKeys = extractDataSetFields(dataset, propertiesMap) || [];
                }
                /*removing keys of null and object type*/
                variableKeys = variableKeys.filter(function (variableKey) {
                    return (dataset[variableKey] !== null) && !WM.isObject(dataset[variableKey]);
                });
                wp.itemlabel.options = wp.itemicon.options = wp.itemlink.options = [''].concat(variableKeys);
                if (wp.itemchildren) {
                    wp.itemchildren.options = [''].concat(variableKeys);
                }
            }

            function onScopeValueChangeProxy(scope, element, attrs, key, newVal, oldVal) {

                if (key === "placeholder" || key === "type") {
                    if (element.is('input') || element.is('textarea')) {
                        attrs.$set(key, newVal);
                    } else {
                        element.find('input').attr(key, newVal);
                    }
                } else if (key === "backgroundimage") {
                    scope.picturesource = Utils.getBackGroundImageUrl(newVal);
                } else if (key === "backgroundcolor") {
                    /* setting background image as none when background color is set. This is done because background
                    gradients are set as background image and have precedence over background color.*/
                    if (!scope.picturesource) {
                        scope.picturesource = 'none';
                    }
                } else if (key === "class") {
                    element.removeClass(oldVal).addClass(newVal);
                } else if (key === "name") {
                    attrs.$set("name", newVal);
                } else if (key === "showindevice") {
                    /*Apply the corresponding classes only in runMode*/
                    if (CONSTANTS.isRunMode) {
                        var newValues = newVal ? newVal.split(',') : newVal;
                        if (WM.element.inArray("all", newValues) === 0) {
                            WM.forEach(deviceSizeArray.all.classToRemove, function (device) {
                                element.removeClass(device + scope.widgetProps.showindevice.displaytype || 'block');
                            });
                        } else {
                            /*If others are selected, add classes accordingly */
                            WM.forEach(newValues, function (value) {
                                element.addClass(deviceSizeArray[value].class + (scope.widgetProps.showindevice.displaytype || 'block'));
                            });
                        }
                    }
                } else if (key === "animation") {
                    /*add the animated class only in the run mode since it will break the ui in design mode*/
                    if (CONSTANTS.isRunMode) {
                        element.addClass("animated " + newVal);
                    }
                }

                triggerFn = Utils.triggerFn;

                scope.propertyManager
                    .get(scope.propertyManager.ACTIONS.CHANGE)
                    .forEach(function (handler) {
                        var notifyFor = handler.notifyFor;
                        if ((notifyFor && notifyFor[key]) || !notifyFor) {
                            triggerFn(handler, key, newVal, oldVal);
                        }
                    });
            }

            /*
             This method will handle the initialization stuff when called from widget's (directive) post method.
             1. assign a name to a widget
             2. cleanupMarkup -- removes few attributes from the markup
             3. triggers onScopeValueChange function for the initial state of the widget(default values and attributes specified on the element).
             */
            function postWidgetCreate(scope, element, attrs) {
                cleanupMarkup(element);

                if (!scope || !scope._initState) {
                    return;
                }

                function triggerInitValueChange() {
                    Object.keys(scope._initState)
                        .forEach(function (key) {
                            var value = scope[key];
                            if (WM.isDefined(value)) {
                                onScopeValueChangeProxy(scope, element, attrs, key, value);
                            }
                        });
                    scope._isInitialized = true;
                    if (!scope.__onTransclude) {
                        Utils.triggerFn(scope.onReady, scope, element, attrs);
                    }
                }

                triggerInitValueChange();
            }

            /* find the scope of the controller using the scope passed */
            function findCtrlScope(scope) {
                /*for unit test cases, scope is rootScope, so in that case, we return*/
                if (scope.ctrlScope || scope.$id === $rootScope.$id) {
                    /* able to find ctrlScope from scope */
                    return;
                }

                var tScope = scope;
                do {
                    tScope = tScope.$parent;
                    if (tScope.ctrlScope) { /* found the ctrlScope */
                        scope.ctrlScope = tScope.ctrlScope;
                        /* save a reference to ctrlScope in scope */
                        break;
                    }
                } while (tScope.$id !== $rootScope.$id);
                /* loop exit condition */
            }

            /* when the model is provided, this function will create a two way binding between model(controller's scope) and view(input element) */
            function injectModelUpdater(element, model) {

                var isolateScope = element.isolateScope(), /* reference to the isolateScope of the element */
                    ctrlScope = element.scope(), /* reference to the scope which inherits from the controller */
                    _model,
                    dotIdx,
                    braceIdx,
                    idx,
                    name;


                if (model) { /* if the model is provided as an attribute on element parse it */
                    _model = $parse(model);
                    /* using _model we will be able to update the model in the controller */
                }

                /* not able to access ctrlScope from tScope(element.scope()). let me try to find it. */
                if (!ctrlScope.ctrlScope) {
                    findCtrlScope(ctrlScope);
                }

                if (!ctrlScope.ctrlScope) {
                    return;
                    /* not able to find the ctrlScope */
                }

                if (model) {
                    dotIdx = model.indexOf(".");
                    braceIdx = model.indexOf("[");
                    if (dotIdx === -1 && braceIdx === -1) {
                        /* model is provided with a variable name eg. model = x, we need to update in the controller directly */
                        ctrlScope = ctrlScope.ctrlScope;
                        /* refer to the scope of controller */
                    } else {
                        /* model might be provided as obj.variable name or obj[key] */
                        if (braceIdx === -1) {
                            idx = dotIdx;
                            /* dot is present in the model value*/
                        } else if (dotIdx === -1) {
                            idx = braceIdx;
                            /* brace is present in the model value*/
                        } else {
                            /* both dot and brace are present i.e a.b[x] */
                            idx = Math.min(dotIdx, braceIdx);
                            /* extract the object name from the model */
                        }
                        if (idx > 0) {
                            /* if the object specified is not defined in the controller's scope. create a new object with the extracted name */
                            name = model.substring(0, idx);
                            /* name of the object to be created */
                            if (!WM.isDefined(ctrlScope.ctrlScope[name])) { /* object is not defined in controller's scope */

                                /*
                                 * we will always define a Object ie. {} if the controller's scope doesn't have it.
                                 * if other than Object is expected i.e, Array, user must initialize it in controller's scope
                                 */
                                ctrlScope.ctrlScope[name] = {};
                                /* define the object in controller's scope */
                            }

                            if (WM.isUndefined(ctrlScope[name])) { /* not able to access object from ctrlScope */
                                Object.defineProperty(ctrlScope, name, {
                                    get: function () {
                                        return ctrlScope.ctrlScope[name];
                                        /* whenever object is accessed from scope, read it from controller's scope and return */
                                    }
                                });
                            }
                        }
                    }
                }

                /* this method will update the view value in the controller's scope */
                function updateModel() {
                    /*if (element.hasClass('app-calendar')) {
                        *//* if model for Calendar or Date widget and model is a valid date, update the model with the primitive value
                         * else make it undefined *//*
                        var formattedDate = new Date(isolateScope._model_);
                        isolateScope._model_ = $filter('date')(formattedDate, isolateScope.datepattern);
                    }*/

                    if (_model && ctrlScope) {
                        /* update the model value in the controller if the controller scope is available */
                        _model.assign(ctrlScope, isolateScope._model_);
                    }
                }

                /* _onChange is a wrapper fn for onChange. */
                isolateScope._onChange = function ($event) {
                    updateModel();
                    /* update the view value in the controller */
                    if ($event && isolateScope.onChange) {
                        isolateScope.onChange({$event: $event, $scope: isolateScope});
                        /* trigger the onChange fn */
                    }
                };

                /* update the view value when the model is updated */
                if (model && ctrlScope) {
                    /* watch the model */

                    isolateScope.$on('$destroy', ctrlScope.$watch(model, function (newVal) {
                        if (isolateScope._model_ === newVal) {
                            return;
                        }

                        /* update the view value if the model is updated */
                        isolateScope._model_ = newVal;

                    }, true));
                }

            }

            /*Function that returns all the internal object keys in the bound dataset*/
            function extractDataSetFields(dataset, propertiesMap, sort) {
                var columns = [],
                    columnDefs,
                    properties;

                if (WM.isString(dataset)) {
                    return;
                }
                /*In case of live variable getting the properties map*/
                if (dataset && propertiesMap) {
                    columns = Utils.fetchPropertiesMapColumns(propertiesMap);
                    properties = [Utils.resetObjectWithEmptyValues(columns)];
                    columns = Object.keys(properties[0]);
                } else {
                    columnDefs = Utils.prepareFieldDefs(dataset, null, false, true);
                    columnDefs.forEach(function (columnDef) {
                        columns.push(columnDef.field);
                    });
                }
                if (sort) {
                    columns = columns.sort();
                }
                return columns;
            }

            function addEventAttributes($template, tAttrs, customEventsMap) {

                if (tAttrs.widgetid) { // widget is inside canvas
                    return;
                }
                var eventsMap = customEventsMap || EventsMap;
                Object.keys(eventsMap).forEach(function (evtName) {
                    var evtDetails = eventsMap[evtName];
                    if (tAttrs[evtName]) {
                        $template.attr(evtDetails.name, evtDetails.value);
                    }
                });

                return $template;
            }

            function getPreparedTemplate(templateId, tElement, tAttrs) {
                var isInsideCanvs = tAttrs.widgetid,
                    template,
                    $template;

                template =  $templateCache.get(templateId);

                if (isInsideCanvs) {
                    return template;
                }

                $template = WM.element(template);
                addEventAttributes($template, tAttrs);

                return $template[0].outerHTML;
            }

            function registerPropertyChangeListener(listener, iScope, notifyFor) {
                listener.notifyFor = notifyFor;
                /* register the property change handler */
                iScope.propertyManager.add(iScope.propertyManager.ACTIONS.CHANGE, listener);
            }

            function getObjValueByKey(obj, strKey) {
                /* check for the key-string */
                if (strKey) {
                    var val;
                    /* convert indexes to properties, so as to work for even 'key1[0].child1'*/
                    strKey.replace(/\[(\w+)\]/g, '.$1').split('.').forEach(function (key) {
                        val = (val && val[key]) || obj[key];
                    });
                    return val;
                }
                return obj;
            }
            /*
            * Function evaluates passed key(expression/bound expression) and returns corresponding value of dataObj
            * @params: {dataObj} object from which values are extracted
            * @params: {scope} scope of the function called. Used for eval
            * @params: {propertyObj} Ex :{fieldName : "displayfield", expressionName : "displayexpression" }
            * @params: {value} previously computed key passed as an extra argument
            * Priority : boundExpressionName >> expressionName >> value >> fieldName
            * */
            function getEvaluatedData(scope, dataObj, propertyObj, value) {
                var boundExpressionName = propertyObj ? ("bind" + propertyObj.expressionName) : undefined,
                    expressionValue;
                /* if key is bound expression*/
                if (scope[boundExpressionName]) {
                    /*remove 'bind:' prefix from the boundExpressionName*/
                    expressionValue = scope[boundExpressionName].replace("bind:", "");
                    /* parse the expressionValue for replacing all the expressions with values in the object */
                    return scope.$eval(expressionValue.replace(/\$\[(\w)+(\w+(\[\$i\])?\.+\w+)*\]/g, function (expr) {
                        var val;
                        /*remove '$[' prefix & ']' suffix from each expression pattern */
                        expr = expr.replace(/[\$\[\]]/gi, '');
                        /*split to get all keys in the expr*/
                        expr.split('.').forEach(function (key) {
                            /* get the value for the 'key' from the dataObj first & then value itself,
                             * as it will be the object to scan
                             * */
                            val = (val && val[key]) || dataObj[key];
                            /*if val is a string, append single quotes to it */
                            if (WM.isString(val)) {
                                val = "'" + val + "'";
                            }
                        });
                        /* return val to the original string*/
                        return val;
                    }));
                }
                /*If key is expression*/
                if (propertyObj && scope[propertyObj.expressionName]) {
                    return Utils.getEvaluatedExprValue(dataObj, scope[propertyObj.expressionName], scope);
                }
                /*If value is passed*/
                if (value) {
                    return getObjValueByKey(dataObj, value);
                }
                /*If fieldName is defined*/
                if (propertyObj && scope[propertyObj.fieldName]) {
                    return getObjValueByKey(dataObj, scope[propertyObj.fieldName]);
                }
            }

            return {

                /**
                 * @ngdoc function
                 * @name wm.widgets.$WidgetUtilService#postWidgetCreate
                 * @methodOf wm.widgets.$WidgetUtilService
                 * @function
                 *
                 * @description
                 * This method will handle the initialization stuff when called from widget's (directive) post method.
                 * 1. assign a name to a widget
                 * 2. cleanupMarkup -- removes few attributes from the markup
                 */
                postWidgetCreate: postWidgetCreate,

                /**
                 * @ngdoc function
                 * @name wm.widgets.$WidgetUtilService#injectModelUpdater
                 * @methodOf wm.widgets.$WidgetUtilService
                 * @function
                 *
                 * @description
                 * when the model is provided, this function will create a two way binding between model(controller's scope) and view(input element)
                 */
                injectModelUpdater: injectModelUpdater,

                onScopeValueChangeProxy: onScopeValueChangeProxy,

                updatePropertyPanelOptions: updatePropertyPanelOptions,

                extractDataSetFields: extractDataSetFields,


                /**
                 * @ngdoc function
                 * @name wm.widgets.$WidgetUtilService#getPreparedTemplate
                 * @methodOf wm.widgets.$WidgetUtilService
                 * @function
                 *
                 * @description
                 * returns the widget template after adding event related attributes
                 */
                getPreparedTemplate: getPreparedTemplate,

                /**
                 * @ngdoc function
                 * @name wm.widgets.$WidgetUtilService#addEventAttributes
                 * @methodOf wm.widgets.$WidgetUtilService
                 * @function
                 *
                 * @description
                 * returns the widget template after adding event related attributes
                 */
                addEventAttributes: addEventAttributes,
                /**
                 * @ngdoc function
                 * @name wm.widgets.$WidgetUtilService#registerPropertyChangeListener
                 * @methodOf wm.widgets.$WidgetUtilService
                 * @function
                 *
                 * @description
                 * registers a property change listener
                 */
                registerPropertyChangeListener: registerPropertyChangeListener,

                /**
                 * @ngdoc function
                 * @name wm.widgets.$WidgetUtilService#getObjValueByKey
                 * @methodOf wm.widgets.$WidgetUtilService
                 * @function
                 *
                 * @description
                 * Returns the value for the provided key in the object
                 */
                getObjValueByKey: getObjValueByKey,

                /**
                 * @ngdoc function
                 * @name wm.widgets.$WidgetUtilService#getDisplayFieldData
                 * @methodOf wm.widgets.$WidgetUtilService
                 * @function
                 *
                 * @description
                 * returns the display field data for select, radioboxset and checkboxset widgets
                 * Based on the bind display expression or display expression or display name,
                 * data is extracted and formatted from the passed option object
                 */
                getEvaluatedData: getEvaluatedData
            };
        }])
    .directive('applyStyles', [
        'WidgetUtilService',

        function (WidgetUtilService) {
            'use strict';

            var notifyFor = {},
                DIMENSION_PROPS,

                propNameCSSKeyMap,
                SHELL_TYPE_IGNORE_LIST,
                CONTAINER_TYPE_IGNORE_LIST,
                SCROLLABLE_CONTAINER_TYPE_IGNORE_LIST;


            propNameCSSKeyMap = {
                'backgroundattachment'  : 'backgroundAttachment',
                'backgroundcolor'       : 'backgroundColor',
                'backgroundgradient'    : 'backgroundGradient',
                'backgroundposition'    : 'backgroundPosition',
                'backgroundrepeat'      : 'backgroundRepeat',
                'backgroundsize'        : 'backgroundSize',
                'bordercolor'           : 'borderColor',
                'borderradius'          : 'borderRadius',
                'borderstyle'           : 'borderStyle',
                'color'                 : 'color',
                'cursor'                : 'cursor',
                'display'               : 'display',
                'fontfamily'            : 'fontFamily',
                'fontstyle'             : 'fontStyle',
                'fontvariant'           : 'fontVariant',
                'fontweight'            : 'fontWeight',
                'height'                : 'height',
                'horizontalalign'       : 'textAlign',
                'lineheight'            : 'lineHeight',
                'opacity'               : 'opacity',
                'overflow'              : 'overflow',
                'picturesource'         : 'backgroundImage',
                'textalign'             : 'textAlign',
                'textdecoration'        : 'textDecoration',
                'verticalalign'         : 'verticalAlign',
                'visibility'            : 'visibility',
                'whitespace'            : 'whiteSpace',
                'width'                 : 'width',
                'wordbreak'             : 'wordbreak',
                'zindex'                : 'zIndex'
            };
            SHELL_TYPE_IGNORE_LIST     = 'height overflow paddingunit paddingtop paddingright paddingbottom paddingleft';
            CONTAINER_TYPE_IGNORE_LIST = 'textalign';
            SCROLLABLE_CONTAINER_TYPE_IGNORE_LIST = 'textalign width';

            _.keys(propNameCSSKeyMap)
                .concat(SHELL_TYPE_IGNORE_LIST.split(' '))
                .concat(CONTAINER_TYPE_IGNORE_LIST.split(' '))
                .forEach(function (propName) {
                    notifyFor[propName] = true;
                });

            DIMENSION_PROPS = _.flatten(_.map(['padding', 'border', 'margin'], function (prop) {
                return [prop + 'top', prop + 'right', prop + 'bottom', prop + 'left', prop + 'unit'];
            }));

            // add dimension related properties to notifyFor
            _.forEach(DIMENSION_PROPS, function (prop) {
                notifyFor[prop] = true;
            });

            // few extra properties which need some calculation/manipulations before applying as CSS.
            notifyFor.fontsize        = true;
            notifyFor.fontunit        = true;
            notifyFor.backgroundimage = true;

            function isDimensionProp(key) {
                return _.includes(DIMENSION_PROPS, key);
            }

            function setDimensionProp($is, cssObj, key) {
                var prefix,
                    suffix,
                    unit;

                prefix = prefix || (_.startsWith(key, 'border') && 'border');
                suffix = prefix ? 'Width' : '';
                prefix = prefix || (_.startsWith(key, 'margin') && 'margin');
                prefix = prefix || (_.startsWith(key, 'padding') && 'padding');

                if (!prefix) {
                    return;
                }

                unit = $is[prefix + 'unit'];

                cssObj[prefix + 'Top' + suffix]    = $is[prefix + 'top']    + unit;
                cssObj[prefix + 'Right' + suffix]  = $is[prefix + 'right']  + unit;
                cssObj[prefix + 'Bottom' + suffix] = $is[prefix + 'bottom'] + unit;
                cssObj[prefix + 'Left' + suffix]   = $is[prefix + 'left']   + unit;
            }

            function applyCSS($is, $el, applyType, key, nv) {

                var obj = {},
                    cssName = propNameCSSKeyMap[key],
                    keys,
                    resetObj;

                // if the type is `shell` and the key is in the SHELL_TYPE_IGNORE_LIST, return
                if (applyType === 'shell' && _.includes(SHELL_TYPE_IGNORE_LIST, key)) {
                    return;
                }

                // if the type is `inner-shell` and the key is NOT in the SHELL_TYPE_IGNORE_LIST, return
                if (applyType === 'inner-shell') {
                    if (!_.includes(SHELL_TYPE_IGNORE_LIST, key)) {
                        return;
                    }
                    if (key === 'height') {
                        obj.overflow = nv ? 'auto' : '';
                    }
                }

                // if the type is `container` and the key is in the CONTAINER_TYPE_IGNORE_LIST, return
                if (applyType === 'container' && _.includes(CONTAINER_TYPE_IGNORE_LIST, key)) {
                    return;
                }
                if (applyType === 'scrollable-container') {
                    if (_.includes(SCROLLABLE_CONTAINER_TYPE_IGNORE_LIST, key)) {
                        return;
                    }

                    if (key === 'height') {
                        obj.overflow = nv ? 'auto' : '';
                    }
                }

                if (isDimensionProp(key)) {
                    setDimensionProp($is, obj, key);
                } else {
                    if (cssName) {
                        obj[cssName] = nv;
                    } else if (key === 'fontsize' || key === 'fontunit') {
                        obj.fontSize = $is.fontsize === '' ? '' : $is.fontsize + $is.fontunit;
                    } else if (key === 'backgroundimage') {
                        obj.backgroundImage = $is.picturesource;
                    }
                }

                keys = _.keys(obj);

                if (keys.length) {
                    //reset obj;
                    resetObj = _.zipObject(keys, _.range(keys.length).map(function () { return ''; }));
                    $el.css(resetObj);
                    $el.css(obj);
                }
            }

            function onCSSPropertyChange($is, $el, attrs, key, nv) {
                applyCSS($is, $el, attrs.applyStyles, key, nv);
            }

            return {
                'link': function ($is, $el, attrs) {
                    WidgetUtilService.registerPropertyChangeListener(onCSSPropertyChange.bind(undefined, $is, $el, attrs), $is, notifyFor);
                }
            };
        }
    ])

    /**
     * @ngdoc service
     * @name wm.widgets.$Widgets
     * @description
     * The `Widgets` provides utility methods for the accessing the scope of the widgets.
     */
    .service('Widgets', ["$rootScope", 'wmToaster', 'CONSTANTS',
        function ($rootScope, wmToaster, CONSTANTS) {
            "use strict";

            var registry = {}, /* widgetId - scope map */
                nameIdMap = {}, /* name - widgetId map */
                returnObj = {};
            /* return value of the Widgets service */

            /* returns the scope of the widget by widgetId */
            function byId(widgetId) {
                return registry[widgetId];
            }

            /* returns the scope of the widget by name */
            function byName(name) {
                return byId(nameIdMap[name]);
            }

            function byType(types) {
                /* if type not provided, return all widgets */
                if (!types) {
                    return registry;
                }

                /* if comma separated types are provided, make it an array*/
                if (typeof types === "string") {
                    /* if form-widgets required */
                    if (types === "form-widgets") {
                        types = ["wm-label",
                            "wm-text",
                            "wm-checkbox",
                            "wm-checkboxset",
                            "wm-radio",
                            "wm-radioset",
                            "wm-textarea",
                            "wm-select",
                            "wm-button",
                            "wm-picture",
                            "wm-anchor",
                            "wm-popover",
                            "wm-date",
                            "wm-calendar",
                            "wm-time",
                            "wm-datetime",
                            "wm-currency",
                            "wm-colorpicker",
                            "wm-slider",
                            "wm-fileupload",
                            "wm-grid",
                            "wm-livefilter",
                            "wm-livelist",
                            "wm-datanavigator",
                            "wm-html",
                            "wm-prefab",
                            "wm-richtexteditor",
                            "wm-search",
                            "wm-menu",
                            "wm-switch",
                            "wm-nav",
                            "wm-tree",
                            "wm-liveform",
                            "wm-rating",
                            "wm-camera",
                            "wm-barcodescanner",
                            "wm-mobile-navbar ",
                            "wm-chart",
                            "wm-view",
                            "wm-form"
                            ];
                    } else if (types === 'page-container-widgets') {
                        types = [
                            'wm-accordionpane',
                            'wm-container',
                            'wm-panel',
                            'wm-tabcontent',
                            'wm-footer',
                            'wm-header',
                            'wm-left-panel',
                            'wm-right-panel',
                            'wm-top-nav'
                        ];
                    } else {
                        types = types.split(",");
                    }
                }

                var collection = {};

                WM.forEach(types, function (type) {
                    type = type.trim();
                    WM.forEach(registry, function (widget) {
                        if (widget.widgettype === type) {
                            collection[widget.name] = widget;
                        }
                    });
                });
                return collection;
            }

            /* checks for the unique constraint of the name, if the given name is not used returns true else false */
            function isValidName(name) {
                var isValid = true, errMsgTitle, errMsgDesc;

                /* isEmpty? */
                if (!name) {
                    isValid = false;
                    errMsgTitle = "MESSAGE_ERROR_INVALID_WIDGETNAME_TITLE";
                    errMsgDesc = "MESSAGE_ERROR_INVALID_WIDGETNAME_DESC";
                } else if (nameIdMap[name]) { /* check for duplicate name */
                    isValid = false;
                    errMsgTitle = "MESSAGE_ERROR_DUPLICATE_WIDGETNAME_TITLE";
                    errMsgDesc = "MESSAGE_ERROR_DUPLICATE_WIDGETNAME_DESC";
                }

                /* name is not valid, show the error message */
                if (!isValid) {
                    wmToaster.show("error", $rootScope.locale[errMsgTitle], $rootScope.locale[errMsgDesc]);
                }

                return isValid;
            }

            /* checks if the widget name already exists */
            function isExists(name) {
                var _isExists = false;
                /* check for the name */
                if (nameIdMap[name]) {
                    _isExists = true;
                }
                return _isExists;
            }

            /* this is a private method to the Widgets service. This function unregisters the widget by its name. So that we can re-use the name */
            function unregister(name) {
                var widgetId = nameIdMap[name];

                delete registry[widgetId];
                /* delete the entry from the registry */
                delete nameIdMap[name];
                /* delete the entry from the nameIdMap */
            }

            /* byId, byName, isValidName methods will be exposed by this service */

            /**
             * @ngdoc function
             * @name wm.widgets.$Widgets#byId
             * @methodOf wm.widgets.$Widgets
             * @function
             *
             * @description
             * returns the scope of the widget by widgetid
             */
            returnObj.byId = byId;

            /**
             * @ngdoc function
             * @name wm.widgets.$Widgets#byName
             * @methodOf wm.widgets.$Widgets
             * @function
             *
             * @description
             * returns the scope of the widget by name
             */
            returnObj.byName = byName;

            /**
             * @ngdoc function
             * @name wm.widgets.$Widgets#isValidName
             * @methodOf wm.widgets.$Widgets
             * @function
             *
             * @description
             * checks for the unique constraint of the name, if the given name is not used returns true else false
             */
            returnObj.isValidName = isValidName;

            /**
             * @ngdoc function
             * @name wm.widgets.$Widgets#isExists
             * @methodOf wm.widgets.$Widgets
             * @function
             *
             * @description
             * checks for the widget with the provided name, if the widget exists return true else false
             */
            returnObj.isExists = isExists;
            /**
             * @ngdoc function
             * @name wm.widgets.$Widgets#byType
             * @methodOf wm.widgets.$Widgets
             * @function
             *
             * @description
             * returns an array of scopes of widgets of specified type(returns all if no type specified)
             */
            returnObj.byType = byType;

            /* listen for the changes in name and update the registry accordingly */
            $rootScope.$on("name-change", function (evt, widgetId, newName, oldName, scope) {

                /* process only canvas widgets in STUDIO mode (assumption: only widgets in canvas will have widgetId) */
                if (CONSTANTS.isStudioMode && !widgetId) {
                    return;
                }

                delete nameIdMap[oldName];
                /* delete the entry with old name */
                delete returnObj[oldName];
                /* delete the name entry from the service */

                /*In run mode we do not have the widgetId hence using the newName*/
                widgetId = widgetId || newName;

                nameIdMap[newName] = widgetId;
                /* update the new name value with the widgetId */

                registry[widgetId] = scope;

                /* define a property with the name on service. with this users will be able to access a widget by its name. e.b, Widgets.test */
                Object.defineProperty(returnObj, newName, {
                    configurable: true,
                    get: function () {
                        return byName(newName);
                    }
                });

                /* unregister the widget when it is deleted or when the scope is destroyed */
                scope.$on("$destroy", function () {
                    unregister(scope.name);
                });
            });

            return returnObj;
        }]);

/*global WM, _*/
/**
 * @ngdoc directive
 * @name wm.widgets.directive:initWidget
 * @restrict A
 * @element ANY
 * @requires $rootScope
 * @requires WidgetUtilService
 * @requires DialogService
 * @requires Utils
 * @requires CONSTANTS
 * @description
 * This directive is for the widgets.
 * It sets the default values and values passed as attributes into the isolateScope of the widget.
 * It triggers the onScopeValueChange function defined on the isolateScope when a scope value changes.
 * It injects the modelUpdater function when has-model attribute is present on the element.
 * It emits invokeService event to the rootScope which can used in run mode to invoke a service
 */

WM.module('wm.widgets.base')
    .directive('initWidget', [
        '$rootScope',
        'WidgetUtilService',
        'DialogService',
        'Utils',
        'CONSTANTS',
        '$parse',
        '$timeout',
        'DataFormatService', /*Do not remove*/
        '$animate',
        '$routeParams',
        'BindingManager',

        function ($rs, WidgetUtilService, DialogService, Utils, CONSTANTS, $parse, $timeout, DataFormatService, $animate, $routeParams, BindingManager) {
            'use strict';

            var booleanAttrs = [
                    'readonly', 'autofocus', 'disabled', 'startchecked', 'multiple',
                    'selected', 'required', 'controls', 'autoplay', 'loop', 'muted'
                ],
                DLG_ACTIONS = {
                    'SHOW': 'show',
                    'HIDE': 'hide'
                },
                EVENT = 'event';

            function isBooleanAttr(key) {
                _.includes(booleanAttrs, key);
            }

            function PropertyManager() {
                var handlers = {
                    'change': []
                };

                this.ACTIONS = {
                    'CHANGE': 'change'
                };

                this.add = function (action, handler) {
                    handlers[action].push(handler);
                };
                this.get = function (action) {
                    return handlers[action];
                };
            }

            function handleDialogShowHideActions($s, dialogName, show) {
                if (show) {
                    // Pass the scope of the controller. if the controller scope is not found, dialog will be compiled with the rootScope.
                    DialogService.showDialog(dialogName, {'scope': $s.ctrlScope || $s});
                } else {
                    DialogService.hideDialog(dialogName);
                }
            }

            function handleAppCustomEvent($s, isAnchor, $evt, customEvtName) {

                var parts;

                /* For anchor elements suppressing the default action to refresh the page */
                if (isAnchor) {
                    $evt.preventDefault();
                }

                parts = customEvtName.split('.');

                if (parts.length === 2) {
                    if (parts[1] === DLG_ACTIONS.SHOW) {
                        handleDialogShowHideActions($s, parts[0], true);
                        return;
                    }
                    if (parts[1] === DLG_ACTIONS.HIDE) {
                        handleDialogShowHideActions($s, parts[0], false);
                        return;
                    }
                }

                /* Emit the event in a timeout, so that any variable watching on current widget is updated with its value */
                $timeout(function () {
                    $rs.$emit('invoke-service', customEvtName, {'scope': $s});
                });
            }

            if (CONSTANTS.isRunMode) {
                $rs._handleAppCustomEvent = handleAppCustomEvent;
            }

            function overrideEventHandlers($is, $s, $el, attrs) {

                var wp = $is.widgetProps;

                _.keys(attrs)
                    .filter(function (attrName) {
                        return wp[attrName] && wp[attrName].type === EVENT;
                    })
                    .forEach(function (evtName) {
                        var overrideFlg = false,
                            fn,
                            getParentMethod,
                            $parent,
                            evtValue = attrs[evtName],
                            isAnchor = $el.is('a');

                        if (!evtValue) {
                            return;
                        }

                        if (evtValue === ('goToPage-' + $routeParams.name) || evtValue === ('goToPage_' + $routeParams.name)) {
                            $el.addClass('active');
                            if (isAnchor) {
                                $parent = $el.parent();
                                if ($parent.hasClass('app-nav-item')) {
                                    $parent.addClass('active');
                                }
                            }
                        }

                        fn = evtValue
                            .split(';')
                            .map(function (fnName) {
                                var trimmedFnName = fnName.trim();
                                if (!_.includes(trimmedFnName, '(') && !_.includes(trimmedFnName, '=')) {
                                    overrideFlg = true;
                                    return '$root._handleAppCustomEvent($s, ' + isAnchor + ', $event, "' + trimmedFnName + '")';
                                }
                                return trimmedFnName;
                            })
                            .join(';');

                        //override the functions
                        if (overrideFlg) {
                            attrs['_' + evtName]  = fn;
                            getParentMethod = $parse(fn);
                            $is[evtName] = function (locals) {
                                locals = locals || {};
                                locals.iScope = $is;
                                locals.$s  = $s;

                                var retVal = getParentMethod($s, locals);
                                $rs.$safeApply($s);
                                return retVal;
                            };
                        }
                    });
            }

            function onWatchExprValueChange($is, $s, key, watchExpr, newVal) {
                $is[key + '__updateFromWatcher'] = true;
                if (WM.isDefined(newVal) && newVal !== null && newVal !== '') {
                    /*Check if "newVal" is a Pageable object.*/
                    if (WM.isObject(newVal) && Utils.isPageable(newVal)) {
                        /*Check if the scope is configured to accept Pageable objects.
                         * If configured, set the newVal.
                         * Else, set only the content.*/
                        if ($is.allowPageable) {
                            $is[key] = newVal;
                        } else {
                            $is[key] = newVal.content;
                        }
                    } else {
                        $is[key] = newVal;
                    }
                } else {
                    /*In studio mode, remove ".data[$i]" in the watch-expression so that it is not visible in the canvas.*/
                    if (CONSTANTS.isStudioMode) {
                        watchExpr = watchExpr.replace('.data[$i]', '');
                    }
                    /*
                     * Show the binding text
                     * if the widget is having a widget(i.e, inside canvas)
                     * OR if the mode is studio and if the widget is inside a partial
                     * OR if the mode is studio and if the widget is inside a prefab
                     */
                    $is[key] = ($is.widgetid || (CONSTANTS.isStudioMode && ($s.partialcontainername || $s.prefabname))) ? watchExpr : '';
                }
            }

            function processEventAttr($is, attrName, attrValue) {
                var onEvtName = _.camelCase(attrName); /* prepend the event name with "on" eg, 'click' with on --> onClick */

                // save the attrValue in isolateScope. eg, $is.__onClick = "f1();dialog1.show;f2();"
                $is['__' + onEvtName] = attrValue;
            }

            function isInterpolated(val) {
                return _.includes(val, '{{') && _.includes(val, '}}');
            }

            function watchProperty($is, attrs, attrName) {
                attrs.$observe(attrName, function (nv) {
                    $is[attrName] = nv;
                });
            }

            function setInitProp($is, propName, value) {
                if (WM.isDefined(value)) {
                    $is._initState[propName] = value;
                }
            }

            function processAttr($is, $s, attrs, widgetProps, attrName, attrValue) {
                var propValue = attrValue;

                /* monitor only the properties that are defined inside widgetProps and which are not defined in scope {} */

                /*
                 * if the attribute is inside widget property,
                 * update the attribute value in _widgetState
                 * These values will be updated in the scope after the postWidgetCreate */
                if (widgetProps.hasOwnProperty(attrName)) {
                    /* class can't have interpolated value.
                     * As angular will combine the templateEl(eg.<wm-button>) and template(eg. <button>) classes, read the class value from templateEl */
                    if (attrName === 'class') {
                        setInitProp($is, attrName, propValue);
                    } else {
                        // if the resource to be loaded is from a prefab
                        if ($s.prefabname && _.startsWith(propValue, 'resources/')) {
                            if (CONSTANTS.isRunMode) {
                                propValue = './app/prefabs/' + $s.prefabname + '/' + propValue;
                            } else {
                                propValue = 'services/prefabs/' + $s.prefabid + '/files/webapp/' + propValue;
                            }
                            setInitProp($is, attrName, propValue);
                        } else {
                            /* if the value is other than class read it from the attrs, which will have resolved interpolated values */
                            if (isInterpolated(propValue)) {
                                watchProperty($is, attrs, attrName);
                            } else {
                                setInitProp($is, attrName, attrValue);
                            }
                        }
                    }
                } else {
                    /* attributes which not part of widgetProps like wigetid, widgettype will be handled here. */

                    if (isInterpolated(propValue)) {
                        watchProperty($is, attrs, attrName);
                    } else {
                        $is[attrName] = attrs[attrName];
                    }
                }
            }

            function processAttrs($is, $s, $tEl, attrs) {
                var widgetProps = $is.widgetProps;
                _.forEach($tEl.context.attributes, function (attr) {
                    var attrName = attr.name,
                        attrValue = attr.value.trim(),
                        attrNameInCamelCase,
                        fn;

                    if (_.startsWith(attrName, 'on-')) {
                        if (attrs.widgetid) { // widget is inside canvas
                            processEventAttr($is, attrName, attrValue);
                        } else {
                            attrNameInCamelCase = _.camelCase(attrName);
                            fn = $parse(attrs[attrNameInCamelCase]);
                            $is[attrNameInCamelCase] = function (locals) {
                                locals = locals || {};
                                if (!locals.$scope) {
                                    locals.$scope = $is;
                                }

                                var retVal = fn($s, locals);
                                $rs.$safeApply($s);
                                return retVal;
                            };
                        }

                    } else {
                        if (attrs.hasOwnProperty(attrName) && !$is.$$isolateBindings[attrName]) {
                            processAttr($is, $s, attrs, widgetProps, attrName, attrValue);
                        }
                    }
                });
            }

            function deregisterWatchersOniScope($is) {
                _.values($is._watchers).forEach(Utils.triggerFn);
                $is._watchers = {};
            }

            function toBoolean(val, identity) {
                return val === true || val === 'true' || (identity ? val === identity : false);
            }

            function defineBindPropertyGetterSetters($is, $s, attrs, propDetails, key, value) {
                var bindKey              = 'bind' +  key,
                    acceptedTypes        = propDetails.type,
                    acceptsArray         = _.includes(acceptedTypes, 'array'),
                    _watchers            = $is._watchers,
                    isWidgetInsideCanvas = attrs.widgetid,
                    isShowProperty       = key === 'show';

                Object.defineProperty($is, bindKey, {
                    'get': function () {
                        return value;
                    },
                    'set': function (nv) {
                        var fn = _watchers[key],
                            watchExpr,
                            listenerFn;

                        Utils.triggerFn(fn); // de register the existing watch

                        /* if property is bound to a variable/widget, watch on it */
                        if (nv) {
                            // when the `show` property is bound to a property/expression do not evaluate that when the widget is in canvas
                            if (isWidgetInsideCanvas && isShowProperty) {
                                $is.show = true;
                            } else {
                                watchExpr = nv.replace('bind:', '');
                                listenerFn = onWatchExprValueChange.bind(undefined, $is, $s, key, watchExpr);
                                _watchers[key] = BindingManager.register($s, watchExpr, listenerFn, {'deepWatch': true, 'allowPageable': $is.allowPageable, 'acceptsArray': acceptsArray});
                            }
                        } else {
                            _watchers[key] = undefined;
                        }

                        value = nv;
                    }
                });
            }

            function defineDataValueGetterSetters($is, $el, attrs) {
                var flg,
                    key                 = 'datavalue',
                    bindKey             = 'bind' + key,
                    _watchers           = $is._watchers,
                    UPDATE_FROM_WATCHER = key + '__updateFromWatcher',
                    isSelect     = flg  = $el.is('select'),
                    isNumberType = flg  = !flg && $el.is('input[type=number], .app-currency, .app-slider, .app-ratings'),
                    isCheckbox   = flg  = !flg && $el.is('.app-checkbox'),
                    isDate              = !flg && $el.is('input[type=date]');

                function parseDataValue(val) {
                    var modifiedVal = val,
                        temp;

                    if (isSelect && attrs.multiple) {
                        // convert the comma separated list into array and update _model_
                        modifiedVal = val.split(',').map(function (opt) {return ('' + opt).trim(); });
                    } else if (isNumberType) {
                        temp = +val; // convert the value to number and update the scope property
                        if (isNaN(temp)) {
                            temp = 0;
                        }
                        modifiedVal = temp;
                    } else if (isCheckbox) {
                        if (!$is.checkedvalue) {
                            modifiedVal = toBoolean(val);
                        }
                    } else if (isDate) {
                        modifiedVal = new Date(val);
                    }
                    return modifiedVal;
                }

                Object.defineProperty($is, key, {
                    'get': function () {
                        return $is._model_;
                    },
                    'set': function (nv) {
                        if (!$is[UPDATE_FROM_WATCHER]) { // value is not from watch.
                            Utils.triggerFn(_watchers[key]); // remove the binddatavalue watcher
                            _watchers[key] = undefined;
                        } else {
                            $is[UPDATE_FROM_WATCHER] = false;
                        }

                        if (_.startsWith(nv, 'bind:')) {  // set up new watch
                            $is[bindKey] = nv;
                            return;
                        }

                        $is._model_ = parseDataValue(nv);
                        Utils.triggerFn($is._onChange);
                    }
                })
            }

            function definePropertyGetterSetters($is, $s, $el, attrs, propDetails, isBindableProperty, key , value) {
                var flg,
                    bindKey             = 'bind' + key,
                    UPDATE_FROM_WATCHER = key + '__updateFromWatcher',
                    _watchers           = $is._watchers,
                    type                = propDetails.type,
                    isBooleanType = flg = type === 'boolean',
                    isNumberType        = !flg && type === 'number',
                    _isBooleanAttr      = isBooleanAttr(key),
                    isFontSize          = key === 'fontsize',
                    isName              = key === 'name';

                setInitProp($is, key, value);

                function parseValue(val) {
                    var modifiedValue = val,
                        numVal;
                    if (isBooleanType) {
                        modifiedValue = toBoolean(val, _isBooleanAttr && key);
                    } else if (isNumberType) {
                        numVal = +val;
                        if (isFontSize) {
                            if (WM.isString(val) && val.trim().length) {
                                modifiedValue = numVal;
                            }
                        } else {
                            modifiedValue = +val;
                        }
                    }
                    return modifiedValue;
                }

                function hasValueChanged(nv, ov, doEqualsCheck) {
                    /*When both "oldVal" and "newVal" are objects/arrays, comparison is not done.*/
                    if (doEqualsCheck) {
                        return !WM.equals(nv, ov);
                    }

                    return (nv !== ov || WM.isObject(nv) || WM.isObject(ov));
                }

                Object.defineProperty($is, key, {
                    'get': function () {
                        return value;
                    },
                    'set': function (nv) {
                        var ov = value,
                            _nv,
                            doEqualsCheck;

                        if (isBindableProperty) {
                            if (!$is[UPDATE_FROM_WATCHER]) {
                                Utils.triggerFn(_watchers[key]);
                                _watchers[key] = undefined;
                                doEqualsCheck = true;
                            } else {
                                $is[UPDATE_FROM_WATCHER] = false;
                            }

                            if (_.startsWith(nv, 'bind:')) {
                                $is[bindKey] = nv;
                                return;
                            }
                        } else {
                            doEqualsCheck = true;
                        }

                        _nv = parseValue(nv);

                        if (!hasValueChanged(_nv, ov, doEqualsCheck)) {
                            return;
                        }

                        /* if the name is changed, update the tree and registry of the Widgets service */
                        if (isName) {
                            if (attrs.widgetid) { // widget is inside the canvas
                                $rs.$emit('name-change', attrs.widgetid, nv, ov, $is);
                            } else if ($s.Widgets) { // widget may be inside canvas inside a page container or in run mode.
                                $s.Widgets[attrs.name] = $is;
                            }
                        }

                        value = _nv;

                        WidgetUtilService.onScopeValueChangeProxy($is, $el, attrs, key, _nv, ov);
                    }
                });
            }

            function isBindableProperty(propDetails) {
                return propDetails.bindable === 'in-bound' || propDetails.bindable === 'in-out-bound';
            }

            function defineGetterSettersForProp($is, $s, $el, attrs, hasModel, propName, propDetails) {

                var _isBindableProperty;

                if (propName === 'datavalue' && hasModel) {
                    defineBindPropertyGetterSetters($is, $s, attrs, propDetails, propName);
                    defineDataValueGetterSetters($is, $el, attrs);
                } else if (!propDetails.ignoreGetterSetters){

                    _isBindableProperty = isBindableProperty(propDetails);
                    if (_isBindableProperty) {
                        defineBindPropertyGetterSetters($is, $s, attrs, propDetails, propName);
                    }
                    definePropertyGetterSetters($is, $s, $el, attrs, propDetails, _isBindableProperty, propName, attrs[propName] ? undefined : propDetails.value);
                }
            }

            function defineGetterSettersForProps($is, $s, $el, attrs) {
                var wp = $is.widgetProps,
                    hasModel = attrs.hasOwnProperty('hasModel');

                _.keys(wp)
                    .filter(function (propName) {
                        var propDetails = wp[propName];
                        return !($is.$$isolateBindings[propName] || propDetails.type === EVENT);
                    })
                    .forEach(function (propName) {
                        var propDetails = wp[propName];
                        defineGetterSettersForProp($is, $s, $el, attrs, hasModel, propName, propDetails);
                    });
            }

            /*
             * Class : FieldDef
             * Discription : FieldDef contains getter and setter methods to get and set fields of widgets
             * */
            wm.baseClasses.FieldDef = function () {
            };

            wm.baseClasses.FieldDef.prototype = {
                setProperty : function (field, newval) {
                    this.$is.setProperty.call(this, field, newval);
                    this.$is.reRender && this.$is.reRender();
                },
                getProperty : function (field) {
                    return this.$is.getProperty.call(this, field);
                }
            };

            return {
                'restrict': 'A',
                'compile': function ($tEl) {
                    return {
                        pre: function ($is, $el, attrs) {
                            var hasDataValue,
                                datavalue_value,
                                $s = $el.scope(),
                                scopeVarName;

                            if (!$is || !$is.widgetProps) {
                                return;
                            }

                            $is.propertyManager = new PropertyManager();
                            $is._watchers = {};

                            $is.$on('$destroy', deregisterWatchersOniScope.bind(undefined, $is));
                            /*Register a watch on the element for destroy and destroy the scope.
                             In some cases such as tabs, the tab-content couldn't be destroyed from isolateScope if the parent tabs was destroyed first*/
                            if (attrs.widgetid) {
                                $el.on('$destroy', $is.$destroy.bind($is));
                            } else {
                                $is._widgettype = $tEl.context.tagName.toLowerCase();
                            }
                            $is._initState = {};

                            if (attrs.hasOwnProperty('hasModel') && !attrs.widgetid) {
                                scopeVarName = $tEl.context.attributes.scopedatavalue;
                                scopeVarName = scopeVarName && scopeVarName.value;
                                if (scopeVarName && isInterpolated(scopeVarName)) {
                                    attrs.$observe('scopedatavalue', function (newValue) {
                                        WidgetUtilService.injectModelUpdater($el, newValue);
                                    });
                                } else {
                                    WidgetUtilService.injectModelUpdater($el, scopeVarName);
                                }
                            }

                            /*Setter for widget properties*/
                            $is.setProperty = function(option, value) {
                                this[option] = value;
                            };

                            /*Getter for widget properties*/
                            $is.getProperty = function(option) {
                                return this[option];
                            };

                            if (CONSTANTS.isStudioMode) {
                                WM.extend($is.widgetProps, {'active': {}});
                            }

                            /* initialize setters and getters */
                            defineGetterSettersForProps($is, $s, $el, attrs);

                            processAttrs($is, $s, $tEl, attrs);

                            /* remove the datavalue property from scope and store it temporarily, so that all dependencies are intialized first */
                            if ($is._initState.hasOwnProperty('datavalue')) {
                                hasDataValue = true;
                                datavalue_value = $is._initState.datavalue;
                                delete $is._initState.datavalue;
                            }

                            _.keys($is._initState)
                                .forEach(function (key) {
                                    // set the value in scope;
                                    $is[key] = $is._initState[key];
                                });

                            /* if element has datavalue, populate it into the isolateScope */
                            if (hasDataValue) {
                                $is.datavalue = datavalue_value;
                            }

                            if (CONSTANTS.isRunMode) {
                                overrideEventHandlers($is, $s, $el, attrs);
                            }
                        }
                    };
                }
            };
        }
    ])
    .service('BindingManager', [
        'Utils',
        'CONSTANTS',

        function (Utils, CONSTANTS) {
            'use strict';

            var regex = /\[\$i\]/g,
                $I = '[$i]',
                $0 = '[0]';

            function isArrayTypeExpr(expr) {
                var matchers = expr.match(regex); // check for `[$i]` in the expression
                return matchers && matchers.length;
            }

            function arrayConsumer(listenerFn, allowPageable, restExpr, newVal, oldVal) {
                var data = newVal,
                    formattedData;
                /*Check if "newVal" is a Pageable object.*/
                if (WM.isObject(data) && Utils.isPageable(data) && !allowPageable) {
                    /*Check if the scope is configured to accept Pageable objects.
                     * If configured, set the newVal.
                     * Else, set only the content.*/
                    data = data.content;
                }

                if (WM.isArray(data)) {
                    formattedData = data.map(function (datum) {
                        return Utils.findValueOf(datum, restExpr);
                    });

                    listenerFn(formattedData, oldVal);
                }
            }

            function getUpdatedWatchExpr(expr, acceptsArray, allowPageable, listener) {
                // listener doesn't accept array
                // replace all `[$i]` with `[0]` and return the expression
                if (!acceptsArray) {
                    return {
                        'expr': expr.replace(regex, $0),
                        'listener': listener
                    };
                }

                // listener accepts array
                // replace all except the last `[$i]` with `[0]` and return the expression.
                var index = expr.lastIndexOf($I),
                    _expr = expr.substr(0, index).replace($I, $0),
                    restExpr = expr.substr(index + 5),
                    arrayConsumerFn = listener;

                if (restExpr) {
                    arrayConsumerFn = arrayConsumer.bind(undefined, listener, allowPageable, restExpr);
                }

                return {
                    'expr': _expr,
                    'listener': arrayConsumerFn
                };
            }

            /*
             * scope: scope on which watch needs to be registered.
             * watchExpr: watch expression
             * listenerFn: callback function to be triggered when the watch expression value changes
             * config: Object containing deepWatch, allowPageable, acceptsArray keys
             * deepWatch: if this flag is true a deep watch will be registered in the scope
             * allowPageable: is the data pageable
             * acceptsArray: bound entity accepts array like values
             */
            function register(scope, watchExpr, listenerFn, config) {
                var watchInfo,
                    _config        = config || {},
                    deepWatch      = _config.deepWatch,
                    allowPageable  = _config.allowPageable,
                    acceptsArray   = _config.acceptsArray,
                    regExp         = new RegExp(/Variables\.(\w*)\.dataSet\[\$i\]/g), //Reg exp to match all Variables which has dataSet[$i]
                    variableObject;

                function isPageable(variable) {
                    return ((variable.category === 'wm.ServiceVariable' && variable.serviceType === "DataService" && variable.controller !== "ProcedureExecution") || variable.category === "wm.LiveVariable");
                }

                if (isArrayTypeExpr(watchExpr)) {
                    if (CONSTANTS.isStudioMode) {
                        listenerFn();
                        return;
                    }
                    //Check each match is pageable and replace dataSet[$i] with dataSet.content[$i]
                    watchExpr = watchExpr.replace(regExp, function (match, key) {
                        variableObject = _.get(scope.Variables, key);
                            /*In case of queries(native sql,hql) the actual data is wrapped inside content but in case of procedure its not wrapped*/
                            /*So for procedures the watch expression will not have content in it*/
                            if(variableObject && isPageable(variableObject)) {
                                return 'Variables.' + key + '.dataSet.content[$i]';
                            }
                    });

                    watchInfo = getUpdatedWatchExpr(watchExpr, acceptsArray, allowPageable, listenerFn);
                } else {
                    watchInfo = {
                        'expr': watchExpr,
                        'listener': listenerFn
                    };
                }

                return scope.$watch(watchInfo.expr, watchInfo.listener, deepWatch);
            }

            this.register = register;
        }
    ]);
/*global WM */

WM.module('wm.widgets.base')
    .directive('pageContainer', [
        '$compile',
        '$rootScope',
        '$routeParams',
        'PropertiesFactory',
        'Variables',
        'FileService',
        'CONSTANTS',
        'Utils',
        'WidgetUtilService',

        function ($compile, $rootScope, $routeParams, PropertiesFactory, Variables, FileService, CONSTANTS, Utils, WidgetUtilService) {
            'use strict';

            var props = PropertiesFactory.getPropertiesOf('wm.pagecontainer'),
                notifyFor = {
                    'content': true,
                    'active': true
                },

            // to hold the whether the content of partials is loaded or not
                loadedPartials = {};

            function evtHandler(e) {
                // Do not allow the drop event when this widgets content is set to other page.
                e.stopPropagation();
                e.preventDefault();
            }

            function bindEvtHandler(element) {
                element.on('drop', evtHandler);
            }

            function unbindEvtHandler(element) {
                element.off('drop', evtHandler);
            }

            /* before compilation of the partial content*/
            function preCompilePartial(partialElement) {
                /* any of the partial children having on-click attr as goToPage- navigation call, remove 'active' class on it*/
                partialElement.find('[on-click^="goToPage-"][on-click^="goToPage_"]').removeClass('active');
                /*get active-page & get the element goToPage-ActivePage navigation call, add 'active' class on it*/
                partialElement.find('[on-click="goToPage-' + (CONSTANTS.isRunMode ? $routeParams.name : $rootScope.activePageName) + '"][on-click="goToPage_' + (CONSTANTS.isRunMode ? $routeParams.name : $rootScope.activePageName) + '"]').addClass('active');
            }

            /* to manually compile the partial page*/
            function compilePartialAndUpdateVariables(iScope, element, partialName, partialMarkup) {
                var target = iScope.target,
                    scope;

                /* set the partial-page variables (will be registered by the partial) */
                Variables.setPageVariables(partialName, loadedPartials[partialName].variables);

                /* append the pageContentMarkup to original markup, to compile it manually*/
                partialMarkup = partialMarkup + '<div class="app-included-page">' + (loadedPartials[partialName].html || '') + '</div>';

                /* wm-livelist and wm-login elements will have ngController directive this will result in
                 * error:multidir Multiple Directive Resource Contention
                 * to resolve this issue,
                 * RunMode: remove the ngController directive from the element and add a wrapper with the controller name
                 * StudioMode: remove the ngController directive
                 */
                if (CONSTANTS.isRunMode) {
                    partialMarkup = WM.element(Utils.processMarkup(partialMarkup));
                } else {
                    partialMarkup = partialMarkup + '<div class="content-overlay"></div>';
                    partialMarkup = WM.element(partialMarkup);
                    partialMarkup.find('wm-livelist, wm-login').removeAttr('data-ng-controller');
                }

                /*get the element scope*/
                scope = element.scope();
                scope = scope.$new();
                // element might got removed by this time, check for scope
                if (scope) {
                    /* pre-compile */
                    preCompilePartial(partialMarkup);
                    scope.partialname = partialName;
                    scope.partialcontainername = iScope.name;
                    /* compile */
                    target.html($compile(partialMarkup)(scope));
                } else {
                    return;
                }

                if (CONSTANTS.isStudioMode) {
                    /*reset loaded partials, as they contain the htmlMarkup & variables*/
                    loadedPartials[partialName] = undefined;
                    iScope.toolbar = target.find('button.wm-included-page-heading').first();
                    iScope.overlay = target.find('div.content-overlay').first();
                    $rootScope.$safeApply(iScope);
                } else if (CONSTANTS.isRunMode) {
                    /* if the compilation of whole page along with partials happen in Async, then call the page-part-load fn
                     * else don't call as the page-part is not registered */
                    if (iScope.isPagePartRegistered) {
                        iScope.isPagePartRegistered = undefined;
                        Utils.triggerFn(scope.onPagePartLoad);
                    }
                }
                scope.$emit('on-pagecontainer-ready');
            }

            /* This function handles the change in content property of the page-container */
            function onPageIncludeChange(iScope, element, attrs, newVal) {
                var target = iScope.target,
                    el = '',
                    page = 'pages/' + newVal + '/',
                    addToolBar;

                if (!target) {
                    iScope.target = target = WM.isDefined(attrs.pageContainerTarget) ? element : element.find('[page-container-target]').eq(0);
                }

                element.attr('content', newVal);
                if (CONSTANTS.isStudioMode) {
                    target.find('.app-included-page, .app-included-page + .content-overlay, .wm-included-page-heading').remove();
                }
                //checking if the newVale is there
                if (newVal && newVal.trim().length) {
                    /*load the partial on-demand*/
                    if (!loadedPartials[newVal]) {
                        //checking if it is a studio mode then remove the button element from the toolbar
                        if (CONSTANTS.isStudioMode) {
                            iScope.Widgets = {};
                            bindEvtHandler(element);
                            addToolBar = WM.isDefined(attrs.widgetid);

                            /* check for addToolBar*/
                            if (addToolBar) {
                                el = '<button class="wm-included-page-heading button-primary" data-ng-click=_openPageWS("' + newVal + '"); title="edit ' + newVal + '"><i class="wm-edit fa fa-pencil"></i></button>';
                            }
                        }
                        /*read the file content*/
                        FileService.read({
                            path: CONSTANTS.isStudioMode ? "../../../" + page + 'page.min.html' : page + 'page.min.html',
                            projectID : $rootScope.project.id
                        }, function (pageContent) {
                            /*get individual file contents like - html/js/css */
                            loadedPartials[newVal] = Utils.parseCombinedPageContent(pageContent, newVal);
                            /* to compile the partial page*/
                            compilePartialAndUpdateVariables(iScope, element, newVal, el);
                        }, function () {
                            if (element[0].hasAttribute('page-container-target')) {
                                target = element;
                            } else {
                                target = element.find('[page-container-target]').first();
                            }
                            target.html('<div class="app-partial-info"><div class="partial-message">Content for the container is unavailable.</div></div>');
                        });
                    } else {
                        /* to compile the partial page*/
                        compilePartialAndUpdateVariables(iScope, element, newVal, el);
                    }
                } else {
                    if (CONSTANTS.isStudioMode) {
                        iScope.Widgets = undefined;
                        if (iScope.widgettype === 'wm-top-nav' && !element.children().length) {
                            $rootScope.$emit('canvas-add-widget', {
                                widgetType: 'wm-list',
                                parentName: iScope.name
                            }, true);
                        }
                        unbindEvtHandler(element);
                    }
                }
            }

            /* Define the property change handler. This function will be triggered when there is a change in the widget property */
            function propertyChangeHandler(iScope, element, attrs, key, newVal) {
                switch (key) {
                case 'content':
                    // if the $lazyLoad is method is defined on the iScope of the widget (eg, tabContent and accordionContent) and if the widget is not active
                    // load the page on-demand(lazily) otherwise load immediately
                    if (newVal && iScope.$lazyLoad && !iScope.isActive) {
                        // override the $lazyLoad method defined on the iScope.
                        // page will be loaded only when this method is triggered.
                        iScope.$lazyLoad = function () {
                            onPageIncludeChange(iScope, element, attrs, newVal);
                            // page is loaded successfully. reset the $lazyLoad to WM.noop. executing this method multiple times will do nothing.
                            iScope.$lazyLoad = WM.noop;
                        };
                    } else {
                        onPageIncludeChange(iScope, element, attrs, newVal);
                    }

                    break;
                case 'active':
                    if (!CONSTANTS.isStudioMode || !iScope.toolbar) {
                        return;
                    }
                    if (newVal) {
                        iScope.toolbar.addClass('active');
                        iScope.overlay.addClass('active');
                    } else {
                        iScope.toolbar.removeClass('active');
                        iScope.overlay.removeClass('active');
                    }
                    break;
                }
            }

            return {
                'priority': '1000',
                'compile': function () {
                    return {
                        'pre': function (iScope, element, attrs) {
                            var partialName = attrs.page || attrs.content;
                            WM.extend(iScope.widgetProps || {}, Utils.getClonedObject(props));
                            iScope['page-container'] = true;
                            //Trigger registerPageContainer method of page widget when the content of this widget is loaded from other page.
                            // if the $lazyLoad method is defined on the iScope, do not register the pagePart.
                            if (CONSTANTS.isRunMode && partialName && !loadedPartials[partialName] && !iScope.$lazyLoad) {
                                iScope.isPagePartRegistered = true;
                                Utils.triggerFn(element.scope().registerPagePart);
                            }
                        },
                        'post': function (iScope, element, attrs) {
                            if (CONSTANTS.isStudioMode && iScope.widgettype === 'wm-pagedialog') {
                                // if the mode is studio and widget is pagedialog update the widget type of content property
                                iScope.widgetProps.content.widget = 'pagedialog-pages-list';
                            }

                            WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, iScope, element, attrs), iScope, notifyFor);

                            //support for deprecated page attribute;
                            if (iScope.hasOwnProperty('page') && !iScope.content) {
                                iScope.content = iScope.page;
                            }
                        }
                    };
                }
            };
        }
    ]);

/*global WM, */
/*Directive for anchor */

WM.module('wm.widgets.basic')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/widget/anchor.html',
                '<a data-identifier="anchor" class="app-anchor" init-widget data-ng-show="show" title="{{hint}}" apply-styles role="button" accesskey="{{shortcutkey}}">' +
                    '<img data-identifier="img" class="anchor-image-icon" data-ng-src="{{iconsrc}}" data-ng-if="showimage" data-ng-style="{width:iconwidth ,height:iconheight, margin:iconmargin}"/>' +
                    '<i class="app-icon {{iconclass}}" data-ng-style="{width:iconwidth, height:iconheight, margin:iconmargin}" data-ng-if="showicon"></i> ' +
                    '<span class="anchor-caption"></span>' +
                    '<span data-ng-if="badgevalue" class="badge pull-right">{{badgevalue}}</span>' +
                '</a>'
            );

    }]).directive('wmAnchor', ['PropertiesFactory', 'WidgetUtilService', '$sce', 'Utils', 'CONSTANTS', function (PropertiesFactory, WidgetUtilService, $sce, Utils, CONSTANTS) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.anchor', ['wm.base', 'wm.base.editors', 'wm.base.events', 'wm.base.events.focus']),
            notifyFor = {
                'iconname': true,
                'iconurl': true,
                'target': true,
                'hyperlink': true,
                'caption': true,
                'iconposition': true
            };

        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
        function propertyChangeHandler(scope, element, attrs, key, newVal) {
            switch (key) {
            case 'target':
                attrs.$set('target', newVal);
                break;
            case 'iconposition':
                element.attr('icon-position', newVal);
                break;
            case 'hyperlink':
                attrs.$set('href', newVal);
                /* if hyperlink starts with 'www.' append 'http://' in the beginning */
                if (CONSTANTS.isRunMode && Utils.stringStartsWith(newVal, 'www.')) {
                    scope.hyperlink =  'http://' + newVal;
                }
                break;
            case 'iconclass':
                /*showing icon when iconurl is not set*/
                scope.showicon = scope.iconclass !== '_none_' && newVal !== '' && !scope.iconurl;
                break;
            case 'iconurl':
                /*hiding icon when iconurl is set*/
                /*showing icon when iconurl is not set*/
                var showIcon = newVal === '';
                scope.showicon = showIcon;
                scope.showimage = !showIcon;
                scope.iconsrc = Utils.getImageUrl(newVal);
                break;
            case 'caption':
                if (WM.isObject(newVal)) {
                    element.children('.anchor-caption').text(JSON.stringify(newVal));
                } else {
                    element.children('.anchor-caption').html(($sce.trustAs($sce.HTML, newVal.toString()).toString()));
                }
                break;
            }

        }

        return {
            'restrict': 'E',
            'replace': true,
            'scope': {},
            'template': WidgetUtilService.getPreparedTemplate.bind(undefined, 'template/widget/anchor.html'),
            'compile': function (tElement) {
                return {
                    'pre': function (scope, element, attrs) {
                        //@Deprecated iconname; use iconclass instead
                        if (!attrs.iconclass && attrs.iconname) {
                            WM.element(tElement.context).attr('iconclass', 'glyphicon glyphicon-' + attrs.iconname);
                            attrs.iconclass = 'glyphicon glyphicon-' + attrs.iconname;
                        }
                        scope.showicon = !scope.iconurl;
                        scope.widgetProps = widgetProps;
                    },
                    'post': function (scope, element, attrs) {
                        /* register the property change handler */
                        WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, scope, element, attrs), scope, notifyFor);
                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                        if (!attrs.hyperlink && !attrs.href) {
                            element.attr('href', 'javascript:void(0)');
                        }
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.widgets.basic.directive:wmAnchor
 * @restrict E
 *
 * @description
 * The `wmAnchor` directive defines the anchor widget.
 * It can be dragged and moved in the canvas.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 * @requires $sce
 * @requires Utils
 * @requires CONSTANTS
 *
 * @param {string=} name
 *                  Name of the anchor.
 * @param {string=} hint
 *                  Title/hint for the anchor. <br>
 *                  This is a bindable property.
 * @param {string=} caption
 *                  Content of the anchor. <br>
 *                  This is a bindable property.
 * @param {string=} badgevalue
 *                  Value to be displayed as badge for the anchor. <br>
 *                  This is a bindable property.
 * @param {number=} tabindex
 *                  This property specifies the tab order of the anchor.
 * @param {string=} target
 *                  Target property of the anchor. <br>
 *                  Possible values are: <br>
 *                  `_blank` : Opens the linked document in a new window. <br>
 *                  `_self`  : Opens the linked document in the same frame as it was clicked (this is default). <br>
 *                  `_parent`: Opens the linked document in the parent frameset. <br>
 *                  `_top`   : Opens the linked document in the full body of the window. <br>
 * @param {string=} width
 *                  Width of the anchor.
 * @param {string=} height
 *                  Height of the anchor.
 * @param {string=} hyperlink
 *                  href of the anchor. <br>
 *                  This is a bindable property.
 * @param {boolean=} show
 *                  This is a bindable property. <br>
 *                  This property will be used to show/hide the anchor on the web page. <br>
 *                  Default value: `true`. <br>
 * @param {string=} animation
 *                  This property controls the animation of the anchor. <br>
 *                  The animation is based on the css classes and works only in the run mode. <br>
 *                  Possible values are `bounce`, `flash`, `pulse`, `rubberBand`, `shake`, `etc`.
 * @param {string=} iconclass
 *                  CSS class for the icon. <br>
 *                  This is a bindable property.
 * @param {string=} iconurl
 *                  url of the icon. <br>
 *                  This is a bindable property.
 * @param {string=} iconwidth
 *                  Width of the icon. <br>
 *                  Default value: 16px
 * @param {string=} iconheight
 *                  Height of the icon.  <br>
 *                  Default value: 16px
 * @param {string=} iconmargin
 *                  Margin of the icon.
 * @param {string=} on-click
 *                  Callback function which will be triggered when the widget is clicked.
 * @param {string=} on-dblclick
 *                  Callback function which will be triggered when the widget is double-clicked.
 * @param {string=} on-mouseenter.
 *                  Callback function which will be triggered when the mouse enters the widget.
 * @param {string=} on-mouseleave
 *                  Callback function which will be triggered when the mouse leaves the widget.
 * @param {string=} on-focus
 *                  Callback function which will be triggered when the widget gets focused.
 * @param {string=} on-blur
 *                  Callback function which will be triggered when the widget loses focus.
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
                <wm-anchor
                    caption="google"
                    target="{{target}}"
                    hyperlink="http://www.google.com"
                    hint="go to google.com"
                    iconclass="{{icon}}"
                    on-mouseenter="f('mouseenter');"
                    on-mouseleave="f('mouseleave')">
                </wm-anchor><br>
                <wm-composite>
                   <wm-label caption="target:"></wm-label>
                   <wm-select scopedataset="targets" scopedatavalue="target"></wm-select>
                </wm-composite>
                <wm-composite>
                    <wm-label caption="icon:"></wm-label>
                    <wm-select scopedatavalue="icon" scopedataset="icons"></wm-select>
                </wm-composite>
            </div>
        </file>
        <file name="script.js">
            function Ctrl($scope) {
                $scope.icons = ["ok", "star", "remove", "user", "random"];
                $scope.targets = ["_blank", "_self", "_parent", "_top"];
                $scope.f = function (eventtype) {
                    console.log("inside function f for event", eventtype);
                }
            }
        </file>
    </example>
 */

/*global WM*/
/*Directive for Icon*/

WM.module('wm.widgets.basic')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/widget/icon.html',
            '<i init-widget class="app-icon"  data-ng-class="iconclass" data-ng-show="show"  data-ng-style="{\'font-size\' : iconsize, \'color\' : color, \'opacity\' : opacity}"></i>'
            );
    }])
        .directive('wmIcon', ['PropertiesFactory', 'WidgetUtilService', function (PropertiesFactory, WidgetUtilService) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.icon', ['wm.base']);
        return {
            'restrict': 'E',
            'scope': {},
            'replace': true,
            'template': WidgetUtilService.getPreparedTemplate.bind(undefined, 'template/widget/icon.html'),
            'compile': function () {
                return {
                    'pre': function (scope) {
                        scope.widgetProps = widgetProps;
                    },
                    'post': function (scope, element, attrs) {
                        /* register the property change handler */
                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
}]);


/**
 * @ngdoc directive
 * @name wm.widgets.basic.directive:wmIcon
 * @restrict E
 * @element ANY
 * @description
 * The 'wmIcon' directive defines a icon.
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 *
 * @param {string=} name
 *                  Name of the container widget.
 * @param {string=} title
 *                  Title of the container widget. <br>
 *                  This is a bindable property.
 * @param {boolean=} show
 *                  This is a bindable property. <br>
 *                  This property will be used to show/hide the icon widget on the web page. <br>
 *                  Default value: `true`. <br>
 * @param {string=} animation
 *                  This property controls the animation of the icon widget. <br>
 *                  The animation is based on the css classes and works only in the run mode. <br>
 *                  Possible values are `bounce`, `flash`, `pulse`, `rubberBand`, `shake`, `etc`.
 * @param {string=} iconclass
 *                  class name of the icon. <br>
 *                  This is a bindable property.
 *
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
                <br>
                <wm-icon iconclass="glyphicon glyphicon-search" iconsize="3em"></wm-icon>
            </div>
        </file>
        <file name="script.js">
            function Ctrl($scope) {}
        </file>
    </example>
 */

/*global WM*/
/*Directive for html */

WM.module('wm.widgets.basic')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/widget/htmlTemplate.html',
            '<div class="app-html-container" init-widget title="{{hint}}" data-ng-show="show" apply-styles>' +
                '<div class="html-content"></div>' +
            ' </div>'
            );
    }])
    .directive('wmHtml', ['PropertiesFactory', 'WidgetUtilService', function (PropertiesFactory, WidgetUtilService) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.html', ['wm.base', 'wm.base.editors', 'wm.base.events']),
            notifyFor = {
                'content': true,
                'autoscroll': true
            };

        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
        function propertyChangeHandler(element, targetEl, key, newVal) {
            switch (key) {
            case 'content':
                targetEl.html(newVal);
                break;
            case 'autoscroll':
                newVal = newVal === true || newVal === 'true';
                element.css('overflow', newVal ? 'auto' : 'hidden');
                break;
            }
        }

        return {
            'restrict': 'E',
            'replace': true,
            'scope': {},
            'template': WidgetUtilService.getPreparedTemplate.bind(undefined, 'template/widget/htmlTemplate.html'),
            'compile': function (tElement) {
                return {
                    'pre': function (scope) {
                        /*Applying widget properties to directive scope*/
                        scope.widgetProps = widgetProps;
                    },
                    'post': function (scope, element, attrs) {
                        var targetElement = element.children().first(),
                            content = tElement.context.innerHTML;

                        /* if content is provided as an attribute, give it preference */
                        scope.content = attrs.content || content;

                        /* set the html content*/
                        targetElement.html(scope.content);

                        element.css('overflow', 'hidden');

                        /* register the property change handler */
                        WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, element, targetElement), scope, notifyFor);

                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]);


/**
 * @ngdoc directive
 * @name wm.widgets.basic.directive:wmHtml
 * @restrict E
 *
 * @description
 * The 'wmHtml' directive defines a html-widget.
 * This is a container widget for the html content.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires $templateCache
 * @requires WidgetUtilService
 *
 * @param {string=} name
 *                  Name of the html-widget.
 * @param {string=} hint
 *                  Title/hint for the html-widget.<br>
 *                  This is a bindable property. <br>
 * @param {string=} width
 *                  Width of the html-widget.
 * @param {string=} height
 *                  Height of the html-widget.
 * @param {string=} content
 *                  Content of the html-widget. <br>
 *                  This is a bindable property.
 * @param {boolean=} show
 *                  This property will be used to show/hide the html-widget on the web page. <br>
 *                  This is a bindable property. <br>
 *                  Default value: `true`. <br>
 * @param {boolean=} autoscroll
 *                  This property defines if the html-widget should be allowed to scroll automatically. <br>
 *                  Default value: `false`. <br>
 * @param {string=} on-click
 *                  Callback function which will be triggered when the widget is clicked.
 * @param {string=} on-dblclick
 *                  Callback function which will be triggered when the widget is double-clicked.
 * @param {string=} on-mouseenter.
 *                  Callback function which will be triggered when the mouse enters the widget.
 * @param {string=} on-mouseleave
 *                  Callback function which will be triggered when the mouse leaves the widget.
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
                Show Html widget: <wm-checkbox scopedatavalue="show"></wm-checkbox> <br><br>
                Width: <wm-text scopedatavalue="width"></wm-text> <br><br>
                height: <wm-text scopedatavalue="height"></wm-text> <br><br>
                Click Count: {{clickCount}} <br><br>
                <div>
                   <wm-html width="{{width}}" height="{{height}}" show="{{show}}" on-click="f()" bordertop="2" borderleft="2" borderright="2" borderbottom="2" bordercolor="crimson" borderstyle="solid" paddingtop="10" paddingleft="10" paddingright="10" paddingbottom="10">
                       <div>
                           <h2 style="text-decoration:underline;">Html-widget content</h2>
                           <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>
                       </div>
                       <br>
                   </wm-html>
                </div>
            </div>
        </file>
        <file name="script.js">
            function Ctrl($scope) {
               $scope.clickCount = 0;
               $scope.width = "350px";
               $scope.height = "250px";
               $scope.show = true;

               $scope.f = function () {
                   $scope.clickCount++;
               }
            }
        </file>
    </example>
 */
/*global WM, */
/*Directive for Label */

WM.module('wm.widgets.basic')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/widget/label.html',
            '<label class="control-label app-label" data-ng-show="show" title="{{hint}}" init-widget apply-styles data-ng-class="{required:required}"></label>'
            );
    }])
    .directive('wmLabel', ['PropertiesFactory', 'WidgetUtilService', '$sce', function (PropertiesFactory, WidgetUtilService, $sce) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.label', ['wm.base', 'wm.base.editors', 'wm.base.events']),
            notifyFor = {
                'caption': true
            };

        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
        function propertyChangeHandler(element, key, newVal) {
            switch (key) {
            case 'caption':
                if (WM.isObject(newVal)) {
                    element.text(JSON.stringify(newVal));
                } else {
                    element.html(($sce.trustAs($sce.HTML, newVal.toString()).toString()));
                }
                break;
            }
        }

        return {
            'restrict': 'E',
            'scope': {},
            'replace': true,
            'template': WidgetUtilService.getPreparedTemplate.bind(undefined, 'template/widget/label.html'),
            'compile': function () {
                return {
                    'pre': function (scope) {
                        scope.widgetProps = widgetProps;
                    },
                    'post': function (scope, element, attrs) {

                        /* register the property change handler */
                        WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, element), scope, notifyFor);
                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.widgets.basic.directive:wmLabel
 * @restrict E
 *
 * @description
 * The `wmLabel` directive defines the label widget.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 * @requires $sce
 *
 * @param {string=} name
 *                  Name of the label widget.
 * @param {string=} hint
 *                  Title/hint for the label. <br>
 *                  This is a bindable property.
 * @param {string=} caption
 *                  Content of the label. <br>
 *                  This is a bindable property.
 * @param {string=} width
 *                  Width of the label.
 * @param {string=} height
 *                  Height of the label.
 * @param {boolean=} required
 *                  This is a bindable property. <br>
 *                  if the required property is set to true, `required` class is applied to the label [an asterik will be displayed next to the content of the label]. <br>
 *                  Default value: `false`. <br>
 * @param {boolean=} show
 *                  This is a bindable property. <br>
 *                  This property will be used to show/hide the label widget on the web page. <br>
 *                  Default value: `true`. <br>
 * @param {string=} animation
 *                  This property controls the animation of the label. <br>
 *                  The animation is based on the css classes and works only in the run mode. <br>
 *                  Possible values are `bounce`, `flash`, `pulse`, `rubberBand`, `shake`, `etc`.
 * @param {string=} on-click
 *                  Callback function which will be triggered when the widget is clicked.
 * @param {string=} on-dblclick
 *                  Callback function which will be triggered when the widget is double-clicked.
 * @param {string=} on-mouseenter.
 *                  Callback function which will be triggered when the mouse enters the widget.
 * @param {string=} on-mouseleave
 *                  Callback function which will be triggered when the mouse leaves the widget.
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
                <div>single click count: {{clickCount}}</div>
                <div>dbl click count: {{dblclickCount}}</div>
                <div>mouse enter count: {{mouseenterCount}}</div>
                <div>mouse leave count: {{mouseleaveCount}}</div>
                <wm-label bordertop="1" borderleft="1" borderright="1" borderbottom="1" bordercolor="crimson" borderstyle="solid" paddingtop="4" paddingleft="4" paddingright="4" paddingbottom="4"
                    caption="{{caption}}"
                    hint="hint/title for label"
                    show="{{show}}"
                    width="{{width}}"
                    height="{{height}}"
                    color="{{color}}"
                    required="{{required}}"
                    on-click="f('click');"
                    on-dblclick="f('dblclick');"
                    on-mouseenter="f('mouseenter');"
                    on-mouseleave="f('mouseleave')">
                </wm-label><br>
                <wm-composite>
                    <wm-label caption="caption:"></wm-label>
                    <wm-text scopedatavalue="caption"></wm-text>
                </wm-composite>
                <wm-composite>
                    <wm-label caption="show:"></wm-label>
                    <wm-checkbox scopedatavalue="show"></wm-checkbox>
                </wm-composite>
                <wm-composite>
                    <wm-label caption="required:"></wm-label>
                    <wm-checkbox scopedatavalue="required"></wm-checkbox>
                </wm-composite>
                <wm-composite>
                    <wm-label caption="width:"></wm-label>
                    <wm-text scopedatavalue="width"></wm-text>
                </wm-composite>
                <wm-composite>
                    <wm-label caption="height:"></wm-label>
                    <wm-text scopedatavalue="height"></wm-text>
                </wm-composite>
                <wm-composite>
                    <wm-label caption="color:"></wm-label>
                    <wm-select scopedatavalue="color" scopedataset="colors"></wm-select>
                </wm-composite>
            </div>
        </file>
        <file name="script.js">
           function Ctrl($scope) {
               $scope.clickCount =
               $scope.dblclickCount =
               $scope.mouseenterCount =
               $scope.mouseleaveCount = 0;

               $scope.required = true;
               $scope.show = true;
               $scope.width = "100px";
               $scope.height= "30px";
               $scope.caption = " Wavemaker! ";
               $scope.color = "blue";

               $scope.icons = ["ok", "star", "remove", "user", "random"];
               $scope.colors = ["blue", "crimson", "green", "orange", "red"];

               $scope.f = function (eventtype) {
                   $scope[eventtype + 'Count']++;
               }
            }
        </file>
    </example>
 */
/*global WM */
/*Directive for message */

WM.module('wm.widgets.basic')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/widget/message.html',
            '<p class="alert app-message" data-ng-show="show" init-widget apply-styles ' +
                'data-ng-class=\'{' +
                '"alert-success":messageType.isSuccess, ' +
                '"alert-danger":messageType.isError, ' +
                '"alert-warning":messageType.isWarning, ' +
                '"alert-info":messageType.isInfo, ' +
                '"alert-info alert-loading":messageType.isLoading}\' ' +
                '><i title="{{type}} Alert" class="{{type}} icon {{messageIcon}}"></i>' +
                '<span ng-bind-html="messageContent"></span>' +
                '<button title="Close" type="button" class="btn-transparent close" data-ng-hide="hideclose">&times;</button>' +
            '</p>'
            );
    }])
    .directive('wmMessage', ['PropertiesFactory', '$templateCache', 'WidgetUtilService', '$sce', function (PropertiesFactory, $templateCache, WidgetUtilService, $sce) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.message', ['wm.base']),
            notifyFor = {
                'type': true,
                'dataset': true,
                'caption': true
            };

        /*set caption, type & show properties */
        function setDataSet(dataset, scope) {
            if (!WM.isArray(dataset) && WM.isObject(dataset)) {
                scope.messageContent = $sce.trustAs($sce.HTML, dataset.caption);
                scope.type = dataset.type;
                scope.show = dataset.show = true;
            } else {
                scope.show = false;
            }
        }

        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
        function propertyChangeHandler(scope, attrs, key, newVal) {
            switch (key) {
            case 'type':
                if (newVal === 'success') {
                    scope.messageType = {
                        isSuccess: true
                    };
                    scope.messageIcon = 'glyphicon glyphicon-ok-sign';
                } else if (newVal === 'error') {
                    scope.messageType = {
                        isError: true
                    };
                    scope.messageIcon = 'glyphicon glyphicon-remove-sign';
                } else if (newVal === 'warning') {
                    scope.messageType = {
                        isWarning: true
                    };
                    scope.messageIcon = 'glyphicon glyphicon-alert';
                } else if (newVal === 'warn') {/*Fallback to support old projects with type as "warn"*/
                    scope.type = 'warning';
                } else if (newVal === 'info') {
                    scope.messageType = {
                        isInfo: true
                    };
                    scope.messageIcon = 'glyphicon glyphicon-info-sign';
                } else if (newVal === 'loading') {
                    scope.messageType = {
                        isLoading: true
                    };
                    scope.messageIcon = 'fa fa-spinner fa-spin';
                }
                break;
            case 'dataset':
                if (attrs.dataset) {
                    setDataSet(newVal, scope);
                }
                break;
            case 'caption':
                scope.messageContent = $sce.trustAsHtml(newVal);
                break;
            }
        }

        return {
            'restrict': 'E',
            'replace': true,
            'scope': {
                'scopedataset': '=?',
                'onClose': '&'
            },
            'template': function (tElement, tAttrs) {
                var isWidgetInsideCanvas = tAttrs.hasOwnProperty('widgetid'),
                    template = WM.element($templateCache.get('template/widget/message.html'));

                if (!isWidgetInsideCanvas) {
                    template.children().last().attr('data-ng-click', 'dismiss({$event: $event, $scope: this})');
                }
                return template[0].outerHTML;
            },
            'compile': function () {
                return {
                    'pre': function (scope) {
                        scope.widgetProps = widgetProps;
                    },
                    'post': function (scope, element, attrs) {
                        scope.hideclose = attrs.hideclose || attrs.hideClose || false;

                        /*on-click of close icon*/
                        scope.dismiss = function (eventObject) {
                            /* trigger the onClose function before closing */
                            /*If a javascript function is given call the function directly else trigger the custom 'close' event*/
                            scope.onClose({$event: eventObject.$event, $scope: eventObject.$scope});
                            if (scope.dataset) {
                                scope.dataset.show = false;
                                setDataSet(null, scope);
                            } else if (scope.scopedataset) {
                                scope.scopedataset.show = false;
                                setDataSet(null, scope);
                            } else {
                                scope.show = false;
                            }
                        };

                        /*function to be called explicitly, to manage show/hide properties*/
                        scope.toggle = function (showHide, caption, type) {
                            if (WM.isUndefined(showHide)) {
                                scope.show = !scope.show;
                            } else {
                                scope.show = showHide === 'show' ? true : (showHide === 'hide' ? false : showHide);
                                scope.messageContent = caption || scope.messageContent;
                                scope.type = type || scope.type;
                            }
                        };

                        /* register the property change handler */
                        WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, scope, attrs), scope, notifyFor);

                        /* fields defined in scope: {} MUST be watched explicitly */
                        /*watching model attribute to the data for the message element.*/
                        if (!scope.widgetid) {
                            if (attrs.scopedataset) {
                                scope.$watch('scopedataset', function (newVal) {
                                    setDataSet(newVal, scope);
                                });
                            }
                        }

                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.widgets.basic.directive:wmMessage
 * @restrict E
 *
 * @description
 * The `wmMessage` directive defines the message widget. <br>
 * This widget exposes `dismiss` method which when invoked will destroy the message widget.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires $templateCache
 * @requires WidgetUtilService
 *
 * @param {string=} name
 *                  Name of the message widget.
 * @param {string=} type
 *                  Type of the message. <br>
 *                  Possible values are `success`, `error`, `warn`, and `info`. <br>
 *                  Default value: `success`. <br>
 *                  This is a bindable property.
 * @param {string=} caption
 *                  Content of the message. <br>
 *                  This property is bindable.
 * @param {boolean=} show
 *                  This is a bindable property. <br>
 *                  This property will be used to show/hide the message widget on the web page. <br>
 *                  Default value: `true`. <br>
 * @param {string=} animation
 *                  This property controls the animation of the anchor. <br>
 *                  The animation is based on the css classes and works only in the run mode. <br>
 *                  Possible values are `bounce`, `flash`, `pulse`, `rubberBand`, `shake`, `etc`.
 * @param {string=} on-close
 *                  Callback function which will be triggered when message widget is closed.
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
                <wm-message name="demoMessage" scopedataset="messageDataSet">
                </wm-message>
                <wm-composite>
                    <wm-label caption="Message Type:"></wm-label>
                    <wm-select scopedataset="content" datafield="All Fields" displayfield="type" scopedatavalue="messageDataSet"></wm-select>
                </wm-composite>
            </div>
        </file>
        <file name="script.js">
           function Ctrl($scope) {
               $scope.content = [
                   {
                       type: 'success',
                       caption: 'Success Content'
                   },
                   {
                       type: 'error',
                       caption: 'Error Content'
                   },
                   {
                       type: 'warn',
                       caption: 'Warning Content'
                   },
                   {
                       type: 'info',
                       caption: 'Information Content'
                   }
               ];
               $scope.messageDataSet = $scope.content[0];

            }
        </file>
    </example>
 */
/*global WM */
/*Directive for picture */

WM.module('wm.widgets.basic')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/widget/picture.html',
                '<img init-widget alt="{{hint}}" title="{{hint}}" ng-class="[imgClass]" class="app-picture" data-ng-src="{{imagesource}}" apply-styles data-ng-show="show">'
            );
    }])
    .directive('wmPicture', ['PropertiesFactory', 'WidgetUtilService', 'Utils', function (PropertiesFactory, WidgetUtilService, Utils) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.picture', ['wm.base', 'wm.base.editors', 'wm.base.events']),
            notifyFor = {
                'pictureaspect': true,
                'picturesource': true,
                'shape': true
            };

        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
        function propertyChangeHandler(scope, element, key, newVal) {
            switch (key) {
            case 'pictureaspect':
                switch (newVal) {
                case 'None':
                    element.css({width: '', height: ''});
                    break;
                case 'H':
                    element.css({width: '100%', height: ''});
                    break;
                case 'V':
                    element.css({width: '', height: '100%'});
                    break;
                case 'Both':
                    element.css({width: '100%', height: '100%'});
                    break;
                }
                break;
            case 'picturesource':
                scope.imagesource = Utils.getImageUrl(newVal);
                break;
            case 'shape':
                scope.imgClass = "img-" + newVal;
                break;
            }

        }

        return {
            'restrict': 'E',
            'replace': true,
            'scope': {},
            'template': WidgetUtilService.getPreparedTemplate.bind(undefined, 'template/widget/picture.html'),
            'compile': function () {
                return {
                    'pre': function (scope) {
                        scope.widgetProps = widgetProps;
                    },
                    'post': function (scope, element, attrs) {

                        /* register the property change handler */
                        WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, scope, element), scope, notifyFor);
                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.widgets.basic.directive:wmPicture
 * @restrict E
 *
 * @description
 * The `wmPicture` directive defines the picture widget.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 * @requires Utils
 *
 * @param {string=} name
 *                  Name of the picture widget.
 * @param {string=} hint
 *                  Title/hint for the picture. <br>
 *                  This is a bindable property.
 * @param {number=} tabindex
 *                  This property specifies the tab order of the picture widget.
 * @param {string=} width
 *                  Width of the picture.
 * @param {string=} height
 *                  Height of the picture.
 * @param {string=} pictureaspect
 *                  This property can automatically size an image to the height or width of the picture widget. <br>
 *                  Valid values are: <br>
 *                      `None`: the image is displayed at its default size. <br>
 *                      `H`: image is resized so that the width of the image is the same as the width of the picture widget. <br>
 *                      `V`: image is resized so that the height of the image is the same as the height of the picture widget. <br>
 *                      `Both`: image is resized so that the height and width of the image are same as the height and width of the picture widget. <br>
 *                  Default value is: `None`
 * @param {string=} shape
 *                  This property controls the shape of the picture. <br>
 *                  Valid values are: <br>
 *                      `None`: the image is displayed in its original shape. <br>
 *                      `rounded`: adds rounded corners to an image. <br>
 *                      `circle`: shapes the image to a circle. <br>
 *                      `thumbnail`: shapes the image to a thumbnail.
 * @param {string=} picturesource
 *                  This property specifies the source for the picture. <br>
 *                  This is a bindable property. <br>
 *                  Default value is: `resources/images/imagelists/default-image.png`.
 * @param {boolean=} show
 *                  This property will be used to show/hide the picture widget on the web page. <br>
 *                  This is a bindable property. <br>
 *                  Default value: `true`.
 * @param {boolean=} disabled
 *                  This property will be used to disable/enable the picture widget on the web page. <br>
 *                  This is a bindable property. <br>
 *                  Default value: `false`.
 * @param {string=} animation
 *                  This property controls the animation of the picture widget. <br>
 *                  The animation is based on the css classes and works only in the run mode. <br>
 *                  Possible values are `bounce`, `flash`, `pulse`, `rubberBand`, `shake`, `etc`.
 * @param {string=} on-click
 *                  Callback function which will be triggered when the widget is clicked.
 * @param {string=} on-dblclick
 *                  Callback function which will be triggered when the widget is double-clicked.
 * @param {string=} on-mouseenter.
 *                  Callback function which will be triggered when the mouse enters the widget.
 * @param {string=} on-mouseleave
 *                  Callback function which will be triggered when the mouse leaves the widget.
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
                <wm-composite>
                    <wm-label caption="Select an image:"></wm-label>
                    <wm-select scopedatavalue="image" scopedataset="images"></wm-select>
                </wm-composite>
                <div>single click count: {{clickCount}}</div>
                <div>mouse enter count: {{mouseenterCount}}</div>
                <div>mouse leave count: {{mouseleaveCount}}</div>
                <div style="margin: 20px;"></div>
                <wm-picture picturesource="{{image}}" on-click="f('click')" on-mouseenter="f('mouseenter')"  on-mouseleave="f('mouseleave')"></wm-picture>
            </div>
        </file>
        <file name="script.js">
           function Ctrl($scope) {
               $scope.clickCount = $scope.mouseenterCount = $scope.mouseleaveCount = 0;

               $scope.images = {
                   "http://angularjs.org/img/AngularJS-large.png": "angularJS",
                   "http://c0179631.cdn.cloudfiles.rackspacecloud.com/wavemaker_logo1.jpg": "wavemaker"
               };

               $scope.image = "http://angularjs.org/img/AngularJS-large.png";

               $scope.f = function (eventtype) {
                   $scope[eventtype + 'Count']++;
               }
            }
        </file>
    </example>
 */
/*global WM, document, _ */
/*jslint sub: true*/
/*Directive for popover */

WM.module('wm.widgets.basic')
    .run(['$templateCache', function ($templateCache) {
        'use strict';

        $templateCache.put('template/widget/basic/popover.html',
                '<div class="app-popover popover invisible {{class}} {{popoverplacement}}" data-ng-style="{width : popoverwidth, height : popoverheight}">' +
                    '<div class="arrow" data-ng-show="popoverarrow"></div>' +
                    '<h3 class="popover-title" data-ng-if="title">{{title}}</h3>' +
                    '<wm-container class="popover-content" content="{{content}}"></wm-container>' +
                '</div>');
    }])
    .directive('wmPopover', ['PropertiesFactory', 'WidgetUtilService', '$sce', 'Utils', 'CONSTANTS', '$rootScope', '$compile', '$templateCache', '$timeout', function (PropertiesFactory, WidgetUtilService, $sce, Utils, CONSTANTS, $rootScope, $compile, $templateCache, $timeout) {
        'use strict';

        var widgetProps = PropertiesFactory.getPropertiesOf('wm.popover', ['wm.base', 'wm.base.editors', 'wm.anchor']),
            notifyFor = {
                'iconclass': true,
                'iconurl': true,
                'caption': true,
                'contentsource': CONSTANTS.isStudioMode
            },
            popoverProperties = PropertiesFactory.getPropertiesOf('wm.popover');

        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
        function propertyChangeHandler(scope, element, key, newVal) {
            switch (key) {
            case 'iconposition':
                element.attr('icon-position', newVal);
                break;
            case 'contentsource':
                //check for 2 option inline || partial
                if (newVal === 'inline') {
                    scope.widgetProps.inlinecontent.show = true;
                    scope.widgetProps.content.show = false;
                } else {
                    scope.widgetProps.content.show = true;
                    scope.widgetProps.inlinecontent.show = false;
                }

                break;
            case 'iconclass':
                /*showing icon when iconurl is not set*/
                scope.showicon = scope.iconclass !== '_none_' && newVal !== '' && !scope.iconurl;
                break;
            case 'iconurl':
                /*hiding icon when iconurl is set*/
                /*showing icon when iconurl is not set*/
                var showIcon = newVal === '';
                scope.showicon = showIcon;
                scope.showimage = !showIcon;
                scope.iconsrc = Utils.getImageUrl(newVal);
                break;
            case 'caption':
                if (WM.isObject(newVal)) {
                    element.find('>span.anchor-caption').text(JSON.stringify(newVal));
                } else {
                    element.find('>span.anchor-caption').html(($sce.trustAs($sce.HTML, newVal.toString()).toString()));
                }
                break;
            }
        }

        /* returns element dimensions' absolute value*/
        function getEleDimensions(ele) {
            return {
                'width' : Math.abs(ele.outerWidth()),
                'height' : Math.abs(ele.outerHeight())
            };
        }
        /**
         * Object to listen for an event on an element's parent but not on the element itself.
         *
         * @param parent - element whose events have to be listened.
         * @param child  - element whose events have to be skipped.
         * @constructor
         */
        function ParentEventListener(parent, child) {
            var processEvent = false,
                objectId = 'parenteventlistener' + new Date().getTime();
            function getEventName(event) {
                return event + '.' + objectId;
            }
            /* add callback to invoke when the event occurs */
            this.on = function (event, callBack) {
                var eventName = getEventName(event);
                child.off(eventName).on(eventName, function () {
                    processEvent = false;
                });
                parent.off(eventName).on(eventName, function (event) {
                    if (processEvent) {
                        Utils.triggerFn(callBack, event);
                    } else {
                        processEvent = true;
                    }
                });
            };
            /* turns off event listening */
            this.off = function (event) {
                var eventName = getEventName(event);
                processEvent = false;
                child.off(eventName);
                parent.off(eventName);
            };
        }
        /**
         * Computes popover position based on the available port area and placement preference.
         * @param hook - element, in relative to which the popover has to be placed.
         * @param popoverEle - the popver element for which the position has to be computed.
         * @param placement - [left, right, top, bottom] in reference to hook.
         * @returns {{left: *, top: *}}
         */
        function computePopoverPosition(hook, popoverEle, placement) {
            var popoverDims = getEleDimensions(popoverEle),
                arrow = popoverEle.find('.arrow'),
                arrowDims = {'width' : 0, height : 0},
                documentDims = getEleDimensions(WM.element(document)),
                targetDims = getEleDimensions(hook),
                targetPosition = hook.offset(),
                tipOffset = {
                    'width': -arrowDims.width / 2,
                    'height': -arrowDims.height / 2
                },
                popoverPosition = {
                    'left' : targetPosition.left + tipOffset.width,
                    'top'  : targetPosition.top + tipOffset.height
                };
            if (placement === 'left' || placement === 'right') {
                if (placement === 'left') {
                    popoverPosition.left += (-1 * (popoverDims.width + arrowDims.width));
                } else {
                    popoverPosition.left += targetDims.width + arrowDims.width;
                }
                if (targetPosition.top + popoverDims.height <= documentDims.height) {
                    arrow.addClass('top');
                } else {
                    popoverPosition.top = targetPosition.top + targetDims.height - popoverDims.height;
                    arrow.addClass('bottom');
                }
            } else if (placement === 'top' || placement === 'bottom') {
                if (placement === 'top') {
                    popoverPosition.top += (-1 * popoverDims.height);
                } else {
                    popoverPosition.top += targetDims.height + arrowDims.height;
                }
                if (targetPosition.left + popoverDims.width <= documentDims.width) {
                    arrow.addClass('left');
                } else {
                    popoverPosition.left = targetPosition.left + targetDims.width - popoverDims.width;
                    arrow.addClass('right');
                }
            }
            return popoverPosition;
        }

        /**
         * Constructs popover inheriting from the controller scope
         * @param element - target element to which the popiver has to be attached.
         * @returns a scope to use for popover
         */
        function createPopoverScope(element) {
            var scope = element.isolateScope(),
                popoverScope = element.scope().$new(true);
            _.forEach(_.keys(popoverProperties), function (k) {
                popoverScope[k] = scope[k];
            });
            return popoverScope;
        }
        /**
         * Transfers focus to the first focusable child of the given element.
         * Following are focusable elements.
         * 1) Element with tabIndex
         * 2) input or button or select
         * @param element
         */
        function shiftFocusToChild(element) {
            var selectors = ['[tabindex]:first', 'button:first,input:first,select:first'];
            _.forEach(selectors, function (selector) {
                var e = element.find(selector);
                if (e.length > 0) {
                    e.focus();
                    return false;
                }
            });
        }

        /**
         * Constructs Popover element and adds it to the top-level page.
         *
         * @param element element to which the popover has to be hooked.
         * @param onOpen  callback to invoke when popover is visible.
         * @param onClose callback to invoke when popover closes automatically.
         * @constructor
         */
        function Popover(element, transcludeFn, isInlineContent, onOpen, onClose) {
            var scope = element.isolateScope(),
                popoverScope = createPopoverScope(element),
                page = $rootScope.$activePageEl,
                popoverEle = $compile($templateCache.get('template/widget/basic/popover.html'))(popoverScope),
                pageClickListener;
            page.append(popoverEle);
            popoverEle.show();
            //check if inline content
            if (isInlineContent) {
                transcludeFn(element.scope(), function (clone) {
                    popoverEle.find('> .popover-content').append(clone);
                });
            } else {
                /**
                 * When the page content is ready, copy the widgets and variables to the scope.
                 */
                popoverScope.$on('on-pagecontainer-ready', function ($event) {
                    $event.stopPropagation();
                    var includedPageScope = popoverEle.find('[data-ng-controller]:first').scope();
                    scope.Widgets = includedPageScope.Widgets;
                    scope.Variables = includedPageScope.Variables;
                    Utils.triggerFn(onOpen);
                });
            }
            /**
             * Do calculations after the current digest cycle.
             * This is to make sure that all the popover scope values are applied on to the dom.
             */
            $timeout(function () {
                popoverEle.css(computePopoverPosition(element, popoverEle, popoverScope.popoverplacement));
                popoverEle.removeClass('invisible');
                shiftFocusToChild(popoverEle);
            });
            if (popoverScope.popoverautoclose) {
                pageClickListener = new ParentEventListener(page, popoverEle);
                pageClickListener.on('click', function (event) {
                    Utils.triggerFn(onClose, event);
                });
            }
            /**
             * Does the clean up.
             */
            this.destroy = function () {
                if (pageClickListener) { pageClickListener.off('click'); }
                popoverScope.$destroy();
                popoverEle.remove();
                popoverScope = popoverEle = undefined;
                delete scope['Widgets'];
                delete scope['Variables'];
            };
        }
        return {
            'restrict': 'E',
            'replace': true,
            'scope': {},
            'transclude': true,
            'template': function () {
                var template = WM.element($templateCache.get('template/widget/anchor.html'));
                if (CONSTANTS.isRunMode) {
                    template.attr('data-ng-click', 'togglePopover($event)');
                    template.attr('data-ng-keydown', 'togglePopover($event)');
                }
                template.addClass('app-popover-anchor');
                return template[0].outerHTML;
            },
            'compile': function (tElement) {
                return {
                    'pre': function (scope) {
                        scope.showicon = !scope.iconurl;
                        scope.widgetProps = Utils.getClonedObject(widgetProps);
                    },
                    'post': function (scope, element, attrs, nullCtrl, transcludeFn) {
                        var popover,
                            isInlineContent = (attrs.contentsource === 'inline'),
                            onOpen = function (event) {
                                Utils.triggerFn(scope.onShow, {'$event': event, '$scope' : scope});
                            },
                            onClose = function (event) {
                                scope.togglePopover(event);
                            };
                        if (CONSTANTS.isRunMode) {
                            scope.togglePopover = function (event) {
                                if (event.keyCode && event.keyCode !== 13) {
                                    //If it is a key event and Enter key, then process it.
                                    return;
                                }
                                if (popover) {
                                    //destroy the existing popover
                                    popover.destroy();
                                    popover = undefined;
                                    element.removeClass('app-popover-open');
                                    //Set the focus basck to anchor element
                                    element.focus();
                                    Utils.triggerFn(scope.onHide, {'$event': event, '$scope': scope});
                                } else {
                                    popover = new Popover(element, transcludeFn, isInlineContent, onOpen.bind(undefined, event), onClose);
                                    element.addClass('app-popover-open');
                                }
                                return false;
                            };

                        } else {
                            /* if content is provided as an attribute, give it preference */
                            scope.inlinecontent = tElement.context.innerHTML;
                        }

                        WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, scope, element), scope, notifyFor);
                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.widgets.basic.directive:wmPopover
 * @restrict E
 *
 * @description
 * The `wmPopover` directive defines the popover widget.
 * It can be dragged and moved in the canvas.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 * @requires $sce
 * @requires Utils
 * @requires CONSTANTS
 *
 * @param {string=} name
 *                  Name of the popover.
 * @param {string=} hint
 *                  Title/hint for the anchor. <br>
 *                  This is a bindable property.
 * @param {string=} caption
 *                  Content of the popover. <br>
 *                  This is a bindable property.
 * @param {number=} tabindex
 *                  This property specifies the tab order of the popover.
 * @param {string=} content
 *                  This property specifies the content of the popover widget. <br>
 *                  Possible values are `Inline content` and `Page's content`. <br>
 *                  Page's content values are `login`, `footer`, `header`, `lefnav`, `rightnav`, and `topnav`.
 * @param {boolean=} show
 *                  This is a bindable property. <br>
 *                  This property will be used to show/hide the popover on the web page. <br>
 *                  Default value: `true`. <br>
 * @param {string=} contentsource
 *                  Content source for the popover. <br>
 *                  Possible values are `partial` and `inline`. <br>
 *                  Default value: `partial`.
 * @param {string=} title
 *                  Title for the popover.
 * @param {string=} popoverplacement
 *                  This property defines the position of the popover <br>
 *                  Possible values are 'top', 'bottom', 'left', and 'right'. <br>
 *                  Default value: `bottom`.
 * @param {boolean=} popoverarrow
 *                  If set true, then a arrow pointer will be shown. <br>
 *                  Default value: `true`.
 * @param {boolean=} popoverautoclose
 *                  If set true, then a click on the document (except popover content) will automatically close the popover. <br>
 *                  Default value: `true`.
 * @param {string=} animation
 *                  This property controls the animation of the popover widget. <br>
 *                  The animation is based on the css classes and works only in the run mode. <br>
 *                  Possible values are `bounce`, `flash`, `pulse`, `rubberBand`, `shake`, `etc`.
 * @param {string=} iconclass
 *                  CSS class for the icon. <br>
 *                  This is a bindable property.
 * @param {string=} iconurl
 *                  url of the icon. <br>
 *                  This is a bindable property.
 * @param {string=} iconwidth
 *                  Width of the icon. <br>
 *                  Default value: 16px
 * @param {string=} iconheight
 *                  Height of the icon. <br>
 *                  Default value: 16px
 * @param {string=} iconmargin
 *                  Margin of the icon.
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
                <br>
                <wm-page ng-controller="WM.noop">
                    <wm-popover caption="Click here to see the popover including the content from a partial"
                        content="dropdownMenu"
                        popoverwidth="300"
                        popoverheight="200"
                        popoverautoclose="true"
                        popoverplacement="bottom"
                        popoverarrow="true"
                        title="Popover Title"
                        contentsource="partial">
                    </wm-popover>

                    <br/><br/>
                    <wm-popover caption="Click here to see the inline content popover"
                        popoverwidth="300"
                        popoverheight="200"
                        popoverautoclose="true"
                        popoverplacement="bottom"
                        popoverarrow="true"
                        title="Popover Title"
                        contentsource="inline">
                        <wm-label caption="I am inline popover"></wm-label>
                    </wm-popover>
                </wm-page>

            </div>
        </file>
        <file name="script.js">
            function Ctrl($scope) {}
        </file>
        <file name="style.css">
            .wm-app, .app-page {
                position: static !important; // these are required only for the documentation example
            }
        </file>
    </example>
 */
/*global WM */
/*Directive for video */

WM.module('wm.widgets.basic')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/widget/video.html',
            '<video init-widget alt="{{hint}}" title="{{hint}}" class="app-video" preload="{{videopreload}}" data-ng-attr-poster="{{postersource}}" data-ng-src="{{mp4videoUrl}}" apply-styles data-ng-show="show" >' +
                '<source type="video/mp4" data-ng-src="{{mp4videoUrl}}" data-ng-if="mp4videoUrl">' +
                '<source type="video/webm" data-ng-src="{{webmvideoUrl}}" data-ng-if="webmvideoUrl">' +
                '<source type="video/ogg" data-ng-src="{{oggvideoUrl}}" data-ng-if="oggvideoUrl">' +
                '<track kind="subtitles" label="{{subtitlelang}}" data-ng-if="tracksource" data-ng-src="{{tracksource}}" srclang="{{subtitlelang}}" default>' +
                '{{videosupportmessage}}' +
            '</video>'
            );
    }]).directive('wmVideo', ['PropertiesFactory', '$templateCache', 'WidgetUtilService', 'Utils', '$sce', 'CONSTANTS', function (PropertiesFactory, $templateCache, WidgetUtilService, Utils, $sce, CONSTANTS) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.video', ['wm.base', 'wm.containers']),
            notifyFor = {
                'videoposter': true,
                'mp4format': true,
                'oggformat': true,
                'webmformat': true,
                'subtitlesource': true
            };

        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
        function propertyChangeHandler(scope, key, newVal) {
            switch (key) {
            case 'videoposter':
                scope.postersource = Utils.getImageUrl(newVal);
                break;
            case 'mp4format':
                if (WM.isString(newVal) && newVal.indexOf('Variables') === -1) {
                    scope.mp4videoUrl =  $sce.trustAsResourceUrl(newVal);
                }
                break;
            case 'oggformat':
                if (WM.isString(newVal) && newVal.indexOf('Variables') === -1) {
                    scope.oggvideoUrl =  $sce.trustAsResourceUrl(newVal);
                }
                break;
            case 'webmformat':
                if (WM.isString(newVal) && newVal.indexOf('Variables') === -1) {
                    scope.webmvideoUrl =  $sce.trustAsResourceUrl(newVal);
                }
                break;
            case 'subtitlesource':
                if (WM.isString(newVal) && newVal.length && newVal.indexOf('Variables') === -1) {
                    scope.tracksource =  Utils.getResourceUrl(newVal);
                }
                break;
            }
        }

        return {
            'restrict': 'E',
            'replace': true,
            'scope': {},
            'template': $templateCache.get('template/widget/video.html'),
            'compile': function (tElement) {

                // donot play the media in studio mode
                if (CONSTANTS.isStudioMode) {
                    tElement.removeAttr('autoplay');
                }

                return {
                    'pre': function (scope) {
                        scope.widgetProps = widgetProps;
                    },
                    'post': function (scope, element, attrs) {
                        /* register the property change handler */
                        WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, scope), scope, notifyFor);

                        // update the mute property manually
                        element.removeAttr('muted');
                        element[0].muted = attrs.hasOwnProperty('muted') && attrs.muted !== 'false';

                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.widgets.basic.directive:wmVideo
 * @restrict E
 *
 * @description
 * The `wmVideo` directive defines the Video widget.
 * It can be dragged and moved in the canvas.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires $rootScope
 * @requires $templateCache
 * @requires WidgetUtilService
 * @requires Utils
 * @requires $sce
 * @requires CONSTANTS
 *
 * @param {string=} name
 *                  Name of the video widget.
 * @param {string=} hint
 *                  Title/hint for the video. <br>
 *                  This is a bindable property.
 * @param {number=} tabindex
 *                  This property specifies the tab order of the video widget.
 * @param {string=} width
 *                  Width of the video.
 * @param {string=} height
 *                  Height of the video.
 * @param {string=} videoposter
 *                  poster of the video. <br>
 *                  This is a bindable property.
 * @param {string=} mp4format
 *                  mp4 format of the video. <br>
 *                  This is a bindable property.
 * @param {string=} oggformat
 *                  ogg format of the video. <br>
 *                  This is a bindable property.
 * @param {string=} webmformat
 *                  webm format of the video. <br>
 *                  This is a bindable property.
 * @param {string=} videopreload
 *                  Preload options for the video. <br>
 *                  The possible values are `none`, `metadata` and `auto`. <br>
 *                  Default value: `none`.
 * @param {string=} videosupportmessage
 *                  The message shown to the user when the Html5 video is not supported.
 * @param {string=} subtitlesource
 *                  This property allows to set the source url for the subtitle in the .vtt format. <br>
 *                  This is a bindable property.
 * @param {string=} subtitlelang
 *                  This property allows to set the language for the subtitle. <br>
 *                  This is a bindable property.
 * @param {boolean=} show
 *                  This is a bindable property. <br>
 *                  This property will be used to show/hide the video widget on the web page. <br>
 *                  Default value: `true`. <br>
 * @param {boolean=} controls
 *                  If set true, this property will enable the controls for the video. <br>
 *                  Default value: `true`.
 * @param {boolean=} autoplay
 *                  If set true, this property will enable the autoplay for the video. <br>
 *                  Default value: `false`.
 * @param {boolean=} loop
 *                  If set true, this property will enable the loop for the video. <br>
 *                  Default value: `false`.
 * @param {boolean=} muted
 *                  If set true, this property will disable the sound for the video. <br>
 *                  Default value: `false`.
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
                <wm-video videopreload="none" muted="true"
                   videoposter="{{video.poster}}"
                   mp4format="{{video.source.mp4}}"
                   oggformat="{{video.source.ogg}}"
                   webmformat="{{video.source.webm}}"
                   controls="controls">
                </wm-video>
            </div>
        </file>
        <file name="script.js">
           function Ctrl($scope) {
               $scope.video = {
                   "poster": "http://static.splashnology.com/articles/html5-video-players/videojs.jpg",
                   "source": {
                       "mp4": "http://vjs.zencdn.net/v/oceans.mp4",
                       "ogg": "http://www.w3schools.com/html/movie.ogg",
                       "webm": "http://www.w3schools.com/html/movie.webm"
                   }
               }
           }
        </file>
    </example>
 */
/*global WM */
/*Directive for audio */

WM.module('wm.widgets.basic')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/widget/audio.html',
            '<audio init-widget alt="{{hint}}" title="{{hint}}" class="app-audio" preload="{{audiopreload}}" data-ng-src="{{mp3audioUrl}}" apply-styles data-ng-show="show" >' +
                '<source type="audio/mp3" ng-src="{{mp3audioUrl}}">' +
                '{{audiosupportmessage}}' +
                '</audio>');
    }]).directive('wmAudio', ['PropertiesFactory', '$templateCache', 'WidgetUtilService', '$sce', 'CONSTANTS', function (PropertiesFactory, $templateCache, WidgetUtilService, $sce, CONSTANTS) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.audio', ['wm.base', 'wm.containers']),
            notifyFor = {
                'mp3format': true
            };
        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
        function propertyChangeHandler(scope, key, newVal) {
            switch (key) {
            case 'mp3format':
                if (WM.isString(newVal) && newVal.indexOf('Variables') === -1) {
                    scope.mp3audioUrl = $sce.trustAsResourceUrl(newVal);
                }
                break;
            }
        }

        return {
            'restrict': 'E',
            'replace': true,
            'scope': {},
            'template': $templateCache.get('template/widget/audio.html'),
            'compile': function (tElement) {

                // donot play the media in studio mode
                if (CONSTANTS.isStudioMode) {
                    tElement.removeAttr('autoplay');
                }

                return {
                    'pre': function (scope) {
                        scope.widgetProps = widgetProps;
                    },
                    'post': function (scope, element, attrs) {
                        /* register the property change handler */
                        WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, scope), scope, notifyFor);

                        // update the mute property manually
                        element.removeAttr('muted');
                        element[0].muted = attrs.hasOwnProperty('muted') && attrs.muted !== 'false';

                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.widgets.basic.directive:wmAudio
 * @restrict E
 *
 * @description
 * The `wmAudio` directive defines the Audio widget.
 * It can be dragged and moved in the canvas.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires $rootScope
 * @requires $templateCache
 * @requires WidgetUtilService
 * @requires Utils
 * @requires $sce
 * @requires CONSTANTS
 *
 * @param {string=} name
 *                  Name of the audio widget.
 * @param {string=} hint
 *                  Title/hint for the audio. <br>
 *                  This is a bindable property.
 * @param {number=} tabindex
 *                  This property specifies the tab order of the audio widget.
 * @param {string=} width
 *                  Width of the audio.
 * @param {string=} height
 *                  Height of the audio.
 * @param {string=} mp3format
 *                  mp3 format of the audio. <br>
 *                  This is a bindable property.
 * @param {string=} audiopreload
 *                  audiopreload options for the audio. <br>
 *                  Possible values are `none`, `metadata`, and `auto`. <br>
 *                  Default value: `none`.
 * @param {string=} audiosupportmessage
 *                  The message shown to the user when the Html5 audio is not supported.
 * @param {boolean=} show
 *                  This is a bindable property. <br>
 *                  This property will be used to show/hide the audio widget on the web page. <br>
 *                  Default value: `true`. <br>
 * @param {boolean=} controls
 *                  If true, this property will enable the controls for the audio. <br>
 *                  Default value: `true`.
 * @param {boolean=} autoplay
 *                  If true, this property will enable the autoplay for the audio. <br>
 *                  Default value: `false`.
 * @param {boolean=} loop
 *                  If true, this property will enable the loop for the audio. <br>
 *                  Default value: `false`.
 * @param {boolean=} muted
 *                  If true, this property will disable the sound for the audio. <br>
 *                  Default value: `false`.
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
                <wm-audio audiopreload="none" muted="true"
                   mp3format="{{audio.source.mp3}}"
                   controls="controls">
                </wm-audio>
            </div>
        </file>
        <file name="script.js">
           function Ctrl($scope) {
               $scope.audio = {
                   "source": {
                       "mp3": "http://www.stephaniequinn.com/Music/Vivaldi%20-%20Spring%20from%20Four%20Seasons.mp3"
                   }
               }
           }
        </file>
    </example>
 */

/*global WM, _ */
/*jslint todo: true */
/*Directive for search */

WM.module('wm.widgets.basic')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/widget/form/searchlist.html',
            '<a>' +
                '<img data-ng-src="{{match.model.wmImgSrc}}" data-ng-if="match.model.wmImgSrc" width="16">' +
                '<span ng-bind-html="match.label | uibTypeaheadHighlight:query"></span>' +
            '</a>'
            );
        $templateCache.put('template/widget/form/search.html',
            '<div class="app-search input-group" init-widget has-model' +
                ' data-ng-show="show"' +
                ' data-ng-style="{' +
                    ' color: color, ' +
                    ' height: height, ' +
                    ' width: width, ' +
                    ' cursor: cursor, ' +
                    ' fontFamily: fontfamily, ' +
                    ' fontSize: fontsize, ' +
                    ' fontWeight: fontweight, ' +
                    ' fontStyle: fontstyle, ' +
                    ' opacity: opacity, ' +
                    ' textDecoration: textdecoration, ' +
                    ' whiteSpace: whitespace, ' +
                    ' wordBreak: wordbreak, ' +
                    ' zIndex: zindex' +
                ' }">' +
                    '<input title="{{hint}}" data-ng-if="dataSetType === \'listOfObjects\'" type="text" class="app-textbox form-control list-of-objs" placeholder="{{placeholder}}" ' +
                        'data-ng-model="query"' +
                        ' tabindex="{{tabindex}}"' +
                        ' accesskey="{{shortcutkey}}"' +
                        'uib-typeahead="item[displaylabel] for item in itemList | _custom_search_filter:searchkey:$viewValue:casesensitive | limitTo:limit" ' +
                        'typeahead-on-select="onTypeAheadSelect($event, $item, $model, $label)"' +
                        'typeahead-template-url="template/widget/form/searchlist.html"' +
                    '>' +
                    '<input title="{{hint}}" data-ng-if="dataSetType === \'listOfStrings\'" type="text" class="app-textbox form-control list-of-strings" placeholder="{{placeholder}}"' +
                        'data-ng-model="query"' +
                        ' accesskey="{{shortcutkey}}"' +
                        ' tabindex="{{tabindex}}"' +
                        'uib-typeahead="item for item in itemList | filter:$viewValue:casesensitive | limitTo:limit" ' +
                        'typeahead-on-select="onTypeAheadSelect($event, $item, $model, $label)"' +
                        'typeahead-template-url="template/widget/form/searchlist.html"' +
                    '>' +
                '<span class="input-group-addon" data-ng-if="dataSetType === \'listOfObjects\' || dataSetType === \'listOfStrings\'" >' +
                    '<form data-ng-submit="onSubmit({$event: $event, $scope: this})" >' +
                        '<button title="Search" class="app-search-button glyphicon glyphicon-search" type="submit" ' +
                            'data-ng-click="onTypeAheadSelect($event, $item, $model, $label)"' +
                        '></button>' +
                    '</form>' +
                '</span>' +
            '</div>'
            );
        // this template is specify to search widget in mobile-navbar
        $templateCache.put('template/widget/form/navsearch.html',
            '<div class="app-mobile-search" init-widget has-model>' +
                '<input title="{{hint}}" data-ng-if="dataSetType === \'listOfObjects\'" type="text" class="form-control list-of-objs" placeholder="{{placeholder}}" ' +
                    'data-ng-model="query"' +
                    ' accesskey="{{shortcutkey}}"' +
                    'uib-typeahead="item[displaylabel] for item in itemList | _custom_search_filter:searchkey:$viewValue:casesensitive | limitTo:limit" ' +
                    'typeahead-on-select="onTypeAheadSelect($event, $item, $model, $label)"' +
                    'typeahead-template-url="template/widget/form/searchlist.html"' +
                '>' +
                '<input title="{{hint}}" data-ng-if="dataSetType === \'listOfStrings\'" type="text" class="form-control list-of-strings" placeholder="{{placeholder}}"' +
                    'data-ng-model="query"' +
                    ' accesskey="{{shortcutkey}}"' +
                    'uib-typeahead="item for item in itemList | filter:$viewValue:casesensitive | limitTo:limit" ' +
                    'typeahead-on-select="onTypeAheadSelect($event, $item, $model, $label)"' +
                    'typeahead-template-url="template/widget/form/searchlist.html"' +
                '>' +
                '<i class="btn-close glyphicon glyphicon-remove" data-ng-show="showClosebtn" data-ng-click="clearText();"></i>' +
            '</div>'
            );
    }])
    .filter('_custom_search_filter', function () {
        'use strict';
        return function (entries, key, val, casesensitive) {
            // filter the entries based on the $is.searchkey and the input
            if (!key) {
                return entries;
            }

            return _.filter(entries, function (entry) {
                var a = entry[key], b = val;
                if (!casesensitive) {
                    a = a && a.toLowerCase();
                    b = b && b.toLowerCase();
                }
                return _.includes(a, b);
            });
        };
    })
    .directive('wmSearch', ['PropertiesFactory', 'WidgetUtilService', 'CONSTANTS', 'Utils', '$timeout', function (PropertiesFactory, WidgetUtilService, CONSTANTS, Utils, $timeout) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.search', ['wm.base']),
            dataSetRegEx = new RegExp(/scopedataset\./ig),
            notifyFor = {
                'searchkey': true,
                'displaylabel': true,
                'dataset': true,
                'displayimagesrc': true,
                'active': true
            };

        // to filter & set the dataset property of the search widget
        function setDataSet(data, scope) {
            // sanity check for data availability
            if (!data) {
                // checking if dataSetType is available or not
                if (!scope.dataSetType && !scope.binddataset) {
                    scope.dataSetType = 'listOfStrings';
                } else if (scope.binddataset) {
                    scope.dataSetType = 'listOfObjects';
                }

                // checking if itemList is available or not
                if (!scope.itemList) {
                    scope.itemList = [];
                }
                return;
            }

            if (CONSTANTS.isRunMode) {
                // get the variable-data w.r.t the variable type
                data = (data && data.data) || data;
                // set data-set
                var dataSet = Utils.getClonedObject(data);
                // if data-set is an array, show the 'listOfObjects' mode
                if (WM.isArray(dataSet)) {
                    // check if dataSet contains list of objects, then switch to 'listOfObjects', else display 'default'
                    if (WM.isObject(dataSet[0])) {
                        scope.dataSetType = 'listOfObjects';
                        WM.forEach(dataSet, function (eachItem, index) {
                            // convert display-label-value to string, as ui.typeahead expects only strings
                            dataSet[index][scope.displaylabel] = eachItem[scope.displaylabel] && eachItem[scope.displaylabel].toString();
                            // to save all the image urls
                            dataSet[index].wmImgSrc = eachItem[scope.displayimagesrc];
                        });
                    } else {
                        scope.dataSetType = 'listOfStrings';
                        // convert all the values in the array to strings
                        WM.forEach(dataSet, function (val, index) {
                            dataSet[index] = val.toString();
                        });
                    }

                    // set the itemList
                    scope.itemList = dataSet;

                } else if (WM.isString(dataSet) && dataSet.trim()) {
                    // make the string an array, for ex. => if dataSet is 1,2,3 then make it [1,2,3]
                    setDataSet(dataSet.split(','), scope);
                } else if (WM.isObject(dataSet)) {
                    setDataSet(Object.keys(dataSet).join(','), scope);
                }
            }
        }

        // update search-key, display-label in the property panel
        function updatePropertyPanelOptions(dataset, scope) {
            var variableKeys = [];
            // on binding of data
            if (dataset) {
                dataset = dataset[0] || dataset;
                variableKeys = WM.isObject(dataset) && !WM.isArray(dataset) ? Object.keys(dataset || {}) : [];
            }

            // re-initialize the property values
            if (scope.newcolumns) {
                scope.newcolumns = false;
                scope.searchkey = '';
                scope.displaylabel = '';
                scope.datafield = '';
                scope.$root.$emit("set-markup-attr", scope.widgetid, {'searchkey': scope.searchkey, 'datafield': scope.datafield, 'displaylabel': scope.displaylabel});
            }

            // assign all the keys to the options of the search widget
            scope.widgetProps.searchkey.options = scope.widgetProps.displaylabel.options = scope.widgetProps.displayimagesrc.options = [''].concat(variableKeys);
            scope.widgetProps.datafield.options = ['All Fields'].concat(variableKeys);
        }

        // update the query and datavalue before submit.
        function onsearchSubmit($is) {
            if ($is.onSearch) {
                $is.onSearch({$scope: $is});
            }
        }

        // onkeyup show the close icon.
        function onKeyUp(scope, element, event) {
            var $navbarElScope,
                _action,
                inputVal = element.find('input').val();

            if (element.hasClass('app-mobile-search')) {
                //update query on the input val change
                $navbarElScope = element.closest('[data-role="mobile-navbar"]').isolateScope();
                $navbarElScope.query = inputVal;
                scope.query = inputVal;

                _action = Utils.getActionFromKey(event);
                if (_action === 'ENTER') {
                    onsearchSubmit($navbarElScope, element);
                }
            }

            scope.$evalAsync(function () {
                scope.showClosebtn = (inputVal !== '');
            });
        }

        // this function updates the search widgets query if datavalue is set.
        function updateQuery(scope, element) {
            if (scope.datavalue) {
                var ctrl, newVal;

                $timeout(function () {
                    var deregister = scope.$watch(function () {
                        var $ele;
                        if (scope.dataSetType === 'listOfObjects') {
                            $ele = element.find('input.list-of-objs');
                        } else {
                            $ele = element.find('input.list-of-strings');
                        }
                        ctrl = $ele.controller('uibTypeahead');
                        if (ctrl) {
                            deregister(); // deregister the watch.

                            newVal = scope.datavalue;
                            // set the query based on datavalue
                            if (WM.isString(newVal)) {
                                scope.query = scope.datavalue;
                            } else if (WM.isObject(newVal)) {
                                if (scope.searchkey) {
                                    scope.query = newVal[scope.searchkey] || '';
                                }
                            }
                            // show the close icon if query is set by default
                            if (scope.query.length > 0) {
                                scope.showClosebtn = true;
                            }

                        }
                    });
                });
            }
        }

        // depending on the dataSetType the default query is updated.
        function setupDataSetTypeListner(scope, element) {
            scope._datasetTypeListener = scope.$watch('dataSetType', function () {
                if (scope.datavalue) {
                    updateQuery(scope, element);
                }
            });
        }


        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
        function propertyChangeHandler(scope, key, newVal) {
            switch (key) {
            case 'searchkey':
                scope.searchkey = newVal && newVal.replace(dataSetRegEx, '');
                break;
            case 'displaylabel':
                scope.displaylabel = newVal && newVal.replace(dataSetRegEx, '');
                break;
            case 'dataset':
                // if studio-mode, then update the search-key, display-label in property panel
                if (scope.widgetid) {
                    updatePropertyPanelOptions((newVal && newVal.data) || newVal, scope);
                }
                // set the datatSet of the widget
                setDataSet(newVal, scope);
                break;
            case 'displayimagesrc':
                scope.displayimagesrc = newVal;
                break;
            case 'active':
                /*listening on 'active' property, as losing the properties during page switch
                if studio-mode, then update the displayField & dataField in property panel*/
                if (scope.widgetid && newVal) {
                    updatePropertyPanelOptions((scope.dataset && scope.dataset.data) || scope.dataset, scope);
                }
                break;
            }
        }

        return {
            'restrict': 'E',
            'replace': true,
            'scope': {
                'scopedataset': '=?',
                'onSubmit': '&'
            },
            'template': function (tElement, tAttrs) {
                var template, url = '';
                if (tAttrs.navsearchbar) {
                    url = 'template/widget/form/navsearch.html';
                } else {
                    url = 'template/widget/form/search.html';
                }
                template = WM.element(WidgetUtilService.getPreparedTemplate(url, tElement, tAttrs));
                return template[0].outerHTML;
            },
            'compile': function () {
                return {
                    'pre': function (scope) {
                        scope.widgetProps = widgetProps;
                    },
                    'post': function (scope, element, attrs) {

                        // In Studio mode aways display the input box
                        if (CONSTANTS.isStudioMode) {
                            scope.dataSetType = "listOfStrings";
                        }

                        // register the property change handler
                        WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, scope), scope, notifyFor);

                        // on-select of type-ahead element, call the user-defined submit fn
                        scope.onTypeAheadSelect = function ($event, $item, $model, $label) {
                            $event = $event || {};
                            // 'wmImgSrc' attr is found for the item select, then delete it
                            if ($item && $item.wmImgSrc) {
                                $item = Utils.getClonedObject($item);
                                delete $item.wmImgSrc;
                            }
                            // add the selected object to the event.data and send to the user
                            $event.data = {'item': $item, 'model': $model, 'label': $label, 'query': element.find('input').val()};

                            // set selected item on widget's exposed property
                            scope.datavalue = (scope.datafield && scope.datafield !== 'All Fields') ? $item[scope.datafield] : $item;

                            // call user 'onSubmit' fn
                            scope.onSubmit({$event: $event, $scope: scope});
                        };

                        /* fields defined in scope: {} MUST be watched explicitly
                            watching model attribute to the data for the search element.*/
                        scope.$watch('scopedataset', function (newVal) {
                            setDataSet(newVal, scope);
                        });

                        // this functions clears the input value
                        scope.clearText = function () {
                            element.find('input').val('');
                            scope.showClosebtn = false;
                        };

                        // set the searchquery if the datavalue exists.
                        if (CONSTANTS.isRunMode) {
                            // keyup event to enable/ disable close icon of the search input.
                            element.bind('keyup', onKeyUp.bind(undefined, scope, element));

                            setupDataSetTypeListner(scope, element);
                        }
                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                        element.removeAttr('tabindex');
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.widgets.basic.directive:wmSearch
 * @restrict E
 *
 * @description
 * The `wmSearch` directive defines the search widget. <br>
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires $templateCache
 * @requires WidgetUtilService
 * @requires CONSTANTS
 *
 * @param {string=}  name
 *                   Name of the search widget.
 * @param {string=}  placeholder
 *                   Placeholder for the search widget.
 * @param {number=} tabindex
 *                  This property specifies the tab order of the search widget.
 * @param {string=}  scopedataset
 *                   The script variable that contains the data to be provided the search widget, that can be searched onto.
 * @param {string=}  dataset
 *                   The data to be provided the search widget from a live variable or the property panel, that can be searched onto. <br>
 *                   This is a bindable property.
 * @param {string=}  limit
 *                   Limits the search results to be displayed in the auto-complete.
 * @param {string=}  searchkey
 *                   The key to be search in the data provided to the search widget.
 * @param {string=}  displaylabel
 *                   The property to be displayed in the search auto-complete.
 * @param {string=}  imagesource
 *                  This property sets the image to be displayed in the search results.
 * @param {string=}  datafield
 *                   This property sets the dataValue to be returned by a select editor when the list is populated using the dataSet property.
 * @param {boolean=} show
 *                  This is a bindable property. <br>
 *                  This property will be used to show/hide the search widget on the web page. <br>
 *                  Default value: `true`.
 * @param {boolean=} casesensitive
 *                  This property decides whether search will be case-sensitive or not. <br>
 *                  Default value: `false`.
 * @param {string=}  on-submit
 *                  Callback function which will be triggered when the search icon is clicked.
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
                <wm-label caption='Search widget with an array of country list:' width='300px' color='#919191'></wm-label>
                <wm-search name='search-countries' scopedataset='countries'></wm-search>
                <br><br>
                <wm-label caption='Search widget with list of days:' width='300px' color='#919191'></wm-label>
                <wm-search name='search-countries' scopedataset='days' searchkey='day' displaylabel='day'></wm-search>
            </div>
        </file>
        <file name="script.js">
           function Ctrl($scope) {
               $scope.countries = new Array("Afghanistan", "Albania", "Algeria", "Andorra", "Angola", "Antarctica", "Antigua and Barbuda", "Argentina", "Armenia", "Australia", "Austria", "Azerbaijan", "Bahamas", "Bahrain", "Bangladesh", "Barbados", "Belarus", "Belgium", "Belize", "Benin", "Bermuda", "Bhutan", "Bolivia", "Bosnia and Herzegovina", "Botswana", "Brazil", "Brunei", "Bulgaria", "Burkina Faso", "Burma", "Burundi", "Cambodia", "Cameroon", "Canada", "Cape Verde", "Central African Republic", "Chad", "Chile", "China", "Colombia", "Comoros", "Congo, Democratic Republic", "Congo, Republic of the", "Costa Rica", "Cote d'Ivoire", "Croatia", "Cuba", "Cyprus", "Czech Republic", "Denmark", "Djibouti", "Dominica", "Dominican Republic", "East Timor", "Ecuador", "Egypt", "El Salvador", "Equatorial Guinea", "Eritrea", "Estonia", "Ethiopia", "Fiji", "Finland", "France", "Gabon", "Gambia", "Georgia", "Germany", "Ghana", "Greece", "Greenland", "Grenada", "Guatemala", "Guinea", "Guinea-Bissau", "Guyana", "Haiti", "Honduras", "Hong Kong", "Hungary", "Iceland", "India", "Indonesia", "Iran", "Iraq", "Ireland", "Israel", "Italy", "Jamaica", "Japan", "Jordan", "Kazakhstan", "Kenya", "Kiribati", "Korea, North", "Korea, South", "Kuwait", "Kyrgyzstan", "Laos", "Latvia", "Lebanon", "Lesotho", "Liberia", "Libya", "Liechtenstein", "Lithuania", "Luxembourg", "Macedonia", "Madagascar", "Malawi", "Malaysia", "Maldives", "Mali", "Malta", "Marshall Islands", "Mauritania", "Mauritius", "Mexico", "Micronesia", "Moldova", "Mongolia", "Morocco", "Monaco", "Mozambique", "Namibia", "Nauru", "Nepal", "Netherlands", "New Zealand", "Nicaragua", "Niger", "Nigeria", "Norway", "Oman", "Pakistan", "Panama", "Papua New Guinea", "Paraguay", "Peru", "Philippines", "Poland", "Portugal", "Qatar", "Romania", "Russia", "Rwanda", "Samoa", "San Marino", " Sao Tome", "Saudi Arabia", "Senegal", "Serbia and Montenegro", "Seychelles", "Sierra Leone", "Singapore", "Slovakia", "Slovenia", "Solomon Islands", "Somalia", "South Africa", "Spain", "Sri Lanka", "Sudan", "Suriname", "Swaziland", "Sweden", "Switzerland", "Syria", "Taiwan", "Tajikistan", "Tanzania", "Thailand", "Togo", "Tonga", "Trinidad and Tobago", "Tunisia", "Turkey", "Turkmenistan", "Uganda", "Ukraine", "United Arab Emirates", "United Kingdom", "United States", "Uruguay", "Uzbekistan", "Vanuatu", "Venezuela", "Vietnam", "Yemen", "Zambia", "Zimbabwe");
               $scope.days = [
                   {
                       'key':'Sun',
                       'day':'Sunday'
                   },
                   {
                       'key':'Mon',
                       'day':'Monday'
                   },
                   {
                       'key':'Tues',
                       'day':'Tuesday'
                   },
                   {
                       'key':'Wed',
                       'day':'Wednesday'
                   },
                   {
                       'key':'Thurs',
                       'day':'Thursday'
                   },
                   {
                       'key':'Fri',
                       'day':'Friday'
                   },
                   {
                       'key':'Sat',
                       'day':'Saturday'
                   }
               ];
            }
        </file>
    </example>
 */
/*global WM, _ */
/*Directive for spinner*/

WM.module('wm.widgets.basic')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/widget/spinner.html',
            '<div ng-class="[\'app-spinner\', size, spinnerclass]" ng-show="show" init-widget title="{{hint}}" apply-styles>' +
                '<div class="spinner-message">' +
                    '<i class="spinner-image animated infinite {{animation}}" ng-class="iconclass" ng-show="show" ng-style="{\'font-size\' : iconsize}" ></i>' +
                    '<span class="spinner-text" ng-bind-html="messageContent" ng-if="messageContent" ></span>' +
                '</div>' +
            '</div>'
            );
    }]).directive('wmSpinner', ['PropertiesFactory', '$rootScope', '$templateCache', 'WidgetUtilService', 'Utils', '$sce', function (PropertiesFactory, $rootScope, $templateCache, WidgetUtilService, Utils, $sce) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.spinner', ['wm.base']),
            notifyFor = {
                'image': true,
                'backgroundimage': true,
                'caption': true,
                'iconclass': true,
                'animation': true
            };

        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
        function propertyChangeHandler(scope, key, newVal) {
            switch (key) {
            case 'image':
                scope.picture = Utils.getBackGroundImageUrl(newVal);
                break;
            case 'backgroundimage':
                scope.backgroundimgsource = Utils.getBackGroundImageUrl(newVal);
                break;
            case 'caption':
                scope.messageContent = $sce.trustAsHtml(newVal);
                break;
            case 'iconclass':
                scope.iconclass = scope.iconclass || 'fa fa-spinner fa-spin';
                break;
            case 'animation':
                // if animation class is spin then add fa-spin class
                if (newVal === 'spin') {
                    scope.iconclass = scope.iconclass + ' fa-spin';
                } else if (!_.includes(scope.iconclass, 'fa-spinner')) {
                    scope.iconclass = _.replace(scope.iconclass, 'fa-spin', '');
                }
                break;
            }
        }

        return {
            'restrict': 'E',
            'scope': {},
            'replace': true,
            'template': $templateCache.get('template/widget/spinner.html'),
            'compile': function () {
                return {
                    'pre': function (scope) {
                        scope.widgetProps = widgetProps;
                    },
                    'post': function (scope, element, attrs) {
                        /* register the property change handler */
                        WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, scope), scope, notifyFor);

                        WidgetUtilService.postWidgetCreate(scope, element, attrs);

                        scope.iconclass = scope.iconclass || 'fa fa-spinner';

                        if (!scope.widgetid) {
                            scope.$on('$destroy', $rootScope.$on('toggle-variable-state', function (event, variableName, show) {
                                if (variableName === scope.servicevariabletotrack) {
                                    scope.show = show;
                                }
                            }));
                        }
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.widgets.basic.directive:wmSpinner
 * @restrict E
 *
 * @description
 * The `wmSpinner` directive defines the loader widget. <br>
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires $templateCache
 * @requires WidgetUtilService
 * @requires Utils
 *
 * @param {string=}  name
 *                   Name of the spinner widget.
 * @param {string=}  caption
 *                   Loading text to be displayed when the spinner is active. <br>
 * @param {string=}  trackvariable
 *                   This property allows you to bind to the service variable for which you want to show the loading dialog.
 * @param {string=}  image
 *                   Source path of the image in the widget. <br>
 *                   This is a bindable property.
 * @param {string=} width
 *                  Width of the spinner.
 * @param {string=} height
 *                  Height of the spinner.
 * @param {boolean=} show
 *                  This is a bindable property. <br>
 *                  This property will be used to show/hide the spinner widget on the web page. <br>
 *                  Default value: `true`.
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
                <wm-content contentwidth="12" name="example-content" backgroundcolor='transparent'>
                   <wm-column columnwidth="3" border="0" name="options-column">
                       <wm-composite>
                           <wm-label caption="Show:"></wm-label>
                           <wm-checkbox name="checkbox1" scopedatavalue="show" checked="checked"></wm-checkbox>
                       </wm-composite>
                       <wm-composite>
                           <wm-label caption="Image Path:"></wm-label>
                           <wm-text scopedatavalue="imagepath"></wm-text>
                       </wm-composite>
                   </wm-column>
                   <wm-column columnwidth="9" border="0" name="spinner-column">
                       <wm-spinner show='{{show}}' name="loader" image="{{imagepath}}"></wm-search>
                   </wm-column>
                </wm-content>
            </div>
        </file>
        <file name="script.js">
           function Ctrl($scope) {
               $scope.show = true;
               $scope.imagepath = '../app/build/studio/images/loader.gif';
           }
        </file>
    </example>
 */
/*global WM,_ */
/**
 * @ngdoc service
 * @name wm.widgets.basic.wmSpinner
 * @description
 * This service can be used to show/hide spinner on a page.
 */

WM.module('wm.widgets.basic').
    factory('wmSpinner', function ($animate) {
        "use strict";
        var spinnerMap = {},
            spinnerId = 0,
            appSpinner;

        function getAppSpinnerScope() {
            if (!appSpinner) {
                appSpinner = WM.element('body >.app-spinner:first').isolateScope();
                $animate.enabled(false, appSpinner);
            }
            return appSpinner;
        }

        return {
            /**
             * @ngdoc method
             * @name  wm.widgets.basic.wmSpinner#show
             * @methodOf  wm.widgets.basic.wmSpinner
             * @description
             * Increments the spinner counter and Shows a spinner on the page.
             * @param {string} message for the spinner.
             * @param {id} optional id for the spinner. If not provided, service will generate the id.
             * @param {spinnerClass} spinnerClass, optional. ClassNames that are to be applied on the spinner.
             * @returns {number} spinnerId, this id needs to be passed while calling the hide method.
             */

            'show' : function (message, id, spinnerClass) {
                var spinnerScope = getAppSpinnerScope();

                id                   = id || ++spinnerId;
                spinnerMap[id]       = _.trim(message);
                spinnerScope.caption = _.without(_.values(spinnerMap), '', undefined).join('<br/>');
                spinnerScope.show    = true;

                spinnerScope.spinnerclass = spinnerClass;

                return id;
            },

            /**
             * @ngdoc method
             * @name  wm.widgets.basic.wmSpinner#hide
             * @methodOf  wm.widgets.basic.wmSpinner
             * @description
             * Hides the spinner when spinner count is zero.
             * @param {number} id sets the spinner count to zero.
             */

            'hide' : function (id) {
                var spinnerScope = getAppSpinnerScope(),
                    spinnerCount;

                if (id) {
                    delete spinnerMap[id];
                    spinnerScope.caption = _.without(_.values(spinnerMap), '', undefined).join('<br/>');
                    spinnerCount = Object.keys(spinnerMap).length;
                    if (spinnerCount === 0) {
                        getAppSpinnerScope().show = false;
                    }
                } else {
                    spinnerMap = {};
                }
            }
        };

    });
/*global WM, _, document*/
/*Directive for Tree */

WM.module('wm.widgets.basic')
    .directive('wmTree', [
        'PropertiesFactory',
        '$rootScope',
        'WidgetUtilService',
        '$timeout',
        'Utils',
        'CONSTANTS',

        function (PropertiesFactory, $rs, WidgetUtilService, $timeout, Utils, CONSTANTS) {
            'use strict';

            var widgetProps = PropertiesFactory.getPropertiesOf('wm.tree', ['wm.base', 'wm.base.editors']),
                notifyFor = {
                    'scopedataset' : true,
                    'dataset'      : true,
                    'treeicons'    : true,
                    'nodelabel'    : true,
                    'nodeicon'     : true,
                    'nodechildren' : true
                },
                defaultTreeIconClass = 'plus-minus',
                ICON_CLASSES = {
                    'folder': {
                        'expanded' : 'glyphicon-folder-open',
                        'collapsed': 'glyphicon-folder-close'
                    },
                    'circle-plus-minus': {
                        'expanded' : 'glyphicon-minus-sign',
                        'collapsed': 'glyphicon-plus-sign'
                    },
                    'chevron': {
                        'expanded' : 'glyphicon-chevron-down',
                        'collapsed': 'glyphicon-chevron-right'
                    },
                    'menu': {
                        'expanded' : 'glyphicon-menu-down',
                        'collapsed': 'glyphicon-menu-right'
                    },
                    'triangle': {
                        'expanded' : 'glyphicon-triangle-bottom',
                        'collapsed': 'glyphicon-triangle-right'
                    },
                    'expand-collapse': {
                        'expanded' : 'glyphicon-collapse-down',
                        'collapsed': 'glyphicon-expand'
                    },
                    'plus-minus': {
                        'expanded' : 'glyphicon-minus',
                        'collapsed': 'glyphicon-plus'
                    }
                };

            function constructNodes($is, nodes, parent, levels, deep) {

                var $ul           = WM.element('<ul></ul>'),
                    iconField     = $is.nodeicon     || 'icon',
                    labelField    = $is.nodelabel    || 'label',
                    childrenField = $is.nodechildren || 'children',
                    _iconClses    = ICON_CLASSES[$is.treeicons || defaultTreeIconClass],
                    _expr         = CONSTANTS.isRunMode ? $is.datavalue : undefined,
                    _iconCls,
                    _cls;

                _cls     = levels > 0 ? ' expanded ' : ' collapsed ';
                _iconCls = _cls + (levels > 0 ? _iconClses.expanded : _iconClses.collapsed);

                deep = deep || 0;

                parent.append($ul);
                nodes.forEach(function (node, idx) {
                    var $li          = WM.element('<li></li>'),
                        $iconNode    = WM.element('<i></i>'),
                        nodeLabel    = node[labelField],
                        nodeIcon     = node[iconField],
                        nodeChildren = node[childrenField],
                        expandCollapseIcon;

                    $li.data('nodedata', node)
                        .append($iconNode)
                        .append('<span class="title">' + nodeLabel + '</span>')
                        .appendTo($ul);


                    // if datavalue(ie, expr) is provided select the tree node accordingly
                    // if datavalue === 'FirstNode' -- select the FirstNode at level 0
                    // if datavalue === 'LastNode' -- select the LastNode at level 0
                    // if datavalue is a bind expression evaluate the expression for each node of the tree till the condition is satisfied.

                    // Perform LastNode check only at level 0.(ie, deep = 0);
                    if (!$is._selectNode && _expr) {
                        if ((_expr === 'FirstNode' && idx === 0)
                                || (!deep && _expr === 'LastNode' && idx === nodes.length - 1)
                                || $is.$eval(_expr, node)
                                ) {
                            // save a reference of the node to be selected in `_selectNode`
                            $is._selectNode = $li;
                        }
                    }

                    if (nodeIcon) {
                        $iconNode.addClass(nodeIcon);
                    }

                    if (nodeChildren && nodeChildren.length) { // parent node
                        $li.addClass('parent-node ' + _cls);
                        expandCollapseIcon = WM.element('<i class="glyphicon ' + _iconCls  + ' "></i>');
                        if (nodeIcon) {
                            $iconNode.addClass(nodeIcon);
                        }
                        $li.prepend(expandCollapseIcon);
                        if (!$is.widgetid) { // when the widget is in canvas render only the first level
                            constructNodes($is, nodeChildren, $li, levels - 1, deep + 1);
                        }
                    } else {
                        if (!nodeIcon) {
                            $iconNode.addClass('leaf-node');
                        }
                        $li.addClass('leaf-node');
                    }
                });
            }

            function getNodes($is, newVal) {
                var nodes = [];
                if (WM.isString(newVal)) {
                    newVal = newVal.trim();
                    if (newVal) {
                        nodes = newVal.split(',').map(function (item) {
                            return {
                                'label': item && item.trim()
                            };
                        });
                    }
                } else if (WM.isArray(newVal)) {
                    nodes = newVal;
                } else if (WM.isObject(newVal)) {
                    nodes = [newVal];
                }

                if ($is.widgetid) { // when the widget is inside canvas
                    $is.keys = WM.isObject(nodes[0]) ? Object.keys(nodes[0]) : [];
                    /*Changing the properties like labels,children and icons*/
                    $is.widgetProps.nodelabel.options = $is.widgetProps.nodechildren.options = $is.widgetProps.nodeicon.options = [''].concat($is.keys);
                }
                return nodes;
            }

            function changeTreeIcons($el, nv, ov) {
                nv = nv || defaultTreeIconClass;
                ov = ov || defaultTreeIconClass;
                $el.find('i.expanded').switchClass(ICON_CLASSES[ov].expanded, ICON_CLASSES[nv].expanded);
                $el.find('i.collapsed').switchClass(ICON_CLASSES[ov].collapsed, ICON_CLASSES[nv].collapsed);
            }

            function toggleExpandCollapseNode($is, $i, $li) {
                var treeIcons = ICON_CLASSES[$is.treeicons || defaultTreeIconClass];

                if ($i.hasClass('collapsed')) {
                    $i.switchClass('collapsed ' + treeIcons.collapsed, 'expanded ' + treeIcons.expanded);
                    $li.switchClass('collapsed').addClass('expanded');
                } else if ($i.hasClass('expanded')) {
                    $i.switchClass('expanded ' + treeIcons.expanded, 'collapsed ' + treeIcons.collapsed);
                    $li.removeClass('expanded').addClass('collapsed');
                }
            }

            function renderTree($el, $is, attrs) {
                var levels = +attrs.levels || 0,
                    docFrag,
                    $li,
                    data,
                    path = '',
                    fn;

                $el.empty();

                if (attrs.widgetid) {
                    levels = 0;
                }
                if ($is.nodes.length) {
                    docFrag = document.createDocumentFragment();
                    constructNodes($is, $is.nodes, WM.element(docFrag), levels);
                    $el.append(docFrag);
                }

                if ($is._selectNode) {
                    $li = $is._selectNode;
                    $li.addClass('selected');
                    data = $li.data('nodedata');

                    $li.parentsUntil($el, 'li.parent-node.collapsed')
                        .each(function () {
                            var $current = WM.element(this),
                                $i       = $current.children('i.collapsed'),
                                $title   = $current.children('.title');
                            toggleExpandCollapseNode($is, $i, $current);

                            path = '/' + $title.text() + path;
                        });

                    $is.selecteditem = Utils.getClonedObject(data);
                    $is.selecteditem.path = path;

                    fn = $is.onSelect({$event: undefined, $scope: $is, $item: data, $path: path});
                    Utils.triggerFn(fn);
                    $rs.$safeApply($is);
                }
            }

            function propertyChangeHandler($is, $el, attrs, key, newVal, oldVal) {
                switch (key) {
                case 'scopedataset':
                case 'dataset':
                    $is.nodes = getNodes($is, newVal.data || newVal);
                    $is.renderTree($el, $is, attrs);
                    break;
                case 'nodeicon':
                case 'nodelabel':
                case 'nodechildren':
                    $is.renderTree($el, $is, attrs);
                    break;
                case 'treeicons':
                    changeTreeIcons($el, newVal, oldVal);
                    break;
                }
            }

            function bindEvents($is, element) {

                element.on('click', function (evt) {
                    var target = WM.element(evt.target), li = target.closest('li'),
                        fn,
                        path = '',

                        data;
                    $is.selecteditem = {};
                    evt.stopPropagation();

                    if (target.is('i')) {
                        toggleExpandCollapseNode($is, target, li);
                    } else if (target.is('span.title')) {
                        element.find('.selected').removeClass('selected');
                        li.addClass('selected');
                        data = li.data('nodedata');

                        target.parents('.app-tree li')
                            .each(function () {
                                var current = WM.element(this).children('.title').text();
                                path = '/' + current + path;
                            });

                        $is.selecteditem = Utils.getClonedObject(data);
                        $is.selecteditem.path = path;

                        fn = $is.onSelect({$event: evt, $scope: $is, $item: data, $path: path});
                        Utils.triggerFn(fn);
                        $rs.$safeApply($is);
                    }
                });
            }

            function defineDatavalueGetterSetter($is, val) {
                if (CONSTANTS.isStudioMode) {
                    var DEFAULTS = ['', 'FirstNode', 'LastNode'];
                    Object.defineProperty($is, 'datavalue', {
                        'get': function () {
                            return val;
                        },
                        'set': function (nv) {
                            if (_.includes(DEFAULTS, nv)) {
                                $is.binddatavalue = undefined;
                                val = nv;
                            } else {
                                $is.binddatavalue = nv;
                                val = undefined;
                            }
                        }
                    });
                }
            }

            return {
                'restrict': 'E',
                'scope': {
                    'scopedataset': '=?',
                    'onSelect': '&'
                },
                'template': '<div class="app-tree" init-widget apply-styles="container" data-ng-show="show"></div>',
                'replace': true,
                'compile': function () {
                    return {
                        'pre': function ($is) {
                            if (CONSTANTS.isStudioMode) {
                                $is.widgetProps = Utils.getClonedObject(widgetProps);
                            } else {
                                $is.widgetProps = widgetProps;
                            }
                            defineDatavalueGetterSetter($is);
                        },
                        'post': function ($is, $el, attrs) {

                            if (!$is.widgetid) {
                                bindEvents($is, $el);
                            }

                            // wait till all the properties are set in the scope.
                            $is.renderTree = _.debounce(renderTree, 20);

                            var onPropertyChange = propertyChangeHandler.bind(undefined, $is, $el, attrs);
                            WidgetUtilService.registerPropertyChangeListener(onPropertyChange, $is, notifyFor);

                            if (attrs.datavalue && CONSTANTS.isRunMode) {
                                $is.datavalue = attrs.datavalue.replace('bind:', '');
                            }

                            if (!$is.widgetid && attrs.scopedataset) {
                                $timeout(function () {
                                    $is.$watch('scopedataset', function (newVal) {
                                        onPropertyChange('scopedataset', newVal);
                                    }, true);
                                }, 0);
                            }

                            WidgetUtilService.postWidgetCreate($is, $el, attrs);
                        }
                    };
                }
            };

        }
    ]);

/**
 * @ngdoc directive
 * @name wm.widgets.basic.directive:wmTree
 * @restrict E
 *
 * @description
 * The `wmTree` directive defines a tree widget.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires $rootScope
 * @requires WidgetUtilService
 * @requires $timeout
 * @requires Utils
 *
 * @param {string=} name
 *                  Name of the tree widget.
 * @param {string=} width
 *                  Width of the tree.
 * @param {string=} height
 *                  Height of the tree.
 * @param {string=} treeicons
 *                  This property sets expand-collapse icons on the tree. <br>
 *                  Possible values are `folder`, `plus-minus`, `circle-plus-minus`, `chevron`, `menu`, `triangle` and `expand-collapse`. <br>
 *                  Default value: `triangle`. <br>
 * @param {string=} scopedataset
 *                  The script variable that contains the data to be displayed on the tree widget.
 * @param {object=} dataset
 *                  Set this property to a variable to populate the list of values to display. <br>
 *                  This is a bindable property.
 * @param {string=} datavalue
 *                  Provided expression will be evaluated for each node of the tree and the first node which satisfies the given expression will be selected by default. <br>
 *                  This is a bindable property.
 * @param {string=} nodelabel
 *                  This property from the dataset will be used to display label for the tree node.
 * @param {string=} nodeicon
 *                  This property from the dataset will be used to display icon for the tree node.
 * @param {string=} nodechildren
 *                  This property from the dataset will be used to display children for the tree node.
 * @param {number=} levels
 *                  This property sets levels of the tree to be expanded by default.
 * @param {boolean=} show
 *                  This is a bindable property. <br>
 *                  This property will be used to show/hide the tree widget on the web page. <br>
 *                  Default value: `true`. <br>
 * @param {string=} on-select
 *                  Callback function which will be triggered on selection of the widget.
 *
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
               <wm-tree scopedataset="nodes" levels="2" datavalue="label==='item2.1'"></wm-tree>
            </div>
        </file>
        <file name="script.js">
           function Ctrl($scope) {
           $scope.nodes = [
               {
                   "label": "item1",
                   "icon": "glyphicon glyphicon-euro",
                   "children": []
               }, {
                   "label": "item2",
                   "icon": "glyphicon glyphicon-euro",
                   "children": [{
                       "label": "item2.1",
                       "icon": "glyphicon glyphicon-euro",
                       "children": [{
                           "label": "item2.1",
                           "icon": "glyphicon glyphicon-euro",
                           "children": [{
                               "label": "item2.1",
                               "icon": "glyphicon glyphicon-euro"
                           }, {
                               "label": "item2.2",
                               "icon": "glyphicon glyphicon-euro"
                           }, {
                               "label": "item2.3",
                               "icon": "glyphicon glyphicon-euro"
                           }, {
                               "label": "item2.4",
                               "icon": "glyphicon glyphicon-euro"
                           }]
                       }]
                   }, {
                       "label": "item2.2",
                       "icon": "glyphicon glyphicon-euro"
                   }, {
                       "label": "item2.3",
                       "icon": "glyphicon glyphicon-euro"
                   }, {
                       "label": "item2.4",
                       "icon": "glyphicon glyphicon-euro"
                   }]
               }, {
                   "label": "item3",
                   "icon": "glyphicon glyphicon-euro"
               }, {
                   "label": "item4",
                   "icon": "glyphicon glyphicon-euro"
               }
           ];
           }
        </file>
    </example>
 */

/*global WM, nv, d3, _ */
/*Directive for chart */

WM.module('wm.widgets.basic')
    .run(['$templateCache', function ($templateCache) {
        "use strict";
        $templateCache.put("template/widget/form/chart.html",
            '<div init-widget class="app-chart" title="{{hint}}" data-ng-show="show" apply-styles>' +
                '<div class="app-chart-inner">' +
                    '<svg></svg>' +
                    '<div class="wm-content-info readonly-wrapper {{class}}" data-ng-show="showContentLoadError">' +
                        '<p class="wm-message" title="{{hintMsg}}">{{errMsg}}</p>' +
                    '</div>' +
                '</div>' +
            '</div>'
            );
    }]).directive('wmChart', function (PropertiesFactory, $templateCache, $rootScope, WidgetUtilService, CONSTANTS, QueryBuilder, Utils, $timeout) {
        "use strict";
        var widgetProps = PropertiesFactory.getPropertiesOf("wm.chart", ["wm.base"]),
            themes = {
                'Terrestrial': {
                    colors: ["#1f77b4", "#aec7e8", "#ff7f0e", "#ffbb78", "#2ca02c", "#98df8a", "#d62728", "#ff9896", "#9467bd", "#c5b0d5", "#8c564b", "#c49c94", "#e377c2", "#f7b6d2", "#7f7f7f", "#c7c7c7", "#bcbd22", "#dbdb8d", "#17becf", "#9edae5"],
                    tooltip: {
                        "backgroundColor": "#de7d28",
                        "textColor": "#FFFFFF"
                    }
                },
                'Annabelle': {
                    colors: ["#393b79", "#5254a3", "#6b6ecf", "#9c9ede", "#637939", "#8ca252", "#b5cf6b", "#cedb9c", "#8c6d31", "#bd9e39", "#e7ba52", "#e7cb94", "#843c39", "#ad494a", "#d6616b", "#e7969c", "#7b4173", "#a55194", "#ce6dbd", "#de9ed6"],
                    tooltip: {
                        "backgroundColor": "#2e306f",
                        "textColor": "#FFFFFF"
                    }
                },
                'Azure': {
                    colors: ["#3182bd", "#6baed6", "#9ecae1", "#c6dbef", "#e6550d", "#fd8d3c", "#fdae6b", "#fdd0a2", "#31a354", "#74c476", "#a1d99b", "#c7e9c0", "#756bb1", "#9e9ac8", "#bcbddc", "#dadaeb", "#636363", "#969696", "#bdbdbd", "#d9d9d9"],
                    tooltip: {
                        "backgroundColor": "#3182bd",
                        "textColor": "#FFFFFF"
                    }
                },
                'Retro': {
                    colors: ["#0ca7a1", "#ffa615", "#334957", "#acc5c2", "#988f90", "#8accc9", "#515151", "#f27861", "#36c9fd", "#794668", "#0f709d", "#0d2738", "#44be78", "#4a1839", "#6a393f", "#557d8b", "#6c331c", "#1c1c1c", "#861500", "#09562a"],
                    tooltip: {
                        "backgroundColor": "#80513a",
                        "textColor": "#FFFFFF"
                    }
                },
                'Mellow': {
                    colors: ["#f0dcbf", "#88c877", "#aeb918", "#2e2c23", "#ddddd2", "#dfe956", "#4c963b", "#5d3801", "#e1eec3", "#cd8472", "#fcfab3", "#9a4635", "#9295ad", "#2e3f12", "#565677", "#557d8b", "#4f4d02", "#0c0c1b", "#833324", "#24120e"],
                    tooltip: {
                        "backgroundColor": "#7c9e73",
                        "textColor": "#FFFFFF"
                    }
                },
                'Orient': {
                    colors: ["#a80000", "#cc6c3c", "#f0e400", "#000084", "#fccc6c", "#009c6c", "#cc309c", "#78cc00", "#fc84e4", "#48e4fc", "#4878d8", "#186c0c", "#606060", "#a8a8a8", "#000000", "#d7d7d7", "#75a06e", "#190d0b", "#888888", "#694b84"],
                    tooltip: {
                        "backgroundColor": "#c14242",
                        "textColor": "#FFFFFF"
                    }
                },
                'GrayScale': {
                    colors: ["#141414", "#353535", "#5b5b5b", "#848484", "#a8a8a8", "#c3c3c3", "#e0e0e0", "#c8c8c8", "#a5a5a5", "#878787", "#656565", "#4e4e4e", "#303030", "#1c1c1c", "#4f4f4f", "#3b3b3b", "#757575", "#606060", "#868686", "#c1c1c1"],
                    tooltip: {
                        "backgroundColor": "#575757",
                        "textColor": "#FFFFFF"
                    }
                },
                'Flyer': {
                    colors: ["#3f454c", "#5a646e", "#848778", "#cededf", "#74c4dd", "#0946ed", "#380bb1", "#000ff0", "#f54a23", "#1db262", "#bca3aa", "#ffa500", "#a86b32", "#63a18c", "#56795e", "#934343", "#b75f5f", "#752d2d", "#4e1111", "#920606"],
                    tooltip: {
                        "backgroundColor": "#47637c",
                        "textColor": "#FFFFFF"
                    }
                },
                'Luminosity': {
                    colors: ["#FFFFFF", "#e4e4e4", "#00bcd4", "#f0dd2f", "#00aabf", "#018376", "#e91e63", "#39e5d4", "#ff6d6d", "#00ff76", "#ff9800", "#969696", "#ff4200", "#e00000", "#95cbe5", "#5331ff", "#fff4a7", "#e7a800", "#0061e4", "#d5e7ff"],
                    tooltip: {
                        "backgroundColor": "#47637c",
                        "textColor": "#FFFFFF"
                    }
                }
            },
           /* properties of the respective chart type */
            options = {
                'Column'         : ['showcontrols', 'staggerlabels', 'reducexticks', 'barspacing', 'xaxislabel', 'yaxislabel', 'xunits', 'yunits', 'yaxislabeldistance', 'captions', 'showxaxis', 'showyaxis', 'xdomain', 'ydomain'],
                'Line'           : ['xaxislabel', 'yaxislabel', 'xunits', 'yunits', 'yaxislabeldistance', 'captions', 'showxaxis', 'showyaxis', 'highlightpoints', 'linethickness'],
                'Area'           : ['showcontrols', 'xaxislabel', 'yaxislabel', 'xunits', 'yunits', 'yaxislabeldistance', 'captions', 'showxaxis', 'showyaxis', 'highlightpoints', 'xdomain', 'ydomain'],
                'Cumulative Line': ['showcontrols', 'xaxislabel', 'yaxislabel', 'xunits', 'yunits', 'yaxislabeldistance', 'captions', 'showxaxis', 'showyaxis', 'highlightpoints', 'linethickness'],
                'Bar'            : ['barspacing', 'showvalues', 'showcontrols', 'xaxislabel', 'yaxislabel', 'xunits', 'yunits', 'xaxislabeldistance', 'captions', 'showxaxis', 'showyaxis'],
                'Pie'            : ['showlabels', 'labeltype', 'showlabelsoutside'],
                'Donut'          : ['showlabels', 'labeltype', 'donutratio', 'showlabelsoutside', 'title'],
                'Bubble'         : ['showxdistance', 'showydistance', 'bubblesize', 'shape']
            },
            /*XPaths to get actual data of data points in charts*/
            chartDataPointXpath = {
                'Column'         : 'rect.nv-bar',
                'Bar'            : 'g.nv-bar',
                'Area'           : '.nv-stackedarea .nv-point',
                'Cumulative Line': '.nv-cumulativeLine .nv-scatterWrap path.nv-point',
                'Line'           : '.nv-lineChart .nv-scatterWrap path.nv-point',
                'Pie'            : '.nv-pieChart .nv-slice path',
                'Donut'          : '.nv-pieChart .nv-slice path',
                'Bubble'         : '.nv-scatterChart .nv-point-paths path'
            },
            /*all properties of the chart*/
            allOptions = ['showvalues', 'showlabels', 'showcontrols', 'useinteractiveguideline', 'staggerlabels', 'reducexticks', 'barspacing', 'labeltype', 'donutratio', 'showlabelsoutside', 'xaxislabel', 'yaxislabel', 'xunits', 'yunits', 'xaxislabeldistance', 'yaxislabeldistance', 'showxdistance', 'showydistance', 'bubblesize', 'shape', 'captions', 'showxaxis', 'showyaxis', 'title', 'highlightpoints', 'linethickness', 'xdomain', 'ydomain'],
            advanceDataProps = ['aggregation', 'aggregationcolumn', 'groupby', 'orderby'],
            chartTypes = ["Column", "Line", "Area", "Cumulative Line", "Bar", "Pie", "Donut", "Bubble"],
            styleProps = {
                "fontunit"      : "font-size",
                "fontsize"      : "font-size",
                "color"         : "fill",
                "fontfamily"    : "font-family",
                "fontweight"    : "font-weight",
                "fontstyle"     : "font-style",
                "textdecoration": "text-decoration"
            },
            tickformats = {
                'Round to Thousand': {
                    'prefix': "K",
                    'divider': 1000
                },
                'Round to Million' : {
                    'prefix': "M",
                    'divider': 1000000
                },
                'Round to Billion' : {
                    'prefix': "B",
                    'divider': 1000000000
                }
            },
            dataTypeJSON = ['Column', 'Line', 'Pie', 'Bar', 'Donut', 'Bubble'],     /*Charts that supports the data to be JSON*/
            dataTypeArray = ['Cumulative Line', 'Area'],     /*Charts that supports the data to be Array*/
            lineTypeCharts = ['Line', 'Area', 'Cumulative Line'],   /*Charts that does not supports the string type of data in the xaxis in the nvd3*/
            allShapes = ["circle", "square", "diamond", "cross", "triangle-up", "triangle-down"],
            sampleData = {},
            notifyFor = {
                'dataset'           : true,
                'xaxisdatakey'      : true,
                'yaxisdatakey'      : true,
                'type'              : true,
                'height'            : true,
                'width'             : true,
                'show'              : true,
                'xaxislabel'        : true,
                'yaxislabel'        : true,
                'xunits'            : true,
                'yunits'            : true,
                'xnumberformat'     : true,
                'xdigits'           : true,
                'xdateformat'       : true,
                'ynumberformat'     : true,
                'ydigits'           : true,
                'ydateformat'       : true,
                'showlegend'        : true,
                'showvalues'        : true,
                'showlabels'        : true,
                'showcontrols'      : true,
                'staggerlabels'     : true,
                'reducexticks'      : true,
                'offsettop'         : true,
                'offsetbottom'      : true,
                'offsetright'       : true,
                'offsetleft'        : true,
                'barspacing'        : true,
                'xaxislabeldistance': true,
                'yaxislabeldistance': true,
                'theme'             : true,
                'labeltype'         : true,
                'donutratio'        : true,
                'showlabelsoutside' : true,
                'aggregation'       : true,
                'aggregationcolumn' : true,
                'groupby'           : true,
                'orderby'           : true,
                'fontsize'          : true,
                'fontunit'          : true,
                'color'             : true,
                'fontfamily'        : true,
                'fontweight'        : true,
                'fontstyle'         : true,
                'textdecoration'    : true,
                'legendposition'    : true,
                'shape'             : true,
                'nodatamessage'     : true,
                'captions'          : true,
                'showxaxis'         : true,
                'showyaxis'         : true,
                'title'             : true,
                'customcolors'      : true,
                'legendtype'        : true,
                'highlightpoints'   : true,
                'linethickness'     : true,
                'selecteditem'      : true,
                'xdomain'           : true,
                'ydomain'           : true
            };

        /* returns true if chart type is pie */
        function isPieChart(type) {
            return (type === 'Pie');
        }

        /* returns true if chart type is bar */
        function isBarChart(type) {
            return (type === 'Bar');
        }

        /* returns true if chart type is donut */
        function isDonutChart(type) {
            return (type === 'Donut');
        }

        /* returns true if chart type is bubble */
        function isBubbleChart(type) {
            return (type === 'Bubble');
        }

        /* returns true if chart type is column */
        function isColumnChart(type) {
            return (type === 'Column');
        }

        /* returns true if chart type is area */
        function isAreaChart(type) {
            return (type === 'Area');
        }

        /* returns true if chart type is pie or donut */
        function isPieType(type) {
            return (isPieChart(type) || isDonutChart(type));
        }

        /* The format of chart data is array of json objects in case of the following types of chart */
        function isChartDataJSON(type) {
            return (dataTypeJSON.indexOf(type) > -1 || chartTypes.indexOf(type) === -1);
        }

        /* The format of chart data is array of objects in case of the following types of chart */
        function isChartDataArray(type) {
            return (dataTypeArray.indexOf(type) > -1);
        }

        /* returns true is the chart type is 'line', 'area' or 'cumulative line' else false*/
        function isLineTypeChart(type) {
            return (lineTypeCharts.indexOf(type) > -1);
        }

        /*X/Y Domain properties are supported only for Column and Area charts*/
        function isAxisDomainSupported(type) {
            return isColumnChart(type) || isAreaChart(type);
        }

        /* Formatting the data based on the data-type */
        function formatData(scope, d, dataType, options) {
            var datakey = (options.isXaxis && options.xDataKeyArr && options.xDataKeyArr.length) ? options.xDataKeyArr[d] : d,
                formattedData,
                divider,
                prefix;
            switch (dataType) {
            case 'date':
                return !isLineTypeChart(scope.type) ? d3.time.format(options.dateFormat)(new Date(d)) : datakey;
            case 'string':
            case 'year':
                return datakey;
            default:
                formattedData = d3.format(options.format)(d);
                /** formating the data based on number format selected **/
                if (options.numberFormat && dataType) {
                    /*Getting the respective divider[1000,1000000,1000000000] based on the number format choosen*/
                    divider = (tickformats[options.numberFormat] && tickformats[options.numberFormat].divider) || 0;
                    prefix = tickformats[options.numberFormat] && tickformats[options.numberFormat].prefix;
                    if (prefix && divider !== 0) {
                        formattedData = d3.format('.2f')(d / divider) + prefix;
                    }
                } else if (!options.numberFormat) {
                    /*Auto formatting the data when no formating option is chosen*/
                    formattedData = d3.format('.3s')(d);
                }
                return formattedData;
            }
        }

        /*Construct the sample data*/
        function constructSampleData(scope) {
            var i,
                jsonFormatData = [],
                pieChartData = [],
                arrayFormatData = [],
                pieName = 'Group',
                dataPoint;

            for (i = 1; i < 5; i += 1) {
                dataPoint = {};
                pieChartData.push({x: pieName + i, y: i});
                dataPoint.x = i;
                dataPoint.y = i;
                /*Only bubble type of the chart has the size attribute */
                if (isBubbleChart(scope.type)) {
                    dataPoint.size =  (i + 1) * 2;
                    dataPoint.shape =  scope.shape || 'circle';
                }
                jsonFormatData.push(dataPoint);
                arrayFormatData.push([i, i]);

            }
            sampleData.jsonFormat = jsonFormatData;
            sampleData.arrayFormat = arrayFormatData;
            sampleData.pieChartFormat = pieChartData;
        }


        /** Sample data to populate when no data is bound*/
        function getSampleData(scope) {
            var dataType;
            if (Utils.isEmptyObject(sampleData) ||  isBubbleChart(scope.type)) {
                constructSampleData(scope);
            }

            if (isPieType(scope.type)) {
                return sampleData.pieChartFormat;
            }

            dataType = isChartDataJSON(scope.type) ? "jsonFormat" : "arrayFormat";
            return [{values: sampleData[dataType], key: 'Default'}];
        }

        /* get the data type for the service variable type*/
        function getDataType(key, data) {
            var keys = key.split('.'),
                newKey = key,
                value;
            if (data) {
                value = data[key];
                /*If the element is not directly accessible then access it inside of it*/
                if (value === undefined && keys.length > 1) {
                    data = data[keys[0]];
                    keys.shift();
                    newKey = keys.join('.');
                    return getDataType(newKey, data);
                }
                return typeof value;
            }
            return null;
        }

        /* get the column type definition for the live data-source*/
        function getColumnType(key, columns) {
            var keys = key.split('.'),
                newKey,
                i,
                type;
            if (columns) {
                for (i = 0; i < columns.length; i += 1) {
                    /*Trying to get the column type of key fields of object columns*/
                    if (keys.length > 0 && key.indexOf('.') > -1) {
                        if (Utils.initCaps(keys[0]) === columns[i].relatedEntityName) {
                            /*initialising columns with columns of object type column*/
                            columns = columns[i].columns;
                            /*removing already accessed keys*/
                            keys.shift();
                            newKey = keys.join('.');
                            return getColumnType(newKey, columns);
                        }
                    } else if (columns[i].fieldName === key) {
                        type = columns[i].type;
                    }
                }
            }
            return type || null;
        }

        /* Hide the properties that are passed to it*/
        function hideOrShowProperties(properties, scope, show) {
            /* sanity check */
            show = WM.isDefined(show) ? show : false;

            var _widgetProps = scope.widgetProps;
            properties.forEach(function (prop) {
                _widgetProps[prop].show = show;
            });
        }

        /* Configuring the properties panel based on the type of the chart chosen*/
        function togglePropertiesByChartType(scope) {
            /* Initially hiding all the properties*/
            hideOrShowProperties(allOptions, scope, false);
            /* Showing the properties based on the type of the chart*/
            hideOrShowProperties((chartTypes.indexOf(scope.type) === -1) ? options.Column : options[scope.type], scope, true);

            if (isPieType(scope.type)) {
                /* If pie chart, set the display key for x and y axis datakey and subgroups */
                scope.widgetProps.xaxisdatakey.displayKey = 'LABEL_PROPERTY_LABEL';
                scope.widgetProps.yaxisdatakey.displayKey = 'LABEL_PROPERTY_VALUES';
                PropertiesFactory.getPropertyGroup('xaxis').displayKey = 'LABEL_PROPERTY_LABEL_DATA';
                PropertiesFactory.getPropertyGroup('yaxis').displayKey = 'LABEL_PROPERTY_VALUE_DATA';

                /* If it is a pie chart then the yaxisdatakey must be a single select else it has to be a multiselect */
                scope.widgetProps.yaxisdatakey.widget = 'list';
                /* Only if bound to valid dataset populate the options*/
                if (scope.dataset) {
                    scope.widgetProps.yaxisdatakey.options = scope.axisoptions;
                }
            } else {
                scope.widgetProps.xaxisdatakey.displayKey = undefined;
                scope.widgetProps.yaxisdatakey.displayKey = undefined;
                PropertiesFactory.getPropertyGroup('xaxis').displayKey = undefined;
                PropertiesFactory.getPropertyGroup('yaxis').displayKey = undefined;

                scope.widgetProps.yaxisdatakey.widget = 'multiselect';
                $timeout(function () {
                    scope.widgetDataset.yaxisdatakey = scope.axisoptions || [];
                }, 5);
            }
        }

        /*
         * Displaying the formatting options based on the type of the column chosen
         * @param axis, x or y axis
         */
        function displayFormatOptions(scope, axis) {
            var type,
                key = axis + "axisdatakey",
                numFormat = axis + "numberformat",
                digits = axis + "digits",
                dateFormat = axis + "dateformat";
            /* return in case of pie/donut chart and x axis return*/
            if (isPieType(scope.type) && axis === 'x') {
                return;
            }

            /* get column type */
            if (scope.dataset && scope.dataset.propertiesMap) {
                type = scope[key] ? getColumnType(scope[key].split(',')[0], scope.dataset.propertiesMap.columns) : null;
            }
            switch (type) {
            case 'integer':
            case 'float':
                hideOrShowProperties([numFormat, digits], scope, true);
                hideOrShowProperties([dateFormat], scope, false);
                break;
            case 'string':
                hideOrShowProperties([numFormat, digits, dateFormat], scope, false);
                break;
            case 'date':
                hideOrShowProperties([numFormat, digits], scope, false);
                hideOrShowProperties([dateFormat], scope, true);
                break;
            }
        }

        /** Checks if the yaxisdatakey is a singleselect or multiselect based on chart type */
        function isSingleYAxis(type) {
            return isPieType(type) ? true : false;
        }

        /** Based on the chart type, sets the options for the yaxisdatakey*/
        function setYAxisDataKey(scope, options, dataSet) {
            if (isSingleYAxis(scope.type)) {
                scope.widgetProps.yaxisdatakey.widget = 'list';
                scope.widgetProps.yaxisdatakey.options = options;
            } else {
                scope.widgetDataset.yaxisdatakey = dataSet || options || [];
            }
        }

        function isGroupByEnabled(groupby) {
            return (groupby && groupby !== "none");
        }

        /* enables/disables the aggregation column property*/
        function toggleAggregationColumnState(scope) {
            scope.widgetProps.aggregationcolumn.disabled = !(isGroupByEnabled(scope.groupby) && scope.aggregation && scope.aggregation !== "none");
        }

        /* enables/disables the aggregation function property */
        function toggleAggregationState(scope) {
            scope.widgetProps.aggregation.disabled = !(isGroupByEnabled(scope.groupby));
            /* enables/disables the aggregation column property*/
            toggleAggregationColumnState(scope);
        }

        /* Displaying options for x and y axis based on the columns chosen in aggregation column and groupby*/
        function modifyAxesOptions(scope) {
            var xAxisOptions = [],
                yAxisOptions = [],
                isAggregationApplied = (isGroupByEnabled(scope.groupby) && scope.aggregation && scope.aggregation !== "none"),
                options;
            /*Check if the data-set has been bound and the value is available in data-set.*/
            if (scope.binddataset && WM.isObject(scope.dataset)) {

                /* get axis options */
                options = scope.axisoptions;
                if (isAggregationApplied) {
                    if (scope.groupby) {
                        xAxisOptions = scope.groupby.split(',');
                        scope.xaxisdatakey = xAxisOptions[0];
                    } else {
                        xAxisOptions = options;
                    }
                    /*If "aggregation" is not "none" and if the "aggregationColumn" has not already been added into the axesOptions, then add it.*/
                    if (isAggregationApplied && scope.aggregationcolumn) {
                        yAxisOptions.push(scope.aggregationcolumn);
                        scope.yaxisdatakey = yAxisOptions[0];
                    } else {
                        yAxisOptions = options;
                    }
                    scope.widgetProps.xaxisdatakey.options = xAxisOptions;
                    setYAxisDataKey(scope, yAxisOptions, '');
                    setYAxisDataKey(scope, yAxisOptions, yAxisOptions);
                    /*Setting the bubble size and tooltip columns to be shown*/
                    if (isBubbleChart(scope.type)) {
                        scope.widgetProps.bubblesize.options = options;
                    }
                } else {
                    scope.widgetProps.xaxisdatakey.options = options;
                    setYAxisDataKey(scope, options, '');
                    if (isBubbleChart(scope.type)) {
                        scope.widgetProps.bubblesize.options = options;
                    }
                }

                displayFormatOptions(scope, 'x');
                displayFormatOptions(scope, 'y');
            } else if (!scope.binddataset) {/*Else, set all the values to default.*/
                scope.widgetProps.xaxisdatakey.options = [];
                setYAxisDataKey(scope, [], '');
                scope.widgetProps.aggregationcolumn.options = [];
                scope.xaxisdatakey = scope.yaxisdatakey = '';
                scope.xaxislabel = scope.yaxislabel = '';
                scope.xunits = scope.yunits = '';
                scope.bubblesize = '';
                scope.widgetProps.bubblesize.options = [];
                scope.widgetProps.aggregationcolumn.disabled = true;
                scope.widgetProps.aggregation.disabled = true;
                /*Setting the values to the default*/
                if (scope.active) {
                    $rootScope.$emit('update-widget-property', 'aggregation', "");
                    $rootScope.$emit('update-widget-property', 'aggregationcolumn', "");
                    $rootScope.$emit('update-widget-property', 'groupby', "");
                    $rootScope.$emit('update-widget-property', 'orderby', "");
                }
            }
            scope.$root.$emit("set-markup-attr", scope.widgetid, {'xaxisdatakey': scope.xaxisdatakey, 'yaxisdatakey': scope.yaxisdatakey});
        }

        /* Check if x and y axis that are chosen are valid to plot chart */
        function isValidAxis(scope) {
            /* Check if x axis and y axis are chosen and are not equal */
            return scope.binddataset ? (scope.xaxisdatakey && scope.yaxisdatakey) : true;
        }

        /* Check if aggregation is chosen */
        function isAggregationEnabled(scope) {
            return ((isGroupByEnabled(scope.groupby) && scope.aggregation !== "none" && scope.aggregationcolumn)) || isGroupByEnabled(scope.groupby) || scope.orderby;
        }

        /*Checks if the column type choosen is of number type*/
        function isNumberType(dataType) {
            var numberTypes = ['integer', 'float', 'number', 'big_decimal', 'big_integer', 'double', 'short'];
            return (numberTypes.indexOf(dataType) !== -1);
        }

        /*Gets the value by parsing upto the leaf node*/
        function getLeafNodeVal(key, dataObj) {
            var keys = key.split('.'),
                data = dataObj,
                i;
            for (i = 0; i < keys.length; i += 1) {
                if (data) {
                    data = data[keys[i]];
                } else { /*If value becomes undefined then acceess the key directly*/
                    data =  dataObj[key];
                    break;
                }
            }
            return data;
        }

        /*Charts like Line,Area,Cumulative Line does not support any other datatype
        other than integer unlike the column and bar.It is a nvd3 issue. Inorder to
        support that this is a fix*/
        function getxAxisVal(scope, dataObj, xKey, index) {
            var value = getLeafNodeVal(xKey, dataObj);
            /*If x axis is other than number type then add indexes*/
            if (isLineTypeChart(scope.type) && !isNumberType(scope.xAxisDataType)) {
                /*Verification to get the unique data keys */
                scope.xDataKeyArr.push(value);
                return index;
            }
            return value;
        }

        /*Getting the min and max values among all the x values*/
        function getXMinMaxValues(datum) {
            if (!datum) {
                return;
            }
            var xValues = {};
            /*
             compute the min x value
             eg: When data has objects
                input: [{x:1, y:2}, {x:2, y:3}, {x:3, y:4}]
                min x: 1
             eg: When data has arrays
                input: [[10, 20], [20, 30], [30, 40]];
                min x: 10
            */
            xValues.min = _.minBy(datum.values, function (dataObject) {
                return (dataObject.x || dataObject[0]);
            });
            /*
             compute the max x value
             eg: When data has objects
                input: [{x:1, y:2}, {x:2, y:3}, {x:3, y:4}]
                max x: 3
             eg: When data has arrays
                input: [[10, 20], [20, 30], [30, 40]];
                max x: 30
             */
            xValues.max = _.maxBy(datum.values, function (dataObject) {
                return (dataObject.x || dataObject[0]);
            });
            return xValues;
        }

        /*Getting the min and max values among all the y values*/
        function getYMinMaxValues(datum) {
            var yValues = {},
                minValues = [],
                maxValues = [];
            if (!datum) {
                return;
            }

            /*
             Getting the min and max y values among all the series of data
             compute the min y value
             eg: When data has objects
                input: [[{x:1, y:2}, {x:2, y:3}, {x:3, y:4}], [{x:2, y:3}, {x:3, y:4}, {x:4, y:5}]]
                min y values : '2'(among first set) & '3'(among second set)
                max y values : '4'(among first set) & '5'(among second set)

             eg: When data has arrays
                input: [[[10, 20], [20, 30], [30, 40]], [[20, 30], [30, 40], [40, 50]]]
                min y values : '20'(among first set) & '30'(among second set)
                max y values : '40'(among first set) & '50'(among second set)
             */

            _.forEach(datum, function (data) {
                minValues.push(_.minBy(data.values, function (dataObject) { return dataObject.y || dataObject[1]; }));
                maxValues.push(_.maxBy(data.values, function (dataObject) { return dataObject.y || dataObject[1]; }));
            });
            /*Gets the least and highest values among all the min and max values of respective series of data*/
            yValues.min = _.minBy(minValues, function (dataObject) {
                return dataObject.y || dataObject[1];
            });
            yValues.max = _.maxBy(maxValues, function (dataObject) {
                return dataObject.y || dataObject[1];
            });
            return yValues;
        }

        /*Returns the single data point based on the type of the data chart accepts*/
        function valueFinder(scope, dataObj, xKey, yKey, index, shape) {
            var xVal = getxAxisVal(scope, dataObj, xKey, index),
                value = getLeafNodeVal(yKey, dataObj),
                yVal = parseFloat(value) || value,
                dataPoint = {},
                size = parseFloat(dataObj[scope.bubblesize]) || 2,
                type = scope.type;

            if (isChartDataJSON(type)) {
                dataPoint.x = xVal;
                dataPoint.y = yVal;
                /*only Bubble chart has the third dimension*/
                if (isBubbleChart(type)) {
                    dataPoint.size = size;
                    dataPoint.shape = shape || 'circle';
                }
            } else if (isChartDataArray(type)) {
                dataPoint = [xVal, yVal];
            }
            /*Adding actual unwrapped data to chart data to use at the time of selected data point of chart event*/
            dataPoint._dataObj = dataObj;
            return dataPoint;
        }

        /*Formatting the binded data compatible to chart data*/
        function getChartData(scope) {
            scope.sampleData = getSampleData(scope);
            /* scope variables used to keep the actual key values for x-axis */
            scope.xDataKeyArr = [];
            /*Plotting the chart with sample data when the chart dataset is not bound*/
            if (!scope.binddataset) {
                return scope.sampleData;
            }

            if (CONSTANTS.isStudioMode) {
                scope.showContentLoadError = false;
                /** When binddataset value is there and chartData is not populated yet then a Loading message will be shown*/
                if (scope.binddataset && !scope.chartData) {
                    return [];
                }
                if (scope.isServiceVariable) {
                    scope.showContentLoadError = true;
                    scope.errMsg = $rootScope.locale.MESSAGE_INFO_SAMPLE_DATA;
                    scope.hintMsg = $rootScope.locale.MESSAGE_ERROR_DATA_DISPLAY + scope.name;
                    return scope.sampleData;
                }
                if (!scope.chartData) {
                    return scope.sampleData;
                }
            } else {
                /*When invalid axis are chosen when aggregation is enabled then plot the chart with sample data*/
                if ((!isValidAxis(scope) && isAggregationEnabled(scope))) {
                    return scope.sampleData;
                }
                if (!scope.chartData) {
                    return [];
                }
            }

            var datum = [],
                xAxisKey = scope.xaxisdatakey,
                yAxisKeys = scope.yaxisdatakey ? scope.yaxisdatakey.split(',') : [],
                dataSet = scope.chartData,
                yAxisKey,
                shapes = [];

            /*check if the datasource is live variable then get the column definition else directly get the data type of the object passed*/
            if (scope.isLiveVariable) {
                scope.xAxisDataType = getColumnType(xAxisKey, scope.dataset.propertiesMap.columns);
                scope.yAxisDataType = getColumnType(yAxisKeys[0], scope.dataset.propertiesMap.columns);
            } else {
                if (scope.chartData && scope.chartData[0]) {
                    scope.xAxisDataType = getDataType(xAxisKey, scope.chartData[0]);
                    scope.yAxisDataType = getDataType(yAxisKeys[0], scope.chartData[0]);
                }
            }

            if (WM.isArray(dataSet)) {
                if (isPieType(scope.type)) {
                    yAxisKey = yAxisKeys[0];
                    datum = _.map(dataSet, function (dataObj, index) {
                        return valueFinder(scope, dataSet[index], xAxisKey, yAxisKey);
                    });
                } else {
                    if (isBubbleChart(scope.type)) {
                        shapes =  scope.shape === 'random' ? allShapes : scope.shape;
                    }
                    yAxisKeys.forEach(function (yAxisKey, series) {
                        datum.push({
                            values: _.map(dataSet, function (dataObj, index) {
                                return valueFinder(scope, dataSet[index], xAxisKey, yAxisKey, index, (WM.isArray(shapes) && shapes[series]) || scope.shape);
                            }),
                            key: yAxisKey
                        });
                    });
                }
            }
            return datum;
        }

        /* Getting the relevant aggregation function based on the selected option*/
        function getAggregationFunction(option) {
            switch (option) {
            case "average":
                return "AVG";
            case "count":
                return "COUNT";
            case "maximum":
                return "MAX";
            case "minimum":
                return "MIN";
            case "sum":
                return "SUM";
            default:
                return "";
            }
        }

        /*Constructing the grouped data based on the selection of orderby, x & y axis*/
        function getGroupedData(scope, queryResponse, groupingColumn) {
            var  chartData = [],
                groupData = {},
                groupValues = [],
                groupKey,
                index = 0,
                i;
            scope.xAxisDataType = getColumnType(scope.xaxisdatakey, scope.dataset.propertiesMap.columns);
            scope.yAxisDataType = getColumnType(scope.yaxisdatakey, scope.dataset.propertiesMap.columns);

            while (queryResponse.length !== 0) {
                groupKey = queryResponse[queryResponse.length - 1][groupingColumn];
                groupValues.unshift(valueFinder(scope, queryResponse[queryResponse.length - 1], scope.xaxisdatakey, scope.yaxisdatakey, 0));
                queryResponse.splice(queryResponse.length - 1, 1);
                for (i = queryResponse.length - 1; i >= 0; i -= 1) {
                    /*Checking if the new column groupKey is same as the choosen groupKey*/
                    /*Then pushing the data*/
                    /*Then splicing the data since it is already pushed*/
                    if (groupKey === queryResponse[i][groupingColumn]) {
                        index += 1;
                        groupValues.unshift(valueFinder(scope, queryResponse[i], scope.xaxisdatakey, scope.yaxisdatakey, index));
                        queryResponse.splice(i, 1);
                    }
                }

                /*Pushing the data with groupKey and values*/
                groupData = {
                    key : groupKey,
                    values : groupValues
                };
                chartData.push(groupData);
                groupValues = [];
                index = 0;
            }
            return chartData;
        }

        function getOrderbyExpression(orderby) {
            var orderbyCols = (orderby ? orderby.replace(/:/g, ' ') : '').split(','),
                trimmedCols = '';
            orderbyCols = orderbyCols.map(function (col) {
                return col.trim();
            });
            trimmedCols = orderbyCols.join();
            return trimmedCols;
        }

        /*Replacing the '.' by the '_' because '.' is not supported in the alias names*/
        function getValidAliasName(aliasName) {
            return aliasName ? aliasName.replace(/\./g, '_') : null;
        }

        /* Returns the columns that are to be fetched in the query response*/
        function getQueryColumns(scope) {
            var columns = [],
                groupbyColumns = scope.groupby ? scope.groupby.split(',') : [],
                yAxisKeys = scope.yaxisdatakey ? scope.yaxisdatakey.split(',') : [],
                expr;

            /* adding groupby columns */
            groupbyColumns.forEach(function (columnName) {
                if (columnName !== scope.aggregationcolumn) {
                    columns.push(columnName + " AS " + getValidAliasName(columnName));
                }
            });

            /* adding aggregation column, if enabled */
            if (scope.aggregation !== "none" &&  scope.aggregationcolumn) {
                columns.push(getAggregationFunction(scope.aggregation) + "(" + scope.aggregationcolumn + ") AS " + getValidAliasName(scope.aggregationcolumn));
            }

            /* adding x-axis column, if not pushed yet */
            if (scope.aggregationcolumn !== scope.xaxisdatakey) {
                expr = scope.xaxisdatakey + " AS " + getValidAliasName(scope.xaxisdatakey);
                if (columns.indexOf(expr) === -1) {
                    columns.push(expr);
                }
            }

            /* adding y-axis columns, if not pushed yet */
            yAxisKeys.forEach(function (yAxisKey) {
                if (yAxisKey !== scope.aggregationcolumn) {
                    expr = yAxisKey + " AS " + getValidAliasName(yAxisKey);
                    if (columns.indexOf(expr) === -1) {
                        columns.push(expr);
                    }
                }
            });

            return columns;
        }

        /*Decides whether the data should be visually grouped or not*/
        /*Visually grouped when a different column is choosen in the group by other than x and y axis*/
        function getGroupingDetails(scope) {
            var isVisuallyGrouped = false,
                visualGroupingColumn = '',
                groupingExpression = '',
                groupbyColumns = scope.groupby ? scope.groupby.split(',') : [],
                yAxisKeys = scope.yaxisdatakey ? scope.yaxisdatakey.split(',') : [],
                groupingColumnIndex;

            if (scope.groupby) {
                /*Getting the group by column which is not selected either in x or y axis*/
                groupbyColumns.every(function (column, index) {
                    if (scope.xaxisdatakey !== column && WM.element.inArray(column, yAxisKeys) === -1) {
                        isVisuallyGrouped = true;
                        visualGroupingColumn = column;
                        groupingColumnIndex = index;
                        groupbyColumns.splice(groupingColumnIndex, 1);
                        return false;
                    }
                    return true;
                });
                /*Constructing the groupby expression*/
                if (visualGroupingColumn) {
                    groupingExpression = visualGroupingColumn;
                    if (groupbyColumns.length) {
                        groupingExpression += ",";
                    }
                }

                if (groupbyColumns.length) {
                    groupingExpression += groupbyColumns.join();
                }
            }

            /* set isVisuallyGrouped flag in scope for later use */
            scope.isVisuallyGrouped = isVisuallyGrouped;

            return {
                expression: groupingExpression,
                isVisuallyGrouped: isVisuallyGrouped,
                visualGroupingColumn: visualGroupingColumn
            };
        }

        /*Function to get the aggregated data after applying the aggregation & group by or order by operations.*/
        function getAggregatedData(scope, element, callback) {
            var query,
                variableName,
                variable,
                columns,
                yAxisKeys = scope.yaxisdatakey ? scope.yaxisdatakey.split(',') : [],
                orderbyexpression = getOrderbyExpression(scope.orderby),
                groupingDetails = getGroupingDetails(scope),
                groupbyExpression = groupingDetails.expression,
                elScope = element.scope();

            /*Returning if the data is not yet loaded*/
            if (!scope.chartData) {
                return;
            }

            /*Set the variable name based on whether the widget is bound to a variable opr widget*/
            if (scope.binddataset.indexOf("bind:Variables.") !== -1) {
                variableName = scope.binddataset.replace("bind:Variables.", "");
                variableName = variableName.substr(0, variableName.indexOf("."));
            } else {
                variableName = scope.dataset.variableName;
            }

            variable = elScope.Variables && elScope.Variables[variableName];
            if (!variable) {
                return;
            }
            columns = getQueryColumns(scope);
            query = QueryBuilder.getQuery({
                "tableName": variable.type,
                "columns": columns,
                "filterFields": scope.filterFields || variable.filterFields,
                "groupby": groupbyExpression,
                "orderby": orderbyexpression
            });

            /*Execute the query.*/
            QueryBuilder.executeQuery({
                "databaseName": variable.liveSource,
                "query": query,
                "page": 1,
                "size": 500,
                "nativeSql": false
            }, function (response) {
                /*Transform the result into a format supported by the chart.*/
                var chartData = [],
                    aggregationAlias = getValidAliasName(scope.aggregationcolumn),
                    visualGroupingColumnAlias = groupingDetails.visualGroupingColumn ? getValidAliasName(groupingDetails.visualGroupingColumn) : '',
                    xAxisAliasKey = getValidAliasName(scope.xaxisdatakey),
                    yAxisAliasKeys = [];

                yAxisKeys.forEach(function (yAxisKey) {
                    yAxisAliasKeys.push(getValidAliasName(yAxisKey));
                });

                WM.forEach(response.content, function (data) {
                    var obj = {};
                    /* Set the response in the chartData based on "aggregationColumn", "xAxisDataKey" & "yAxisDataKey".*/
                    if (scope.aggregation !== "none") {
                        obj[scope.aggregationcolumn] = data[aggregationAlias];
                    }

                    if (visualGroupingColumnAlias) {
                        obj[groupingDetails.visualGroupingColumn] = data[visualGroupingColumnAlias];
                    }

                    obj[scope.xaxisdatakey] = data[xAxisAliasKey];
                    yAxisKeys.forEach(function (yAxisKey) {
                        yAxisAliasKeys.push(getValidAliasName(yAxisKey));
                    });

                    yAxisKeys.forEach(function (yAxisKey, index) {
                        obj[yAxisKey] = data[yAxisAliasKeys[index]];
                    });

                    chartData.push(obj);
                });

                scope.chartData = groupingDetails.isVisuallyGrouped ? getGroupedData(scope, chartData, groupingDetails.visualGroupingColumn) : chartData;

                Utils.triggerFn(callback);
            });
        }

        /* Applying the font related styles for the chart*/
        function setTextStyle(properties, id) {
            var charttext = d3.select('#wmChart' + id + ' svg').selectAll('text');
            charttext.style(properties);
        }

        function modifyLegendPosition(scope) {
            var chartId = "wmChart" + scope.$id,
                legendWrap = d3.select("#" + chartId + " .nv-legendWrap"),
                legendWrapHeight,
                legendWrapTransform,
                coordinates,
                y,
                getChartHeight = function () {
                    var chartHeight = $("#" + chartId + " svg>.nvd3.nv-wrap")[0].getBoundingClientRect().height;
                    if (chartHeight === 0) { /*fix for IE*/
                        chartHeight = ($("#" + chartId + " svg")[0].getBoundingClientRect().height - (legendWrapHeight + 15));
                    }
                    return chartHeight;
                },
                getAxisLabelHeight = function (axis) {
                    var axisLabel = d3.select("#" + chartId + " .nv-" + axis + ".nv-axis .nv-axislabel")[0][0];
                    return axisLabel ? axisLabel.getBoundingClientRect().height : 0;
                };

            if (!legendWrap[0][0]) {
                return;
            }

            legendWrapHeight = legendWrap[0][0].getBoundingClientRect().height;
            legendWrapTransform = (legendWrap && legendWrap.attr("transform")) ? legendWrap.attr("transform").replace(/, /g, ",") : "";
            coordinates = /translate\(\s*([^\s,)]+)[ ,]([^\s,)]+)/.exec(legendWrapTransform);

            switch (scope.legendposition) {
            case "Top":
                y = -(legendWrapHeight + 15);
                break;
            case "Bottom":
                if (scope.offsetbottom > legendWrapHeight) {
                    y = getChartHeight() - (legendWrapHeight + 15);

                    if (scope.type !== "Bar") {
                        y = y - getAxisLabelHeight('x');
                    } else if (scope.type === "Bar") {
                        y = y - getAxisLabelHeight('y');
                    }
                }
                break;
            default:
                y = +coordinates[2];
            }

            legendWrap.attr("transform", "translate(" + coordinates[1] + ", " + y + ")");
        }

        function angle(d) {
            var a = (d.startAngle + d.endAngle) * 90 / Math.PI - 90;
            return a > 90 ? a - 180 : a;
        }

        /*This function sets maximum width for the labels that can be displayed.This will helpful when they are overlapping*/
        function setLabelsMaxWidth(scope) {
            var xTicks,
                tickWidth,
                maxLength,
                xDist,
                yDist,
                totalHeight,
                maxNoLabels,
                nthElement,
                labelsAvailableWidth,
                fontsize = parseInt(scope.fontsize, 10) || 12,
                isBarchart = isBarChart(scope.type),
                barWrapper,
                yAxisWrapper,
                svgWrapper;
            /*getting the x ticks in the chart*/
            xTicks = WM.element('#wmChart' + scope.$id + ' svg').find('g.nv-x').find('g.tick').find('text');

            /*getting the distance between the two visible ticks associated with visible text*/
            xTicks.each(function () {
                var xTick = WM.element(this),
                    xTransform,
                    tickDist;
                if (xTick.text() && xTick.css('opacity') === '1') {
                    xTransform = xTick.parent().attr('transform').split(',');
                    xDist = parseFloat(xTransform[0].substr(10));
                    yDist = parseFloat(xTransform[1] || '0');
                    if (!isBarchart && xDist > 0) {
                        tickDist = xDist;
                    } else if (yDist > 0) {
                        tickDist = yDist;
                    }
                    if (tickWidth) {
                        tickWidth = tickDist - tickWidth;
                        return false;
                    }
                    tickWidth = tickDist;
                    return true;
                }
            });

            /*In case of bar chart getting the available space for the labels to be displayed*/
            if (isBarchart) {
                barWrapper = WM.element('#wmChart' + scope.$id + ' svg>g.nv-wrap>g>g.nv-barsWrap')[0];
                yAxisWrapper = WM.element('#wmChart' + scope.$id + ' svg>g.nv-wrap>g>g.nv-y')[0];
                svgWrapper = WM.element('#wmChart' + scope.$id + ' svg')[0];
                /*getting the total height of the chart*/
                totalHeight = barWrapper ? barWrapper.getBoundingClientRect().height : 0;
                /*getting the labels available space*/
                labelsAvailableWidth = yAxisWrapper ? svgWrapper.getBoundingClientRect().width - yAxisWrapper.getBoundingClientRect().width : svgWrapper.getBoundingClientRect().width;

                /*Setting the max length for the label*/
                maxLength = Math.round(labelsAvailableWidth / fontsize);
                /*if available space for each label is less than the font-size*/
                /*then limiting the labels to be displayed*/
                if (tickWidth < fontsize) {
                    /*calculate the maximum no of labels to be fitted*/
                    maxNoLabels = totalHeight / fontsize;
                    /*showing only the nth element*/
                    nthElement = Math.ceil(scope.chartData.length / maxNoLabels);
                    /*showing up only some labels*/
                    d3.select('#wmChart' + scope.$id + ' svg').select('g.nv-x').selectAll('g.tick').select('text').each(function (text, i) {
                        /*hiding every non nth element*/
                        if (i % nthElement !== 0) {
                            d3.select(this).attr('opacity', 0);
                        }
                    });
                }
            } else {
                /*Setting the max length for the label*/
                maxLength = Math.round(tickWidth / fontsize);
            }

            /*Validating if every label exceeds the max length and if so limiting the length and adding ellipsis*/
            xTicks.each(function () {
                if (this.textContent.length > maxLength) {
                    this.textContent = this.textContent.substr(0, maxLength) + '...';
                }
            });
        }

        /* Returns the columns of that can be choosen in the x and y axis*/
        function getDefaultColumns(scope) {
            var defaultColumns = [],
                type,
                stringColumn,
                columns = scope.isLiveVariable ? scope.dataset.propertiesMap.columns : [],
                i,
                temp;


            for (i = 0; i < columns.length && defaultColumns.length <= 2; i += 1) {
                type = columns[i].type;
                if (!columns[i].isRelated && (isNumberType(type))) {
                    defaultColumns.push(columns[i].fieldName);
                } else if (type === 'string' && !stringColumn) {
                    stringColumn = columns[i].fieldName;
                }
            }
            /*Other than bubble chart x: string type y: number type*/
            /*Bubble chart x: number type y: number type*/
            if (stringColumn && defaultColumns.length > 0 && !isBubbleChart(scope.type)) {
                temp = defaultColumns[0];
                defaultColumns[0] = stringColumn;
                defaultColumns[1] = temp;
            }

            return defaultColumns;
        }

        /*Creating a formatter based on the number format and no of digits chosen*/
        function getFormatOptions(numberformat, digits) {
            var formater,
                nodigits = WM.isDefined(digits) ? digits.toString() : '';
            switch (numberformat) {
            case 'Display Digits':
                formater = nodigits + 'f';
                break;
            case 'Decimal Digits':
                formater = '.' + nodigits + 'f';
                break;
            case 'Precision':
                formater = '.' + nodigits + 'g';
                break;
            case 'Exponential':
                formater = '.' + nodigits + 'e';
                break;
            case 'Percentage':
                formater = '.' + nodigits + '%';
                break;
            case 'Round':
                formater = ',' + nodigits + 'r';
                break;
            case 'Round Percentage':
                formater = '.' + nodigits + 'p';
                break;
            }
            return formater;
        }

        /*Call user defined javascript function when user links it to click event of the widget.*/
        function attachClickEvent(scope) {
            var dataObj;
            d3.select('#wmChart' + scope.$id + ' svg').selectAll(chartDataPointXpath[scope.type]).style("pointer-events", "all").on('click', function (data, index) {
                switch (scope.type) {
                case 'Column':
                case 'Bar':
                    dataObj = data._dataObj;
                    break;
                case 'Pie':
                case 'Donut':
                    dataObj = data.data._dataObj;
                    break;
                case 'Area':
                case 'Cumulative Line':
                case 'Line':
                    dataObj = data[0].values[index]._dataObj;
                    break;
                case 'Bubble':
                    dataObj = data.data.point[4]._dataObj;
                    break;
                }
                $rootScope.$safeApply(scope, function () {
                    scope.selecteditem = dataObj;
                    scope.onSelect && scope.onSelect({$event: d3.event, $isolateScope: scope, selectedChartItem: data, selectedItem: scope.selecteditem});
                });
            });
        }

        /*Check whether X/Y Domain was set to Min and is supported for the present chart*/
        function isAxisDomainValid(scope, axis) {
            if (scope[axis + 'domain'] === 'Min' && (isAxisDomainSupported(scope.type))) {
                return true;
            }
            return false;
        }

        /*Check whether min and max values are finite or not*/
        function areMinMaxValuesValid(values) {
            if (_.isFinite(values.min) && _.isFinite(values.max)) {
                return true;
            }
            return false;
        }

        /*  Returns Y Scale min value
            Ex: Input   : 8.97
                Output  : 8.87

                Input   : 8
                Output  : 7
        */

        function getYScaleMinValue(value) {
            var _min = Math.floor(value);
            /* If the number has a) decimal part returning floor value - 0.1
                                 b) no decimal part returning floor value - 1 */
            return Math.abs(value) - _min > 0 ? value - 0.1 : _min - 1;
        }

        /* intializes the chart obejct */
        function initChart(scope, xDomainValues, yDomainValues) {
            var chart, theme, xValue = {}, yValue = {};
            switch (scope.type) {
            case 'Column':
                chart = nv.models.multiBarChart()
                    .x(function (d) {
                        return d.x;
                    })
                    .y(function (d) {
                        return d.y;
                    })
                    .staggerLabels(scope.staggerlabels)
                    .reduceXTicks(scope.reducexticks)
                    .rotateLabels(0)
                    .showControls(scope.showcontrols)
                    .groupSpacing(scope.barspacing);
                break;
            case 'Cumulative Line':
                chart = nv.models.cumulativeLineChart()
                    .x(function (d) {
                        return d[0];
                    })
                    .y(function (d) {
                        return d[1] / 100;
                    })
                    .useInteractiveGuideline(true)
                    .showControls(scope.showcontrols);
                break;
            case 'Line':
                chart = nv.models.lineChart()
                    .useInteractiveGuideline(true);
                break;
            case 'Area':
                chart = nv.models.stackedAreaChart()
                    .x(function (d) {
                        return d[0];
                    })
                    .y(function (d) {
                        return d[1];
                    })
                    .clipEdge(true)
                    .showControls(scope.showcontrols)
                    .useInteractiveGuideline(true);
                break;
            case 'Bar':
                chart = nv.models.multiBarHorizontalChart()
                    .x(function (d) {
                        return d.x;
                    })
                    .y(function (d) {
                        return d.y;
                    })
                    .showControls(scope.showcontrols)
                    .showValues(scope.showvalues)
                    .groupSpacing(scope.barspacing);
                break;
            case 'Pie':
            case 'Donut':
                chart = nv.models.pieChart()
                    .x(function (d) {
                        return d.x;
                    })
                    .y(function (d) {
                        return d.y;
                    })
                    .showLabels(scope.showlabels)
                    .labelType(scope.labeltype)
                    .valueFormat(d3.format('%'))
                    .title(scope.title)
                    .labelThreshold(0.04)
                    .labelsOutside(scope.showlabelsoutside);
                if (isDonutChart(scope.type)) {
                    chart.donut(true)
                        .donutRatio(scope.donutratio);
                }
                break;
            case 'Bubble':
                chart = nv.models.scatterChart()
                    .x(function (d) {
                        return d.x;
                    })
                    .y(function (d) {
                        return d.y;
                    })
                    .showDistX(scope.showxdistance)
                    .showDistY(scope.showydistance);
                break;
            }

            if (isAxisDomainValid(scope, 'x') && xDomainValues) {
                xValue.min = xDomainValues.min.x || xDomainValues.min[0];
                xValue.max = xDomainValues.max.x || xDomainValues.max[0];
                /*If the values on the x axis are string then min max values gives Infinity*/
                if (areMinMaxValuesValid(xValue)) {
                    /*Reducing the min value to 0.1 so the min value is not missed out*/
                    xValue.min = getYScaleMinValue(xValue.min);
                    chart.xDomain([xValue.min, xValue.max]);
                }
            }

            if (isAxisDomainValid(scope, 'y') && yDomainValues) {
                /*Reducing the min value to 1 so the min value is not missed out*/
                yValue.min = yDomainValues.min.y || yDomainValues.min[1];
                yValue.max = yDomainValues.max.y || yDomainValues.max[1];
                /*If the values on the y axis are string or invalid then min max values gives Infinity*/
                if (areMinMaxValuesValid(yValue)) {
                    /*Reducing the min value to 1 so the min value is not missed out*/
                    yValue.min = getYScaleMinValue(yValue.min);
                    chart.yDomain([yValue.min, yValue.max]);
                }
            }

            /*Setting the legend type choosen by user or default it will be furious*/
            chart.legend.vers((scope.legendtype && scope.legendtype.toLowerCase()) || 'furious');

            if (chartTypes.indexOf(scope.type) === -1) {
                chart = nv.models.multiBarChart()
                    .x(function (d) {
                        return d.x;
                    })
                    .y(function (d) {
                        return d.y;
                    });
            }

            /*Default theme for pie/donut is Azure and for other it is Terrestrial*/
            if (isPieType(scope.type)) {
                theme = scope.theme || 'Azure';
            } else {
                theme = scope.theme || 'Terrestrial';
                chart.showXAxis(scope.showxaxis)
                    .showYAxis(scope.showyaxis);
            }

            if (CONSTANTS.isStudioMode) {
                /*Updating the markup with the theme*/
                scope.theme = theme;
                scope.$root.$emit("set-markup-attr", scope.widgetid, {'theme': theme});
            }

            chart.showLegend(scope.showlegend)
                .margin({top: scope.offsettop, right: scope.offsetright, bottom: scope.offsetbottom, left: scope.offsetleft})
                .color(scope.customcolors || themes[theme].colors);

            chart.tooltip.enabled(scope.tooltips);
            /*setting the no data message*/
            chart.noData(scope.message);
            return chart;
        }

        /*Chooses the data points of line/cumulative line/area chart and highlights them*/
        function highlightPoints(id, highlightpoints) {
            var chartSvg = d3.select('#wmChart' + id + ' svg');
            if (highlightpoints) {
                chartSvg.selectAll('.nv-point').style({"stroke-width": '6px', "fill-opacity": '.95', "stroke-opacity": '.95'});
            } else {
                chartSvg.selectAll('.nv-point').style({"stroke-width": '0px', "fill-opacity": '0'});
            }
        }

        /*Chooses the line of line/cumulative line and increases the thickness of it*/
        function setLineThickness(id, thickness) {
            var chartSvg = d3.select('#wmChart' + id + ' svg');
            if (thickness) {
                chartSvg.selectAll('.nv-line').style({"stroke-width": thickness});
            }
        }

        function postPlotProcess(scope, element, chart) {
            var chartSvg,
                pieLabels,
                pieGroups,
                angleArray,
                styleObj = {};

            /*If user sets to highlight the data points and increase the thickness of the line*/
            if (isLineTypeChart(scope.type)) {
                setLineThickness(scope.$id, scope.linethickness);
                highlightPoints(scope.$id, scope.highlightpoints);
            }

            if (!isPieType(scope.type)) {
                setLabelsMaxWidth(scope);
            } else if (!scope.showlabelsoutside) {
                /** Nvd3 has a issue in rotating text. So we will use this as a temp fix.
                 * If the issue is resolved there, we can remove this.*/
                /* If it is a donut chart, then rotate the text and position them*/
                chartSvg = d3.select('#wmChart' + scope.$id + ' svg');
                pieLabels = chartSvg.select('.nv-pieLabels').selectAll('.nv-label');
                pieGroups = chartSvg.select('.nv-pie').selectAll('.nv-slice');
                angleArray = [];
                if (pieGroups && pieGroups.length) {
                    pieGroups.each(function () {
                        d3.select(this).attr('transform', function (d) {
                            angleArray.push(angle(d));
                        });
                    });
                    pieLabels.each(function (d, i) {
                        var group = d3.select(this);
                        WM.element(group[0][0]).find("text").attr('transform', 'rotate(' + angleArray[i] + ')');
                    });
                }
            }

            /* prepare text style props object and set */
            WM.forEach(styleProps, function (value, key) {
                if (key === 'fontsize' || key === 'fontunit') {
                    styleObj[value] = scope.fontsize + scope.fontunit;
                } else {
                    styleObj[value] = scope[key];
                }
            });
            setTextStyle(styleObj, scope.$id);
            /*Modifying the legend position only when legend is shown*/
            if (scope.showlegend) {
                modifyLegendPosition(scope);
            }

            /*
             * allow window-resize functionality, for only-run mode as
             * updating chart is being handled by watchers of height & width in studio-mode
             * */
            if (CONSTANTS.isRunMode) {
                nv.utils.windowResize(function () {
                    if (element[0].getBoundingClientRect().height) {
                        chart.update();
                        if (!isPieType(scope.type)) {
                            setLabelsMaxWidth(scope);
                        }
                    } else {
                        var parent = element.closest('.app-accordion-panel, .tab-pane').isolateScope();
                        if (parent) {
                            parent.initialized = false;
                        }
                    }
                });
            }
        }

        /* prepares and configures the chart properties */
        function configureChart(scope, element, datum) {
            /*Copy the data only in case of pie chart with default data*/
            /*Reason : when multiple pie charts are bound to same data, first chart theme will be applied to all charts*/
            var chartData = datum,
                xDomainValues,
                yDomainValues,
                chart,
                xFormat,
                yFormat,
                xnumberformat = scope.xnumberformat,
                ynumberformat = scope.ynumberformat,
                xaxislabel,
                yaxislabel;
            if (isAxisDomainValid(scope, 'x')) {
                xDomainValues = scope.binddataset ? getXMinMaxValues(datum[0]) : { 'min' : {'x': 1},  'max' : {'x' : 5}};
            }
            if (isAxisDomainValid(scope, 'y')) {
                yDomainValues = scope.binddataset ? getYMinMaxValues(datum) : { 'min' : {'y' : 1}, 'max' : {'y' : 5}};
            }

            if (isPieType(scope.type) && (!scope.binddataset || !scope.scopedataset)) {
                chartData = Utils.getClonedObject(scope.scopedataset || datum);
            }
            /* checking the parent container before plotting the chart */
            if (!element[0].getBoundingClientRect().height) {
                return;
            }

            if (scope.xnumberformat && scope.xdigits) {
                xFormat = getFormatOptions(scope.xnumberformat, scope.xdigits);
            }
            if (scope.ynumberformat && scope.ydigits) {
                yFormat = getFormatOptions(scope.ynumberformat, scope.ydigits);
            } else if (scope.type === "Cumulative Line") {
                yFormat = getFormatOptions('Percentage', '2');
            }

            /*empty svg to add-new chart*/
            element.find('svg').empty();

            /* get the chart obejct */
            chart = initChart(scope, xDomainValues, yDomainValues);

            if (!isPieType(scope.type)) {
                /*Setting the labels if they are specified explicitly or taking the axiskeys chosen*/
                xaxislabel = scope.xaxislabel || scope.xaxisdatakey || 'x caption';
                yaxislabel = scope.yaxislabel || scope.yaxisdatakey || 'y caption';
                /*Adding the units to the captions if they are specified*/
                xaxislabel += scope.xunits ? "(" + scope.xunits + ")" : "";
                yaxislabel += scope.yunits ? "(" + scope.yunits + ")" : "";

                if (scope.captions) {
                    chart.xAxis.axisLabel(Utils.prettifyLabels(xaxislabel));
                    chart.yAxis.axisLabel(Utils.prettifyLabels(yaxislabel));
                }


                chart.xAxis
                    .axisLabelDistance(scope.xaxislabeldistance)
                    .tickFormat(function (d) {
                        return formatData(scope, d, scope.xAxisDataType, {
                            dateFormat: scope.xdateformat,
                            numberFormat: xnumberformat,
                            format: xFormat,
                            isXaxis: true,
                            xDataKeyArr: scope.xDataKeyArr
                        });
                    });
                chart.yAxis
                    .axisLabelDistance(scope.yaxislabeldistance)
                    .tickFormat(function (d) {
                        return formatData(scope, d, scope.yAxisDataType, {
                            dateFormat: scope.ydateformat,
                            numberFormat: ynumberformat,
                            format: yFormat,
                            isXaxis: false,
                            xDataKeyArr: scope.xDataKeyArr
                        });
                    });
            } else {
                /*In case of pie/donut chart formatting the values of it*/
                if (scope.labeltype === "percent") {
                    chart.valueFormat(d3.format('%'));
                } else {
                    chart.valueFormat(function (d) {
                        return formatData(scope, d, scope.yAxisDataType, {
                            dateFormat: scope.ydateformat,
                            numberFormat: ynumberformat,
                            format: yFormat,
                            isXaxis: false,
                            xDataKeyArr: scope.xDataKeyArr
                        });
                    });
                }
            }


            /*Customizing the tooltips in case of the pie and donut when labelType is value */
            if (isPieType(scope.type)) {
                chart.tooltip.contentGenerator(function (key) {
                    var yValue;
                    if (scope.labeltype === 'percent') {
                        yValue = d3.format('.3s')(key.data.y);
                    } else if (scope.labeltype === 'value') {
                        yValue = formatData(scope, key.data.y, scope.yAxisDataType, {
                            dateFormat: scope.ydateformat,
                            numberFormat: ynumberformat,
                            format: yFormat,
                            isXaxis: false,
                            xDataKeyArr: scope.xDataKeyArr
                        });
                    }
                    return "<div class='nvtooltip xy-tooltip nv-pointer-events-none'>" +
                                "<table>" +
                                    "<tbody>" +
                                        "<tr>" +
                                            "<td class='legend-color-guide'><div style='background-color:" + key.color + ";'></div></td>" +
                                            "<td class='key'>" + key.data.x + "</td>" +
                                            "<td class='value'>" + yValue + "</td>" +
                                        "</tr>" +
                                    "</tbody>" +
                                "</table>" +
                            "</div>";
                });
            }

            /** changing the default no data message**/
            d3.select('#wmChart' + scope.$id + ' svg')
                .datum(chartData)
                .call(chart);

            postPlotProcess(scope, element, chart);
            return chart;
        }

        /* Plotting the chart with set of the properties set to it*/
        function plotChart(scope, element) {
            var datum;
            /*Plot the chart only if valid axis are chosen and aggregation not enabled.
             When aggregation enabled, in run time plot chart with sample data so not returning in that case*/
            if (!isValidAxis(scope)) {
                if (!(CONSTANTS.isRunMode && isAggregationEnabled(scope))) {
                    return;
                }
            }

            /*call user-transformed function*/
            scope.chartData = (scope.onTransform && scope.onTransform({$scope: scope})) || scope.chartData;

            /*Getting the order by data only in run mode. The order by applies for all the charts other than pie and donut charts*/
            if (scope.isVisuallyGrouped && !isPieType(scope.type)) {
                datum = scope.chartData;
            } else {
                datum = getChartData(scope);
            }

            /*return if datum is empty*/
            if ((scope.variableInflight === false && datum && datum.length === 0)) {
                scope.message = scope.nodatamessage || 'No data found';
            }

            nv.addGraph(function () {
                configureChart(scope, element, datum);
            }, function () {
                /*Bubble chart has an time out delay of 300ms in their implementation due to which we
                * won't be getting required data points on attaching events
                * hence delaying it 600ms*/
                setTimeout(function () {
                    attachClickEvent(scope);
                }, 600);
            });
        }

        function plotChartProxy(scope, element) {
            /*If aggregation/group by/order by properties have been set, then get the aggregated data and plot the result in the chart.*/
            if (scope.binddataset && scope.isLiveVariable && (scope.filterFields || isAggregationEnabled(scope))) {
                getAggregatedData(scope, element, function () {
                    plotChart(scope, element);
                });
            } else { /*Else, simply plot the chart.*/
                /*In case of live variable resetting the aggregated data to the normal dataset when the aggregation has been removed*/
                if (scope.dataset && scope.dataset.data && scope.isLiveVariable) {
                    scope.chartData = scope.dataset.data;
                }
                plotChart(scope, element);
            }
        }

        /* sets the default x and y axis options */
        function setDefaultAxisOptions(scope) {
            var defaultColumns = getDefaultColumns(scope);
            /*If we get the valid default columns then assign them as the x and y axis*/
            /*In case of service variable we may not get the valid columns because we cannot know the datatypes*/
            scope.xaxisdatakey = defaultColumns[0] || null;
            scope.yaxisdatakey = defaultColumns[1] || null;
            scope.$root.$emit("set-markup-attr", scope.widgetid, {'xaxisdatakey': scope.xaxisdatakey, 'yaxisdatakey': scope.yaxisdatakey});
        }

        /*Function that iterates through all the columns and then fetching the numeric and non primary columns among them*/
        function setNumericandNonPrimaryColumns(scope) {
            var columns,
                type;
            scope.numericColumns = [];
            scope.nonPrimaryColumns = [];
            /*Fetching all the columns*/
            if (scope.dataset && scope.dataset.propertiesMap) {
                columns = Utils.fetchPropertiesMapColumns(scope.dataset.propertiesMap);
            }

            if (columns) {
                /*Iterating through all the columns and fetching the numeric and non primary key columns*/
                WM.forEach(Object.keys(columns), function (key) {
                    type = columns[key].type;
                    if (isNumberType(type)) {
                        scope.numericColumns.push(key);
                    }
                    /*Hiding only table's primary key*/
                    if (columns[key].isRelatedPk === 'true' || !columns[key].isPrimaryKey) {
                        scope.nonPrimaryColumns.push(key);
                    }
                });
                scope.numericColumns = scope.numericColumns.sort();
                scope.nonPrimaryColumns = scope.nonPrimaryColumns.sort();
            }
        }

        /*Sets the aggregation columns*/
        function setAggregationColumns(scope) {
            if (!scope.axisoptions) {
                return;
            }
            /*Set the "aggregationColumn" to show all keys in case of aggregation function is count or to numeric keys in all other cases.*/
            scope.widgetProps.aggregationcolumn.options = scope.aggregation === "count" ? scope.axisoptions : scope.numericColumns;
        }

        /*Sets the groupby columns to the non primary key columns and other than aggregation column if chosen*/
        function setGroupByColumns(scope) {
            var index,
                columns = Utils.getClonedObject(scope.nonPrimaryColumns),
                choosenColumn = scope.widgetProps.groupby && scope.widgetProps.groupby.selectedvalues ?  scope.widgetProps.groupby.selectedvalues.split(',')[0] : '';
            /*Removing the aggregation column out of the non primary columns*/
            if (scope.nonPrimaryColumns && scope.aggregationcolumn) {
                index = scope.nonPrimaryColumns.indexOf(scope.aggregationcolumn);
                if (index >= 0) {
                    columns.splice(index, 1);
                }
            }
            /*Making groupby as single select when chart is of pie type*/
            if (isPieType(scope.type)) {
                scope.widgetProps.groupby.widget = 'list';
                /*Adding the none option to the groupby columns*/
                if (columns && columns.length > 0 && columns.indexOf("none") === -1) {
                    columns.push('none');
                }
                scope.widgetProps.groupby.options = columns;
                $rootScope.$emit('update-widget-property', 'groupby', choosenColumn);
            } else {
                scope.widgetProps.groupby.widget = 'multiselect';
                scope.widgetDataset.groupby = columns || [];
            }
        }

        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
        function propertyChangeHandler(scope, element, key, newVal, oldVal) {
            var variableName,
                variableObj,
                elScope,
                styleObj = {};
            switch (key) {
            case "dataset":
                elScope = element.scope();
                /*Set the variable name based on whether the widget is bound to a variable opr widget*/
                if (scope.binddataset && scope.binddataset.indexOf("bind:Variables.") !== -1) {
                    variableName = scope.binddataset.replace("bind:Variables.", "");
                    variableName = variableName.substr(0, variableName.indexOf("."));
                } else {
                    variableName = scope.dataset.variableName;
                }
                /*Resetting the flag to false when the binding was removed*/
                if (!newVal && !scope.binddataset) {
                    scope.isVisuallyGrouped = false;
                }

                variableObj = elScope.Variables && elScope.Variables[variableName];
                /*setting the flag for the live variable in the scope for the checks*/
                scope.isLiveVariable = variableObj && variableObj.category === 'wm.LiveVariable';
                scope.axisoptions = WidgetUtilService.extractDataSetFields(scope.dataset, scope.dataset.propertiesMap, true);

                /*If binded to a live variable feed options to the aggregation and group by*/
                if (scope.isLiveVariable && CONSTANTS.isStudioMode) {
                    /*Updating the numeric and non primary columns when dataset is changed*/
                    setNumericandNonPrimaryColumns(scope);
                    setAggregationColumns(scope);
                    setGroupByColumns(scope);
                }
                scope.isServiceVariable = variableObj && variableObj.category === 'wm.ServiceVariable';

                /*liveVariables contain data in 'data' property" of the variable*/
                scope.chartData = scope.isLiveVariable ? newVal && (newVal.data || '') : newVal;

                /*if the data returned is an object make it an array of object*/
                if (!WM.isArray(scope.chartData) && WM.isObject(scope.chartData)) {
                    scope.chartData = [scope.chartData];
                }

                /* perform studio mode actions */
                if (CONSTANTS.isStudioMode) {
                    /* if dataset changed from workspace controller, set default columns */
                    if (scope.newcolumns) {
                        setDefaultAxisOptions(scope);
                        scope.newcolumns = false;
                    }
                    /*hiding the aggregation,group by and order by upon binding to the service variable*/
                    hideOrShowProperties(advanceDataProps, scope, scope.isLiveVariable);
                    modifyAxesOptions(scope);
                }

                if (newVal.filterFields) {
                    scope.filterFields = newVal.filterFields;
                }

                /* plotchart for only valid data and only after bound variable returns data */
                if (scope.chartData.length && !scope.variableInflight) {
                    plotChartProxy(scope, element);
                }
                break;
            case "xaxisdatakey":
                if (scope.chartReady) {
                    /*Showing the formatting options for x axis based on the type of it*/
                    if (CONSTANTS.isStudioMode) {
                        displayFormatOptions(scope, 'x');
                    }
                    plotChartProxy(scope, element);
                }
                break;
            case "yaxisdatakey":
                if (scope.chartReady) {
                    /*Showing the formatting options for y axis based on the type of it*/
                    if (CONSTANTS.isStudioMode) {
                        displayFormatOptions(scope, 'y');
                    }
                    plotChartProxy(scope, element);
                }
                break;
            case "type":
                /*setting group by columns based on the chart type*/
                setGroupByColumns(scope);
                /*Based on the change in type deciding the default margins*/
                if (isPieType(newVal)) {
                    scope.offsettop = 0;
                    scope.offsetright = 0;
                    scope.offsetbottom = 0;
                    scope.offsetleft = 0;
                } else if (isPieType(oldVal)) {
                    scope.offsettop = 25;
                    scope.offsetright = 25;
                    scope.offsetbottom = 55;
                    scope.offsetleft = 75;
                }

                /* In studio mode, configure properties dependent on chart type */
                if (CONSTANTS.isStudioMode) {
                    togglePropertiesByChartType(scope);
                }

                if (scope.chartReady) {
                    plotChartProxy(scope, element);
                }
                break;
            case "showlegend":
                /*Disabling and enabling the legend position and legend type when show legend is changed*/
                scope.widgetProps.legendposition.disabled = !newVal;
                scope.widgetProps.legendtype.disabled = !newVal;
                if (scope.chartReady) {
                    plotChartProxy(scope, element);
                }
                break;
            case "height":
            case "width":
            case "show":
            case "xaxislabel":
            case "yaxislabel":
            case "xunits":
            case "yunits":
            case "xnumberformat":
            case "xdigits":
            case "xdateformat":
            case "ynumberformat":
            case "ydigits":
            case "ydateformat":
            case "showvalues":
            case "showlabels":
            case "showcontrols":
            case "staggerlabels":
            case "reducexticks":
            case "offsettop":
            case "offsetbottom":
            case "offsetright":
            case "offsetleft":
            case "barspacing":
            case "xaxislabeldistance":
            case "yaxislabeldistance":
            case "theme":
            case "labeltype":
            case "donutratio":
            case "showlabelsoutside":
            case "showxdistance":
            case "showydistance":
            case "bubblesize":
            case "shape":
            case "orderby":
            case "nodatamessage":
            case "captions":
            case "showxaxis":
            case "showyaxis":
            case "title":
            case "customcolors":
            case "legendtype":
            case "xdomain":
            case "ydomain":
                    /**In RunMode, the plotchart method will not be called for all property change */
                if (scope.chartReady) {
                    plotChartProxy(scope, element);
                }
                break;
            case "aggregation":
                /*In case of studio mode setting the aggregation columns*/
                if (CONSTANTS.isStudioMode) {
                    toggleAggregationColumnState(scope);
                    modifyAxesOptions(scope);
                    /*Plot the chart when a valid aggregation function and column are chosen*/
                    if (scope.aggregation !== "none") {
                        /*Setting the aggregation columns based on the aggregation function chosen*/
                        setAggregationColumns(scope);
                    }
                }
                /*In case of run mode plotting the chart if valid columns are chosen*/
                if (scope.aggregation !== "none" && scope.aggregationcolumn && scope.groupby) {
                    plotChartProxy(scope, element);
                }
                break;
            case "aggregationcolumn":
                /*In case of studio mode setting the x,y,group by columns*/
                if (scope.chartReady) {
                    if (CONSTANTS.isStudioMode) {
                        modifyAxesOptions(scope);
                        /*Setting the group by columns when aggregation column is changed*/
                        setGroupByColumns(scope);
                    }
                    /*Plot the chart when a valid aggregation column are chosen*/
                    if (scope.aggregation !== "none" && scope.groupby) {
                        plotChartProxy(scope, element);
                    }
                }
                break;
            case "groupby":
                /*In case of studio mode setting the x,y columns*/
                if (scope.chartReady) {
                    if (CONSTANTS.isStudioMode) {
                        toggleAggregationState(scope);
                        scope.widgetProps.groupby.selectedvalues = newVal;
                        modifyAxesOptions(scope);
                    }
                    /*Re-plot the chart when the group by columns are chosen*/
                    plotChartProxy(scope, element);
                }
                break;
            case "fontsize":
            case "fontunit":
            case "color":
            case "fontfamily":
            case "fontweight":
            case "fontstyle":
            case "textdecoration":
                if (scope.chartReady) {
                    styleObj[styleProps[key]] = (key === 'fontsize' || key === 'fontunit') ? scope.fontsize + scope.fontunit : newVal;
                    setTextStyle(styleObj, scope.$id);
                }
                break;
            case "legendposition":
                /*Modifying the legend position only when legend is shown*/
                if (scope.chartReady && scope.showlegend) {
                    modifyLegendPosition(scope);
                }
                break;
            case "linethickness":
                if (scope.chartReady) {
                    setLineThickness(scope.$id, scope.linethickness);
                }
                break;
            case "highlightpoints":
                if (scope.chartReady) {
                    highlightPoints(scope.$id, scope.highlightpoints);
                }
                break;
            }
        }

        return {
            restrict: 'E',
            replace: true,
            scope: {
                "scopedataset": '=?',
                "onTransform": '&',
                "onSelect": '&'
            },
            template: $templateCache.get("template/widget/form/chart.html"),
            compile: function () {
                return {
                    pre: function (iScope) {
                        if (CONSTANTS.isStudioMode) {
                            iScope.widgetProps = Utils.getClonedObject(widgetProps);
                        } else {
                            iScope.widgetProps = widgetProps;
                        }
                    },
                    post: function (scope, element, attrs) {
                        var handlers = [],
                            boundVariableName;
                        /* flag to prevent initial chart plotting on each property change */
                        scope.chartReady = false;

                        /*add id the the chart*/
                        element.attr('id', 'wmChart' + scope.$id);
                        scope.widgetDataset = {};

                        /* register the property change handler */
                        WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, scope, element), scope, notifyFor);

                        /*Executing WidgetUtilService method to initialize the widget with the essential configurations.*/
                        WidgetUtilService.postWidgetCreate(scope, element, attrs);

                        /** Note:  The below code has to be called only after postWidgetCreate */
                        /** During initial load the plot chart will be called only once. During load time, "plotChart" should not
                         * be called on each property change*/
                        scope.chartReady = true;

                        /* When there is not value binding, then plot the chart with sample data */
                        if (!scope.binddataset && !attrs.scopedataset) {
                            plotChartProxy(scope, element);
                        }

                        /* Run Mode Iniitilzation */
                        if (CONSTANTS.isRunMode) {
                            /* fields defined in scope: {} MUST be watched explicitly */
                            /*watching scopedataset attribute to plot chart for the element.*/
                            if (attrs.scopedataset) {
                                scope.$watch("scopedataset", function (newVal) {
                                    scope.chartData = newVal || scope.chartData;
                                    plotChartProxy(scope, element);
                                });
                            }
                        } else {
                            /* on canvas-resize, plot the chart again */
                            scope.$on('$destroy', scope.$root.$on('canvas-resize', function () {
                                plotChartProxy(scope, element);
                            }));
                        }

                        if (scope.binddataset && scope.binddataset.indexOf("bind:Variables.") !== -1) {
                            boundVariableName = scope.binddataset.replace("bind:Variables.", "");
                            boundVariableName = boundVariableName.split('.')[0];
                            handlers.push($rootScope.$on('toggle-variable-state', function (event, variableName, active) {
                                /*based on the active state and response toggling the 'loading data...' and 'no data found' messages */
                                /*variable is active.so showing loading data message*/
                                if (boundVariableName === variableName) {
                                    scope.variableInflight = active;
                                    scope.message = active ? 'Loading Data...' : '';
                                }
                            }));
                        }

                        /*Container widgets like tabs, accordions will trigger this method to redraw the chart.*/
                        scope.redraw = plotChartProxy.bind(undefined, scope, element);
                    }
                };
            }
        };
    });

/**
 * @ngdoc directive
 * @name wm.widgets.basic.directive:wmChart
 * @restrict E
 *
 * @description
 * The `wmChart` directive defines a chart widget.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires $rootScope
 * @requires $templateCache
 * @requires WidgetUtilService
 *
 * @param {string=} name
 *                  Name of the chart widget.
 * @param {list=} type
 *                  The type of the chart.
 * @param {string=} width
 *                  Width of the chart.
 * @param {string=} height
 *                  Height of the chart.
 * @param {string=} offset
 *                  This property controls the offset of the chart.
 * @param {string=} scopedatavalue
 *                  Variable defined in controller scope.<br>
 *                  The value of this variable is used as data in plotting chart.
 * @param {string=} dataset
 *                  Sets the data for the chart.<br>
 *                  This property supports binding with variables.<br>
 *                  When bound to a variable, the data associated with the variable becomes the basis for data for plotting the chart.
 * @param {list=} groupby
 *                  Shows the options to group the data.<br>
 * @param {list=} aggregation
 *                  Shows the options to aggregate the data in the chart.<br>
 * @param {list=} aggregationcolumn
 *                  Shows the options to aggregate the data in the chart.<br>
 * @param {list=} orderby
 *                  Shows the options to order the data.<br>
 * @param {list=} xaxisdatakey
 *                  The key of the object, i.e x-axis variable, on the chart.<br>
 * @param {string=} xaxislabel
 *                  The caption of x axis on the chart.<br>
 * @param {list=} xnumberformat
 *                  Shows the options to format the number type in x axis.<br>
 * @param {number=} xdigits
 *                  The number of digits to be displayed after decimal in x axis.<br>
 * @param {list=} xdateformat
 *                  Shows the options to format the date type in x axis.<br>
 * @param {number=} xaxislabeldistance
 *                  This property controls the distance between the x axis and its label.<br>
 * @param {number=} xaxisunits
 *                  This property controls the distance between the x axis and its label.
 * @param {list=} yaxisdatakey
 *                  The key of the object, i.e y-axis variable, on the chart.<br>
 * @param {string=} yaxislabel
 *                  The caption of x axis on the chart.<br>
 * @param {list=} ynumberformat
 *                  Shows the options to format the number type in x axis.<br>
 * @param {number=} ydigits
 *                  The number of digits to be displayed after decimal in x axis.<br>
 * @param {list=} ydateformat
 *                  Shows the options to format the date type in x axis.<br>
 * @param {number=} yaxislabeldistance
 *                  This property controls the distance between the x axis and its label.<br>
 * @param {number=} yaxisunits
 *                  Specifies the units for the y axis.<br>
 * @param {boolean=} show
 *                  Show isa bindable property. <br>
 *                  This property will be used to show/hide the chart widget on the web page. <br>
 *                  Default value: `true`. <br>
 * @param {string=} nodatamessage
 *                  This message will be displayed in grid, when there is no data to display. <br>
 * @param {boolean=} tooltips
 *                  This property controls whether to show the tooltip on hover. <br>
 * @param {boolean=} showlegend
 *                  This property controls whether to show the legends. <br>
 * @param {list=} legendposition
 *                  This property controls where to show the legends. <br>
 *                  Possible values are Top, Bottom.
 *                  Default value: `Top`. <br>
 *@param {boolean=} showvalues
 *                  This property controls showing of values on the bars. <br>
 *@param {boolean=} showlabels
 *                  This property controls showing of labels. <br>
 *@param {boolean=} showcontrols
 *                  This property controls showing the default controls for charts. <br>
 *@param {boolean=} staggerlabels
 *                  This property controls whether to stagger the labels which distributes labels into multiple lines. <br>
 *@param {boolean=} reducexticks
 *                  This property controls whether to reduce the xticks or not. <br>
 *@param {list=} labeltype
 *                  This property controls the type of the label to be shown in the chart. <br>
 *                  Key is the value of the key data, value is the data value, and percent represents the percentage that the slice of data represents. <br>
 *@param {number=} barspacing
 *                  This property controls the spacing between the bars and value ranges from 0.1 to 0.9. <br>
 *@param {number=} donutratio
 *                  This property controls the radius and value ranges from 0.1 to 1. <br>
 *@param {boolean=} showlabelsoutside
 *                  This property controls the labels should be outside or inside. <br>
 * @param {number=} bubblesize
 *                  This property controls the size of the bubble.<br>
 * @param {number=} showxdistance
 *                  This property enables showing the distance from the x axis.<br>
 * @param {number=} showydistance
 *                  This property enables showing the distance from the y axis.<br>
 * @param {string=} on-transform
 *                  Callback function for `transform` event.
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
                <wm-layoutgrid>
                    <wm-gridrow>
                        <wm-gridcolumn columnwidth="6">
                            <wm-chart type="Column" tooltips="false" staggerlabels="true" barspacing="0.2"></wm-chart>
                        </wm-gridcolumn>
                        <wm-gridcolumn columnwidth="6">
                            <wm-chart type="Line" tooltips="false"></wm-chart>
                        </wm-gridcolumn>
                    </wm-gridrow>
                    <wm-gridrow>
                        <wm-gridcolumn columnwidth="6">
                            <wm-chart type="Area" tooltips="false"></wm-chart>
                        </wm-gridcolumn>
                        <wm-gridcolumn columnwidth="6">
                            <wm-chart type="Pie" tooltips="false"></wm-chart>
                        </wm-gridcolumn>
                    </wm-gridrow>
                    <wm-gridrow>
                        <wm-gridcolumn columnwidth="6">
                            <wm-chart type="Bar" tooltips="false"></wm-chart>
                        </wm-gridcolumn>
                        <wm-gridcolumn columnwidth="6">
                            <wm-chart type="Cumulative Line" tooltips="false"> </wm-chart>
                        </wm-gridcolumn>
                    </wm-gridrow>
                    <wm-gridrow>
                        <wm-gridcolumn columnwidth="6">
                            <wm-chart type="Donut" tooltips="false"></wm-chart>
                        </wm-gridcolumn>
                        <wm-gridcolumn columnwidth="6">
                            <wm-chart type="Bubble" tooltips="false"></wm-chart>
                        </wm-gridcolumn>
                    </wm-gridrow>
                </wm-layoutgrid>
            </div>
        </file>
        <file name="script.js">
            function Ctrl($scope) {}
        </file>
    </example>
 */

/*global WM, */
/*Directive for DataNavigator */

WM.module("wm.widgets.basic")
    .run(["$templateCache", function ($templateCache) {
        "use strict";
        $templateCache.put("template/widget/datanavigator.html",
            '<nav data-identifier="datanavigator" class="app-datanavigator clearfix" data-ng-show="show" init-widget apply-styles>' +
                '<ul class="pagination {{class}}" data-ng-if="navcontrols === \'Advanced\'">' +
                    '<li data-ng-class="{\'disabled\':isDisableFirst}"><a title="Go to Start" name="first" href="javascript:void(0);" aria-label="First" data-ng-click="navigatePage(\'first\', $event)"><i class="glyphicon glyphicon-fast-backward"></i></a></li>' +
                    '<li data-ng-class="{\'disabled\':isDisablePrevious}"><a title="Go Previous" name="prev" href="javascript:void(0);" aria-label="Previous" data-ng-click="navigatePage(\'prev\', $event)"><i class="glyphicon glyphicon-step-backward"></i></a></li>' +
                    '<li class="pagecount disabled"><a><input title="Current Page" type="number" data-ng-disabled="isDisableCurrent" data-ng-model="dn.currentPage" ng-model-options="{updateOn: \'change blur\'}" data-ng-change="onModelChange($event)" class="form-control" /></a></li>' +
                    '<li class="disabled"><a data-ng-hide="isDisableCount"> of {{pageCount}}</a></li>' +
                    '<li data-ng-class="{\'disabled\':isDisableNext}"><a title="Go Next" name="next" href="javascript:void(0);" aria-label="Next" data-ng-click="navigatePage(\'next\', $event)"><i class="glyphicon glyphicon-step-forward"></i></a></li>' +
                    '<li data-ng-class="{\'disabled\':isDisableLast}"><a title="Go to End" name="last" href="javascript:void(0);" aria-label="Last" data-ng-click="navigatePage(\'last\', $event)"><i class="glyphicon glyphicon-fast-forward"></i></a></li>' +
                    '<li data-ng-if="showrecordcount" class="totalcount disabled"><a>Total Records: {{dataSize}}</a></li>' +
                '</ul>' +
                '<ul class="pager" data-ng-if="navcontrols === \'Basic\'">' +
                    '<li class="previous" data-ng-class="{\'disabled\':isDisablePrevious}"><a href="javascript:void(0);" data-ng-click="navigatePage(\'prev\', $event)"><span aria-hidden="true">&larr;</span> Previous</a></li>' +
                    '<li class="next" data-ng-class="{\'disabled\':isDisableNext}"><a href="javascript:void(0);" data-ng-click="navigatePage(\'next\', $event)">Next <span aria-hidden="true">&rarr;</span></a></li>' +
                '</ul>' +
            '</nav>'
            );
    }]).directive('wmDatanavigator', ['PropertiesFactory', '$templateCache', 'WidgetUtilService', 'Utils', 'Variables', '$rootScope', 'wmToaster', 'CONSTANTS', function (PropertiesFactory, $templateCache, WidgetUtilService, Utils, Variables, $rootScope, wmToaster, CONSTANTS) {
        "use strict";
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.datanavigator', ['wm.base', 'wm.base.editors']),
            notifyFor = {
                'dataset': true
            };

        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
        function propertyChangeHandler(scope, key, newVal) {
            switch (key) {
            case 'dataset':
                /*This is to prevent the data-navigator from getting triggered if newVal is undefined or ""*/
                if (CONSTANTS.isStudioMode && !newVal) {
                    return;
                }
                scope.setPagingValues(newVal);
                break;
            }
        }

        return {
            'restrict': 'E',
            'scope': {
                'onSetrecord': '&'
            },
            'replace': true,
            'controller': function ($scope) {

                /**
                 * Returns the orderBy Expression based on the 'sort 'option in pageable object
                 * returned by backend
                 * @param object
                 * @returns {string}
                 */
                function getOrderByExpr(object) {
                    object = object || [];
                    var expr = '',
                        KEY_VAL_SEPARATOR = ' ',
                        FIELD_SEPARATOR = ',';
                    WM.forEach(object, function (obj, index) {
                        expr += obj.property + KEY_VAL_SEPARATOR + obj.direction.toLowerCase() + (index > 0 && index < object.length - 1 ? FIELD_SEPARATOR : '');
                    });

                    return expr;
                }

                $scope.pageCount = 0;

                /*Function to reset the paging values to default.*/
                $scope.resetPageNavigation = function () {
                    $scope.pageCount = 0;
                    $scope.dn.currentPage = 1;
                    $scope.dataSize = 0;
                };

                /*Function to calculate the paging values.*/
                $scope.calculatePagingValues = function (pageCount) {
                    $scope.pageCount = WM.isDefined(pageCount) ? pageCount : (($scope.dataSize > $scope.maxResults) ? (Math.ceil($scope.dataSize / $scope.maxResults)) : ($scope.dataSize < 0 ? 0 : 1));
                    $scope.dn.currentPage = $scope.dn.currentPage || 1;
                };

                $scope.isPagingValuesComputed = function () {
                    return (WM.isDefined($scope.maxResults) && WM.isDefined($scope.dataSize) && WM.isDefined($scope.dn.currentPage) && WM.isDefined($scope.pageCount));
                };

                /*Function to set default values to the paging parameters*/
                $scope.setDefaultPagingValues = function (dataSize, maxResults, currentPage, pageCount) {
                    /*If neither "dataSize" nor "maxResults" is set, then set default values to the paging parameters.*/
                    if (!dataSize && !maxResults) {
                        $scope.pageCount = 1;
                        $scope.dn.currentPage = 1;
                        $scope.maxResults = dataSize;
                        $scope.dataSize = dataSize;
                    } else { /*Else, set the specified values and recalculate paging parameters.*/
                        $scope.maxResults = maxResults || $scope.maxResults;
                        $scope.dataSize = WM.isDefined(dataSize) ? dataSize : $scope.dataSize;
                        $scope.dn.currentPage = currentPage || $scope.dn.currentPage;
                        $scope.calculatePagingValues(pageCount);
                    }
                };

                /*Function to check the dataSize and manipulate the navigator accordingly.*/
                $scope.checkDataSize = function (dataSize) {
                    /*If the dataSize is -1 or Integer.MAX_VALUE( which is 2147483647), then the total number of records is not known.
                     * Hence,
                     * 1. Hide the "Total Record Count".
                     * 2. Disable the "GoToLastPage" link as the page number of the last page is not known.*/
                    if (dataSize === -1 || dataSize === CONSTANTS.INT_MAX_VALUE) {
                        /*
                         * TODO: to remove the 'prevshowrecordcount' and handle the dataSize = -1 case
                         */
                        $scope.prevshowrecordcount = $scope.showrecordcount;
                        $scope.isDisableLast = true;
                        $scope.isDisableCount = true;
                        $scope.showrecordcount = false;
                    } else {
                        $scope.isDisableCount = false;
                        $scope.showrecordcount = $scope.prevshowrecordcount || $scope.showrecordcount;
                    }
                };

                /*Function to disable navigation based on the current and total pages.*/
                $scope.disableNavigation = function () {
                    var isCurrentPageFirst = ($scope.dn.currentPage === 1),
                        isCurrentPageLast = ($scope.dn.currentPage === $scope.pageCount);
                    $scope.isDisableFirst = $scope.isDisablePrevious = isCurrentPageFirst;
                    $scope.isDisableNext = $scope.isDisableLast = isCurrentPageLast;
                    $scope.isDisableCurrent = isCurrentPageFirst && isCurrentPageLast;
                };

                /*Function to check if the variable bound to the data-navigator has paging.*/
                $scope.isVariableHasPaging = function () {
                    var dataSet = $scope.dataset;
                    return (WM.isObject(dataSet) && (dataSet.pagingOptions || Utils.isPageable(dataSet)));
                };

                /*Function to set the values needed for pagination*/
                $scope.setPagingValues = function (newVal) {
                    var dataSize,
                        maxResults,
                        currentPage,
                        pageCount,
                        startIndex,
                        data;

                    /*Set the default value of the "result" property to the newVal so that the widgets bound to the data-navigator can have the dataSet set properly.*/
                    $scope.result = newVal;
                    $scope.isBoundToFilter = undefined;
                    /*Check for sanity*/
                    if ($scope.binddataset) {

                        /*Set the variable name based on whether the widget is bound to a variable opr widget*/
                        if ($scope.binddataset.indexOf('bind:Variables.') !== -1) {
                            $scope.variableName = $scope.binddataset.replace('bind:Variables.', '');
                            $scope.variableName = $scope.variableName.substr(0, $scope.variableName.indexOf('.'));
                        } else if (newVal.isBoundToFilter && newVal.widgetName) {
                            $scope.isBoundToFilter = true;
                            $scope.widgetName = newVal.widgetName;
                        } else {
                            $scope.variableName = newVal.variableName;
                        }

                        /*Check for number of elements in the data set*/
                        if (newVal) {
                            if ($scope.isVariableHasPaging()) {
                                /*If "filterFields" and "sortOptions" have been set, then set them so that the filters can be retained while fetching data upon page navigation.*/
                                $scope.filterFields = newVal.filterFields || {};
                                $scope.sortOptions = newVal.sortOptions || (WM.isArray(newVal.sort) ? getOrderByExpr(newVal.sort) : '');
                                if (WM.isObject(newVal) && Utils.isPageable(newVal)) {
                                    dataSize = newVal.totalElements;
                                    $scope.checkDataSize(dataSize);

                                    maxResults = newVal.size;
                                    if (newVal.numberOfElements > 0) {
                                        if (WM.isDefined(newVal.number)) { // number is page number received from backend
                                            $scope.dn.currentPage = newVal.number + 1;
                                        }
                                        currentPage = $scope.dn.currentPage || 1;
                                    } else {
                                        currentPage = 1;
                                    }
                                    /* Sending pageCount undefined to calculate it again for query.*/
                                    $scope.setDefaultPagingValues(dataSize, maxResults, currentPage, pageCount);
                                    $scope.disableNavigation();
                                }
                                /*Re-compute the paging values in the following cases.
                                1. Paging values have not been computed.
                                2. Data corresponding to the table associated with the live-variable changes.*/
                                if (!$scope.isPagingValuesComputed() || newVal.pagingOptions) {
                                    dataSize = newVal.pagingOptions.dataSize;

                                    maxResults = newVal.pagingOptions.maxResults;
                                    currentPage = newVal.pagingOptions.currentPage;
                                    $scope.setDefaultPagingValues(dataSize, maxResults, currentPage);
                                    $scope.disableNavigation();
                                    $scope.checkDataSize(dataSize);
                                }
                            } else if (!WM.isString(newVal)) {
                                dataSize = WM.isArray(newVal) ? newVal.length : 1;
                                maxResults = ($scope.pagingOptions && $scope.pagingOptions.maxResults) || dataSize;
                                currentPage = 1;

                                $scope.setDefaultPagingValues(dataSize, maxResults, currentPage);
                                $scope.disableNavigation();

                                startIndex = ($scope.dn.currentPage - 1) * $scope.maxResults;
                                data =  WM.isArray(newVal) ? newVal.slice(startIndex, startIndex + $scope.maxResults) : newVal;
                                $scope.result = data;
                            }
                            $rootScope.$safeApply($scope);
                        } else {
                            $scope.resetPageNavigation();
                        }
                    }
                };

                /*Function to check if the current page is the first page*/
                $scope.isFirstPage = function () {
                    return ($scope.dn.currentPage === 1 || !$scope.dn.currentPage);
                };
                /*Function to check if the current page is the last page*/
                $scope.isLastPage = function () {
                    return ($scope.dn.currentPage === $scope.pageCount);
                };

                /*Function to navigate to the last page*/
                $scope.goToLastPage = function (isRefresh, event, callback) {
                    if (!$scope.isLastPage()) {
                        $scope.dn.currentPage = $scope.pageCount;
                        $scope.goToPage(event, callback);
                    } else if (isRefresh) {
                        $scope.goToPage(event, callback);
                    }
                };

                /*Function to navigate to the first page*/
                $scope.goToFirstPage = function (isRefresh, event, callback) {
                    if (!$scope.isFirstPage()) {
                        $scope.dn.currentPage = 1;
                        $scope.goToPage(event, callback);
                    } else if (isRefresh) {
                        $scope.goToPage(event, callback);
                    }
                };

                /*Function to navigate to the current page*/
                $scope.goToPage = function (event, callback) {
                    $scope.firstRow = ($scope.dn.currentPage - 1) * $scope.maxResults;
                    $scope.getPageData(event, callback);
                };

                /*Function to be invoked after the data of the page has been fetched.*/
                $scope.onPageDataReady = function (event, data, callback) {
                    $scope.disableNavigation();
                    $scope.invokeSetRecord(event, data);
                    Utils.triggerFn(callback);
                };

                /*Function to get data for the current page*/
                $scope.getPageData = function (event, callback) {
                    var variable = $scope.navigatorElement.scope().Variables[$scope.variableName],
                        data,
                        startIndex,
                        widgetScope,
                        widgets;
                    if (CONSTANTS.isRunMode && $scope.isBoundToFilter && $scope.widgetName) {
                        widgets = $scope.navigatorElement.scope().Widgets || {};
                        widgetScope = widgets[$scope.widgetName];
                        widgetScope.applyFilter({"page": $scope.dn.currentPage});
                        return;
                    }
                    if ($scope.isVariableHasPaging()) {
                        if (variable && variable.category === "wm.LiveVariable") {
                            /*Invoke the function to get the data corresponding to the specific page.*/
                            variable.update({
                                "page": $scope.dn.currentPage,
                                "filterFields": $scope.filterFields,
                                'orderBy': $scope.sortOptions,
                                "matchMode": 'anywhere',
                                "scope": $scope.navigatorElement.scope()
                            }, function (data, propertiesMap, pagingOptions) {
                                /*Update the "result" in the scope so that widgets bound to the data-navigator are updated.*/
                                $scope.result = {
                                    "data": data,
                                    "propertiesMap": propertiesMap,
                                    "pagingOptions": pagingOptions,
                                    "filterFields": $scope.filterFields,
                                    "orderBy": $scope.sortOptions,
                                    "variableName": $scope.variableName
                                };
                                /*Update the paging options and invoke the function to re-calculate the paging values.*/
                                $scope.dataSize = pagingOptions.dataSize;
                                $scope.maxResults = pagingOptions.maxResults;
                                $scope.calculatePagingValues();
                                /*Invoke the "onPageDataReady" function.*/
                                $scope.onPageDataReady(event, data, callback);
                            }, function (error) {
                                wmToaster.show("error", "ERROR", "Unable to get data of page -" + $scope.dn.currentPage + ":" + error);
                            });
                        } else if (Utils.isPageable($scope.dataset)) {
                            /*Invoke the function to get the data corresponding to the specific page.*/
                            variable.update({
                                "page": $scope.dn.currentPage,
                                "filterFields": $scope.filterFields,
                                "orderBy": $scope.sortOptions,
                                "matchMode": 'anywhere',
                                "scope": $scope.navigatorElement.scope()
                            }, function (data) {
                                $scope.result = data;
                                $scope.onPageDataReady(event, data, callback);
                            }, WM.noop);
                        }
                    } else {
                        startIndex = ($scope.dn.currentPage - 1) * $scope.maxResults;
                        data = WM.isArray($scope.dataset) ?
                                $scope.dataset.slice(startIndex, startIndex + $scope.maxResults) : $scope.dataset;
                        $scope.result = data;
                        $scope.onPageDataReady(event, data, callback);
                    }
                };

                $scope.invokeSetRecord = function (event, data) {
                    /*Trigger the event handler if exists.
                     * Check in the dataNavigator scope and also in the parent (i.e., grid/live-list) scope.*/
                    if ($scope.onSetrecord) {
                        $scope.onSetrecord({$event: event, $scope: this, $data: data, $index: $scope.dn.currentPage});
                    } else if ($scope.$parent.onSetrecord) {
                        $scope.$parent.onSetrecord({$event: event, $scope: this, $data: data, $index: $scope.dn.currentPage});
                    }
                };
                /*Function to validate the page input.
                 In case of invalid input, navigate to the appropriate page; also return false.
                 In case of valid input, return true.*/
                $scope.validateCurrentPage = function (event, callback) {
                    /*If the value entered is not a valid number, then navigate to the first page.*/
                    if (isNaN($scope.dn.currentPage)) {
                        $scope.goToFirstPage(undefined, event, callback);
                        return false;
                    }
                    /*If the value entered is less than 0, then navigate to the first page.*/
                    if ($scope.dn.currentPage < 0) {
                        $scope.goToFirstPage(undefined, event, callback);
                        return false;
                    }
                    /*If the value entered is greater than the last page number, then navigate to the last page.*/
                    if ($scope.pageCount && ($scope.dn.currentPage > $scope.pageCount)) {
                        $scope.goToLastPage(undefined, event, callback);
                        return false;
                    }
                    return true;
                };

                $scope.onModelChange = function (event) {
                    if (!$scope.validateCurrentPage(event)) {
                        return;
                    }
                    $scope.goToPage(event);
                };

                /*Function to navigate to the respective pages.*/
                $scope.navigatePage = function (index, event, isRefresh, callback) {

                    /*Convert the current page to a valid page number.*/
                    $scope.dn.currentPage = parseInt($scope.dn.currentPage, 10);

                    switch (index) {
                    case "first":
                        $scope.goToFirstPage(isRefresh, event, callback);
                        return;
                    case "prev":
                        /*Return if already on the first page.*/
                        if ($scope.isFirstPage() || !$scope.validateCurrentPage(event, callback)) {
                            return;
                        }
                        /*Decrement the current page by 1.*/
                        $scope.dn.currentPage -= 1;
                        break;
                    case "next":
                        /*Return if already on the last page.*/
                        if ($scope.isLastPage() || !$scope.validateCurrentPage(event, callback)) {
                            return;
                        }
                        /*Increment the current page by 1.*/
                        $scope.dn.currentPage += 1;
                        break;
                    case "last":
                        $scope.goToLastPage(isRefresh, event, callback);
                        return;
                    default:
                        break;
                    }

                    /*Navigate to the current page.*/
                    $scope.goToPage(event, callback);
                };
            },
            'template': $templateCache.get("template/widget/datanavigator.html"),
            'compile': function () {
                return {
                    'pre': function (scope) {
                        scope.widgetProps = widgetProps;
                        /*Set the "allowPageable" flag in the scope to indicate that the data-navigator accepts Pageable objects.*/
                        scope.allowPageable = true;

                        scope.navcontrols = 'Advanced';
                    },
                    'post': function (scope, element, attrs) {

                        scope.dn = {}; //dataNavigator

                        scope.navigatorElement = element;
                        /* register the property change handler */
                        WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, scope), scope, notifyFor);

                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.widgets.basic.directive:wmDatanavigator
 * @restrict E
 *
 * @description
 * The `wmDatanavigator` directive defines a data navigator that is used for pagination. <br>
 *
 *
 * @requires PropertiesFactory
 * @requires $templateCache
 * @requires WidgetUtilService
 * @requires Utils
 * @requires Variables
 * @requires wmToaster
 * @requires CONSTANTS
 *
 * @param {string=}  name
 *                   Name of the data-navigator widget.
 * @param {string=} width
 *                  Width of the data navigator.
 * @param {string=} height
 *                  Height of the data navigator.
 * @param {string=} dataset
 *                  Sets the data for the data navigator.<br>
 *                  This is a bindable property..<br>
 *                  When bound to a variable, the data associated with the variable becomes the basis for pagination.
 * @param {boolean=} show
 *                  This is a bindable property. <br>
 *                  This property will be used to show/hide the data navigator on the web page. <br>
 *                  default value: `true`.
 * @param {boolean=} showrecordcount
 *                  This property controls whether the total record count is displayed in the data navigator or not. <br>
 *                  default value: `false`.
 * @param {string=} horizontalalign
 *                  This property used to set text alignment horizontally. <br>
 *                  Possible values are `left`, `center` and `right`. <br>
 *                  default value: `right`.
 * @param {string=} verticalalign
 *                  This property used to set text alignment vertically. <br>
 *                  Possible values are `bottom`, `middle` and `top`. <br>
 *                  default value: `middle`.
 * @param {string=} on-setrecord
 *                  Callback function which will be triggered when the record is set using the data-navigator.
 *
 */

/*global WM, */
/*jslint nomen: true*/

WM.module('wm.widgets.basic')
    .service('wmToaster', ['toaster','$rootScope', '$compile', '$timeout', function (toaster, $rs, $compile, $timeout) {
        'use strict';
        var _showToaster = function (type, title, desc, timeout, bodyOutputType, onClickHandler, onHideCallback) {
            /*pop the toaster only if either title or description are defined*/
            if (title || desc) {
                /*hide all previous toasters*/
                WM.element('.toast').hide();
                /*call pop function in toaster to show the toaster*/
                /*Not closing the toaster only in case type is not success and there is not timeout specified*/

                if (!timeout) {
                    timeout = 0;
                    if (type === 'success') {
                        timeout = 5000;
                    }
                }

                toaster.pop(type, title, desc, timeout, bodyOutputType, onClickHandler, undefined, undefined, undefined, onHideCallback);
            }
        },  classlist = [],
            idCount = 0,
            idMapper = {};
        //renders the custom notification call
        function renderNotification(template, newClass, timeout, position, onclickHandler, onHideCallback) {
            $rs.toasterClasses = {};
            $rs.toasterClasses[newClass] = 'custom-toaster ' + newClass;
            if (!_.includes(classlist, newClass)) {
                idMapper[newClass] = ++idCount;
            }
            var trustedHtml = $compile(template)($rs),
                toastTemplate = '<toaster-container name = "' + newClass + '" toaster-options="{\'limit\': 1,\'time-out\': 2000, \'position-class\': \'' + position + '\', \'icon-classes\': toasterClasses, \'toaster-id\': ' + idMapper[newClass] + '}"></toaster-container>';
            if (!_.includes(classlist, newClass)) {
                WM.element('body').append($compile(toastTemplate)($rs));
                classlist.push(newClass);
            }
            $rs.$safeApply($rs);
            $timeout(function () {
                toaster.pop({ type: newClass, body: trustedHtml[0].outerHTML, onHideCallback: onHideCallback, toasterId: idMapper[newClass], timeout: timeout, bodyOutputType: 'trustedHtml', clickHandler: onclickHandler});
            }, 350);
        }

        return {

            /**
             * @ngdoc function
             * @name $wmToaster#success
             * @methodOf wm.widgets.basic.$wmToaster
             * @function
             *
             * @description
             * pops-up a success message toaster.
             *
             * @param {string} title title to be displayed on the top
             * @param {string} desc of the notification
             */
            success: function (title, desc) {
                _showToaster('success', title, desc, 5000);
            },

            /**
             * @ngdoc function
             * @name $wmToaster#error
             * @methodOf wm.widgets.basic.$wmToaster
             * @function
             *
             * @description
             * pops-up an error message toaster.
             *
             * @param {string} title title to be displayed on the top
             * @param {string} desc of the notification
             */
            error: function (title, desc) {
                _showToaster('error', title, desc, 0);
            },

            /**
             * @ngdoc function
             * @name $wmToaster#info
             * @methodOf wm.widgets.basic.$wmToaster
             * @function
             *
             * @description
             * pops-up an info message toaster.
             *
             * @param {string} title title to be displayed on the top
             * @param {string} desc of the notification
             */
            info: function (title, desc) {
                _showToaster('info', title, desc, 0);
            },

            /**
             * @ngdoc function
             * @name $wmToaster#warn
             * @methodOf wm.widgets.basic.$wmToaster
             * @function
             *
             * @description
             * pops-up a warn message toaster.
             *
             * @param {string} title title to be displayed on the top
             * @param {string} desc of the notification
             */
            warn: function (title, desc) {
                _showToaster('warning', title, desc, 0);
            },

            /**
             * @ngdoc function
             * @name $wmToaster#show
             * @methodOf wm.widgets.basic.$wmToaster
             * @function
             *
             * @description
             * pops-up a toaster depending on the parameter 'type' ({success, error, warn, info}).
             *
             * @param {string} type the type of the message - {success, error, warn, info}
             * @param {string} title title to be displayed on the top
             * @param {string} desc of the notification
             * @param {string} timeout of the notification
             * @param {string} bodyOutputType of the notification
             * @param {function} onClickHandler of the notification
             * @param {function} onHideCallback of the notification
             */
            show: function (type, title, desc, timeout, bodyOutputType, onClickHandler, onHideCallback) {
                _showToaster(type, title, desc, timeout, bodyOutputType, onClickHandler, onHideCallback);
            },

            /**
             * @ngdoc function
             * @name $wmToaster#hide
             * @methodOf wm.widgets.basic.$wmToaster
             * @function
             *
             * @description
             * hides a toaster.
             */
            hide: function () {
                WM.element('.toast').hide();
            },

            /**
             * @ngdoc function
             * @name $wmToaster#createCustomNotification
             * @methodOf wm.widgets.basic.$wmToaster
             * @function
             *
             * @description
             * pops-up a toaster depending on the page name parameter 'content' .
             *
             * @param {string} content the page name you want to display
             * @param {string} className the notification variable name
             * @param {number} timeout the duration of the notification to be displayed
             * @param {string} position the position of the notification
             * @param {method} onClickHandler handles the method of click on notification
             * @param {method} onHideCallback handles the method on hide of notification
             */
            createCustomNotification: function (content, className, timeout, position, onClickHandler, onHideCallback) {
                renderNotification('<wm-container content="' + content + '"></wm-container>', className, timeout, position, onClickHandler, onHideCallback);
            }
        };
    }]);

/**
 * @ngdoc service
 * @name wm.widgets.basic.$wmToaster
 *
 * @description
 * The `wmToaster` loads or pops up a toaster in the window corner for displaying notifications for the user.

 * @param {object=} toaster-options
 *                  toaster options include position-class, time-out duration, max. count of the toasters
 *
 * Toaster is a meek mechanism for showing notifications or messages.
 * The notification pops up onto the window corner upon the content over there, for the nonce.
 * These messages stay for a definite time span, or until the user clicks on them.
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
                <wm-composite>
                    <wm-label caption="Title:"></wm-label>
                    <wm-text scopedatavalue="notificationTitle"></wm-text>
                </wm-composite>
                <wm-composite>
                    <wm-label caption="Description:"></wm-label>
                    <wm-text scopedatavalue="notificationDescription"></wm-text>
                </wm-composite>
                <wm-button on-click='notify("success")' caption='Notify Success' class="btn-success"></wm-button>
                <wm-button on-click='notify("error")' caption='Notify Error' class="btn-danger"></wm-button>
                <wm-button on-click='notify("info")' caption='Notify Info' class="btn-info"></wm-button>
                <wm-button on-click='notify("warning")' caption='Notify Warn' class="btn-warning"></wm-button>
                <toaster-container toaster-options="{'limit': 1,'time-out': 2000, 'position-class': 'toast-bottom-right'}"></toaster-container>
            </div>
        </file>
        <file name="script.js">
           function Ctrl($scope, wmToaster) {
               $scope.notificationTitle = "Sample Title";
               $scope.notificationDescription = "Sample Description";
               $scope.notify = function (type) {
                   wmToaster.show(type, $scope.notificationTitle, $scope.notificationDescription);
               }
            }
        </file>
    </example>
 */
/*global WM */
/*Directive for Progressbar */

WM.module('wm.widgets.basic')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/widget/progress.html',
                '<div class="progress app-progress" data-ng-show="show" title="{{hint}}" init-widget apply-styles>' +
                    '<div class="progress-bar" role="progressbar" aria-valuenow={{datavalue}} aria-valuemin={{minvalue}} aria-valuemax={{maxvalue}} data-ng-hide="isMultipleBar"></div>' +
                '</div>'
            );
    }])
    .directive('wmProgress', ['PropertiesFactory', 'WidgetUtilService', '$interval', 'Utils', 'CONSTANTS', function (PropertiesFactory, WidgetUtilService, $interval, Utils, CONSTANTS) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.progress', ['wm.base', 'wm.base.events']),
            notifyFor = {
                'datavalue': true,
                'minvalue': true,
                'maxvalue': true,
                'type': true,
                'pollinterval': true
            },
            /* map of type and classes to be applied*/
            CLASSES = {
                'default': '',
                'default-striped': 'progress-bar-striped',
                'success': 'progress-bar-success',
                'success-striped': 'progress-bar-success progress-bar-striped',
                'info': 'progress-bar-info',
                'info-striped': 'progress-bar-info progress-bar-striped',
                'warning': 'progress-bar-warning',
                'warning-striped': 'progress-bar-warning progress-bar-striped',
                'danger': 'progress-bar-danger',
                'danger-striped': 'progress-bar-danger progress-bar-striped'
            },
            DISPLAY_FORMAT = {
                'PERCENTAGE': 'percentage',
                'ABSOLUTE': 'ABSOLUTE'
            };


        // returns true if the min and max values are valid, false otherwise
        function areValuesValid(max, min) {
            if (!max || (!min && min !== 0) || (max <= min)) {
                return false;
            }

            return true;
        }

        function isPercentageValue(value) {
            if (WM.isString(value)) {
                value = value.trim();
                return value.charAt(value.length - 1) === '%';
            }
        }

        function triggerCallbackFns(scope, oldDatavalue, newDatavalue, isValueAPercentage) {

            var onStart = false,
                onEnd = false;

            if (isValueAPercentage) {
                if (oldDatavalue <= 0 && newDatavalue > 0) {
                    onStart = true;
                } else if (newDatavalue >= 100) {
                    onEnd = true;
                }
            } else {
                if (oldDatavalue <= scope.minvalue && newDatavalue > scope.minvalue) {
                    onStart = true;
                } else if (newDatavalue >= scope.maxvalue) {
                    onEnd = true;
                }
            }

            if (onStart) {
                Utils.triggerFn(scope.onStart, {$scope: scope});
            } else if (onEnd) {
                endPolling(scope);
                Utils.triggerFn(scope.onComplete, {$scope: scope});
            }
        }

        // if the progressbar is NOT multibar, update the bar when maxvalue, minvalue or datavalue are changed.
        function updateProgressBar(scope, progressBarEl, oldDatavalue, newDatavalue) {

            var isValueAPercentage,
                progressBarWidth,
                displayValue = 0;

            if (scope.isMultipleBar) {
                return;
            }

            isValueAPercentage = isPercentageValue(scope.datavalue);

            if (isValueAPercentage) {
                oldDatavalue = parseInt(oldDatavalue || 0, 10);
                newDatavalue = parseInt(newDatavalue || 0, 10);
            } else {
                if (!areValuesValid(scope.maxvalue, scope.minvalue)) {
                    endPolling(scope);
                    return;
                }
            }

            triggerCallbackFns(scope, oldDatavalue, newDatavalue, isValueAPercentage);

            if (isValueAPercentage) {
                progressBarWidth = displayValue = (scope.datavalue || '0%');
            } else {
                if (WM.isDefined(scope.datavalue)) {
                    displayValue = scope.datavalue * 100 / (scope.maxvalue - scope.minvalue);
                    progressBarWidth = displayValue + '%';

                    if (scope.displayformat === DISPLAY_FORMAT.PERCENTAGE) {
                        displayValue = progressBarWidth;
                    }
                } else {
                    displayValue = progressBarWidth = 0;
                }
            }

            progressBarEl.css('width', progressBarWidth).text(displayValue);
        }

        // if the progress bar is multibar, create the multi-bar related nodes.
        function updateMultipleProgressBar(element, data) {
            data.forEach(function (barInfo) {
                var cls = CLASSES[barInfo.type],
                    val = barInfo.value + '%';
                WM.element('<div class="multi-bar progress-bar"></div>').appendTo(element).addClass(cls).css('width', val).text(val);
            });
        }

        function successHandler(scope, response) {
            // if the binddatavalue is provided... there will be a watch on the bound property
            // do not trigger the onBeforeupdate calback.
            if (!scope.binddatavalue) {
                Utils.triggerFn(scope.onBeforeupdate, {$response: response, $scope: scope});
            }
        }

        function setupPolling(scope) {
            $interval.cancel(scope.invokeInterval);
            if (CONSTANTS.isRunMode && scope.binddataset && scope.pollinterval) {
                scope.invokeInterval = $interval(function () {
                    scope.$root.$emit(
                        'invoke-service',
                        scope.boundServiceName,
                        {},
                        successHandler.bind(undefined, scope)
                    );
                }, scope.pollinterval);
            }
        }

        function endPolling(scope) {
            $interval.cancel(scope.invokeInterval);
        }

        function defineProperties(scope) {
            Object.defineProperty(scope, 'binddataset', {
                get: function () {
                    return this._binddataset;
                },

                set: function (value) {
                    if (this._binddataset === value) {
                        return;
                    }

                    this._binddataset = value;

                    endPolling(scope);
                    if (WM.isString(value)) {
                        var _value = value.replace('bind:Variables.', '');
                        scope.boundServiceName = _value.substr(0, _value.indexOf('.'));
                        setupPolling(scope);
                    }
                }
            });
        }

        function propertyChangeHandler(scope, element, progressBarEl, key, newVal, oldVal) {
            switch (key) {
            case 'minvalue':
            case 'maxvalue':
                updateProgressBar(scope, progressBarEl);
                break;
            case 'datavalue':
                scope.isMultipleBar = false;
                element.children('.multi-bar').remove();
                if (WM.isNumber(newVal) || WM.isString(newVal)) {
                    updateProgressBar(scope, progressBarEl, oldVal, newVal);
                } else if (WM.isArray(newVal)) {
                    scope.isMultipleBar = true;
                    updateMultipleProgressBar(element, newVal);
                }
                break;
            case 'type':
                progressBarEl.removeClass(CLASSES[oldVal]).addClass(CLASSES[newVal]);
                break;
            case 'pollinterval':
                endPolling(scope);
                if (WM.isNumber(newVal)) {
                    setupPolling(scope);
                }
                break;
            }
        }

        return {
            'restrict': 'E',
            'scope': {},
            'replace': true,
            'template': WidgetUtilService.getPreparedTemplate.bind(undefined, 'template/widget/progress.html'),
            'compile': function () {
                return {
                    'pre': function (scope) {
                        scope.widgetProps = widgetProps;
                        Object.defineProperty(scope, 'binddataset', {
                            'configurable': true
                        });
                    },
                    'post': function (scope, element, attrs) {
                        var progressBarEl = element.children().first();

                        defineProperties(scope);
                        if (attrs.dataset) {
                            if (Utils.stringStartsWith(attrs.dataset, 'bind:')) {
                                scope.binddataset = attrs.dataset;
                            }
                        }

                        WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, scope, element, progressBarEl), scope, notifyFor);
                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]);



/**
 * @ngdoc directive
 * @name wm.widgets.basic.directive:wmProgress
 * @restrict E
 *
 * @description
 * The `wmProgress` directive defines the progressbar widget.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 * @requires $interval
 * @requires Utils
 * @requires CONSTANTS
 *
 * @param {string=} name
 *                  Name of the progressbar widget.
 * @param {string=} hint
 *                  Title/hint for the progressbar. <br>
 *                  This is a bindable property.
 * @param {string=} type
 *                  type of the bar to be displayed. <br>
 *                  possible values are: `default`, `default-striped`, `success`, `success-striped`, `info`, `info-striped`, `warning`, `warning-striped`, `danger`, `danger-striped`. <br>
 *                  Default value: `value`. <br>
 * @param {string=} width
 *                  Width of the progressbar.
 * @param {string=} height
 *                  Height of the progressbar.
 * @param {number=} datavalue
 *                  value of the progressbar.<br>
 *                  array of objects(with keyes `type` and `value`) for multiple-bar, a number otherwise. <br>
 *                  This is a bindable property.
 * @param {number=} minvalue
 *                  minvalue of the progressbar. <br>
 *                  This is a bindable property.
 * @param {number=} maxvalue
 *                  maxvalue of the progressbar. <br>
 *                  This is a bindable property.
 * @param {string=} displayformat
 *                  Format(Absolute/Percentage) in which the progress needs to be displayed.
 * @param {number=} pollinterval
 *                  Time interval in milli seconds to poll the service.
 * @param {boolean=} show
 *                  This is a bindable property. <br>
 *                  This property will be used to show/hide the progressbar widget on the web page. <br>
 *                  Default value: `true`. <br>
 * @param {string=} on-click
 *                  Callback function which will be triggered when the widget is clicked.
 * @param {string=} on-dblclick
 *                  Callback function which will be triggered when the widget is double-clicked.
 * @param {string=} on-mouseenter.
 *                  Callback function which will be triggered when the mouse enters the widget.
 * @param {string=} on-mouseleave
 *                  Callback function which will be triggered when the mouse leaves the widget.
 * @param {string=} on-start
 *                  Callback function which will be triggered on the start of the progress.
 * @param {string=} on-complete
 *                  Callback function which will be triggered on the completion of the progress.
 * @param {string=} on-beforeupdate
 *                  Callback function which will be triggered before the update of the progress.
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
                <wm-composite>
                    <wm-label caption="type:"></wm-label>
                    <wm-select scopedatavalue="type" scopedataset="types"></wm-select>
                </wm-composite>
                <wm-composite>
                    <wm-label caption="show:"></wm-label>
                    <wm-checkbox scopedatavalue="show"></wm-text>
                </wm-composite>
                <wm-progress type="{{type}}"
                       height="24" datavalue="20"
                       on-click="f('click')"
                       on-dblclick="f('dblclick')"
                       show="{{show}}">
                </wm-progress>
                <br>
                <div>single click count: {{clickCount}}</div>
                <div>dbl click count: {{dblclickCount}}</div>
                <br>
            </div>
        </file>
        <file name="script.js">
           function Ctrl($scope) {
               $scope.clickCount = $scope.dblclickCount = 0;

               $scope.show = true;

               $scope.types = ['default', 'default-striped', 'success', 'success-striped', 'info', 'info-striped', 'warning', 'warning-striped', 'danger', 'danger-striped'];
               $scope.type = ['default'];

               $scope.f = function (eventtype) {
                   $scope[eventtype + 'Count']++;
               }
            }
        </file>
    </example>
 */
/*global $, window, angular, moment, WM, _, FormData, document, parseInt, Blob*/
/*jslint todo: true*/
/**
 * JQuery Datagrid widget.
 */

'use strict';

$.widget('wm.datagrid', {
    options: {
        data: [],
        statusMsg: '',
        colDefs: [],
        sortInfo: {
            'field': '',
            'direction': ''
        },
        isMobile: false,
        enableSort: true,
        enableSearch: false,
        height: 100,
        showHeader: true,
        selectFirstRow: false,
        allowAddNewRow: true,
        allowDeleteRow: true,
        allowInlineEditing: true,
        showRowIndex: false,
        enableRowSelection: true,
        enableColumnSelection: true,
        multiselect: false,
        filterNullRecords: true,
        cssClassNames: {
            'tableRow': 'app-datagrid-row',
            'headerCell': 'app-datagrid-header-cell',
            'tableCell': 'app-datagrid-cell',
            'grid': '',
            'gridDefault': 'table',
            'gridBody': 'app-datagrid-body',
            'deleteRow': 'danger'
        },
        dataStates: {
            'loading': 'Loading...',
            'ready': '',
            'error': 'An error occurred in loading the data.',
            'nodata': 'No data found.'
        },
        startRowIndex: 1,
        searchHandler: function (searchObj) {
            var searchText = searchObj.value,
                searchTextRegEx,
                field = searchObj.field,
                hasField = field.length,
                $rows = this.gridElement.find('tbody tr'),
                self = this;
            if (!searchText) {
                $rows.show();
                return;
            }

            searchTextRegEx = new RegExp(searchText, 'i');

            $rows.each(function () {
                var $row = $(this),
                    rowId = $row.attr('data-row-id'),
                    text = hasField ? self.preparedData[rowId][field] : $row.text();

                // If the list item does not contain the text phrase fade it out
                if (text === null || text.toString().search(searchTextRegEx) === -1) {
                    $row.hide();
                } else {
                    $row.show();
                }
            });
        },
        sortHandler: function (sortInfo, e) {
            /* Local sorting if server side sort handler is not provided. */
            e.stopPropagation();
            var sortFn = this.Utils.sortFn,
                sorter = sortFn(sortInfo.field, sortInfo.direction),
                data = $.extend(true, [], this.options.data);
            this._setOption('data', data.sort(sorter));
            if ($.isFunction(this.options.afterSort)) {
                this.options.afterSort();
            }
        }
    },
    customColumnDefs: {
        'checkbox': {
            'field': 'checkbox',
            'type': 'custom',
            'displayName': '',
            'sortable': false,
            'searchable': false,
            'resizable': false,
            'selectable': false,
            'readonly': true,
            'style': 'text-align: center;'
        },
        'radio': {
            'field': 'radio',
            'type': 'custom',
            'displayName': '',
            'sortable': false,
            'searchable': false,
            'resizable': false,
            'selectable': false,
            'readonly': true,
            'style': 'text-align: center;'
        },
        'rowIndex': {
            'field': 'rowIndex',
            'type': 'custom',
            'displayName': 'S. No.',
            'sortable': false,
            'searchable': false,
            'selectable': false,
            'readonly': true,
            'style': 'text-align: left;'
        }
    },
    Utils: {
        random: function () {
            return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
        },
        sortFn: function (key, direction) {
            return function (a, b) {
                var strA = a[key] || '',
                    strB = b[key] || '',
                    dir = direction === 'asc' ? -1 : 1;
                if (a[key] && typeof a[key] === 'string') {
                    strA = a[key].toLowerCase();
                }
                if (b[key] && typeof b[key] === 'string') {
                    strB = b[key].toLowerCase();
                }
                return strA === strB ? 0 : (strA < strB ? dir : -dir);
            };
        },
        isDefined: function (value) {
            return value !== undefined;
        },
        isUndefined: function (value) {
            return value === undefined;
        },
        isObject: function (value) {
            return value !== null && typeof value === 'object';
        },
        getObjectIndex: function (data, obj) {
            var matchIndex = -1;
            if (!Array.isArray(data)) {
                return -1;
            }
            data.some(function (data, index) {
                //todo: remove angular dependency.
                if (angular.equals(data, obj)) {
                    matchIndex = index;
                    return true;
                }
            });
            return matchIndex;
        },
        generateGuid: function () {
            var random = this.random;
            return random() + random() + '-' + random() + '-' + random() + '-' +
                random() + '-' + random() + random() + random();
        },
        isValidHtml: function (htm) {
            var validHtmlRegex = /<[a-z][\s\S]*>/i;
            return validHtmlRegex.test(htm);
        }
    },

    _getColumnSortDirection: function (field) {
        var sortInfo = this.options.sortInfo;
        return field === sortInfo.field ? sortInfo.direction : '';
    },
    /*Based on the spacing property, add or remove classes*/
    _toggleSpacingClasses: function (value) {
        switch (value) {
        case 'normal':
            this.gridElement.removeClass('table-condensed');
            this.gridHeaderElement.removeClass('table-condensed');
            if (this.gridSearch) {
                this.gridSearch.find('select').removeClass('input-sm');
                this.gridSearch.find('.input-group').removeClass('input-group-sm');
            }
            break;
        case 'condensed':
            this.gridElement.addClass('table-condensed');
            this.gridHeaderElement.addClass('table-condensed');
            if (this.gridSearch) {
                this.gridSearch.find('select').addClass('input-sm');
                this.gridSearch.find('.input-group').addClass('input-group-sm');
            }
            break;
        }
    },
    /* Returns the table header template. */
    _getHeaderTemplate: function () {

        var cols = '<colgroup>',
            htm = '<thead><tr>',
            isDefined = this.Utils.isDefined,
            isUndefined = this.Utils.isUndefined;

        this.preparedHeaderData.forEach(function (value, index) {

            var id = index,
                type = value.type,
                field = value.field,
                headerLabel = WM.isDefined(value.displayName) ? value.displayName : field,
                headerClasses = this.options.cssClassNames.headerCell,
                sortInfo,
                sortField,
                asc_active,
                desc_active;

            /* Colgroup */
            cols += '<col';
            if (value.style) {
                cols += ' style="' + value.style + '"';
            }
            cols += '/>';
            /* thead */

            if (type === 'custom' && isDefined(value.class)) {
                headerClasses +=  ' ' + value.class;
            }
            if (value.selected) {
                headerClasses += ' info';
            }
            if (field === 'checkbox' || field === 'radio') {
                headerClasses += ' grid-col-small';
            }
            htm += '<th data-col-id="' + id + '" data-col-field="' + field + '" class="' + headerClasses + '" title="' + headerLabel + '" style="text-align: ' +
                value.textAlignment + ';"';
            if (isUndefined(value.resizable) || value.resizable) {
                htm += ' data-col-resizable';
            }
            if (isUndefined(value.selectable) || value.selectable) {
                htm += ' data-col-selectable';
            }
            htm += '>';
            /* For custom columns, show display name if provided, else don't show any label. */
            if (field === 'checkbox') {
                htm += '<input type="checkbox" />';
            }
            if (field === 'radio') {
                htm += '';
            }
            htm += '<div class="header-data">' + headerLabel + '</div>';
            if (this.options.enableSort && (isUndefined(value.sortable) || value.sortable) && !value.widgetType) {
                htm += '<span class="sort-buttons-container">';
                sortInfo = this.options.sortInfo;
                sortField = sortInfo.field;
                asc_active = sortInfo.direction === 'asc' ? ' active' : '';
                desc_active = sortInfo.direction === 'desc' ? ' active' : '';
                if (sortField && sortField === value.field) {
                    htm += '<button class="sort-button" title="Sort Ascending"><i class="sort-icon up' + asc_active + '"></i></button>';
                    htm += '<button type="button" class="sort-button" title="Sort Descending"><i class="sort-icon down' + desc_active + '"></i></button>';
                } else {
                    htm += '<button type="button" class="sort-button"><i class="sort-icon up" title="Sort Ascending"></i></button>';
                    htm += '<button type="button" class="sort-button"><i class="sort-icon down" title="Sort Descending"></i></button>';
                }
                htm += '</span>';
            }
            htm += '</th>';
        }, this);
        htm += '</tr></thead>';
        cols += '</colgroup>';

        return { 'colgroup' : cols, 'header' : htm };
    },

    /* Returns the seachbox template. */
    _getSearchTemplate: function () {
        var htm,
            sel = '<select name="wm-datagrid" data-element="dgFilterValue" ' +
                'class="form-control app-select">' +
                '<option value="" selected>Select Column</option>',
            searchLabel = (this.Utils.isDefined(this.options.searchLabel) &&
                this.options.searchLabel.length) ? this.options.searchLabel : 'Search:';
        this.options.colDefs.forEach(function (colDef, index) {
            if (colDef.field !== 'none' && colDef.field !== 'rowOperations' && colDef.searchable) {
                sel += '<option value="' + colDef.field +
                    '" data-coldef-index="' + index + '">' +
                    (colDef.displayName || colDef.field) + '</option>';
            }
        });

        sel += '</select>';
        htm =
            '<form class="form-search form-inline" onsubmit="return false;"><div class="form-group">' +
                '<label class="control-label app-label" data-element="dgSearchLabel">' +
                    searchLabel + ' </label>' + sel +
                '</div><div class="input-append input-group">' +
                    '<input type="text" data-element="dgSearchText" class="form-control app-textbox" value="" placeholder="Search" style="display: inline-block;"/>' +
                    '<span class="input-group-addon"><button type="button" data-element="dgSearchButton" class="app-search-button" title="Search">' +
                        '<i class="glyphicon glyphicon-search"></i>' +
                    '</button></span>' +
                '</div>' +
            '</div></form>';
        return htm;
    },

    /* Returns the tbody markup. */
    _getGridTemplate: function () {
        var self = this,
            htm;
        htm = this.preparedData.reduce(function (prev, current) {
            return prev + self._getRowTemplate(current);
        }, '<tbody class="' + this.options.cssClassNames.gridBody + '">');

        htm += '</tbody>';
        return htm;
    },

    /* Returns the table row template. */
    _getRowTemplate: function (row) {
        var htm,
            self = this;

        htm = this.preparedHeaderData.reduce(function (prev, current, colIndex) {
            return prev + self._getColumnTemplate(row, colIndex, current);
        }, '<tr class="' + this.options.cssClassNames.tableRow + '" data-row-id="' + row.pk + '">');

        htm += '</tr>';
        return htm;
    },

    _getRowActionsColumnDefIndex: function () {
        var i, len = this.preparedHeaderData.length;
        for (i = 0; i < len; i += 1) {
            if (this.preparedHeaderData[i].field === 'rowOperations') {
                return i;
            }
        }
        return -1;
    },

    _getRowActionsColumnDef: function () {
        var index = this._getRowActionsColumnDefIndex();
        if (index !== -1) {
            return this.preparedHeaderData[index];
        }
        return null;
    },

    /* Returns the table actions (edit, delete) cell template. */
    _getRowActionsTemplate: function (colDef) {
        var htm = '';
        if (colDef.operations.indexOf('update') !== -1) {
            htm +=
                '<button type="button" class="row-action-button edit edit-row-button" title="Edit Row"><i class="glyphicon glyphicon-pencil"></i></button>' +
                '<button type="button" class="row-action-button save save-edit-row-button hidden" title="Save"><i class="glyphicon glyphicon-ok"></i></button>' +
                '<button type="button" class="row-action-button cancel cancel-edit-row-button hidden" title="Cancel"><i class="glyphicon glyphicon-remove"></i></button>';
        }
        if (colDef.operations.indexOf('delete') !== -1) {
            htm += '<button type="button" class="row-action-button delete delete-row-button" title="Delete Record"><i class="glyphicon glyphicon-trash"></i></button>';
        }
        return htm;
    },

    /* Returns the checkbox template. */
    _getCheckboxTemplate: function (row) {
        var checked = row.checked ? ' checked' : '',
            disabled = row.disabed ? ' disabled' : '';
        return '<input type="checkbox"' + checked + disabled + '/>';
    },

    /* Returns the radio template. */
    _getRadioTemplate: function (row) {
        var checked = row.checked ? ' checked' : '',
            disabled = row.disabed ? ' disabled' : '';
        return '<input type="radio" name="" value=""' + checked + disabled + '/>';
    },

    _getColumnValue: function (colDef, row) {
        var columnValue,
            f,
            k;
        if (colDef.field && !(colDef.field in row) && colDef.field.split('.').length > 1) {
            f = colDef.field.split('.');
            columnValue = row[f[0]];
            for (k = 1; k < f.length; k++) {
                if (this.Utils.isDefined(columnValue) && f[k] in columnValue) {
                    columnValue = columnValue[f[k]];
                    break;
                }
            }
            return columnValue;
        }
    },

    /* Returns the table cell template. */
    _getColumnTemplate: function (row, colId, colDef) {
        var classes = this.options.cssClassNames.tableCell + ' ' + colDef.class,
            ngClass = colDef.ngclass || '',
            htm = '<td class="' + classes + '" data-col-id="' + colId + '" style="text-align: ' + colDef.textAlignment + ';"',
            colExpression = colDef.customExpression,
            ctId = row.pk + '-' + colId,
            value,
            isCellCompiled = false,
            columnValue;
        if (colDef.field) {
            //setting the default value
            columnValue = row[colDef.field];
        }
        value = this._getColumnValue(colDef, row);
        if (value) {
            columnValue = value;
        }
        if (ngClass) {
            isCellCompiled = true;
        }
        /*constructing the expression based on the choosen format options*/
        if (colDef.formatpattern && colDef.formatpattern !== "None" && !colExpression) {
            switch (colDef.formatpattern) {
            case 'toDate':
                if (colDef.datepattern) {
                    if (colDef.type === 'datetime') {
                        columnValue = columnValue ? moment(columnValue).valueOf() : undefined;
                    }
                    colExpression = "{{'" + columnValue + "' | toDate:'" + colDef.datepattern + "'}}";
                }
                break;
            case 'toCurrency':
                if (colDef.currencypattern) {
                    colExpression = "{{'" + columnValue + "' | toCurrency:'" + colDef.currencypattern;
                    if (colDef.fractionsize) {
                        colExpression +=  "':'" + colDef.fractionsize + "'}}";
                    } else {
                        colExpression += "'}}";
                    }
                }
                break;
            case 'toNumber':
                if (colDef.fractionsize) {
                    colExpression = "{{'" + columnValue + "' | toNumber:'" + colDef.fractionsize + "'}}";
                }
                break;
            case 'prefix':
                if (colDef.prefix) {
                    colExpression = "{{'" + columnValue + "' | prefix:'" + colDef.prefix + "'}}";
                }
                break;
            case 'suffix':
                if (colDef.suffix) {
                    colExpression = "{{'" + columnValue + "' | suffix:'" + colDef.suffix + "'}}";
                }
                break;
            }
            htm += 'title="' + colExpression + '"';
        }
        if (colExpression) {
            if (isCellCompiled) {
                htm += '>';
            } else {
                htm += 'data-compiled-template="' + ctId + '">';
                isCellCompiled = true;
            }
            htm += colExpression;
        } else {
            if (colDef.type !== 'custom') {
                columnValue = row[colDef.field];
                /* 1. Show "null" values as null if filterNullRecords is true, else show empty string.
                * 2. Show "undefined" values as empty string. */
                if ((this.options.filterNullRecords && columnValue === null) ||
                        this.Utils.isUndefined(columnValue)) {
                    columnValue = '';
                }
                htm += 'title="' + columnValue + '">';
                htm += columnValue;
            } else {
                htm += '>';
                switch (colDef.field) {
                case 'checkbox':
                    htm += this._getCheckboxTemplate(row);
                    break;
                case 'radio':
                    htm += this._getRadioTemplate(row);
                    break;
                case 'rowOperations':
                    htm += this._getRowActionsTemplate(colDef);
                    break;
                case 'rowIndex':
                    htm += row.index;
                    break;
                case 'none':
                    htm += '';
                    break;
                default:
                    htm += ((this.Utils.isUndefined(columnValue) || columnValue === null)) ? '' : columnValue;
                    break;
                }
            }
        }
        htm += '</td>';

        if (ngClass) {
            htm = $(htm).attr({
                'data-ng-class': ngClass,
                'data-compiled-template': ctId
            })[0].outerHTML;
        }

        if (isCellCompiled) {
            this.compiledCellTemplates[ctId] = this.options.getCompiledTemplate(htm, row, colDef, true) || '';
        }
        return htm;
    },

    _getEditableTemplate: function ($el, colDef, cellText, rowId) {
        if (colDef.editWidgetType) {
            var template,
                formName;
            switch (colDef.editWidgetType) {
            case 'select':
                cellText = cellText || '';
                template =  '<wm-select datavalue="' + cellText + '" dataset="' + colDef.dataset + '" datafield="' + colDef.datafield + '" displayfield="' + colDef.displayfield + '"></wm-select>';
                break;
            case 'date':
                $el.addClass('datetime-wrapper');
                template = '<wm-date datavalue="' + cellText + '"></wm-date>';
                break;
            case 'time':
                $el.addClass('datetime-wrapper');
                template = '<wm-time datavalue="' + cellText + '"></wm-time>';
                break;
            case 'datetime':
                $el.addClass('datetime-wrapper');
                template = '<wm-datetime datavalue="' + cellText + '" outputformat="yyyy-MM-ddTHH:mm:ss"></wm-datetime>';
                break;
            case 'checkbox':
                template = '<wm-checkbox datavalue="' + cellText + '" height="10px"></wm-checkbox>';
                break;
            case 'number':
                template = '<wm-text type="number" datavalue="' + cellText + '"></wm-text>';
                break;
            case 'textarea':
                cellText = cellText || '';
                template = '<wm-textarea datavalue="' + cellText + '"></wm-textarea>';
                break;
            case 'upload':
                formName = colDef.field + '_' + rowId;
                $el.attr('form-name', formName);
                template = '<form name="' + formName + '"><input class="file-upload" type="file" name="' + colDef.field + '"/></form>';
                break;
            default:
                template = '<wm-text datavalue="' + cellText + '"></wm-text>';
                break;
            }
            return this.options.compileTemplateInGridScope(template);
        }
        if (this.Utils.isDefined(colDef.customExpression)) {
            return colDef.customExpression;
        }
        return '<input class="editable form-control app-textbox" type="text" value=""/>';
    },

    /* Prepares the grid header data by adding custom column definitions if needed. */
    _prepareHeaderData: function () {
        this.preparedHeaderData = [];

        $.extend(this.preparedHeaderData, this.options.colDefs);
        if (this.options.showRowIndex) {
            this.preparedHeaderData.unshift(this.customColumnDefs.rowIndex);
        }
        if (this.options.multiselect) {
            this.preparedHeaderData.unshift(this.customColumnDefs.checkbox);
        }
        if (!this.options.multiselect && this.options.showRadioColumn) {
            this.preparedHeaderData.unshift(this.customColumnDefs.radio);
        }
    },

    /* Generates default column definitions from given data. */
    _generateCustomColDefs: function () {
        var colDefs = [],
            generatedColDefs = {};

        function generateColumnDef(key) {
            if (!generatedColDefs[key]) {
                var colDef = {
                    'type': 'string',
                    'field': key
                };
                colDefs.push(colDef);
                generatedColDefs[key] = true;
            }
        }

        this.options.data.forEach(function (item) {
            _.keys(item).forEach(generateColumnDef);
        });

        this.options.colDefs = colDefs;
        this._prepareHeaderData();
    },

    /* Prepares the grid data by adding a primary key to each row's data. */
    _prepareData: function () {
        var data = [],
            colDefs = this.options.colDefs,
            self = this,
            isObject = this.Utils.isObject,
            isDefined = this.Utils.isDefined;
        if (!this.options.colDefs.length && this.options.data.length) {
            this._generateCustomColDefs();
        }
        this.options.data.forEach(function (item, i) {
            var rowData = $.extend(true, {}, item);
            colDefs.forEach(function (colDef) {
                if (!colDef.field) {
                    return;
                }
                var fields = colDef.field.split('.'),
                    text = item,
                    j,
                    len = fields.length,
                    key,
                    isArray;

                for (j = 0; j < len; j++) {
                    key = fields[j];
                    isArray = undefined;
                    if (key.indexOf('[0]') !== -1) {
                        key = key.replace('[0]', '');
                        isArray = true;
                    }
                    if (isObject(text) && !isArray) {
                        text = text[key];
                    } else if (isArray) {
                        text = text[key][0];
                    } else {
                        text = undefined;
                        break;
                    }
                }
                if (isDefined(text) && colDef.field in item) {
                    rowData[colDef.field] = text;
                } else if (!(colDef.field in item)) {
                    rowData[colDef.field] = text;
                } else if (fields.length > 1 && colDef.field in item) {
                    /* For case when coldef field name has ".", but data is in
                     * format [{'foo.bar': 'test'}], i.e. when the key value is
                     * not a nested object but a primitive value.
                     * (Ideally if coldef name has ".", for e.g. field name 'foo.bar',
                     * data should be [{'foo': {'bar': 'test'}})*/
                    rowData[colDef.field] = item[colDef.field];
                }
            });

            /* Add a unique identifier for each row. */
            rowData.index = self.options.startRowIndex + i;
            rowData.pk = i;
            data.push(rowData);
        });

        this.preparedData = data;
    },

    /* Select previously selected columns after refreshing grid data. */
    _reselectColumns: function () {
        var selectedColumns = [];
        if (this.gridHeader) {
            selectedColumns = this.gridHeader.find('th.info');
            if (selectedColumns.length) {
                selectedColumns.trigger('click');
            }
        }
    },

    /* Initializes the grid. */
    _create: function () {
        // Add all instance specific values here.
        $.extend(this, {
            dataStatus: {
                'message': '',
                'state': ''
            },
            preparedData: [],
            preparedHeaderData: [],
            dataStatusContainer: null,
            gridContainer: null,
            gridElement: null,
            gridHeader: null,
            gridBody: null,
            gridSearch: null,
            tableId: null,
            searchObj: {
                'field': '',
                'value': '',
                'event': null
            },
            compiledCellTemplates: {}
        });
        this._prepareHeaderData();
        this._prepareData();
        this._render();
    },

    /* Removes the sort buttons, and the corresponding handler if sorting is disabled. */
    removeSort: function () {
        this.gridHeader.find('.sort-button').off('click');
        this.gridHeader.find('.sort-buttons-container').remove();
    },

    /* Re-renders the whole grid. */
    _refreshGrid: function () {
        this._prepareHeaderData();
        this._prepareData();
        this._render();
        this.setColGroupWidths();
    },

    refreshGrid: function () {
        window.clearTimeout(this.refreshGridTimeout);
        this.refreshGridTimeout = window.setTimeout(this._refreshGrid.bind(this), 50);
    },

    /* Re-renders the table body. */
    refreshGridData: function () {
        this._prepareData();
        this.gridBody.remove();
        this._renderGrid();
        this._reselectColumns();
    },

    /* Inserts a new blank row in the table. */
    addNewRow: function () {
        var rowId = this.gridBody.find('tr:visible').length,
            rowData = {},
            $row;

        rowData.index = this.options.startRowIndex + rowId;
        rowData.pk = rowId;
        if (this.options.allowAddNewRow) {
            $row = $(this._getRowTemplate(rowData));
            if (!this.preparedData.length) {
                this.setStatus('ready', this.dataStatus.ready);
            }
            this.gridElement.find('tbody.app-datagrid-body').append($row);
            this.attachEventHandlers($row);
            $row.find('.edit-row-button').trigger('click', {operation: 'new'});
            this.updateSelectAllCheckboxState();
        }
    },

    /* Returns the selected rows in the table. */
    getSelectedRows: function () {
        this.getSelectedColumns();
        var selectedRowsData = [],
            self = this;

        this.preparedData.forEach(function (data, i) {
            if (data.selected) {
                selectedRowsData.push(self.options.data[i]);
            }
        });
        return selectedRowsData;
    },
    /* Sets the selected rows in the table. */
    selectRows: function (rows) {
        var self = this;
        /*Deselect all the previous selected rows in the table*/
        self.gridBody.find('tr').each(function (index) {
            if (self.preparedData[index].selected) {
                $(this).trigger('click');
            }
        });
        /*Select the given row. If rows is an array, loop through the array and set the row*/
        if (_.isArray(rows)) {
            _.forEach(rows, function (row) {
                self.selectRow(row, true);
            });
        } else {
            self.selectRow(rows, true);
        }
    },
    /*Set the default widths for the colgroup*/
    setColGroupWidths : function () {
        if (this.options.showHeader) {
            var headerCols = this.gridHeaderElement.find('col'),
                bodyCols = this.gridElement.find('col');
            this.gridHeaderElement.find('th').each(function (index) {
                /***setting the header col width based on the content width***/
                var $header = $(this),
                    width = $header.width();
                width = $header.hasClass('grid-col-small') ? 30 : (width > 50 ? width : 50); //Keep width as 30 for checkbox and radio; columnSanity check to prevent width being too small
                $(headerCols[index]).css('width', width);
                $(bodyCols[index]).css('width', width);
            });
        }
    },

    /* Returns the selected columns in the table. */
    getSelectedColumns: function () {
        var selectedColsData = {},
            headerData = [],
            self = this,
            multiSelectColIndex,
            radioColIndex,
            colIndex;
        $.extend(headerData, this.preparedHeaderData);

        if (this.options.multiselect) {
            headerData.some(function (item, i) {
                if (item.field === 'checkbox') {
                    multiSelectColIndex = i;
                    return true;
                }
            });
            headerData.splice(multiSelectColIndex, 1);
        } else if (this.options.showRadioColumn) {
            headerData.some(function (item, i) {
                if (item.field === 'radio') {
                    radioColIndex = i;
                    return true;
                }
            });
            headerData.splice(radioColIndex, 1);
        }
        if (this.options.showRowIndex) {
            headerData.some(function (item, i) {
                if (item.field === 'rowIndex') {
                    colIndex = i;
                    return true;
                }
            });
            headerData.splice(colIndex, 1);
        }

        headerData.forEach(function (colDef) {
            var field = colDef.field;
            if (colDef.selected) {
                selectedColsData[field] = {
                    'colDef': colDef,
                    'colData': self.options.data.map(function (data) { return data[field]; })
                };
            }
        });
        return selectedColsData;
    },

    /* Sets the options for the grid. */
    _setOption: function (key, value) {
        this._super(key, value);
        switch (key) {
        case 'showHeader':
            this._toggleHeader();
            break;
        case 'enableSearch':
            this._toggleSearch();
            break;
        case 'searchLabel':
            if (this.gridSearch) {
                this.gridSearch.find(
                    '[data-element="dgSearchLabel"]'
                ).text(value);
            }
            break;
        case 'selectFirstRow':
            this.selectFirstRow(value);
            break;
        case 'data':
            this.refreshGridData();
            break;
        case 'enableSort':
            if (!this.options.enableSort) {
                if (this.gridHeader) {
                    this.removeSort();
                }
            } else {
                this.refreshGrid();
            }
            break;
        case 'dataStates':
            if (this.dataStatus.state === 'nodata') {
                this.setStatus('nodata', this.dataStatus.nodata);
            }
            break;
        case 'multiselect': // Fallthrough
        case 'showRadioColumn':
        case 'colDefs':
        case 'filterNullRecords':
        case 'showRowIndex':
            this.refreshGrid();
            break;
        case 'cssClassNames':
            var gridClass = this.options.cssClassNames.gridDefault + ' ' + this.options.cssClassNames.grid;
            // Set grid class on table.
            this.gridElement.attr('class', gridClass);
            this.gridHeaderElement.attr('class', gridClass);
            if (this.options.spacing === 'condensed') {
                this._toggleSpacingClasses('condensed');
            }
            break;
        case 'spacing':
            this._toggleSpacingClasses(value);
            break;
        }
    },

    getOptions: function () {
        return this.options;
    },

    /* Toggles the table header visibility. */
    _toggleHeader: function () {
        // If header is not already rendered, render it first.
        if (!this.gridHeaderElement.find('thead th').length) {
            this._renderHeader();
        }

        if (this.options.showHeader) {
            this.gridHeaderElement.show();
        } else {
            this.gridHeaderElement.hide();
        }
    },

    /* Toggles the searchbox visibility. */
    _toggleSearch: function () {
        // If search is not already rendered, render it first.
        if (!this.gridSearch) {
            this._renderSearch();
        }

        if (this.options.enableSearch) {
            this.gridSearch.removeClass('hidden');
        } else {
            this.gridSearch.addClass('hidden');
        }
    },

    _isCustomExpressionNonEditable: function (customTag) {
        var $input;
        if (!customTag) {
            return false;
        }
        //Check if expression is provided for custom tag.
        if (_.includes(customTag, '{{') && _.includes(customTag, '}}')) {
            return true;
        }
        $input = $(customTag);
        if ($input.attr('type') === 'checkbox') {
            return false;
        }
        return true;
    },
    /* Marks the first row as selected. */
    selectFirstRow: function (value) {
        var $row = this.gridElement.find('tBody tr:first'),
            id = $row.attr('data-row-id');
        // Select the first row if it exists, i.e. it is not the first row being added.
        if ($row.length && this.preparedData.length) {
            this.preparedData[id].selected = !value;
            $row.trigger('click');
        }
    },

    /* Selects a row. */
    selectRow: function (row, value) {
        var rowIndex = angular.isNumber(row) ? row : this.Utils.getObjectIndex(this.options.data, row),
            selector,
            $row;
        if (rowIndex !== -1) {
            selector = 'tr[data-row-id=' + rowIndex + ']';
            $row = this.gridBody.find(selector);
            if ($row.length) {
                this.preparedData[rowIndex].selected = !value;
            }
            $row.trigger('click');
        }
    },
    /**
     * deselect a row
     */
    deselectRow: function (row) {
        this.selectRow(row, false);
    },

    /* Toggles the table row selection. */
    toggleRowSelection: function ($row, selected) {
        if (!$row.length) {
            return;
        }

        var rowId = $row.attr('data-row-id'),
            $checkbox,
            $radio;

        this.preparedData[rowId].selected = selected;
        if (selected) {
            $row.addClass('active');
        } else {
            $row.removeClass('active');
        }
        if (this.options.showRadioColumn) {
            $radio = $row.find('td input:radio:not(:disabled)');
            $radio.prop('checked', selected);
            this.preparedData[rowId].checked = selected;
        }
        if (this.options.multiselect) {
            $checkbox = $row.find('td input:checkbox:not(:disabled)');
            $checkbox.prop('checked', selected);
            this.preparedData[rowId].checked = selected;
            this.updateSelectAllCheckboxState();
        } else {
            this._deselectPreviousSelection($row);
        }
    },

    /* Checks the header checkbox if all table checkboxes are checked, else unchecks it. */
    updateSelectAllCheckboxState: function () {
        var $headerCheckbox = this.gridHeader.find('th input:checkbox'),
            $tbody = this.gridElement.find('tbody'),
            checkedItemsLength = $tbody.find('tr:visible input:checkbox:checked').length,
            visibleRowsLength = $tbody.find('tr:visible').length;

        if (!visibleRowsLength) {
            $headerCheckbox.prop('checked', false);
            return;
        }
        if (checkedItemsLength === visibleRowsLength) {
            $headerCheckbox.prop('checked', true);
        } else {
            $headerCheckbox.prop('checked', false);
        }
    },

    /* Handles row selection. */
    rowSelectionHandler: function (e, $row) {
        e.stopPropagation();
        var rowId,
            rowData,
            selected;

        $row = $row || $(e.target).closest('tr');
        rowId = $row.attr('data-row-id');
        rowData = this.preparedData[rowId];
        if (!rowData) {
            return;
        }
        selected = rowData.selected || false;
        selected = !selected;
        this.toggleRowSelection($row, selected);
        if (selected && $.isFunction(this.options.onRowSelect)) {
            this.options.onRowSelect(rowData, e);
        }
        if (!selected && $.isFunction(this.options.onRowDeselect)) {
            this.options.onRowDeselect(rowData, e);
        }
    },

    /*Handles the double click of the grid row*/
    rowDblClickHandler: function (e, $row) {
        e.stopPropagation();
        $row = $row || $(e.target).closest('tr');
        var rowData, rowId = $row.attr('data-row-id');
        rowData = this.preparedData[rowId];
        if (!rowData) {
            return;
        }
        if ($.isFunction(this.options.beforeRowUpdate)) {
            this.options.beforeRowUpdate(rowData, e, 'dblclick');
        }
    },

    /* Handles column selection. */
    columnSelectionHandler: function (e) {
        e.stopImmediatePropagation();
        var $th = $(e.target).closest('th'),
            id = $th.attr('data-col-id'),
            colDef = this.preparedHeaderData[id],
            field = colDef.field,
            selector = 'td[data-col-id="' + id + '"]',
            $column = this.gridElement.find(selector),
            selected = $column.data('selected') || false,
            colInfo = {
                colDef: colDef,
                data: this.options.data.map(function (data) { return data[field]; }),
                sortDirection: this._getColumnSortDirection(colDef)
            };
        selected = !selected;
        colDef.selected = selected;
        $column.data('selected', selected);

        if (selected) {
            $column.addClass('info');
            $th.addClass('info');
            if ($.isFunction(this.options.onColumnSelect)) {
                this.options.onColumnSelect(colInfo, e);
            }
        } else {
            $column.removeClass('info');
            $th.removeClass('info');
            if ($.isFunction(this.options.onColumnDeselect)) {
                /*TODO: Confirm what to send to the callback (coldef?).*/
                this.options.onColumnDeselect(colInfo, e);
            }
        }
    },
    _getValue: function ($el) {
        var type = $el.attr('type'),
            text;
        if (type === 'checkbox') {
            text = $el.prop('checked').toString();
        } else {
            text = $el.val();
            $el.text(text);
        }
        return text;
    },
    isDataModified: function ($editableElements, rowData) {
        var isDataChanged = false,
            self = this;
        $editableElements.each(function () {
            var $el = $(this),
                colId = $el.attr('data-col-id'),
                colDef = self.preparedHeaderData[colId],
                fields = colDef.field.split('.'),
                $ie = $el.find('input'),
                text = self._getValue($ie, fields),
                k,
                d;
            if (fields.length === 1) {
                isDataChanged = !text && rowData[colDef.field] === null ? false : !(rowData[colDef.field] == text);
            } else {
                d = rowData[fields[0]];
                for (k = 1; k < fields.length - 1; k++) {
                    if (this.Utils.isDefined(d) && fields[k] in d) {
                        d = d[fields[k]];
                    }
                }
                isDataChanged = !text && d[fields[k]] === null ? false : !(d[fields[k]] == text);
            }
            if (isDataChanged) {
                return !isDataChanged;
            }
        });
        return isDataChanged;
    },
    /* Toggles the edit state of a row. */
    toggleEditRow: function (e, options) {
        e.stopPropagation();
        var $row = $(e.target).closest('tr'),
            $originalElements = $row.find('td'),
            $editButton = $row.find('.edit-row-button'),
            $cancelButton = $row.find('.cancel-edit-row-button'),
            $saveButton = $row.find('.save-edit-row-button'),
            rowData = this.options.data[$row.attr('data-row-id')] || {},
            self = this,
            rowId = parseInt($row.attr('data-row-id'), 10),
            isNewRow,
            $editableElements,
            isDataChanged = false,
            formData,
            isFormDataSupported,
            multipartData;
        if (e.data.action === 'edit') {
            if ($.isFunction(this.options.beforeRowUpdate)) {
                this.options.beforeRowUpdate(rowData, e);
            }

            if ($.isFunction(this.options.setGridEditMode)) {
                this.options.setGridEditMode(true);
            }

            if (!this.options.allowInlineEditing) {
                return;
            }

            $originalElements.each(function () {
                var $el = $(this),
                    cellText = $el.text(),
                    id = $el.attr('data-col-id'),
                    colDef = self.preparedHeaderData[id],
                    editableTemplate,
                    customExp,
                    originalTemplate,
                    compiledTemplate,
                    value;
                if (!(colDef.readonly || (self._isCustomExpressionNonEditable(colDef.customExpression) && !colDef.editWidgetType) || colDef.disableInlineEditing)) {
                    if (options && options.operation === 'new') {
                        value = colDef.defaultvalue;
                    } else {
                        value = cellText;
                    }
                    editableTemplate = self._getEditableTemplate($el, colDef, value, rowId);
                    // TODO: Use some other selector. Input will fail for other types.
                    if (!(colDef.customExpression || colDef.formatpattern)) {
                        $el.addClass('cell-editing').html(editableTemplate).data('originalText', value);
                        $el.find('input').val(cellText);
                    } else {
                        if (colDef.formatpattern) {
                            $el.addClass('cell-editing editable-expression').html(editableTemplate).data('originalText', cellText);
                            // Put the original value while editing, not the formatted value.
                            $el.find('input').val(rowData[colDef.field] || self._getColumnValue(colDef, rowData));
                        } else if (colDef.customExpression) {
                            customExp = colDef.customExpression;
                            originalTemplate = customExp;
                            compiledTemplate = self.options.getCompiledTemplate(customExp, rowData, colDef, true);
                            $el.addClass('cell-editing editable-expression').data('originalValue', {'template': originalTemplate, 'rowData': _.cloneDeep(rowData), 'colDef': colDef});
                            if (colDef.editWidgetType) {
                                $el.html(editableTemplate);
                            } else {
                                $el.html(compiledTemplate);
                            }
                        }
                    }
                }
            });

            // Show editable row.
            $editButton.addClass('hidden');
            $cancelButton.removeClass('hidden');
            $saveButton.removeClass('hidden');
            $editableElements = $row.find('td.cell-editing');
            $($editableElements).find('input').focus();
            $editableElements.on('click', function (e) {
                e.stopPropagation();
            });
        } else {
            $editableElements = $row.find('td.cell-editing');
            isNewRow = rowId >= this.preparedData.length;
            if (e.data.action === 'save') {
                isFormDataSupported = (window.File && window.FileReader && window.FileList && window.Blob);
                multipartData = false;
                if (isFormDataSupported) {
                    /* Angular does not bind file values so using native object to send files */
                    formData = new FormData();
                }
                if ($.isFunction(this.options.onSetRecord)) {
                    this.options.onSetRecord(rowData, e);
                }
                if (isNewRow) {
                    isDataChanged = true;
                } else {
                    isDataChanged = this.isDataModified($editableElements, rowData);
                }
                if (isDataChanged) {
                    $editableElements.each(function () {
                        var $el = $(this),
                            colId = $el.attr('data-col-id'),
                            colDef = self.preparedHeaderData[colId],
                            fields = colDef.field.split('.'),
                            $ie = $el.find('input'),
                            text = self._getValue($ie, fields),
                            d,
                            k,
                            x;
                        $el.removeClass('datetime-wrapper');
                        if (colDef.editWidgetType && colDef.editWidgetType !== 'upload') {
                            text = $el.children().isolateScope().datavalue;
                        }
                        if (colDef.type === 'timestamp' && (!colDef.editWidgetType || colDef.editWidgetType === 'text')) {
                            text = parseInt(text, 10);
                        }
                        if (fields.length === 1) {
                            if (colDef.editWidgetType === 'upload') {
                                if (isFormDataSupported) {
                                    multipartData = true;
                                    formData.append(colDef.field, document.forms[$el.attr('form-name')][colDef.field].files[0]);
                                }
                            } else {
                                rowData[colDef.field] = text;
                            }
                        } else if (!isNewRow && fields[0] in rowData) {
                            d = rowData[fields[0]];
                            for (k = 1; k < fields.length - 1; k++) {
                                if (this.Utils.isDefined(d) && fields[k] in d) {
                                    d = d[fields[k]];
                                }
                            }
                            d[fields[k]] = text;
                        } else if (isNewRow && fields.length > 1) {
                            if (!(fields[0] in rowData)) {
                                rowData[fields[0]] = {};
                            }
                            x = rowData[fields[0]];
                            for (k = 1; k < fields.length - 1; k++) {
                                if (this.Utils.isDefined(x) && !(fields[k] in x)) {
                                    x[fields[k]] = {};
                                }
                            }
                            x[fields[k]] = text;
                        }
                    });
                    if (multipartData) {
                        formData.append('wm_data_json', new Blob([JSON.stringify(rowData)], {
                            type: 'application/json'
                        }));
                        rowData = formData;
                    }
                    if (isNewRow) {
                        this.options.onRowInsert(rowData, e, multipartData);
                    } else {
                        this.options.afterRowUpdate(rowData, e, multipartData);
                    }
                } else {
                    this.cancelEdit($editableElements);
                    $editButton.removeClass('hidden');
                    $cancelButton.addClass('hidden');
                    $saveButton.addClass('hidden');
                    this.options.noChangesDetected();
                }
            } else {
                if (isNewRow) {
                    $row.remove();
                    if (!this.preparedData.length) {
                        this.setStatus('nodata', this.dataStatus.nodata);
                    }
                    return;
                }
                if ($.isFunction(this.options.setGridEditMode)) {
                    this.options.setGridEditMode(false);
                }
                // Cancel edit.
                this.cancelEdit($editableElements);
                $editButton.removeClass('hidden');
                $cancelButton.addClass('hidden');
                $saveButton.addClass('hidden');
            }
        }
    },
    cancelEdit: function ($editableElements) {
        var self = this;
        $editableElements.each(function () {
            var $el = $(this),
                value = $el.data('originalValue'),
                originalValue,
                template;
            $el.removeClass('datetime-wrapper');
            if (!value) {
                $el.text($el.data('originalText'));
            } else {
                originalValue = value;
                if (originalValue.template) {
                    template = self.options.getCompiledTemplate(originalValue.template, originalValue.rowData, originalValue.colDef);
                    $el.html(template);
                } else {
                    $el.html(originalValue);
                }
            }
        });
    },
    hideRowEditMode: function ($row) {
        var $editableElements = $row.find('td.cell-editing'),
            $editButton = $row.find('.edit-row-button'),
            $cancelButton = $row.find('.cancel-edit-row-button'),
            $saveButton = $row.find('.save-edit-row-button'),
            self = this;
        $editableElements.each(function () {
            var $el = $(this),
                value = $el.data('originalValue'),
                originalValue,
                template;
            if (!value) {
                $el.text($el.find('input').val());
            } else {
                originalValue = value;
                if (originalValue.template) {
                    template = self.options.getCompiledTemplate(originalValue.template, originalValue.rowData, originalValue.colDef, true);
                    $el.html(template);
                } else {
                    $el.html(originalValue);
                }
            }
        });
        if ($.isFunction(this.options.setGridEditMode)) {
            this.options.setGridEditMode(false);
        }
        $editButton.removeClass('hidden');
        $cancelButton.addClass('hidden');
        $saveButton.addClass('hidden');
    },
    /* Deletes a row. */
    deleteRow: function (e) {
        e.stopPropagation();
        var $row = $(e.target).closest('tr'),
            rowId = $row.attr('data-row-id'),
            rowData = this.options.data[rowId],
            isNewRow = rowId >= this.preparedData.length,
            className,
            isActiveRow;
        if (isNewRow) {
            $row.remove();
            return;
        }
        if ($.isFunction(this.options.onRowDelete)) {
            className = this.options.cssClassNames.deleteRow;
            isActiveRow = $row.attr('class').indexOf('active') !== -1;
            if (isActiveRow) {
                $row.removeClass('active');
            }
            $row.addClass(className);
            this.options.onRowDelete(rowData, function () {
                if (isActiveRow) {
                    $row.addClass('active');
                }
                $row.removeClass(className);
            }, e);
        }
    },

    /* Deletes a row and updates the header checkbox if multiselect is true. */
    deleteRowAndUpdateSelectAll: function (e) {
        this.deleteRow(e);
        this.updateSelectAllCheckboxState();
    },

    /* Keeps a track of the currently selected row, and deselects the previous row, if multiselect is false. */
    _deselectPreviousSelection: function ($row) {
        var selectedRows = this.gridBody.find('tr.active'),
            rowId = $row.attr('data-row-id'),
            self = this;
        selectedRows.each(function (index, el) {
            var id = $(this).attr('data-row-id'),
                preparedData = self.preparedData[id];
            if (id !== rowId && preparedData) {
                $(this).find('input:radio').prop('checked', false);
                preparedData.selected = preparedData.checked = false;
                $(this).removeClass('active');
            }
        });
    },

    /* Handles table sorting. */
    sortHandler: function (e) {
        e.stopImmediatePropagation();
        var $sortButton = $(e.target).closest('.sort-button'),
            $th = $sortButton.closest('th'),
            id = $th.attr('data-col-id'),
            $sortIcon = $sortButton.find('i'),
            direction = $sortIcon.hasClass('up') ? 'asc' : 'desc',
            sortInfo = this.options.sortInfo,
            $previousSortMarker = this.gridHeader.find('.active'),
            field = $th.attr('data-col-field'),
            $previousSortedColumn,
            colId,
            colDef;
        /* If same field is sorted in same direction again then return. */
        if (sortInfo.field && sortInfo.field === field && sortInfo.direction === direction) {
            return;
        }
        $sortIcon.addClass('active');
        if ($previousSortMarker.length) {
            $previousSortedColumn = $previousSortMarker.closest('th');
            colId = $previousSortedColumn.attr('data-col-id');
            colDef = this.preparedHeaderData[colId];
            $previousSortMarker.removeClass('active');
            colDef.sortInfo = {'sorted': false, 'direction': ''};
        }
        sortInfo.direction = direction;
        sortInfo.field = field;
        this.preparedHeaderData[id].sortInfo = {'sorted': true, 'direction': direction};
        this.options.sortHandler.call(this, this.options.sortInfo, e, 'sort');
    },

    /* Attaches all event handlers for the table. */
    attachEventHandlers: function ($htm) {
        var rowOperationsCol = this._getRowActionsColumnDef(),
            deleteRowHandler;

        if (this.options.enableRowSelection) {
            $htm.on('click', this.rowSelectionHandler.bind(this));
            $htm.on('dblclick', this.rowDblClickHandler.bind(this));
            if (this.options.selectFirstRow) {
                this.selectFirstRow(true);
            }
        }

        if (this.gridHeader) {
            if (this.options.enableColumnSelection) {
                this.gridHeader.find('th[data-col-selectable]').on('click', this.columnSelectionHandler.bind(this));
            }

            if (this.options.enableSort) {
                this.gridHeader.find('.sort-button').on('click', this.sortHandler.bind(this));
            }
        }


        if (this.options.allowInlineEditing || (rowOperationsCol && rowOperationsCol.operations.indexOf('update') !== -1)) {
            $htm.find('.edit-row-button').on('click', {action: 'edit'}, this.toggleEditRow.bind(this));
            $htm.find('.cancel-edit-row-button').on('click', {action: 'cancel'}, this.toggleEditRow.bind(this));
            $htm.find('.save-edit-row-button').on('click', {action: 'save'}, this.toggleEditRow.bind(this));
        }

        if (this.options.allowDeleteRow || (rowOperationsCol && rowOperationsCol.operations.indexOf('delete') !== -1)) {
            deleteRowHandler = this.deleteRowAndUpdateSelectAll;
            if (!this.options.multiselect) {
                deleteRowHandler = this.deleteRow;
            }
            $htm.find('td .delete-row-button').on('click', deleteRowHandler.bind(this));
        }
    },

    /* Replaces all the templates needing angular compilation with the actual compiled templates. */
    _findAndReplaceCompiledTemplates: function () {
        if (!this.gridBody) {
            return;
        }
        var $compiledCells = this.gridBody.find('td[data-compiled-template]'),
            self = this;

        $compiledCells.each(function () {
            var $cell = $(this),
                id = $cell.attr('data-compiled-template');

            $cell.replaceWith(self.compiledCellTemplates[id]);
        });
    },

    /* Renders the search box. */
    _renderSearch: function () {
        var $htm = $(this._getSearchTemplate()),
            self = this,
            $searchBox,
            placeholder;

        function search(e) {
            e.stopPropagation();
            var searchText = $htm.find('[data-element="dgSearchText"]')[0].value,
                $filterField = $htm.find('[data-element="dgFilterValue"]'),
                field = $filterField[0].value,
                colDefIndex = $htm.find('option:selected').attr('data-coldef-index'),
                colDef = self.options.colDefs[colDefIndex],
                type = colDef && colDef.type ? colDef.type : '';

            self.searchObj = {
                'field': field,
                'value': searchText,
                'type': type,
                'event': e
            };
            self.options.searchHandler.call(self, self.searchObj, e, 'search');
        }

        this.element.find('.form-search').remove();
        $htm.insertBefore(this.gridContainer);
        this.gridSearch = this.element.find('.form-search');

        $searchBox = this.gridSearch.find('[data-element="dgSearchText"]');
        this.gridSearch.find('.app-search-button').on('click', search);
        this.gridSearch.find('[data-element="dgFilterValue"]').on('change', function (e) {
            var colDefIndex = $htm.find('option:selected').attr('data-coldef-index'),
                colDef = self.options.colDefs[colDefIndex];
            if (colDef) {
                placeholder = colDef.searchPlaceholder || 'Search';
                $htm.find('[data-element="dgSearchText"]').attr('placeholder', placeholder);
            }
            $searchBox.val('');
            // If "No data found" message is shown, and user changes the selection, then fetch all data.
            if (self.dataStatusContainer.find('.status').text() === self.options.dataStates.nodata) {
                search(e);
            }
        });
        $searchBox.on('keyup', function (e) {
            e.stopPropagation();
            // If the search text is empty then show all the rows.
            if (!$(this).val()) {
                if (self.searchObj.value) {
                    self.searchObj.value = '';
                    search(e);
                }
            }
            /* Search only when enter key is pressed. */
            if (e.which === 13) {
                search(e);
            }
        });
    },

    /* Renders the table header. */
    _renderHeader: function () {
        var $colgroup = $(this._getHeaderTemplate().colgroup),
            $header = $(this._getHeaderTemplate().header),
            self = this;
        function toggleSelectAll(e) {
            var $checkboxes = $('tbody tr:visible td input:checkbox:not(:disabled)', self.gridElement),
                checked = this.checked;
            $checkboxes.prop('checked', checked);
            $checkboxes.each(function () {
                var $row = $(this).closest('tr'),
                    rowId = $row.attr('data-row-id'),
                    rowData = self.preparedData[rowId];
                self.toggleRowSelection($row, checked);
                if (checked && $.isFunction(self.options.onRowSelect)) {
                    self.options.onRowSelect(rowData, e);
                }
                if (!checked && $.isFunction(self.options.onRowDeselect)) {
                    self.options.onRowDeselect(rowData, e);
                }
            });
        }
        /*For mobile view, append header to the main table only*/
        if (this.options.isMobile) {
            this.gridElement.append($header);
            this.gridHeader = this.gridElement.find('thead');
        } else {
            /**Append the colgroup to the header and the body.
             * Colgroup is used to maintain the consistent widths between the header table and body table**/
            this.gridHeaderElement.append($colgroup).append($header);
            /**As jquery references the colgroup, clone the colgroup and add it to the table body**/
            this.gridElement.append($colgroup.clone());
            this.gridHeader = this.gridHeaderElement.find('thead');
        }
        /**Add event handler, to the select all checkbox on the header**/
        $header.on('click', 'input:checkbox', toggleSelectAll);

        if ($.isFunction(this.options.onHeaderClick)) {
            this.gridHeader.on('click', {'col': this.options.colDefs}, this.options.onHeaderClick);
        }

        if (!this.options.isMobile && this.gridHeaderElement.length) {
            this.gridHeaderElement.find('th[data-col-resizable]').resizable({
                handles: 'e',
                minWidth: 50,
                // set COL width
                /* This is needed because if width is initially set on col from coldefs,
                 * then that column was not getting resized.*/
                resize: function (evt, ui) {
                    var $colElement,
                        $colHeaderElement,
                        $cellElements,
                        colIndex = ui.helper.index() + 1,
                        originalWidth = self.gridHeaderElement.find('thead > tr > th:nth-child(' + colIndex + ')').width(),
                        newWidth = ui.size.width,
                        originalTableWidth,
                        newTableWidth;
                    $colHeaderElement = self.gridHeaderElement.find('colgroup > col:nth-child(' + colIndex + ')');
                    $colElement = self.gridElement.find('colgroup > col:nth-child(' + colIndex + ')');
                    $cellElements = self.gridElement.find('tr > td:nth-child(' + colIndex + ') > div');
                    $colElement.width(newWidth);
                    $colHeaderElement.width(newWidth);
                    $cellElements.width(newWidth);
                    // height must be set in order to prevent IE9 to set wrong height
                    $(this).css('height', 'auto');
                    /*Adjust the table width only if the column width is increased*/
                    if (newWidth > ui.originalSize.width) {
                        /*Increase or decrease table width on resizing the column*/
                        originalTableWidth = self.gridHeaderElement.width();
                        newTableWidth = originalTableWidth + newWidth - originalWidth;
                        self.gridHeaderElement.width(newTableWidth);
                        self.gridElement.width(newTableWidth);
                    }
                }
            });
            /*On scroll of the content table, scroll the header*/
            this.gridElement.parent().scroll(function () {
                self.gridHeaderElement.parent().prop("scrollLeft", this.scrollLeft);
            });
        }
    },

    /* Renders the table body. */
    _renderGrid: function () {
        var $htm = $(this._getGridTemplate());
        this.gridElement.append($htm);
        // Set proper data status messages after the grid is rendered.
        if (!this.options.data.length && !this.dataStatus.state.length) {
            this.setStatus('nodata');
        } else {
            this.setStatus(this.dataStatus.state, this.dataStatus.message);
        }
        this.gridBody = this.gridElement.find('tbody');
        this._findAndReplaceCompiledTemplates();
        this.attachEventHandlers($htm);
    },

    /* Renders the table container. */
    _render: function () {
        if (!this.tableId) {
            this.tableId = this.Utils.generateGuid();
        }
        var statusContainer =
                '<div class="overlay" style="display: none;">' +
                    '<div class="status"><i class="fa fa-spinner fa-spin"></i><span class="message"></span></div>' +
                '</div>',
            table = '<div class="table-container table-responsive"><div class="app-grid-header"><div class="app-grid-header-inner"><table class="' + this.options.cssClassNames.gridDefault + ' ' + this.options.cssClassNames.grid + '" id="table_header_' + this.tableId + '">' +
                    '</table></div></div><div class="app-grid-content" style="height:' + this.options.height + ';"><table class="' + this.options.cssClassNames.gridDefault + ' ' + this.options.cssClassNames.grid + '" id="table_' + this.tableId + '">' +
                    '</table></div>' +
                '</div>';
        this.gridContainer = $(table);
        this.gridElement = this.gridContainer.find('.app-grid-content table');
        this.gridHeaderElement = this.gridContainer.find('.app-grid-header table');
        // Remove the grid table element.
        this.element.find('.table-container').remove();
        this.element.append(this.gridContainer);
        this.dataStatusContainer = $(statusContainer);
        this.gridContainer.append(this.dataStatusContainer);
        if (this.options.showHeader) {
            this._renderHeader();
        }
        if (this.options.enableSearch) {
            this._renderSearch();
        }
        if (this.options.spacing === 'condensed') {
            this._toggleSpacingClasses('condensed');
        }
        this._renderGrid();
    },

    setStatus: function (state, message) {
        var loadingIndicator = this.dataStatusContainer.find('.fa');
        this.dataStatus.state = state;
        this.dataStatus.message = message || this.options.dataStates[state];
        this.dataStatusContainer.find('.message').text(this.dataStatus.message);
        if (state === 'loading') {
            loadingIndicator.show();
        } else {
            loadingIndicator.hide();
        }
        if (state === 'ready') {
            this.dataStatusContainer.hide();
        } else {
            this.dataStatusContainer.show();
        }
        if (state === 'nodata') {
            this.dataStatusContainer.addClass('bg-none');
        } else {
            this.dataStatusContainer.removeClass('bg-none');
        }
    },

    setGridDimensions: function (key, value) {
        if (value.indexOf('px') === -1 && value.indexOf('%') === -1 && value.indexOf('em') === -1 && value != 'auto') {
            value = value + 'px';
        }
        this.options[key] = value;
        if (key === 'height') {
            this.gridContainer.find('.app-grid-content').css(key, value);
        }
    },
    /*Change the column header title. function will be called if display name changes in runmode*/
    setColumnProp: function (fieldName, property, val) {
        var $col;
        switch (property) {
        case 'displayName':
            $col = this.gridHeader.find('th[data-col-field="' + fieldName + '"]');
            $col.attr('title', val);
            $col.find('.header-data').text(val);
            break;
        }
    },

    _destroy: function () {
        this.element.text('');
        window.clearTimeout(this.refreshGridTimeout);
    }
});

/*global WM, wmCoreModule, document, window*/

WM.module('wm.widgets.dialog')
    /* Defining constants for wmDialog widget */
    .constant('LOCAL_CONSTANTS', {
        DEFAULT_DIALOG_HEADER_ICON_SIZE: "21px"
    }).run(["$templateCache", function ($templateCache) {
        "use strict";
        $templateCache.put("template/widget/dialog/dialog-template.html",
            '<div tabindex="-1" role="dialog" class="modal default" ng-style="{\'z-index\': 1050 + index*10, display: \'block\'}" ng-click="close($event)" uib-modal-transclude></div>'
            );
        $templateCache.put("template/widget/dialog/dialog.html",
            '<div class="modal-dialog app-dialog" init-widget data-ng-show="show" data-ng-style="{width: dialogWidth}" ><div class="modal-content" wmtransclude></div></div>'
            );
        $templateCache.put("template/widget/dialog/dialog-header.html",
            '<div data-ng-show="show" data-identifier="dialog-header" class="app-dialog-header modal-header" init-widget title="{{hint}}">' +
                '<button data-ng-if="closable" aria-label="Close" class="app-dialog-close close" data-ng-click="hideDialog()" title="Close">' +
                    '<span aria-hidden="true">&times;</span>' +
                '</button>' +
                '<h4 class="app-dialog-title modal-title">' +
                    '<i class="{{iconclass}}" data-ng-style="{width:iconwidth, height:iconheight, margin:iconmargin}"></i> ' +
                    '<span>{{caption}}</span>' +
                '</h4>' +
                '<div class="dialog-header-action" wmtransclude></div>' +
            '</div>'
            );
        $templateCache.put("template/widget/dialog/design.html",
            '<div class="app-dialog-body modal-body" apply-styles="scrollable-container" data-identifier="dialog-content" init-widget wmtransclude></div>'
            );
        $templateCache.put("template/widget/dialog/dialog-footer.html",
            '<div data-ng-show="show" class="app-dialog-footer modal-footer" data-identifier="actions" init-widget wmtransclude></div>'
            );

    }]).directive('wmDialog', ['PropertiesFactory', 'WidgetUtilService', 'DialogService', "$templateCache", '$compile', 'CONSTANTS', '$window', function (PropertiesFactory, WidgetUtilService, DialogService, $templateCache, $compile, CONSTANTS, $window) {
        'use strict';
        var transcludedContent = "",
            id,
            widgetProps = PropertiesFactory.getPropertiesOf("wm.designdialog", ["wm.basicdialog", "wm.base"]),
            notifyFor = {
                'width': true,
                'height': true,
                'iconname': true,
                'iconwidth': true,
                'iconheight': true,
                'iconmargin': true,
                'iconclass': true,
                'closable': true,
                'title': true
            };

        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
        function propertyChangeHandler(scope, key, newVal) {
            switch (key) {
            case "height":
                if (scope.content) {
                    //set the height for the Design Mode
                    if (newVal.indexOf('%') > 0) {
                        scope.content[key] = ($window.innerHeight * (window.parseInt(newVal) / 100) - 132);
                    } else {
                        scope.content[key] = window.parseInt(newVal - 122);
                    }
                }
                break;
            case "width":
                if (CONSTANTS.isStudioMode) {
                    scope.dialogWidth = newVal;
                }
                break;
            case "iconwidth":
            case "iconheight":
            case "iconmargin":
            case "iconclass":
            case "closable":
                scope.header[key] = newVal;
                break;
            case "title":
                scope.header.caption = newVal;
                break;
            }
        }

        return {
            "restrict": "E",
            "transclude": (CONSTANTS.isStudioMode),
            "controller": function ($scope) {
                this.dialogtype = $scope.dialogtype;
            },
            "scope": {
                "dialogtype": '@',
                "dialogid": '@'
            },
            "template": function (template, attrs) {
                transcludedContent = template.html();
                /*to have script tag with name as id in run mode and to have div in studio to be able to style the dialog*/
                if (CONSTANTS.isRunMode) {
                    /* replacing wm-dialog with wm-dialog-container in run mode to have a container for header, content and footer.
                     wm-dialog-container has a template similar to wm-dialog, replacing since wm-dialog returns script tag*/
                    var dialog = template[0].outerHTML.replace("<wm-dialog ", "<wm-dialog-container ");
                    dialog = dialog.replace("</wm-dialog>", "</wm-dialog-container>");
                    transcludedContent = dialog;
                    id = attrs.name;
                    return '<script type="text/ng-template" id="' + id + '">' + transcludedContent + "</script>";
                }
                return $templateCache.get("template/widget/dialog/dialog.html");
            },
            "replace": true,
            "compile": function () {
                return {
                    "pre": function (scope) {
                        scope.widgetProps = widgetProps;
                    },
                    "post": function (scope, element, attrs) {

                        if (CONSTANTS.isStudioMode) {
                            element.append($compile(transcludedContent)(scope));
                        }
                        scope = scope || element.isolateScope();
                        scope.header = element.find('[data-identifier=dialog-header]').isolateScope() || {};
                        scope.content = element.find('[data-identifier=dialog-content]').isolateScope() || {};

                        /* register the property change handler */
                        if (scope.propertyManager) {
                            WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, scope), scope, notifyFor);
                        }

                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]).directive('wmDialogContainer', ["$templateCache", "PropertiesFactory", "WidgetUtilService", "CONSTANTS", '$window', function ($templateCache, PropertiesFactory, WidgetUtilService, CONSTANTS, $window) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf("wm.designdialog", ["wm.basicdialog", "wm.base"]),
            notifyFor = {
                'width': true,
                'height': true,
                'iconwidth': true,
                'iconheight': true,
                'iconmargin': true,
                'iconclass': true,
                'closable': true,
                'title': true
            };

        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
        function propertyChangeHandler(scope, element, key, newVal) {
            switch (key) {
            case "height":
                if (scope.content) {
                    //set the height for the Run Mode
                    if (newVal.indexOf('%') > 0) {
                        scope.content[key] = ($window.innerHeight * (window.parseInt(newVal) / 100) - 112);
                    } else {
                        scope.content[key] = window.parseInt(newVal - 112);
                    }
                }
                break;
            case "width":
                if (scope.width && CONSTANTS.isRunMode) {
                    //update the modal element in the UI for getting shadow and width set
                    element.closest('.modal-dialog').css('width', newVal);
                }
                break;
            case "iconwidth":
            case "iconheight":
            case "iconmargin":
            case "iconclass":
            case "closable":
                scope.header[key] = newVal;
                break;
            case "title":
                scope.header.caption = newVal;
                break;
            }
        }

        return {
            "restrict": "E",
            "transclude": true,
            "controller": function ($scope, $element) {
                this.dialogtype = $scope.dialogtype;
                this.onDialogOk = $scope.onOk;
                this.onDialogCancel = $scope.onCancel;
                this.onDialogClose = $scope.onClose;
                /*making the onclose function available to transclusion scope of wmDialogContainer so that the header can access it */
                $element.scope().onClose = $scope.onClose;
                $element.scope().onOpened = $scope.onOpened;
            },
            "scope": {
                "dialogid": '@',
                "onOk": '&',
                "onClose": '&',
                "onCancel": '&',
                "onOpened": '&'
            },
            "template": $templateCache.get("template/widget/dialog/dialog.html"),
            "replace": true,
            "compile": function () {
                return {
                    "pre": function (scope) {
                        scope.widgetProps = widgetProps;
                    },
                    "post": function (scope, element, attrs) {
                        scope = scope || element.isolateScope();
                        scope.header = element.find('[data-identifier=dialog-header]').isolateScope() || {};
                        scope.content = element.find('[data-identifier=dialog-content]').isolateScope() || {};

                        /* register the property change handler */
                        WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, scope, element), scope, notifyFor);

                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]).directive('wmDialogheader', ["PropertiesFactory", "DialogService", "WidgetUtilService", "LOCAL_CONSTANTS", "$templateCache", function (PropertiesFactory, DialogService, WidgetUtilService, LOCAL_CONSTANTS, $templateCache) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf("wm.dialog.dialogheader", ["wm.base"]),
            notifyFor = {
                'iconclass': true,
                'caption': true
            };

        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
        function propertyChangeHandler(scope, key, newVal) {
            switch (key) {
            case "iconclass":
                if (scope.iconurl && newVal !== '' && newVal !== '_none_') {
                    scope.iconurl = '';
                    scope.iconwidth = scope.iconheight = LOCAL_CONSTANTS.DEFAULT_DIALOG_HEADER_ICON_SIZE;
                } else if (!scope.iconurl && newVal !== '' && newVal !== '_none_') {
                    scope.iconwidth = scope.iconheight = LOCAL_CONSTANTS.DEFAULT_DIALOG_HEADER_ICON_SIZE;
                } else {
                    scope.iconwidth = scope.iconheight = '';
                }
                break;
            }
        }

        return {
            "restrict": 'E',
            "replace": true,
            "transclude": true,
            "controller": 'DialogController',
            "scope": {},
            "template": $templateCache.get("template/widget/dialog/dialog-header.html"),
            "compile": function () {
                return {
                    "pre": function (scope) {
                        scope.widgetProps = widgetProps;
                    },
                    "post": function (scope, element, attrs, dialogCtrl) {
                        var parentEl,
                            onCloseEventName,
                            onOpenedEventName,
                            parentElScope;

                        parentEl = element.closest('.app-dialog');
                        parentElScope = parentEl.isolateScope();

                        /* accessing the onClose from parent scope*/
                        scope.onClose = parentElScope.onClose;
                        scope.onOpened = parentElScope.onOpened;
                        scope.dialogid = parentEl.attr('dialogid');

                        element.scope().dialogid = scope.dialogid;
                        /* getting on-close attr from parent*/
                        onCloseEventName = parentEl.attr("on-close");
                        onOpenedEventName = parentEl.attr("on-opened");

                        scope.hideDialog = function () {
                            if (dialogCtrl) {
                                /*handles close button click*/
                                dialogCtrl._CloseButtonHandler(onCloseEventName);
                            }
                        };
                        if (onOpenedEventName && dialogCtrl && !scope.widgetid) {
                            /*handles close button click*/
                            dialogCtrl._OnOpenedHandler(onOpenedEventName);
                        }

                        /* register the property change handler */
                        WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, scope), scope, notifyFor);

                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]).directive('wmDialogcontent', ["$templateCache", "PropertiesFactory", "WidgetUtilService", function ($templateCache, PropertiesFactory, WidgetUtilService) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf("wm.dialog.dialogcontent", ["wm.base"]);

        return {
            "restrict": 'E',
            "replace": true,
            "require": '?^wmDialog',
            "scope": {},
            "transclude": true,
            "template": $templateCache.get("template/widget/dialog/design.html"),
            "compile": function () {
                return {
                    pre: function (scope) {
                        scope.widgetProps = widgetProps;
                    },
                    "post": function (scope, element, attrs) {
                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }

        };
    }]).directive('wmDialogactions', ["PropertiesFactory", "WidgetUtilService", "$templateCache", "DialogService", function (PropertiesFactory, WidgetUtilService, $templateCache, DialogService) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf("wm.dialog.dialogactions", ["wm.base"]);

        return {
            "restrict": 'E',
            "replace": true,
            "transclude": true,
            "scope": {},
            "template": $templateCache.get("template/widget/dialog/dialog-footer.html"),
            "compile": function () {
                return {
                    "pre": function (scope) {
                        scope.widgetProps = widgetProps;
                    },
                    "post": function (iScope, element, attrs) {
                        var scope = element.scope();
                        scope.closeDialog = function () {
                            DialogService.hideDialog(scope.dialogid);
                        };
                        WidgetUtilService.postWidgetCreate(iScope, element, attrs);
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.widgets.dialog.directive:wmDialog
 * @restrict E
 *
 * @description
 * The `wmDialog` directive defines design dialog widget. <br>
 * wmDialog should contain `wmDialogheader`, `wmDialogcontent`, `wmDialogactions` inside it <br>
 * A dialog is created in an independent view.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 * @requires DialogService
 * @requires $rootScope
 * @requires $templateCache
 * @requires $compile
 * @requires CONSTANTS
 *
 * @param {string=} name
 *                  Name of the dialog.
 * @param {string=} title
 *                  title of the dialog.
 * @param {string=} height
 *                  Height of the dialog.
 * @param {string=} width
 *                  Width of the dialog.
 * @param {boolean=} show
 *                  show is a bindable property. <br>
 *                  This property will be used to show/hide the dialog on the web page. <br>
 *                  Default value:`true`.
 * @param {boolean=} modal
 *                  True value for Modal property shows up a modal dialog. <br>
 *                  Default value:`true`.
 * @param {string=} iconclass
 *                  iconclass sets the icon for dialog header
 * @param {string=} on-close
 *                  Callback function which will be triggered when the dialog is collapsed.
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl">
                <wm-view class="dialog-view">
                    <wm-dialog name="sampleDialog" show="true" title="demo-dialog" on-close="onCloseCallBack()" controller="Ctrl">
                        <wm-dialogheader></wm-dialogheader>
                        <wm-dialogcontent>
                            <wm-form>
                                <wm-composite widget="text">
                                    <wm-label caption="Name"></wm-label>
                                    <wm-text></wm-text>
                                </wm-composite>
                            </wm-form>
                        </wm-dialogcontent>
                        <wm-dialogactions show="true">
                            <wm-button on-click="hideDialog()" caption="Hide Dialog" class="btn-danger"></wm-button>
                        </wm-dialogactions>
                    </wm-dialog>
                </wm-view>
                <wm-button on-click="sampleDialog.show" caption="Show Dialog" class="btn-success"></wm-button>
            </div>
        </file>
        <file name="script.js">
            function Ctrl($scope, DialogService) {
                $scope.onCloseCallBack = function () {
                    console.log("inside close callback");
                }
                $scope.hideDialog = function () {
                    DialogService.close('sampleDialog');
                }
            }
        </file>
    </example>
 */


/**
 * @ngdoc directive
 * @name wm.widgets.dialog.directive:wmDialogheader
 * @restrict E
 *
 * @description
 * The `wmDialogheader` directive defines dialog header. <br>
 * wmDialogheader can be used only inside wmDialog. <br>
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires $templateCache
 * @requires WidgetUtilService
 *
 * @param {string=} name
 *                  Name of the dialogheader.
 * @param {string=} hint
 *                  Any text or html you enter for this property will be shown as a tooltip if the mouse hovers over this widget.
 * @param {string=} width
 *                  Width of the dialog.
 * @param {string=} height
 *                  Height of the dialog.
 * @param {list=} animation
 *                  This property controls the animation of the anchor. <br>
 *                  The animation is based on the css classes and works only in the run mode. <br>
 *                  Possible values are "bounce", "flash", "pulse", "rubberBand", "shake", etc.
 * @param {string=} iconclass
 *                  iconclass sets the icon for dialog header
 * @param {string=} iconwidth
 *                  Optional, This sets the width of the icon in dialog header.
 * @param {string=} iconheight
 *                  Optional, This sets the height of the icon in dialog header.
 * @param {string=} iconmargin
 *                  Optional, This sets the margin of the icon in dialog header.
 * @param {string=} on-close
 *                  Callback function which will be triggered when the dialog is closed.
 * @param {string=} on-opened
 *                  Callback function which will be triggered after the dialog is opened.
 *
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl">
                <wm-view class="dialog-view">
                    <wm-dialog name="sampleDialog" show="true" title="demo-dialog" on-close="onCloseCallBack()" controller="Ctrl">
                        <wm-dialogheader></wm-dialogheader>
                        <wm-dialogcontent>
                            <wm-form>
                                <wm-composite widget="text">
                                    <wm-label caption="Name"></wm-label>
                                    <wm-text></wm-text>
                                </wm-composite>
                            </wm-form>
                        </wm-dialogcontent>
                        <wm-dialogactions show="true">
                            <wm-button on-click="hideDialog()" caption="Hide Dialog" class="btn-danger"></wm-button>
                        </wm-dialogactions>
                    </wm-dialog>
                </wm-view>
                <wm-button on-click="sampleDialog.show" caption="Show Dialog" class="btn-success"></wm-button>
            </div>
        </file>
        <file name="script.js">
            function Ctrl($scope, DialogService) {
                $scope.onCloseCallBack = function () {
                    console.log("inside close callback");
                }
                $scope.hideDialog = function () {
                    DialogService.close('sampleDialog');
                }
            }
        </file>
    </example>
 */


/**
 * @ngdoc directive
 * @name wm.widgets.dialog.directive:wmDialogcontent
 * @restrict E
 *
 * @description
 * The `wmDialogcontent` directive defines accordion-header widget. <br>
 * wmDialogcontent can be used only inside wmDialog. <br>
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires $templateCache
 * @requires WidgetUtilService
 * @requires $compile
 * @requires Utils
 *
 * @param {string=} name
 *                  Name of the dialogcontent.
 * @param {boolean=} show
 *                  show is a bindable property. <br>
 *                  This property will be used to show/hide the dialog on the web page. <br>
 *                  Default value: `true`.
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl">
                <wm-view class="dialog-view">
                    <wm-dialog name="sampleDialog" show="true" title="demo-dialog" on-close="onCloseCallBack()" controller="Ctrl">
                        <wm-dialogheader></wm-dialogheader>
                        <wm-dialogcontent>
                            <wm-form>
                                <wm-composite widget="text">
                                    <wm-label caption="Name"></wm-label>
                                    <wm-text></wm-text>
                                </wm-composite>
                            </wm-form>
                        </wm-dialogcontent>
                        <wm-dialogactions show="true">
                            <wm-button on-click="hideDialog()" caption="Hide Dialog" class="btn-danger"></wm-button>
                        </wm-dialogactions>
                    </wm-dialog>
                </wm-view>
                <wm-button on-click="sampleDialog.show" caption="Show Dialog" class="btn-success"></wm-button>
            </div>
        </file>
        <file name="script.js">
            function Ctrl($scope, DialogService) {
                $scope.onCloseCallBack = function () {
                    console.log("inside close callback");
                }
                $scope.hideDialog = function () {
                    DialogService.close('sampleDialog');
                }
            }
        </file>
    </example>
 */


/**
 * @ngdoc directive
 * @name wm.widgets.dialog.directive:wmDialogactions
 * @restrict E
 *
 * @description
 * The `wmDialogactions` directive defines dialogactions widget. <br>
 * wmDialogactions can be used only inside wmDialog.<br>
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires $templateCache
 * @requires WidgetUtilService
 * @requires Utils
 *
 * @param {string=} name
 *                  Name of the dialogaction.
 * @param {boolean=} show
 *                  show is a bindable property. <br>
 *                  This property will be used to show/hide the dialog on the web page. <br>
 *                  Default value: `true`.
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl">
                <wm-view class="dialog-view">
                    <wm-dialog name="sampleDialog" show="true" title="demo-dialog" on-close="onCloseCallBack()" controller="Ctrl">
                        <wm-dialogheader></wm-dialogheader>
                        <wm-dialogcontent>
                            <wm-form>
                                <wm-composite widget="text">
                                    <wm-label caption="Name"></wm-label>
                                    <wm-text></wm-text>
                                </wm-composite>
                            </wm-form>
                        </wm-dialogcontent>
                        <wm-dialogactions show="true">
                            <wm-button on-click="hideDialog()" caption="Hide Dialog" class="btn-danger"></wm-button>
                        </wm-dialogactions>
                    </wm-dialog>
                </wm-view>
                <wm-button on-click="sampleDialog.show" caption="Show Dialog" class="btn-success"></wm-button>
            </div>
        </file>
        <file name="script.js">
            function Ctrl($scope, DialogService) {
                $scope.onCloseCallBack = function () {
                    console.log("inside close callback");
                }
                $scope.hideDialog = function () {
                    DialogService.close('sampleDialog');
                }
            }
        </file>
    </example>
 */

/**
 * @ngdoc directive
 * @name wm.widgets.dialog.directive:wmDialogContainer
 * @restrict E
 *
 * @description
 * The `wmDialogContainer` directive defines design dialog widget in run mode. <br>
 * It is identical to wmDialog. It is used internally to simluate wmDialog in run mode.
 */
/*global WM, wmCoreModule, wmDialog, _*/
/*Directive for alert dialog */

WM.module('wm.widgets.dialog')
    .run(["$templateCache", function ($templateCache) {
        "use strict";
        $templateCache.put("template/widget/dialog/alertdialog.html",
            '<div class="app-dialog modal-dialog app-alert-dialog" ng-class="{type:type}" dialogclass init-widget data-ng-show="show" data-ng-style="{width: dialogWidth}"><div class="modal-content">' +
                '<wm-dialogheader iconclass="{{iconclass}}" iconwidth="{{iconwidth}}" iconheight="{{iconheight}}" iconmargin="{{iconmargin}}" caption="{{title}}"></wm-dialogheader>' +
                '<div class="app-dialog-body modal-body" apply-styles="scrollable-container">' +
                    '<p class="app-dialog-message text-{{alerttype}}"> {{message}}</p>' +
                '</div>' +
                '<div class="app-dialog-footer modal-footer">' +
                    '<wm-button  class="btn-primary"  caption={{oktext}} on-click="okButtonHandler()"></wm-button>' +
                '</div>' +
            '</div></div>'
            );
    }]).directive('wmAlertdialog', ["$templateCache", "PropertiesFactory", "WidgetUtilService", "CONSTANTS",'Utils', '$window', function ($templateCache, PropertiesFactory, WidgetUtilService, CONSTANTS, Utils, $window) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf("wm.alertdialog", ["wm.basicdialog", "wm.base", "wm.dialog.onOk"]),
            notifyFor = {
                'message': true,
                'oktext': true,
                'height': true,
                'width' : true,
                'type': true
            };

        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
        function propertyChangeHandler(scope, element, attrs, key, newVal) {
            switch (key) {
            case "height":
                if (scope.height) {
                    //set the height for the Run Mode
                    if (newVal.indexOf('%') > 0) {
                        scope.bodyHeight = ($window.innerHeight * (parseInt(newVal, 10) / 100) - 112);
                    } else {
                        scope.bodyHeight = parseInt(newVal - 112, 10);
                    }
                }
                break;
            case "message":
                /*handling default values for notification alert dialog in studio*/
                if (attrs.notificationdialog && !CONSTANTS.isRunMode) {
                    scope.message = "Alert Notification Message";
                }
                break;
            case "oktext":
                /*handling default values for notification alert dialog in studio */
                if (attrs.notificationdialog && !CONSTANTS.isRunMode) {
                    scope.oktext = "OK";
                }
                break;
            case "width":
                if (scope.width && CONSTANTS.isRunMode) {
                    //update the modal element in the UI for getting shadow and width set
                    element.closest('.modal-dialog').css('width', newVal);
                } else if (CONSTANTS.isStudioMode) {
                    scope.dialogWidth = newVal;
                }
                break;
            }
        }

        return {
            "restrict": "E",
            "controller": "DialogController",
            "scope": {
                "dialogid": '@',
                "onOk": '&',
                "onClose": '&'
            },
            "replace": true,
            "template": function (template, attrs) {
                /*if the script tag has not been created already, set inscript to false*/
                if (template.attr('inscript') === undefined) {
                    template.attr('inscript', false);
                }
                /* in run mode, when script tag is not created, create script, else return normal template*/
                if (CONSTANTS.isRunMode && (template.attr('inscript') === "false")) {
                    /*once script tag is created, set inscript attribute to true*/
                    template.attr('inscript', true);
                    var transcludedContent = template[0].outerHTML,
                        id = attrs.name;
                    /*alert dialog is always modal, so setting backdrop to static*/
                    return '<script backdrop="static" type="text/ng-template" id="' + id + '">' + transcludedContent + "</script>";
                }
                return $templateCache.get("template/widget/dialog/alertdialog.html");
            },
            "compile": function () {
                return {
                    "pre": function (iScope, element, attrs) {
                        if (CONSTANTS.isStudioMode) {
                            iScope.widgetProps = Utils.getClonedObject(widgetProps);
                        } else {
                            iScope.widgetProps = widgetProps;
                        }

                        /* for the notification-alert dialogs do not allow the user to edit the properties other than class */
                        if (attrs.widgetid && attrs.notificationdialog) { //widget is in canvas
                            var wp = iScope.widgetProps;
                            _.keys(wp).forEach(function (propName) {
                                if (propName !== 'class') {
                                    wp[propName].disabled = true;
                                }
                            });
                        }
                    },
                    "post": function (scope, element, attrs, dialogCtrl) {
                        /* handles ok button click*/
                        if (!scope.okButtonHandler) {
                            scope.okButtonHandler = function () {
                                dialogCtrl._OkButtonHandler(attrs.onOk);
                            };
                        }

                        /* register the property change handler */
                        if (scope.propertyManager) {
                            WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, scope, element, attrs), scope, notifyFor);
                        }

                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.widgets.dialog.directive:wmAlertdialog
 * @restrict E
 *
 * @description
 * The `wmAlertdialog` directive defines alert dialog widget. <br>
 * An alert dialog is created in an independent view.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 * @requires $templateCache
 * @requires CONSTANTS
 *
 * @param {string=} title
 *                  title of the dialog.
 * @param {string=} name
 *                  Name of the dialog.
 * @param {string=} message
 *                  message is a bindable property. <br>
 *                  message to be shown in the dialog.
 * @param {string=} oktext
 *                  oktext is a bindable property. <br>
 *                  Text to be shown in dialog's Ok button.
 * @param {list=} alerttype
 *                  alerttype sets the type for the alert dialog.
 *                  Valid values are /information/error/success/warning.
 * @param {string=} width
 *                  Width of the dialog.
 * @param {string=} height
 *                  Height of the dialog.
 * @param {boolean=} show
 *                  show is a bindable property. <br>
 *                  This property will be used to show/hide the dialog on the web page. <br>
 *                  Default value: `true`.
 * @param {list=} animation
 *                  This property controls the animation of the dialog. <br>
 *                  The animation is based on the css classes and works only in the run mode. <br>
 *                  Possible values are "bounce", "flash", "pulse", "rubberBand", "shake", etc.
 * @param {string=} iconclass
 *                  Icon sets the icon for dialog header.
 * @param {string=} iconwidth
 *                  Optional, This sets the width of the icon in dialog header.
 * @param {string=} iconheight
 *                  Optional, This sets the height of the icon in dialog header.
 * @param {string=} iconmargin
 *                  Optional, This sets the margin of the icon in dialog header.
 * @param {string=} on-ok
 *                  Callback function which will be triggered when the ok button for the dialog is clicked.
 * @param {string=} on-cancel
 *                  Callback function which will be triggered when the cancel button for the dialog is clicked.
 * @param {string=} on-opened
 *                  Callback function which will be triggered after the dialog is opened.
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
                <wm-view class="dialog-view">
                    <wm-alertdialog name="alertDialog"></wm-alertdialog>
                </wm-view>
                <button ng-click="showDialog()" class="btn-success">Show Dialog</button>
            </div>
        </file>
        <file name="script.js">
            function Ctrl($scope, DialogService) {
                $scope.showDialog = function () {
                    DialogService.open("alertDialog");
                };
            }
            function alertDialogController() {};
        </file>
    </example>
 */
/*global WM, wmCoreModule, wmDialog, _*/
/*Directive for confirm dialog */

WM.module('wm.widgets.dialog')
    .run(["$templateCache", function ($templateCache) {
        "use strict";
        $templateCache.put("template/widget/dialog/confirmdialog.html",
                '<div class="app-dialog modal-dialog app-confirm-dialog" dialogclass init-widget data-ng-show="show" data-ng-style="{width: dialogWidth}">' +
                    '<div class="modal-content">' +
                        '<wm-dialogheader caption="{{title}}" iconclass="{{iconclass}}" iconwidth="{{iconwidth}}" iconheight="{{iconheight}}" iconmargin="{{iconmargin}}"></wm-dialogheader>' +
                        '<div class="app-dialog-body modal-body" apply-styles="scrollable-container">' +
                            '<p class="app-dialog-message {{messageclass}}"> {{message}}</p>' +
                        '</div>' +
                        '<div class="app-dialog-footer modal-footer">' +
                            '<wm-button class="btn-secondary" caption={{canceltext}} on-click="cancelButtonHandler()"></wm-button>' +
                            '<wm-button class="btn-primary" caption={{oktext}} on-click="okButtonHandler()"></wm-button>' +
                        '</div>' +
                    '</div>' +
                '</div>'
            );
    }]).directive('wmConfirmdialog', ["$templateCache", "PropertiesFactory", "WidgetUtilService", "CONSTANTS", 'Utils', '$window', function ($templateCache, PropertiesFactory, WidgetUtilService, CONSTANTS, Utils, $window) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf("wm.confirmdialog", ["wm.basicdialog", "wm.base", "wm.dialog.onOk"]),
            notifyFor = {
                'message': true,
                'oktext': true,
                'canceltext': true,
                'height': true,
                'width' : true
            };

        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
        function propertyChangeHandler(scope, element, attrs, key, newVal) {
            switch (key) {
            case "height":
                if (scope.height) {
                    //set the height for the Run Mode
                    if (newVal.indexOf('%') > 0) {
                        scope.bodyHeight = ($window.innerHeight * (parseInt(newVal, 10) / 100) - 112);
                    } else {
                        scope.bodyHeight = parseInt(newVal - 112, 10);
                    }
                }
                break;
            case "message":
                /*handling default values for notification confirm dialog in studio*/
                if (attrs.notificationdialog && !CONSTANTS.isRunMode) {
                    scope.message = "Confirm Notification Message";
                }
                break;
            case "oktext":
                /*handling default values for notification confirm dialog in studio*/
                if (attrs.notificationdialog && !CONSTANTS.isRunMode) {
                    scope.oktext = "OK";
                }
                break;
            case "canceltext":
                /*handling default values for notification confirm dialog in studio*/
                if (attrs.notificationdialog && !CONSTANTS.isRunMode) {
                    scope.canceltext = "CANCEL";
                }
                break;
            case "width":
                if (scope.width && CONSTANTS.isRunMode) {
                    //update the modal element in the UI for getting shadow and width set
                    element.closest('.modal-dialog').css('width', newVal);
                } else if (CONSTANTS.isStudioMode) {
                    scope.dialogWidth = newVal;
                }
                break;
            }
        }

        return {
            "restrict": "E",
            "controller": "DialogController",
            "scope": {
                "dialogid": '@',
                "onOk": '&',
                "onClose": '&',
                "onCancel": '&',
                "okParams": "@"
            },
            "replace": true,
            "template": function (template, attrs) {
                /*if the script tag has not been created already, set inscript to false*/
                if (template.attr('inscript') === undefined) {
                    template.attr('inscript', false);
                }
                /* in run mode, when script tag is not created, create script, else return normal template*/
                if (CONSTANTS.isRunMode && (template.attr('inscript') === "false")) {
                    /*once script tag is created, set inscript attribute to true*/
                    template.attr('inscript', true);
                    var transcludedContent = template[0].outerHTML,
                        id = attrs.name;
                    /*confirm dialog is always modal, so setting backdrop to static*/
                    return '<script backdrop="static" type="text/ng-template" id="' + id + '" modal="true" keyboard="false">' + transcludedContent + '</script>';

                }
                return $templateCache.get("template/widget/dialog/confirmdialog.html");
            },
            "compile": function () {
                return {
                    "pre": function (iScope, element, attrs) {
                        if (CONSTANTS.isStudioMode) {
                            iScope.widgetProps = Utils.getClonedObject(widgetProps);
                        } else {
                            iScope.widgetProps = widgetProps;
                        }

                        /* for the notification-alert dialogs do not allow the user to edit the properties other than class */
                        if (attrs.widgetid && attrs.notificationdialog) { //widget is in canvas
                            var wp = iScope.widgetProps;
                            _.keys(wp).forEach(function (propName) {
                                if (propName !== 'class') {
                                    wp[propName].disabled = true;
                                }
                            });
                        }
                    },
                    "post": function (scope, element, attrs, dialogCtrl) {
                        /* handles cancel button click*/
                        if (!scope.cancelButtonHandler) {
                            scope.cancelButtonHandler = function () {
                                dialogCtrl._CancelButtonHandler(attrs.onCancel);
                            };
                        }
                        /* handles ok button click*/
                        if (!scope.okButtonHandler) {
                            scope.okButtonHandler = function () {
                                dialogCtrl._OkButtonHandler(attrs.onOk);
                            };
                        }
                        /*adding classes for ok and cancel button for studio*/
                        if (scope.okbuttonclass) {
                            WM.element(element.find('button')[1]).addClass(scope.okbuttonclass);
                        }
                        if (scope.cancelbuttonclass) {
                            WM.element(element.find('button')[0]).addClass(scope.cancelbuttonclass);
                        }

                        /* register the property change handler */
                        if (scope.propertyManager) {
                            WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, scope, element, attrs), scope, notifyFor);
                        }

                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.widgets.dialog.directive:wmConfirmdialog
 * @restrict E
 *
 * @description
 * The `wmConfirmdialog` directive defines confirm dialog widget. <br>
 * A confirm dialog is created in an independent view.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 * @requires $templateCache
 * @requires CONSTANTS
 *
 * @param {string=} title
 *                  title of the dialog.
 * @param {string=} name
 *                  Name of the dialog.
 * @param {string=} message
 *                  message is a bindable property. <br>
 *                  Message to be shown in the dialog.
 * @param {string=} oktext
 *                  oktext is a bindable property. <br>
 *                  Text to be shown in dialog's Ok button.
 * @param {string=} canceltext
 *                  canceltext is a bindable property. <br>
 *                  Text to be shown in dialog's Cancel button.
 * @param {string=} width
 *                  Width of the dialog.
 * @param {string=} height
 *                  Height of the dialog.
 * @param {boolean=} show
 *                  show is a bindable property. <br>
 *                  This property will be used to show/hide the accordion on the web page. <br>
 *                  Default value: `true`.
 * @param {list=} animation
 *                  This property controls the animation of the dialog. <br>
 *                  The animation is based on the css classes and works only in the run mode. <br>
 *                  Possible values are "bounce", "flash", "pulse", "rubberBand", "shake", etc.
 * @param {string=} iconclass
 *                  iconclass sets the icon for dialog header
 * @param {string=} iconwidth
 *                  Optional, This sets the width of the icon in dialog header
  * @param {string=} iconheight
 *                  Optional, This sets the height of the icon in dialog header
 * @param {string=} iconmargin
 *                  Optional, This sets the margin of the icon in dialog header
 * @param {string=} on-close
 *                  Callback function which will be triggered when the dialog is closed.
 * @param {string=} on-ok
 *                  Callback function which will be triggered when the ok button for the dialog is clicked.
 * @param {string=} on-cancel
 *                  Callback function which will be triggered when the cancel button for the dialog is clicked.
 * @param {string=} on-opened
 *                  Callback function which will be triggered after the dialog is opened.
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl">
                <wm-button on-click="confirmDialog.show" caption="Show Dialog" class="btn-primary"></wm-button>
                <wm-view class="dialog-view">
                    <wm-confirmdialog name="confirmDialog" controller="Ctrl"
                        iconclass="glyphicon glyphicon-warning-sign" message="I am a confirm box"
                        oktext="Ok!!" canceltext="Close" on-ok="onOkCallBack()"
                        on-cancel="onCancelCallBack()" on-close="onCloseCallBack()">
                    </wm-confirmdialog>
                </wm-view>
            </div>
        </file>
        <file name="script.js">
            function Ctrl($scope, DialogService) {
                $scope.onCloseCallBack = function () {
                    console.log("inside close callback");
                }
                $scope.onOkCallBack = function () {
                    console.log("inside ok callback");
                }
                $scope.onCancelCallBack = function () {
                    console.log("inside cancel callback");
                    DialogService.close('confirmDialog');
                }
                $scope.onOpenedCallBack = function () {
                    console.log("inside opened callback");
                }
            }
        </file>
    </example>
 */

/*global WM, wmDialog*/
/*jslint todo: true */
/*jslint sub: true */

/* "DialogController" is the controller to handle onOk, onCancel, onClose events for all Dialogs. */

WM.module('wm.widgets.dialog')
    .controller('DialogController', function ($scope, DialogService, Utils, $rootScope) {
        "use strict";
        /* handles all types of events for dialog*/
        var handleEvent = function (eventName, hideDialog, callBack, callbackParams) {
            /* if the name is a function, execute the call back
             * if name is a dialog hide/show option, call the dialog hide show method accordingly
             * else invoke the service and finally close the current dialog*/
            if (eventName && eventName.indexOf("(") !== -1) {
                Utils.triggerFn(callBack, callbackParams);
                return;
            }
            if (callBack && WM.isFunction(callBack())) { /*Studio Dialogs without individual templates do not have a "(" in the eventName.
            callBack() will return a reference to the actual callback.*/
                Utils.triggerFn(callBack(), callbackParams);
            } else if (eventName.indexOf('.show') > -1) {
                DialogService.showDialog(eventName.slice(0, eventName.indexOf('.show')));
            } else if (eventName.indexOf('.hide') > -1) {
                DialogService.hideDialog(eventName.slice(0, eventName.indexOf('.hide')));
            } else {
                if (eventName.trim()) {
                    $rootScope.$emit('invoke-service', eventName);
                }
            }
            if (hideDialog) {
                DialogService.hideDialog($scope.dialogid);
            }
        };
        this._OkButtonHandler = function (eventName) {
            var eventParams;
            /*If "okParams" is a JSON string, then parse it. Else, pass it as is.*/
            if ($scope.okParams && $scope.okParams.indexOf("{") > -1) {
                eventParams = Utils.getValidJSON($scope.okParams);
            } else {
                eventParams = $scope.okParams;
            }
            eventName = eventName || '';
            /* handles all types of events*/
            handleEvent(eventName, true, $scope.onOk, eventParams);
        };
        this._CancelButtonHandler = function (eventName) {
            var eventParams;
            /*If "cancelParams" is a JSON string, then parse it. Else, pass it as is.*/
            if ($scope.cancelParams && $scope.cancelParams.indexOf("{") > -1) {
                eventParams = Utils.getValidJSON($scope.cancelParams);
            } else {
                eventParams = $scope.cancelParams;
            }
            eventName = eventName || '';
            /* handles all types of events*/
            handleEvent(eventName, true, $scope.onCancel, eventParams);
        };
        this._CloseButtonHandler = function (eventName) {
            eventName = eventName || '';
            /* handles all types of events*/
            handleEvent(eventName, true,  $scope.onClose);
        };
        this._OnOpenedHandler = function (eventName) {
            eventName = eventName || '';
            /* handles all types of events*/
            handleEvent(eventName, false, $scope.onOpened);
        };
    });
/*global wm, WM*/
/*jslint todo: true */
/*jslint sub: true */

/* "NotificationDialogController" is the controller for all notification dialogs. */

WM.module('wm.widgets.dialog')
    .controller('NotificationDialogController', ["$scope", "dialogParams", "Utils", function ($scope, dialogParams, Utils) {
        'use strict';
        $scope.notification = {};
        if (dialogParams.notificationDetails) {
            $scope.notification.text = dialogParams.notificationDetails.text;
            $scope.notification.okButtonText = dialogParams.notificationDetails.okButtonText || "OK";
            $scope.notification.cancelButtonText = dialogParams.notificationDetails.cancelButtonText || "CANCEL";
            $scope.notification.alerttype = dialogParams.notificationDetails.alerttype || "information";
        }
        /*called in case an onOk event is associated with the notification variable*/
        $scope.variableOnOk = function () {
            Utils.triggerFn(dialogParams.onOk);
        };
        /*called in case an onClose event is associated with the notification variable*/
        $scope.variableOnClose = function () {
            Utils.triggerFn(dialogParams.onClose);
        };
        /*called in case an onCancel event is associated with the notification variable*/
        $scope.variableOnCancel = function () {
            Utils.triggerFn(dialogParams.onCancel);
        };
    }]);

/*global WM, wmCoreModule, wmDialog, _*/
/*Directive for login dialog */

WM.module('wm.widgets.dialog')
    .run(["$templateCache", function ($templateCache) {
        "use strict";
        $templateCache.put("template/widget/dialog/logindialog.html",
                '<div class="app-dialog modal-dialog app-login-dialog"  data-ng-style="{width: width}" init-widget data-ng-show="show">' +
                    '<div class="modal-content" wmtransclude ></div>' +
                '</div>'
            );
        $templateCache.put("template/widget/dialog/logindialogcontainer.html", '<div wmtransclude></div>');

    }]).directive('wmLogindialog', ['PropertiesFactory', 'WidgetUtilService', "$templateCache", '$compile', 'CONSTANTS', function (PropertiesFactory, WidgetUtilService, $templateCache, $compile, CONSTANTS) {
        'use strict';
        var transcludedContent = "",
            id,
            widgetProps = PropertiesFactory.getPropertiesOf("wm.logindialog", ["wm.basicdialog", "wm.base", "wm.base.events.successerror"]);

        return {
            "restrict": "E",
            "transclude": (CONSTANTS.isStudioMode),
            "scope": {
                "dialogid": '@'
            },
            "template": function (template, attrs) {
                transcludedContent = template.html();
                /*to have script tag with name as id in run mode and to have div in studio to be able to style the dialog*/
                if (CONSTANTS.isRunMode) {
                    /* replacing wm-logindialog with wm-dialog-container in run mode to have a container for header, content and footer.
                     wm-dialog-container has a template similar to wm-dialog, replacing since wm-dialog returns script tag*/
                    var dialogEle = WM.element(template[0].outerHTML),
                        onsuccess = dialogEle.attr('on-success') || '',
                        onerror = dialogEle.attr('on-error') || '',
                        dialog = template[0].outerHTML.replace("<wm-logindialog ", "<wm-dialog-container class='app-login-dialog' ");
                    dialog = dialog.replace("</wm-logindialog>", "</wm-dialog-container>");
                    dialog = '<wm-logindialog-container on-success="' + onsuccess + '" on-error="' + onerror + '">' + dialog + '</wm-logindialog-container>';
                    transcludedContent = dialog;
                    id = attrs.name;
                    return '<script type="text/ng-template" id="' + id + '">' + transcludedContent + "</script>";
                }
                return $templateCache.get("template/widget/dialog/logindialog.html");
            },
            "replace": true,
            "compile": function () {
                return {
                    "pre": function (scope) {
                        scope.widgetProps = widgetProps;
                    },
                    "post": function (scope, element, attrs) {

                        if (CONSTANTS.isStudioMode) {
                            element.append($compile(transcludedContent)(scope));
                        }
                        scope = scope || element.isolateScope();
                        scope.header = element.find('[data-identifier=dialog-header]').isolateScope() || {};
                        scope.content = element.find('[data-identifier=dialog-content]').isolateScope() || {};
                        //Update the title and iconclass for the old login dialogs based on the parent container property set
                        if (attrs.title && !scope.header.caption) {
                            scope.header.caption = attrs.title;
                        }
                        if (attrs.iconclass && !scope.header.iconclass) {
                            scope.header.iconclass = attrs.iconclass;
                        }

                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]).directive('wmLogindialogContainer', ["$templateCache", "PropertiesFactory", "WidgetUtilService", "SecurityService", "BaseService", "Utils", "CONSTANTS", '$window', 'Variables', function ($templateCache, PropertiesFactory, WidgetUtilService, SecurityService, BaseService, Utils, CONSTANTS, $window, Variables) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf("wm.logindialog", ["wm.base"]);
        return {
            "restrict": "E",
            "transclude": true,
            "scope": {
                "dialogid": '@',
                "onSuccess": '&',
                "onError": '&'
            },
            "template": $templateCache.get("template/widget/dialog/logindialogcontainer.html"),
            "replace": true,
            "compile": function () {
                return {
                    "pre": function (scope) {
                        scope.widgetProps = widgetProps;
                    },
                    "post": function (scope, element, attrs) {
                        if (CONSTANTS.isRunMode) {
                            /*function to be called in case of login*/
                            scope.doLogin = function (event) {
                                scope.loginMessage = scope.$parent.loginMessage = null;
                                var curUser = element.find('[name="usernametext"]').val();
                                SecurityService.appLogin({
                                    username: curUser,
                                    password: element.find('[name="passwordtext"]').val()
                                }, function (response) {
                                    var redirectUrl = response && response.url ? response.url : 'index.html';
                                    if (CONSTANTS.hasCordova && _.includes(redirectUrl, '/')) {
                                        /*
                                         * when the application is running as a mobile application,
                                         * use the local app files instead of server files.
                                         */
                                        redirectUrl = redirectUrl.substr(redirectUrl.lastIndexOf('/') + 1);
                                    }
                                    scope.$root.isUserAuthenticated = true;
                                    element.trigger("success");
                                    /*setting the received redirect url for the logged-in user's landing page configuration to the
                                    * current scope to be propagated to the common login dialog success handler*/
                                    scope.redirectUrl = redirectUrl;
                                    /* if a different user logs in than the last logged in user, redirect to his landing page */
                                    if (SecurityService.getLastLoggedInUser() !== curUser) {
                                        $window.location = $window.location.pathname;
                                    }
                                    scope.onSuccess({$event: event, $scope: scope});
                                    scope.$root.$emit("update-loggedin-user");
                                    BaseService.executeErrorCallStack();
                                }, function (error) {
                                    scope.loginMessage = scope.$parent.loginMessage = {
                                        type: 'error',
                                        caption: scope.errormessage || error
                                    };
                                    element.trigger("error");
                                    scope.onError({$event: event, $scope: scope});
                                });
                            };
                            var loginbutton = element.find('.app-button[name="loginbutton"]');
                            /*to remove the on-click event handler*/
                            loginbutton.unbind('click');
                            /*bind sign-in functionality to the sign-in button*/
                            loginbutton.click(scope.doLogin.bind(null));
                            /*bind sign-in functionality to the sign-in button*/
                            element.find('.app-textbox').keypress(function (evt) {
                                evt.stopPropagation();
                                /*Trigger the action to "doLogin" if the "enter" key has been pressed.*/
                                if (Utils.getActionFromKey(evt) === "ENTER") {
                                    scope.doLogin(evt);
                                }
                            });
                        }

                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.widgets.dialog.directive:wmLogindialog
 * @restrict E
 *
 * @description
 * The `wmLogindialog` directive defines login dialog widget. <br>
 * An login dialog is created in an independent view.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 * @requires $templateCache
 * @requires CONSTANTS
 *
 * @param {string=} name
 *                  Name of the dialog.
 * @param {string=} title
 *                  title of the dialog.
 * @param {string=} width
 *                  Width of the dialog.
 * @param {boolean=} show
 *                  show is a bindable property. <br>
 *                  This property will be used to show/hide the dialog on the web page. <br>
 *                  Default value: `true`.
 * @param {string=} iconclass
 *                  Icon class for the icon in dialog header
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl">
                <wm-view class="dialog-view">
                    <wm-logindialog modal="false" iconclass="glyphicon glyphicon-log-in" title="Login" name="loginDialog" on-error="logindialog1Error($event, $scope)" on-success="logindialog1Success($event, $scope)">
                        <wm-dialogheader></wm-dialogheader>
                        <wm-dialogcontent>
                            <wm-form>
                                <wm-message type="error" caption="{{errMsg}}" show="{{showErrMsg}}" class="app-logindialog-message" hide-close="true"></wm-message>
                                <wm-composite>
                                    <wm-label caption="Username" class="col-md-4"></wm-label>
                                    <wm-text placeholder="Enter username" class="app-logindialog-username"></wm-text>
                                </wm-composite>
                                <wm-composite widget="text">
                                    <wm-label caption="Password" class="col-md-4"></wm-label>
                                    <wm-text type="password" placeholder="Enter password" class="app-logindialog-password"></wm-text>
                                </wm-composite>
                            </wm-form>
                        </wm-dialogcontent>
                        <wm-dialogactions>
                            <wm-button class="btn-primary" caption="Sign in"></wm-button>
                        </wm-dialogactions>
                    </wm-logindialog>
                </wm-view>
                <wm-button on-click="loginDialog.show" caption="Show Dialog" class="btn-primary"></wm-button>
            </div>
        </file>
        <file name="script.js">
            function Ctrl($scope) {}
            function loginDialogController() {}
        </file>
    </example>
 */

/*global WM, wm, wmCoreModule*/
/*jslint todo: true */
/*
 Extends the popup directive for HTML capabilities inside the popup.
 */
WM.module('ui.bootstrap.popover')

    /**
     * The $wmPopup service creates tooltip- and popup-like directives as well as
     * houses global options for them.
     */
    .provider('$wmPopup', function () {
        'use strict';
        /*The default options tooltip and popup.*/
        var defaultOptions = {
            placement: 'bottom',
            animation: true,
            popupDelay: 0,
            autoClose: true,
            arrow: false,
            isText: false
        }, triggerMap = {
            'mouseenter': 'mouseleave',
            'click': 'click',
            'focus': 'blur'
        }, globalOptions = {}, popupRegistry = [];

        /**
         * `options({})` allows global configuration of all tooltips in the
         * application.
         *
         *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $wmPopupProvider ) {
         *     place tooltips left instead of top by default
         *     $wmPopupProvider.options( { placement: 'left' } );
         *   });
         */
        this.options = function (value) {
            WM.extend(globalOptions, value);
        };

        /**
         * This allows you to extend the set of trigger mappings available. E.g.:
         *
         *   $wmPopupProvider.setTriggers( 'openTrigger': 'closeTrigger' );
         */
        this.setTriggers = function setTriggers(triggers) {
            WM.extend(triggerMap, triggers);
        };

        /**
         * Returns the actual instance of the $wmPopup service.
         * TODO support multiple triggers
         */
        this.$get = [ '$compile', '$timeout', '$parse', '$document', '$position', '$interpolate', 'Utils', function ($compile, $timeout, $parse, $document, $position, $interpolate, Utils) {
            return function $wmPopup(type, prefix, defaultTriggerShow) {
                var options = WM.extend({}, defaultOptions, globalOptions), directiveName, triggers, startSym,
                    endSym, directiveTemplate;

                function setTriggers(trigger) {
                    var show, hide;
                    show = trigger || options.trigger || defaultTriggerShow;
                    if (options.trigger) {
                        hide = triggerMap[options.trigger] || show;
                    } else {
                        hide = triggerMap[show] || show;
                    }

                    return {
                        show: show,
                        hide: hide
                    };
                }

                /* hide all opened popups */
                function hideAllPopups() {
                    var i, popupCount = popupRegistry.length, currPopup, currPopupScope;
                    for (i = 0; i < popupCount; i += 1) {
                        currPopup = popupRegistry[i];
                        currPopupScope = currPopup.isolateScope();
                        if (currPopupScope.isOpen && currPopupScope.autoClose !== 'false') {
                            currPopupScope.hidePopup();
                        }
                    }
                }

                $document.find('body').on('click', function (event) {
                    hideAllPopups();
                });

                directiveName = Utils.hyphenate(type);
                triggers = setTriggers(undefined);
                startSym = $interpolate.startSymbol();
                endSym = $interpolate.endSymbol();
                directiveTemplate =
                    '<' + directiveName + '-window ' +
                    'content="' + startSym + 'popup_content' + endSym + '" ' +
                    'style-class="' + startSym + 'popup_style_class' + endSym + '"' +
                    'placement="' + startSym + 'popup_placement' + endSym + '" ' +
                    'auto-close="popup_autoClose" ' +
                    'identifier="' + startSym + 'popup_identifier' + endSym + '" ' +
                    'animation="popup_animation()" ' +
                    'arrow="popup_arrow()" ' +
                    'is-text="popup_isText()" ' +
                    'is-open="popup_isOpen"' +
                    '>' +
                    '</' + directiveName + '-window>';
                return {
                    restrict: 'EA',
                    scope: true,
                    link: function link(scope, element, attrs) {
                        var tooltip = $compile(directiveTemplate)(scope), isTooltipExist = false,
                            transitionTimeout, popupTimeout, $body,
                            appendToBody = options.appendToBody || false;

                        /*Show the tooltip popup element.*/
                        function show() {
                            var position, popupWidth, popupHeight, popupPosition, mousePos, tooltipScope;

                            /* hide previously opened popups */
                            hideAllPopups();

                            /*Don't show empty tooltips.*/
                            if (!scope.popup_content) {
                                return;
                            }

                            /*If there is a pending remove transition, we must cancel it, lest the
                             tooltip be mysteriously removed.*/
                            if (transitionTimeout) {
                                $timeout.cancel(transitionTimeout);
                            }

                            /*Set the initial positioning.*/
                            tooltip.css({ top: 0, left: 0, display: 'block' });

                            if (!isTooltipExist) {
                                if (appendToBody) {
                                    $body = $body || $document.find('body');
                                    $body.append(tooltip);
                                } else {
                                    element.after(tooltip);
                                }
                            }

                            /*Get the position of the directive element.*/
                            position = options.appendToBody ? $position.offset(element) : $position.position(element);

                            /*Get the height and width of the tooltip so we can center it.*/
                            popupWidth = tooltip.prop('offsetWidth');
                            popupHeight = tooltip.prop('offsetHeight');

                            /*Calculate the tooltip's top and left coordinates to center it with
                             this directive.*/
                            switch (scope.popup_placement) {
                            case 'mouse':
                                mousePos = $position.mouse();
                                popupPosition = {
                                    top: mousePos.y,
                                    left: mousePos.x
                                };
                                break;
                            case 'right':
                                popupPosition = {
                                    top: position.top + position.height / 2 - popupHeight / 2,
                                    left: position.left + position.width
                                };
                                break;
                            case 'bottom':
                                popupPosition = {
                                    top: position.top + position.height,
                                    left: position.left + position.width / 2 - popupWidth / 2
                                };
                                break;
                            case 'left':
                                popupPosition = {
                                    top: position.top + position.height / 2 - popupHeight / 2,
                                    left: position.left - popupWidth
                                };
                                break;
                            default:
                                popupPosition = {
                                    top: position.top - popupHeight,
                                    left: position.left + position.width / 2 - popupWidth / 2
                                };
                                break;
                            }

                            popupPosition.top += 'px';
                            popupPosition.left += 'px';

                            /*Now set the calculated positioning.*/
                            tooltip.css(popupPosition);

                            /*And show the tooltip.*/
                            scope.popup_isOpen = true;

                            /* to enable custom controller code */

                            tooltipScope = tooltip.isolateScope();
                            if (tooltipScope && WM.isFunction(tooltipScope.showCallBack)) {
                                tooltipScope.showCallBack();
                            }
                        }

                        /*Hide the tooltip popup element.*/
                        function hide() {
                            /*First things first: we don't show it anymore.*/
                            scope.popup_isOpen = false;
                            tooltip.css('display', 'none');

                            /*if tooltip is going to be shown after delay, we must cancel this*/
                            $timeout.cancel(popupTimeout);

                            /* to enable custom controller code */
                            var tooltipScope = tooltip.isolateScope();
                            if (tooltipScope && WM.isFunction(tooltipScope.hideCallBack)) {
                                tooltipScope.hideCallBack();
                            }
                        }

                        /*Show the tooltip with delay if specified, otherwise show it immediately*/
                        function showTooltipBind(event) {
                            if (scope.popup_popupDelay) {
                                popupTimeout = $timeout(show, scope.popup_popupDelay);
                            } else {
                                scope.$apply(show);
                            }
                            event.stopPropagation();
                        }

                        function hideTooltipBind(event) {
                            scope.$apply(function () {
                                hide();
                            });
                            event.stopPropagation();
                        }

                        scope.hide = function () {
                            scope.$apply(function () {
                                hide();
                            });
                        };
                        tooltip.isolateScope().hidePopup = function () {
                            hide();
                        };
                        /*By default, the tooltip is not open.
                         TODO add ability to start tooltip opened*/
                        scope.popup_isOpen = false;

                        function toggleTooltipBind(event) {
                            if (!scope.popup_isOpen) {
                                showTooltipBind(event);
                            } else {
                                hideTooltipBind(event);
                            }
                        }

                        attrs.$observe(type, function (val) {
                            scope.popup_content = val;
                        });

                        // setup default popup placement
                        scope.popup_placement = options.placement;
                        attrs.$observe(prefix + 'Placement', function (val) {
                            scope.popup_placement = val ? val.trim() : options.placement;
                        });

                        // setup default popup style class
                        scope.popup_style_class = options.styleClass;
                        attrs.$observe(prefix + 'StyleClass', function (val) {
                            scope.popup_style_class = val ? val.trim() : options.styleClass;
                        });

                        // setup default popup auto close
                        scope.popup_autoClose = options.autoClose;
                        attrs.$observe(prefix + 'AutoClose', function (val) {
                            scope.popup_autoClose = val ? val.trim() : options.autoClose;
                        });

                        // setup default popup identifier
                        scope.popup_identifier = ('popup' + scope.$id);
                        attrs.$observe(prefix + 'Identifier', function (val) {
                            scope.popup_identifier = val ? val.trim() : ('popup' + scope.$id);
                        });

                        function default_animation() {
                            return options.animation;
                        }
                        // setup default popup animation
                        scope.popup_animation = default_animation;
                        attrs.$observe(prefix + 'Animation', function (val) {
                            scope.popup_animation = val ? $parse(val) : default_animation;
                        });

                        function default_arrow() {
                            return options.arrow;
                        }
                        // setup default popup Arrow
                        scope.popup_arrow = default_arrow;
                        attrs.$observe(prefix + 'Arrow', function (val) {
                            scope.popup_arrow = val ? $parse(val) : default_arrow;
                        });

                        function default_isText() {
                            return options.isText;
                        }
                        // setup default isText
                        scope.popup_isText = default_isText;
                        attrs.$observe(prefix + 'IsText', function (val) {
                            scope.popup_isText = val ? $parse(val) : default_isText;
                        });

                        // setup default popup delay
                        scope.popup_popupDelay = options.popupDelay;
                        attrs.$observe(prefix + 'PopupDelay', function (val) {
                            var delay = parseInt(val, 10);
                            scope.popup_popupDelay = !isNaN(delay) ? delay : options.popupDelay;
                        });

                        function update_triggers(val) {
                            triggers = setTriggers(val);

                            if (triggers.show === triggers.hide) {
                                element.bind(triggers.show, function (event) {
                                    toggleTooltipBind(event);
                                });
                            } else {
                                element.bind(triggers.show, function (event) {
                                    showTooltipBind(event);
                                });
                                element.bind(triggers.hide, function (event) {
                                    hideTooltipBind(event);
                                });
                            }
                        }
                        if (attrs.hasOwnProperty('wmPopupTrigger')) {
                            attrs.$observe(prefix + 'Trigger', function (val) {
                                /* This code is preventing custom click handlers to be attached with buttons */
                                /*element.unbind(triggers.show);
                                 element.unbind(triggers.hide);*/

                                update_triggers(val);
                            });
                        } else {
                            update_triggers();
                        }

                        attrs.$observe(prefix + 'AppendToBody', function (val) {
                            appendToBody = val ? $parse(val)(scope) : appendToBody;
                        });

                        /* if a tooltip is attached to <body> we need to remove it on
                         location change as its parent scope will probably not be destroyed
                         by the change.*/
                        if (appendToBody) {
                            scope.$on('$locationChangeSuccess', function closeTooltipOnLocationChangeSuccess() {
                                if (scope.popup_isOpen) {
                                    hide();
                                }
                            });
                        }

                        /* Make sure tooltip is destroyed and removed.*/
                        scope.$on('$destroy', function onDestroyTooltip() {
                            if (scope.popup_isOpen) {
                                hide();
                            } else {
                                tooltip.remove();
                            }
                        });
                        /* Flushing popup registry to remove stale popups */
                        scope.$on('$routeChangeStart', function () {
                            popupRegistry.length = 0;
                        });

                        /* Pushing popovers into registry */
                        popupRegistry.push(tooltip);
                    }
                };
            };
        }];
    })

    /**
     * @ngdoc directive
     * @name wm.widgets.directive:wmPopupWindow
     * @restrict E
     * @description
     * The `wmPopupWindow` directive creates a popup window. Used internally by $wmPopupProvider.
     * @param {url} content Sets the content to be displayed inside the popup
     * @param {string} placement Position of popup, possible values: 'top', 'bottom', 'left', 'right', 'mouse'; default 'bottom'
     * @param {boolean} arrow Tells whether arrow should be displayed over the popup or not, default 'false'
     * @param {boolean} auto-close Tells whether popup should get closed when other popups are opened or clicked outside, default 'true'
     * @param {string} identifier Assigns an identifier to popup otherwise default value is assigned
     * @example
     <doc:example>
     <doc:source>
        <wm-popup-window content="URL"
            placement="top" arrow="true"
            animation="true" identifier="my_popup">
     </wm-popup-window>
     </doc:source>
     <doc:scenario>
     it('should check wm-popup-window', function() {
     });
     </doc:scenario>
     </doc:example>
     */
    .directive('wmPopupWindow', function () {
        'use strict';

        var getPopupTemplate = function () {
            return '<div class="popover {{placement}} {{styleClass}}" data-ng-class="{ in: isOpen, fade: animation() }">' +
                '<div data-ng-class="{ arrow: arrow() }"></div>' +
                '<div class="alert {{alertClass}}" data-ng-show="showAlert">{{statusMsg}}</div>' +
                '<div class="popover-inner">' +
                ' <div ng-switch on="isText()">' +
                '  <div ng-switch-when="true">' +
                '   <div class="popover-content" data-ng-bind="content"></div>' +
                '  </div>' +
                '  <div ng-switch-default>' +
                '   <div class="popover-content" data-ng-include="content"></div>' +
                '  </div>' +
                ' </div>' +
                '</div>' +
                '</div>' +
                '</div>';
        };

        return {
            restrict: 'E',
            replace: true,
            controller: 'PopupController',
            scope: { content: '@', styleClass: '@', placement: '@', animation: '&', isOpen: '=', arrow: '&', autoClose: '=', identifier: '@', isText: '&' },
            template: getPopupTemplate(),
            link: function (scope, element) {
                element.bind('click', function (event) {
                    event.stopPropagation();
                });
            }
        };
    })

    /**
     * @ngdoc directive
     * @name wm.widgets.directive:wmPopup
     * @restrict EA
     * @description
     * The `wm-popup` attribute directive creates a popup window for that particular element on click.
     * @param {url} value Sets the content to be displayed inside the popup
     * @param {string} popup-placement Position of popup, possible values: 'top', 'bottom', 'left', 'right', 'mouse'; default 'bottom'
     * @param {boolean} popup-arrow Tells whether arrow should be displayed over the popup or not, default 'false'
     * @param {boolean} popup-auto-close Tells whether popup should get closed when other popups are opened or clicked outside, default 'true'
     * @param {string} popup-identifier Assigns an identifier to popup otherwise default value is assigned
     * @example
     <doc:example>
     <doc:source>
     <div class="wm-studio-button"
         wm-popup="URL"
         popup-placement="bottom"
         popup-identifier="my_popover"
         popup-arrow="false"
         popup-auto-close="true">
     </div>
     </doc:source>
     <doc:scenario>
     it('should check wm-popup-window', function() {
         });
     </doc:scenario>
     </doc:example>
     */
    .directive('wmPopup', ['$wmPopup', function ($wmPopup) {
        'use strict';
        return $wmPopup('wmPopup', 'wmPopup', 'click');
    }]);
/*global WM, wmDialog*/
/*jslint sub:true*/

/**
 * @ngdoc service
 * @name wm.widgets.dialog.DialogService
 * @description
 * The `DialogService` provides methods for showing and hiding dialogs of a particular id.
 */

/*
 $uibModal injected to open the dialog using $uibModal.open
 $rootScope injected to maintain the default value for scope to be passed $uibModal.open
 */
WM.module('wm.widgets.dialog')
    .service('DialogService', ['$rootScope', '$uibModal', 'CONSTANTS', '$uibModalStack', function ($rootScope, $uibModal, CONSTANTS, $uibModalStack) {
        'use strict';

        /*
         keep track of all the dialog instances that got opened.
         remove from $uibModalInstances when a dialog is closed using hideDialog
         */
        var $uibModalInstances = {},
        /*dialogId is the id of the dialog to be opened
         and params is a key value pair with values for resolve, scope, windowClass that are required as options in $uibModal
         */
            openDialogIds = [];

        /**
         * @deprecated
         * @ngdoc function
         * @name wm.widgets.dialog.DialogService#showDialog
         * @methodOf wm.widgets.dialog.DialogService
         * @function
         *
         * @description
         * shows a dialog with a particular id
         * <div class="alert alert-danger">
         * [DEPRECATED] -- Use DialogService.open method instead.
         * </div>
         *
         * @param {string} dialogId id of the dialog to be opened
         * @param {object} params for the dialog
         */
        function showDialog(dialogId, params) {

            /* id must be provided to open the dialog*/
            if (!dialogId || ($uibModalInstances && $uibModalInstances[dialogId])) {
                return;
            }
            var template = WM.element("script[id=" + dialogId + "]"),
                controller = template.attr('controller'),
                content = template.html(),
                backdrop,
                keyboard,
                windowClass,

            /* convert the content to DOM (uncompiled version) , it will be easy to add attributes*/
                dialogContainer = WM.element("<div></div>").html(content),
                modal;

            modal = template.attr('modal');
            /*
             Modal : True => Backdrop : Static
             Modal : False => Backdrop : True
             */
            if (modal === 'true') {
                backdrop = 'static';
            } else {
                backdrop = true;
            }
            keyboard = template.attr('keyboard');
            /* to change original keyboard value(which is string) to boolean because $uibModal.open expects boolean */
            keyboard = keyboard !== 'false';
            /* in case no params are passed, creating an empty object*/
            if (!params) {
                params = {};
            }

            /* to apply the class to modal div added by bootstrap*/
            windowClass = dialogContainer.find("wm-dialog, wm-alertdialog, wm-confirmdialog, wm-pagedialog, wm-iframedialog, wm-logindialog").attr('dialogclass');
            /* to apply dialogclass and theme class (which gets applied to parent view) to modal dialog div*/
            if (!windowClass) {
                windowClass = (dialogContainer.find("wm-dialog-container").attr('dialogclass') || "") + (template.parent().attr("theme") || "") + " default";
            }
            /*
             setting the id and controller values.
             id to be used for closing the dialog by default close button in the dialog and support close if multiple dialogs are opened.
             controller value to be used later.
             */

            dialogContainer.find('wm-dialog, wm-dialog-container, wm-alertdialog, wm-confirmdialog, wm-pagedialog, wm-iframedialog, wm-logindialog').
                attr({
                    'controller': controller,
                    'dialogid': dialogId
                });
            content = dialogContainer.html();
            dialogContainer = null;
            /* dialogContainer will be eligible for GC */

            $uibModalInstances[dialogId] = $uibModal.open({
                template: content,
                controller: controller || dialogId + "Controller",
                backdrop: backdrop,
                keyboard: keyboard,
                windowTemplateUrl: "template/widget/dialog/dialog-template.html",
                resolve: params.resolve || null,
                scope: params.scope || (CONSTANTS.isStudioMode ? $rootScope : WM.element("[data-ng-controller='AppController']").scope()),
                windowClass: windowClass || params.windowClass || ""
            });

            $uibModalInstances[dialogId].result.then(null,
                /* called when dialog closes on backdrop click*/
                function () {
                    // destroy the scope of the dialog
                    if ($uibModalInstances[dialogId].scope) {
                        $uibModalInstances[dialogId].scope.$destroy();
                    }
                    $uibModalInstances[dialogId] = null;
                });

            // save a reference to the scope which with dialog got compiled.
            $uibModalInstances[dialogId].opened.then(function () {
                var dialogCtrlScope = $uibModalStack.getTop().value.modalScope;
                if (params._props) {
                    WM.extend(dialogCtrlScope, params._props);
                }
                $uibModalInstances[dialogId].scope = dialogCtrlScope;

                if (WM.isFunction(params.onOpen)) {
                    params.onOpen($uibModalInstances[dialogId].scope);
                }
            });

            openDialogIds.push(dialogId);
        }


        /* close specific open dialog using dialog ID*/
        function _closeDialog(dialogId) {
            var dialogRef = openDialogIds.indexOf(dialogId);
            if (dialogRef !== -1) {
                openDialogIds.splice(dialogRef, 1);
            }
        }
        /**
         * @deprecated
         * @ngdoc function
         * @name wm.widgets.dialog.DialogService#hideDialog
         * @methodOf wm.widgets.dialog.DialogService
         * @function
         *
         * @description
         * hides a dialog with a particular id
         * <div class="alert alert-danger">
         * [DEPRECATED] -- Use DialogService.close method instead.
         * </div>
         *
         * @param {string} dialogId id of the dialog to be closed
         */
        function hideDialog(dialogId) { /* to close the dialog, hideDialog MUST be used*/

            /* id must be provided to close the dialog*/
            if (!dialogId || ($uibModalInstances && !$uibModalInstances[dialogId])) {
                return;
            }
            $uibModalInstances[dialogId].close();
            // destroy the scope of the dialog
            if ($uibModalInstances[dialogId].scope) {
                $uibModalInstances[dialogId].scope.$destroy();
            }
            $uibModalInstances[dialogId] = null;
            /* to pop the dialog id from the openDialogIds array */
            _closeDialog(dialogId);
        }

        /**
         * @ngdoc function
         * @name wm.widgets.dialog.DialogService#showConfirmDialog
         * @methodOf wm.widgets.dialog.DialogService
         * @function
         *
         * @description
         * shows Confirm Dialog and sets it parameters
         *
         * @param {object} params required for confirm dialog(oktext, canceltext, callbacks, message, icon)
         */

        function showConfirmDialog(params) {

            var dialogId = "global-confirm-dialog",
                template,
                controller,
                content,
                backdrop,
                keyboard,
                windowClass,
                dialogCaption,
                dialogContainer,
                confirmDialog;

            /* id must be provided to open the dialog*/
            if ($uibModalInstances && $uibModalInstances[dialogId]) {
                return;
            }
            template = WM.element("script[id=" + dialogId + "]");
            controller = params.controller;
            content = template.html();

            /* convert the content to DOM (uncompiled version) , it will be easy to add attributes*/
            dialogContainer = WM.element("<div></div>").html(content);

            dialogCaption = $rootScope.locale[params.caption] || params.caption;
            backdrop = params.backdrop || template.attr('backdrop');
            /* backdrop expects 3 values from {true, false, static}*/
            if (backdrop !== 'static') {
                if (backdrop === 'false') {
                    /* to change original backdrop value(which is string) to boolean because $uibModal.open expects boolean or 'static' */
                    backdrop = false;
                } else if (backdrop === 'true' || backdrop === 'undefined') {
                    /* to maintain the default value as maintained by bootstrap modal */
                    backdrop = true;
                }
            }
            keyboard = params.keyboard || template.attr('keyboard');
            if (keyboard === 'false') {
                /* to change original keyboard value(which is string) to boolean because $uibModal.open expects boolean */
                keyboard = false;
            } else if (keyboard === 'true' || keyboard === 'undefined') {
                /* to maintain the default value as maintained by bootstrap modal */
                keyboard = true;
            }
            /* in case no params are passed, creating an empty object*/
            if (!params) {
                params = {};
            }
            /* to apply the class to modal div added by bootstrap*/

            windowClass = dialogContainer.find("wm-confirmdialog").attr('dialogclass');
            /* to apply dialogclass and theme class (which gets applied to parent view) to modal dialog div*/
            if (!windowClass) {
                windowClass = (dialogContainer.find("wm-dialog-container").attr('dialogclass') || "") + (template.parent().attr("theme") || "") + " default";
            }
            /*
             setting the id and controller values.
             id to be used for closing the dialog by default close button in the dialog and support close if multiple dialogs are opened.
             controller value to be used later.
             */
            confirmDialog = dialogContainer.find('wm-confirmdialog');
            confirmDialog.
                attr({
                    'controller': controller,
                    'dialogid': dialogId,
                    'title': dialogCaption,
                    'message': $rootScope.locale[params.content] || params.content,
                    'messageclass': params.contentClass || '',
                    'iconname': params.iconName || '',
                    'iconclass': params.iconClass || '',
                    'oktext': params.oktext || $rootScope.locale["LABEL_OK"],
                    'canceltext': params.canceltext || $rootScope.locale["LABEL_CANCEL"]
                });

            if (params.onOk) {
                confirmDialog.attr('on-ok', params.onOk);
            }
            if (params.onCancel) {
                confirmDialog.attr('on-cancel', params.onCancel);
            }
            if (params.onClose) {
                confirmDialog.attr('on-close', params.onClose);
            }

            if (params.okParams) {
                confirmDialog.attr('ok-params', params.okParams);
            }
            if (params.cancelParams) {
                confirmDialog.attr('cancel-params', params.cancelParams);
            }

            content = dialogContainer.html();
            dialogContainer = null;
            /* dialogContainer will be eligible for GC */

            $uibModalInstances[dialogId] = $uibModal.open({
                template: content,
                controller: controller || dialogId + "Controller",
                backdrop: backdrop,
                keyboard: keyboard,
                resolve: params.resolve || null,
                scope: params.scope || $rootScope,
                windowClass: windowClass || params.windowClass || "",
                windowTemplateUrl: "template/widget/dialog/dialog-template.html"
            });

            $uibModalInstances[dialogId].result.then(null,
                /* called when dialog closes on backdrop click*/
                function () {
                    $uibModalInstances[dialogId] = null;
                });

            // save a reference to the scope which with dialog got compiled.
            $uibModalInstances[dialogId].opened.then(function () {
                $uibModalInstances[dialogId].scope = $uibModalStack.getTop().value.modalScope;
            });
            openDialogIds.push(dialogId);
        }
        /**
         * @ngdoc function
         * @name wm.widgets.dialog.DialogService#closeAllDialogs
         * @methodOf wm.widgets.dialog.DialogService
         * @function
         *
         * @description
         * hides all dialogs open at a time
         */
        /* close all opened dialogs */
        function closeAllDialogs() {
            var index;
            for (index = 0; index < openDialogIds.length; index += 1) {
                hideDialog(openDialogIds[index]);
            }
        }

        /**
         * @ngdoc function
         * @name wm.widgets.dialog.DialogService#open
         * @methodOf wm.widgets.dialog.DialogService
         * @function
         *
         * @description
         * shows a dialog with a particular id <br>
         * Example:
         * ```js
         *     // controller of the page
         *     function PageController($scope) {
         *          // click event handler for the button on which the dialog needs to be opened.
         *          function btnClickHandler() {
         *              DialogService.open('userDetailsDialog', $scope, {key1: 'value1', key2: 'value2'});
         *          }
         *     }
         *
         *     function DialogController($scope) {
         *          // DialogController's scope extends the scope[2nd argument]
         *          // We will be able to access the properties[3rd argument] on the DialogController's scope.
         *          // console.log($scope.key1) // prints `value1`
         *          // console.log($scope.key2) // prints `value2`
         *     }
         * ```
         *
         * @param {string} dialogId id of the dialog to be opened
         * @param {object} [parentScope] scope with which dialog controller's scope needs to be extended. <br>
         *                 If the scope is not provided, $rootScope is extended.
         * @param {object} [properties] properties that are to be defined on the dialog controller's scope.
         *
         */
        function open(dialogId, parentScope, properties) {
            var obj = {
                'scope': parentScope,
                '_props': properties
            };
            showDialog(dialogId, obj);
        }

        /**
         * @ngdoc function
         * @name wm.widgets.dialog.DialogService#close
         * @methodOf wm.widgets.dialog.DialogService
         * @function
         *
         * @description
         * close/hide a dialog with a particular id
         *
         * @param {string} dialogId id of the dialog to be closed
         */

        this.open = open;
        this.close = hideDialog;
        this.hideDialog = hideDialog;
        this.showDialog = showDialog;
        this.showConfirmDialog = showConfirmDialog;
        this.closeAllDialogs = closeAllDialogs;
    }]);
/*global WM */
/*Directive for button */

WM.module('wm.widgets.form')
    .run(['$templateCache', function ($templateCache) {
        'use strict';

        $templateCache.put('template/widget/form/button.html',
            '<button class="btn app-button" init-widget title="{{hint}}" apply-styles data-ng-disabled="disabled" data-ng-show="show" role="input" accesskey="{{shortcutkey}}">' +
                '<img data-identifier="img" class="button-image-icon" data-ng-src="{{iconsrc}}"  data-ng-if="showimage" data-ng-style="{width:iconwidth ,height:iconheight, margin:iconmargin}"/>' +
                '<i class="app-icon {{iconclass}}" data-ng-style="{width:iconwidth, height:iconheight, margin:iconmargin, fontSize:iconwidth}" data-ng-if="showicon"></i> ' +
                '<span class="btn-caption"></span>' +
                '<span data-ng-if="badgevalue" class="badge pull-right">{{badgevalue}}</span>' +
            '</button>'
            );
    }])
    .directive('wmButton', ['PropertiesFactory', 'WidgetUtilService', '$sce', 'Utils', function (PropertiesFactory, WidgetUtilService, $sce, Utils) {
        'use strict';

        var widgetProps = PropertiesFactory.getPropertiesOf('wm.button', ['wm.base', 'wm.base.editors', 'wm.base.events', 'wm.base.events.focus', 'wm.base.events.keyboard']),
            notifyFor = {
                'iconclass': true,
                'iconurl': true,
                'caption': true,
                'iconposition': true
            };

        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
        function propertyChangeHandler(scope, element, key, newVal) {
            switch (key) {
            case 'iconposition':
                element.attr('icon-position', newVal);
                break;
            case 'iconclass':
                /*showing icon when iconurl is not set*/
                scope.showicon = scope.iconclass !== '_none_' && newVal !== '' && !scope.iconurl;
                break;
            case 'iconurl':
                /*hiding icon when iconurl is set*/
                /*showing icon when iconurl is not set*/
                var showIcon = newVal === '';
                scope.showicon = showIcon;
                scope.showimage = !showIcon;
                scope.iconsrc = Utils.getImageUrl(newVal);
                break;
            case 'caption':
                if (WM.isObject(newVal)) {
                    element.children('.btn-caption').text(JSON.stringify(newVal));
                } else {
                    element.children('.btn-caption').html(($sce.trustAs($sce.HTML, newVal.toString()).toString()));
                }
                break;
            }
        }

        return {
            'restrict': 'E',
            'replace': true,
            'scope': {},
            'template': WidgetUtilService.getPreparedTemplate.bind(undefined, 'template/widget/form/button.html'),
            'compile': function (tElement) {
                return {
                    'pre': function (scope, element, attrs) {
                        //@Deprecated iconname; use iconclass instead
                        if (!attrs.iconclass && attrs.iconname) {
                            WM.element(tElement.context).attr('iconclass', 'glyphicon glyphicon-' + attrs.iconname);
                            attrs.iconclass = 'glyphicon glyphicon-' + attrs.iconname;
                        }
                        /*Applying widget properties to directive scope*/
                        scope.widgetProps = widgetProps;
                    },
                    'post': function (scope, element, attrs) {
                        WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, scope, element), scope, notifyFor);

                        /*Called from form reset when users clicks on form reset*/
                        scope.reset = function () {
                            //TODO implement custom reset logic here
                        };

                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.widgets.form.directive:wmButton
 * @restrict E
 *
 * @description
 * The `wmButton` directive defines the button widget.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 * @requires $sce
 *
 * @param {string=} caption
 *                  This property specifies the label of the button. <br>
 *                  This property is bindable.
 * @param {string=} badgevalue
 *                  This Property specifies inline Value to be displayed along with the label of the button. <br>
 *                  This property is bindable.
 * @param {string=} name
 *                  Name of the button widget.
 * @param {string=} type
 *                  Type of the button widget. <br>
 *                  valid value is: button/submit/reset <br>
 *                  Default value: `button`
 * @param {string=} hint
 *                  Title/hint for the button. <br>
 *                  This property is bindable.
 * @param {number=} tabindex
 *                  This property specifies the tab order of the Button Widget. <br>
 * @param {string=} width
 *                  Width of the button.
 * @param {string=} height
 *                  Height of the button.
 * @param {boolean=} show
 *                  Show is a bindable property. <br>
 *                  This property will be used to show/hide the button widget on the web page. <br>
 *                  Default value: `true`. <br>
 * @param {boolean=} disabled
 *                  Disabled is a bindable property. <br>
 *                  This property will be used to disable/enable the button widget on the web page. <br>
 *                  Default value: `false`. <br>
 * @param {string=} animation
 *                  This property controls the animation of Button widget. <br>
 *                  The animation is based on the css classes and works only in the run mode. <br>
 *                  possible values are "bounce", "flash", "pulse", "rubberBand", "shake" etc.
 * @param {string=} iconclass
 *                  CSS class of the icon.
 * @param {string=} iconurl
 *                  url of the icon.
 * @param {string=} iconwidth
 *                  width of the icon.
 *                  Default value: 16px
 * @param {string=} iconheight
 *                  height of the icon.
 *                  Default value: 16px
 * @param {string=} iconmargin
 *                  margin of the icon.
 * @param {string=} on-focus
 *                  Callback function which will be triggered when the widget gets focused.
 * @param {string=} on-blur
 *                  Callback function which will be triggered when the widget loses focus.
 * @param {string=} on-click
 *                  Callback function which will be triggered when the widget is clicked.
 * @param {string=} on-dblclick
 *                  Callback function which will be triggered when the widget is double clicked.
 * @param {string=} on-mouseenter
 *                  Callback function which will be triggered when the mouse enters the widget.
 * @param {string=} on-mouseleave
 *                  Callback function which will be triggered when the mouse leaves the widget.
 .
 * @example
 *   <example module="wmCore">
 *       <file name="index.html">
 *           <div data-ng-controller="Ctrl" class="wm-app">
 *               <div>single click count: {{clickCount}}</div>
 *               <div>dbl click count: {{dblclickCount}}</div>
 *               <div>mouse enter count: {{mouseenterCount}}</div>
 *               <div>mouse leave count: {{mouseleaveCount}}</div>
 *               <div>focus count: {{focusCount}}</div>
 *               <div>blur count: {{blurCount}}</div>
 *               <wm-button
 *                   caption="{{caption}}"
 *                   hint="hint/title for button"
 *                   on-click="f('click');"
 *                   on-dblclick="f('dblclick');"
 *                   on-focus="f('focus');"
 *                   on-blur="f('blur');"
 *                   on-mouseenter="f('mouseenter');"
 *                   on-mouseleave="f('mouseleave')"
 *                   width="{{width}}"
 *                   height="{{height}}"
 *                   color="{{color}}"
 *                   iconclass="{{icon}}">
 *               </wm-button><br>
 *               <wm-composite>
 *                   <wm-label caption="caption:"></wm-label>
 *                   <wm-text scopedatavalue="caption"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="width:"></wm-label>
 *                   <wm-text scopedatavalue="width"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="height:"></wm-label>
 *                   <wm-text scopedatavalue="height"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="color:"></wm-label>
 *                   <wm-select scopedatavalue="color" scopedataset="colors"></wm-select>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="icon:"></wm-label>
 *                   <wm-select scopedatavalue="icon" scopedataset="icons"></wm-select>
 *               </wm-composite>
 *           </div>
 *       </file>
 *       <file name="script.js">
 *          function Ctrl($scope) {
 *              $scope.clickCount =
 *              $scope.dblclickCount =
 *              $scope.mouseenterCount =
 *              $scope.mouseleaveCount =
 *              $scope.focusCount =
 *              $scope.blurCount = 0;
 *
 *              $scope.width = "100px";
 *              $scope.height= "30px";
 *              $scope.caption = " Click Me! ";
 *              $scope.color = "crimson";
 *
 *              $scope.icons = ["ok", "star", "remove", "user", "random"];
 *              $scope.colors = ["crimson", "green", "orange", "red"];
 *
 *              $scope.f = function (eventtype) {
 *                  $scope[eventtype + 'Count']++;
 *              }
 *           }
 *       </file>
 *   </example>
 */


/*global WM */
/*Directive for button group */

WM.module('wm.widgets.form')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/widget/form/button-group.html',
                '<div class="btn-group app-button-group" wmtransclude init-widget data-ng-class=\'{"btn-group-vertical": vertical}\' apply-styles="container" title="{{hint}}" data-ng-show="show" role="input"></div>'
            );
    }])
    .directive('wmButtongroup', ['$templateCache', 'PropertiesFactory', 'WidgetUtilService', function ($templateCache, PropertiesFactory, WidgetUtilService) {
        'use strict';

        var widgetProps = PropertiesFactory.getPropertiesOf('wm.buttongroup', ['wm.base', 'wm.base.editors']);

        return {
            'restrict': 'E',
            'replace': true,
            'scope': {},
            'template': $templateCache.get('template/widget/form/button-group.html'),
            'transclude': true,
            'compile': function () {
                return {
                    'pre': function (scope) {
                        scope.widgetProps = widgetProps;
                    },
                    'post': function (scope, element, attrs) {

                        /*Called from form reset when users clicks on form reset*/
                        scope.reset = function () {
                            //TODO implement custom reset logic here
                        };

                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.widgets.basic.directive:wmButtongroup
 * @restrict E
 *
 * @description
 * The `wmButtongroup` directive defines a button group widget.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires $rootScope
 * @requires $templateCache
 * @requires WidgetUtilService
 *
 * @param {string=} name
 *                  Name of the button group widget.
 * @param {string=} hint
 *                  Title/hint for the button group widget.<br>
 *                  This property is bindable.
 * @param {string=} width
 *                  Width of the button group.
 * @param {string=} height
 *                  Height of the button group.
 * @param {object=} vertical
 *                  Determines whether the buttons should be vertical or not.
 * @param {boolean=} show
 *                  Show is a bindable property. <br>
 *                  This property will be used to show/hide the Button Group widget on the web page. <br>
 *                  Default value: `true`. <br>
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
                Will you try this widget?? <br>
                <wm-buttongroup>
                    <wm-button backgroundcolor="teal" caption="Yes"></wm-button>
                    <wm-button backgroundcolor="DarkSlateBlue" caption="May be"></wm-button>
                    <wm-button backgroundcolor="crimson" caption="No"></wm-button>
                </wm-buttongroup>
            </div>
        </file>
        <file name="script.js">
           function Ctrl($scope) {}
        </file>
    </example>
 */

/*global WM */
/*Directive for switch */

WM.module('wm.widgets.form')
    .run([
        '$templateCache',

        function ($templateCache) {
            'use strict';
            $templateCache.put('template/widget/form/switch.html',
                '<div data-ng-show="show" class="app-switch" init-widget has-model apply-styles role="input">' +
                    '<div class="btn-group btn-group-justified">' +
                        '<a title="{{opt[displayfield || \'label\']}}" href="javascript:void(0);" role="button" class="btn btn-default" data-ng-disabled="disabled" ' +
                            ' data-ng-repeat="opt in options track by $index" data-ng-class="{\'selected\': selected.index === $index}"' +
                            ' data-ng-click="selectOpt($event, $index)">{{opt[displayfield || "label"]}}</a>' +
                    '</div>' +
                    '<span title="{{_model_}}" class="btn btn-primary app-switch-overlay switch-handle" data-ng-style="{\'width\': btnwidth + \'%\'}">{{options[selected.index][displayfield || "label"] || _model_}}</span>' +
                    '<input type="hidden" class="ng-hide model-holder" data-ng-disabled="disabled" value="{{_model_}}">' +
                '</div>'
                );
        }
    ])
    .directive('wmSwitch', [
        'PropertiesFactory',
        'WidgetUtilService',

        function (PropertiesFactory, WidgetUtilService) {
            'use strict';

            var widgetProps = PropertiesFactory.getPropertiesOf('wm.switch', ['wm.base', 'wm.base.editors', 'wm.base.editors.abstracteditors']),
                notifyFor = {
                    'dataset': true
                },
                COMMA_SEP_STRING = 1,
                ARRAY_STRINGS = 2,
                ARRAY_OBJECTS = 3,
                NONE = 0;

            function updatePropertyPanelOptions(dataset, propertiesMap, scope) {
                var variableKeys = [];
                /* on binding of data*/
                if (dataset && WM.isObject(dataset)) {
                    dataset = dataset[0] || dataset;
                    variableKeys = WidgetUtilService.extractDataSetFields(dataset, propertiesMap) || [];
                }

                /*removing null values from the variableKeys*/
                WM.forEach(variableKeys, function (variableKey, index) {
                    if (dataset[variableKey] === null || WM.isObject(dataset[variableKey])) {
                        variableKeys.splice(index, 1);
                    }
                });

                /* re-initialize the property values */
                if (scope.newcolumns) {
                    scope.newcolumns = false;
                    scope.datafield = '';
                    scope.displayfield = '';
                    scope.$root.$emit("set-markup-attr", scope.widgetid, {'datafield': scope.datafield, 'displayfield': scope.displayfield});
                }

                scope.widgetProps.datafield.options = ['', 'All Fields'].concat(variableKeys);
                scope.widgetProps.displayfield.options = [''].concat(variableKeys);
            }

            function trim(str) {
                if (WM.isString(str)) {
                    return str.trim();
                }
                return str;
            }

            function toOptionsObjFromString(str) {
                return {
                    'value': str,
                    'label': str
                };
            }

            function setSelectedValue(scope) {
                var options = scope.options;
                if (scope._model_ !== undefined && scope._model_ !== null) {
                    options.some(function (opt, index) {

                        if (scope._model_ === opt
                                || scope._model_ === opt[scope.datafield]
                                || scope._model_ === opt.value) {

                            scope.selected.index = index;

                            return true;
                        }
                    });
                }
            }

            function updateHighlighter(scope, element) {
                var handler = element.find('span.app-switch-overlay'),
                    left,
                    index = scope.selected.index;
                if (index === undefined || index === null) {
                    index = -1;
                }
                left = index * scope.btnwidth;
                handler.animate({
                    left: left + '%'
                }, 300);
            }

            function updateSwitchOptions(scope, element, dataset) {
                var options = [];

                scope.selected.index = -1;
                scope.datasetType = NONE;
                dataset = dataset ? dataset.data || dataset : [];

                if (WM.isString(dataset)) { // comma separated strings
                    options = dataset.split(',').map(trim).map(toOptionsObjFromString);
                    scope.datasetType = COMMA_SEP_STRING;
                } else if (WM.isObject(dataset)) { // array or object
                    if (WM.isArray(dataset)) { // array
                        if (WM.isString(dataset[0])) { // array of strings
                            options = dataset.map(trim).map(toOptionsObjFromString);
                            scope.datasetType = ARRAY_STRINGS;
                        } else if (WM.isObject(dataset[0]) && !WM.isArray(dataset[0])) { // array of objects
                            options = dataset;
                            scope.datasetType = ARRAY_OBJECTS;
                        }
                    }
                }

                if (options.length) {
                    scope.btnwidth = (100 / options.length);
                }

                scope.options = options;

                setSelectedValue(scope);
                updateHighlighter(scope, element);
            }

            /* Define the property change handler. This function will be triggered when there is a change in the widget property */
            function propertyChangeHandler(scope, element, key, newVal) {
                switch (key) {
                case 'dataset':
                    if (scope.widgetid && WM.isDefined(newVal) && newVal !== null) {
                        updatePropertyPanelOptions(newVal.data || newVal, newVal.propertiesMap, scope);
                    }
                    updateSwitchOptions(scope, element, newVal);
                    break;
                }
            }

            return {
                'restrict': 'E',
                'replace': true,
                'scope': {
                    'scopedataset': '=?'
                },
                'template': function (tElement, tAttrs) {
                    var template = WM.element(WidgetUtilService.getPreparedTemplate('template/widget/form/switch.html', tElement, tAttrs));
                    return template[0].outerHTML;
                },
                'compile': function () {
                    return {
                        'pre': function (scope) {
                            scope.widgetProps = widgetProps;
                        },
                        'post': function (scope, element, attrs) {

                            scope.options = [];

                            /* fields defined in scope: {} MUST be watched explicitly */

                            if (!scope.widgetid && attrs.scopedataset) {
                                scope.$watch('scopedataset', function (newVal) {
                                    /*generating the radioset based on the values provided*/
                                    updateSwitchOptions(scope, element, newVal);
                                });
                            }

                            scope.selectOptAtIndex = function ($index) {
                                var opt = scope.options[$index];
                                if (scope.datasetType === ARRAY_OBJECTS) {
                                    if (scope.datafield) {
                                        if (scope.datafield === 'All Fields') {
                                            scope._model_ = opt;
                                        } else {
                                            scope._model_ = opt[scope.datafield];
                                        }
                                    }
                                } else {
                                    scope._model_ = opt.value;
                                }
                            };

                            scope.selectOpt = function ($event, $index) {

                                $event.preventDefault();

                                if (scope.disabled) {
                                    return;
                                }

                                if (scope.selected.index === $index) {
                                    if (scope.options.length === 2) {
                                        $index = $index === 1 ? 0 : 1;
                                    } else {
                                        return;
                                    }
                                }
                                scope.selected.index = $index;

                                scope.selectOptAtIndex($index);
                                updateHighlighter(scope, element);

                                scope._onChange($event);
                            };

                            scope.$watch('_model_', function () {
                                setSelectedValue(scope);
                                updateHighlighter(scope, element);
                            });

                            scope.selected = {};

                            /*Called from form reset when users clicks on form reset*/
                            scope.reset = function () {
                                if (scope.options.length > 0) {
                                    scope.datavalue = scope.options[0].value;
                                    scope.selected.index = 0;
                                }
                            };

                            WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, scope, element), scope, notifyFor);
                            WidgetUtilService.postWidgetCreate(scope, element, attrs);
                        }
                    };
                }
            };
        }]);
/**
 * @ngdoc directive
 * @name wm.widgets.form.directive:wmSwitch
 * @restrict E
 *
 * @description
 * The `wmSwitch` directive defines the switch widget.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 * @requires CONSTANTS
 *
 * @param {string=} name
 *                  Name of the switch widget.
 * @param {string=} hint
 *                  Title/hint for the switch. <br>
 *                  This property is bindable.
 * @param {number=} tabindex
 *                  This property specifies the tab order of switch widget. <br>
 *                  Default value : 0
 * @param {string=} width
 *                  Width of the switch.
 * @param {string=} height
 *                  Height of the switch.
 * @param {string=} scopedatavalue
 *                  This property accepts the initial value for the switch widget from a variable defined in the script workspace. <br>
 * @param {string=} datavalue
 *                  This property will be used to set the initial state of the switch widget. <br>
 *                  Possible values are 'on' , 'off'
 *                  Default value: `on`. <br>
 * @param {string=} scopedataset
 *                  This property accepts the value for the switch widget from a variable defined in the script workspace. <br>
 * @param {string=} dataset
 *                  This property defines two states of switch. Comma separated values example: On, Off <br>
 *                  Default value: `On, Off`. <br>
 * @param {string=} datafield
 *                  This property sets the dataValue to be returned by a switch widget when the list is populated using the dataSet property.
 * @param {string=} displayfield
 *                  This property sets the displayValue to show in the switch widget when the list is populated using the dataSet property.
 * @param {boolean=} required
 *                   This property will be used to validate the state of the switch widget when used inside a form widget.
 * @param {boolean=} show
 *                  Show is a bindable property. <br>
 *                  This property will be used to show/hide the switch widget on the web page. <br>
 *                  Default value: `true`. <br>
 * @param {boolean=} disabled
 *                   Disabled is a bindable property. <br>
 *                   This property will be used to disable/enable the switch widget on the web page. <br>
 *                   Default value: `false`. <br>
 * @param {string=} on-change
 *                  Callback function which will be triggered when the widget value is changed.
 * @param {string=} on-focus
 *                  Callback function which will be triggered when the widget gets focused.
 * @param {string=} on-blur
 *                  Callback function which will be triggered when the widget loses focus.
 * @param {string=} on-click
 *                  Callback function which will be triggered when the widget is clicked.
 * @param {string=} on-mouseenter
 *                  Callback function which will be triggered when the mouse enters the widget.
 * @param {string=} on-mouseleave
 *                  Callback function which will be triggered when the mouse leaves the widget.
 * @example
 *   <example module="wmCore">
 *       <file name="index.html">
 *           <div data-ng-controller="Ctrl" class="wm-app">
 *               <div>single click count: {{clickCount}}</div>
 *               <div>change count: {{changeCount}}</div>
 *               <div>mouse enter count: {{mouseenterCount}}</div>
 *               <div>mouse leave count: {{mouseleaveCount}}</div>
 *               <div>focus count: {{focusCount}}</div>
 *               <div>blur count: {{blurCount}}</div>
 *
 *               <wm-composite>
 *                   <wm-label caption="{{switchlabel}}"></wm-label>
 *                   <wm-switch
 *                       hint="hint/title for switch"
 *                       scopedataset="switchoptions"
 *                       on-click="f('click');"
 *                       on-change="f('change');"
 *                       on-focus="f('focus');"
 *                       on-blur="f('blur');"
 *                       on-mouseenter="f('mouseenter');"
 *                       on-mouseleave="f('mouseleave')"
 *                       width="{{width}}"
 *                       height="{{height}}">
 *                   </wm-switch>
 *               </wm-composite>
 *
 *               <div>Switch state: {{favitem1}}</div>
 *
 *               <wm-composite>
 *                   <wm-label caption="Options"></wm-label>
 *                   <wm-text scopedatavalue="switchoptions" placeholder="enter comma separated values"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="width:"></wm-label>
 *                   <wm-text scopedatavalue="width"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="height:"></wm-label>
 *                   <wm-text scopedatavalue="height"></wm-text>
 *               </wm-composite>
 *           </div>
 *       </file>
 *       <file name="script.js">
 *          function Ctrl($scope) {
 *              $scope.clickCount =
 *              $scope.changeCount =
 *              $scope.mouseenterCount =
 *              $scope.mouseleaveCount =
 *              $scope.focusCount =
 *              $scope.blurCount = 0;
 *              $scope.favcolors = [];
 *
 *              $scope.width = "120px";
 *              $scope.height= "30px";
 *
 *              $scope.switchoptions = "on,off";
 *
 *              $scope.f = function (eventtype) {
 *                  $scope[eventtype + 'Count']++;
 *              }
 *           }
 *       </file>
 *   </example>
 */
/*global WM, _ */
/*Directive for menu */

WM.module('wm.widgets.form')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/widget/form/menu.html',
                '<div class="dropdown app-menu" init-widget data-ng-show="show" uib-dropdown role="input" tabindex="-1">' +
                    '<button title="{{hint}}" class="btn app-button dropdown-toggle {{menuclass}}" uib-dropdown-toggle apply-styles tabindex="{{tabindex}}" accesskey="{{shortcutkey}}">' +
                    '<i class="app-icon {{iconclass}}"></i>' +
                        ' {{caption}} ' +
                        '<span wmtransclude></span>' +
                        '<span class="caret"></span>' +
                    '</button>' +
                    '<wm-menu-dropdown menulayout="menulayout" items="menuItems" linktarget="linktarget" menualign="menualign"/>' +
                '</div>'
            );
        $templateCache.put('template/widget/form/anchormenu.html',
                '<div class="dropdown app-menu" init-widget data-ng-show="show" uib-dropdown role="input" tabindex="-1">' +
                    '<a title="{{hint}}" href="javascript:void(0);" class="app-anchor dropdown-toggle {{menuclass}}" uib-dropdown-toggle apply-styles accesskey="{{shortcutkey}}"><i class="app-icon {{iconclass}}" tabindex="{{tabindex}}"></i>' +
                        ' {{caption}} ' +
                        '<span wmtransclude></span>' +
                        '<span class="caret"></span>' +
                    '</a>' +
                    '<wm-menu-dropdown menulayout="menulayout" items="menuItems" linktarget="linktarget" menualign="menualign"/>' +
                '</div>'
            );
        $templateCache.put('template/widget/form/menu/dropdown.html',
                '<ul class="dropdown-menu {{menulayout}} {{menualign}}" uib-dropdown-menu>' +
                    '<wm-menu-dropdown-item data-ng-repeat="item in items" linktarget="linktarget" item="item" menualign="menualign"/>' +
                '</ul>'
            );
        $templateCache.put('template/widget/form/menu/dropdownItem.html',
                '<li data-ng-class="{\'disabled\': item.disabled, \'dropdown-submenu\' : item.children.length > 0}">' +
                    '<a tabindex="0" href="javascript:void(0);" title="{{item.label}}" ng-href="{{item.link}}" target="{{linktarget}}">' +
                    '<span data-ng-if="item.children.length" class="pull-right fa" data-ng-class="{ \'fa-caret-left\': {{menualign === \'pull-right\'}}, \'fa-caret-right\': {{menualign === \'pull-left\' || menualign === undefined}}, \'fa-caret-down\': {{menualign === \'dropinline-menu\'}} }"></span>' +
                        '<i class="app-icon {{item.icon}}"></i>' +
                        '{{item.label}}' +
                    '</a>' +
                '</li>'
            );
    }])
    .directive('wmMenu', ['$templateCache', 'PropertiesFactory', 'WidgetUtilService', '$timeout', 'Utils', 'CONSTANTS', function ($templateCache, PropertiesFactory, WidgetUtilService, $timeout, Utils, CONSTANTS) {
        'use strict';

        var widgetProps = PropertiesFactory.getPropertiesOf('wm.menu', ['wm.base.editors', 'wm.menu.dataProps']),
            notifyFor = {
                'iconname'      : true,
                'scopedataset'  : true,
                'dataset'       : true,
                'menuposition'  : true,
                'menualign'     : true,
                'linktarget'    : true
            },
            POSITION = {
                DOWN_RIGHT  : 'down,right',
                DOWN_LEFT   : 'down,left',
                UP_RIGHT    : 'up,right',
                UP_LEFT     : 'up,left',
                INLINE      : 'inline'
            };

        function getMenuItems(newVal, scope) {
            var menuItems = [],
                transformFn;
            if (WM.isString(newVal)) {
                menuItems = newVal.split(',').map(function (item) {
                    var _val = item && item.trim();
                    return {
                        'label': _val,
                        'value': _val
                    };
                });
            } else if (WM.isArray(newVal)) {
                if (WM.isObject(newVal[0])) {
                    transformFn = function (item) {
                        var children = (WidgetUtilService.getEvaluatedData(scope, item, {expressionName: 'itemchildren'}) || item.children);
                        return {
                            'label'     : WidgetUtilService.getEvaluatedData(scope, item, {expressionName: 'itemlabel'}) || item.label,
                            'icon'      : WidgetUtilService.getEvaluatedData(scope, item, {expressionName: 'itemicon'}) || item.icon,
                            'disabled'  : item.disabled,
                            'link'      : WidgetUtilService.getEvaluatedData(scope, item, {expressionName: 'itemlink'}) || item.link,
                            'value'     : scope.datafield ? (scope.datafield === 'All Fields' ? item : Utils.findValueOf(item, scope.datafield)) : item,
                            'children'  : (WM.isArray(children) ? children : []).map(transformFn)
                        };
                    };
                    menuItems = newVal.map(transformFn);
                } else {
                    menuItems = newVal.map(function (item) {
                        return {
                            'label': item,
                            'value': item
                        };
                    });
                }
            }

            return menuItems;
        }

        function propertyChangeHandler(scope, element, key, newVal) {
            switch (key) {
            case 'scopedataset':
            case 'dataset':
                /*if studio-mode, then update the itemlabel, itemicon, itemlink & itemchildren in property panel*/
                if (CONSTANTS.isStudioMode && WM.isDefined(newVal) && newVal !== null) {
                    WidgetUtilService.updatePropertyPanelOptions(newVal.data || newVal, newVal.propertiesMap, scope);
                }
                scope.itemlabel = scope.itemlabel || scope.displayfield;
                if (CONSTANTS.isRunMode && newVal) {
                    scope.menuItems = getMenuItems(newVal.data || newVal, scope);
                }
                break;
            case 'linktarget':
                scope.linktarget = newVal;
                break;
            case 'menuposition':
                switch (newVal) {
                case POSITION.DOWN_RIGHT:
                    element.removeClass('dropup');
                    scope.menualign = 'pull-left';
                    break;
                case POSITION.DOWN_LEFT:
                    element.removeClass('dropup');
                    scope.menualign = 'pull-right';
                    break;
                case POSITION.UP_LEFT:
                    element.addClass('dropup');
                    scope.menualign = 'pull-right';
                    break;
                case POSITION.UP_RIGHT:
                    element.addClass('dropup');
                    scope.menualign = 'pull-left';
                    break;
                case POSITION.INLINE:
                    scope.menualign = 'dropinline-menu';
                    break;
                }
                break;
            }
        }

        return {
            'restrict': 'E',
            'scope': {
                'scopedataset': '=?',
                'onSelect': '&'
            },
            'template': function (tElement, tAttrs) {
                var template = '';
                if (tAttrs.type && tAttrs.type === 'anchor') {
                    template = WM.element($templateCache.get('template/widget/form/anchormenu.html'));
                } else {
                    template = WM.element($templateCache.get('template/widget/form/menu.html'));
                }
                return template[0].outerHTML;
            },
            'replace': true,
            'transclude': true,
            'compile': function (tElement) {
                return {
                    'pre': function (iScope, element, attrs) {
                        //@Deprecated iconname; use iconclass instead
                        if (!attrs.iconclass && attrs.iconname) {
                            WM.element(tElement.context).attr('iconclass', 'glyphicon glyphicon-' + attrs.iconname);
                            attrs.iconclass = 'glyphicon glyphicon-' + attrs.iconname;
                        }
                        /* support for dropposition */
                        if (attrs.dropposition === 'up') {
                            if (attrs.menuposition === POSITION.DOWN_RIGHT) {
                                attrs.menuposition = POSITION.UP_RIGHT;
                            } else if (attrs.menuposition === POSITION.DOWN_LEFT) {
                                attrs.menuposition = POSITION.UP_LEFT;
                            }
                        } else if (attrs.dropposition === 'down') {
                            if (attrs.menuposition === POSITION.UP_RIGHT) {
                                attrs.menuposition = POSITION.DOWN_RIGHT;
                            } else if (attrs.menuposition === POSITION.UP_LEFT) {
                                attrs.menuposition = POSITION.DOWN_LEFT;
                            }
                        }
                        if (CONSTANTS.isStudioMode) {
                            iScope.widgetProps = Utils.getClonedObject(widgetProps);
                        } else {
                            iScope.widgetProps = widgetProps;
                        }
                    },
                    'post': function (scope, element, attrs) {
                        var onPropertyChange = propertyChangeHandler.bind(undefined, scope, element);
                        /* register the property change handler */
                        WidgetUtilService.registerPropertyChangeListener(onPropertyChange, scope, notifyFor);

                        /*Called from form reset when users clicks on form reset*/
                        scope.reset = function () {
                            //TODO implement custom reset logic here
                        };

                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                        if (!scope.widgetid && attrs.scopedataset) {
                            $timeout(function () {
                                scope.$watch('scopedataset', function (newVal) {
                                    onPropertyChange('scopedataset', newVal);
                                });
                            }, 0, true);
                        }
                    }
                };
            }
        };
    }])
    .directive('wmMenuDropdown', ['$templateCache', function ($templateCache) {
        'use strict';
        return {
            'restrict': "E",
            'replace': true,
            'scope': {
                'items': '=',
                'menualign': '=',
                'menulayout': '=',
                'linktarget': '='
            },
            'template': $templateCache.get('template/widget/form/menu/dropdown.html'),
            'compile': function () {
                return {
                    'post': function (scope) {
                        scope.onSelect = function (args) {
                            if (!args.$scope.item.link) {
                                scope.$parent.onSelect(args);
                            }
                        };
                    }
                };
            }
        };
    }])
    .directive('wmMenuDropdownItem', ['$templateCache', '$compile', 'CONSTANTS',  function ($templateCache, $compile, CONSTANTS) {
        'use strict';
        return {
            'restrict': "E",
            'replace': true,
            'scope': {
                'item': '=',
                'menualign': '=',
                'linktarget': '='
            },
            'template': function () {
                var template = WM.element($templateCache.get('template/widget/form/menu/dropdownItem.html'));
                if (!CONSTANTS.isStudioMode) {
                    template.attr('data-ng-click', 'onSelect({$event: $event, $scope: this, $item: item.value || item.label })');
                }
                return template[0].outerHTML;
            },
            'link': function (scope, element) {
                if (scope.item.children && scope.item.children.length > 0) {
                    element.append('<wm-menu-dropdown items="item.children"  linktarget="linktarget" menualign="menualign"/>');
                    element.off('click');
                    $compile(element.contents())(scope);
                }
                scope.onSelect = function (args) {
                    if (!args.$scope.item.link) {
                        scope.$parent.onSelect(args);
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.widgets.basic.directive:wmMenu
 * @restrict E
 *
 * @description
 * The `wmMenu` directive defines a menu widget.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires $rootScope
 * @requires $templateCache
 * @requires WidgetUtilService
 *
 * @param {string=} caption
 *                  Content / Label of the Menu widget. <br>
 *                  This property is bindable.
 * @param {string=} name
 *                  Name of the menu widget.
 * @param {string=} position
 *                  This property defined the Position of the Menu dropdown - up/down <br>
 *                  Possible values are ["up" ,"down"] <br>
 *                  Default value : "down"
 * @param {string=} width
 *                  Width of the menu.
 * @param {string=} height
 *                  Height of the menu.
 * @param {string=} scopedatavalue
 *                  This property accepts the value for the Menu widget from a variable defined in the script workspace. <br>
 * @param {string=} dataset
 *                  This property accepts the options to create the Menu widget from a wavemaker studio variable (live or static) which can hold object, array or string data.
 * @param {string=} datafield
 *                  This property sets the dataValue to be returned by a menu widget when the list is populated using the dataSet property.
 * @param {string=} displayfield
 *                  This property sets the displayValue to show in the menu widget when the list is populated using the dataSet property.
 * @param {expression=} displayexpression
 *                      This is an advanced property that gives more control over what is displayed in the Menu widget. <br>
 *                      A Display Expression uses a Javascript expression to format exactly what is shown. <br>
 *                      This property is bindable.
 * @param {boolean=} show
 *                  Show is a bindable property. <br>
 *                  This property will be used to show/hide the chart widget on the web page. <br>
 *                  Default value: `true`. <br>
 * @param {string=} iconclass
 *                  CSS class of the icon.
 * @param {string=} on-select
 *                  Callback function which is executed when a Menu value is selected.
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
               <wm-menu scopedataset="nodes" menuposition="down,right" caption="Menu" iconclass="glyphicon glyphicon-align-justify"></wm-menu>
            </div>
        </file>
        <file name="script.js">
            function Ctrl($scope) {
               $scope.nodes = [
                   {
                       "label": "item1",
                       "icon": "glyphicon glyphicon-euro",
                       "children" : [
                           {
                               "label": "sub-menu-item1",
                               "icon": "glyphicon glyphicon-euro"
                           },
                           {
                               "label": "sub-menu-item2",
                               "icon": "glyphicon glyphicon-euro",
                                "children" : [
                                    {
                                       "label": "sub-menu-child-item1",
                                       "icon": "glyphicon glyphicon-euro"
                                   },
                                   {
                                       "label": "sub-menu-child-item2",
                                       "icon": "glyphicon glyphicon-euro"
                                  }
                             ]
                           }
                       ]
                   },
                   {
                       "label": "item2",
                       "icon": "glyphicon glyphicon-euro"
                   },
                   {
                       "label": "item3",
                       "icon": "glyphicon glyphicon-euro"
                   },
                   {
                       "label": "item4",
                       "icon": "glyphicon glyphicon-euro"
                   }
               ];
            }
        </file>
    </example>
 */
/*global WM */
/*Directive for slider */

WM.module('wm.widgets.form')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/widget/form/slider.html',
                '<div class="app-slider slider" init-widget has-model data-ng-show="show" title="{{hint}}" apply-styles role="input">' +
                    '<span class="app-slider-value">{{minvalue}}</span>' +
                    '<span class="app-slider-value pull-right">{{maxvalue}}</span>' +
                    '<input class="range-input" type="range" title="{{_model_}}" min="{{minvalue}}" max="{{maxvalue}}" step="{{step}}"' +
                       ' data-ng-model="_model_"' + /* _model_ is a private variable inside this scope */
                       ' data-ng-disabled="disabled"' +
                       ' accesskey="{{shortcutkey}}"' +
                       ' data-ng-change="_onChange({$event: $event, $scope: this})" />' + /* private method defined in this scope */
                    '<div data-ng-show="readonly || disabled" class="readonly-wrapper"></div>' +
                '</div>'
            );
    }])
    .directive('wmSlider', ['PropertiesFactory', '$templateCache', 'WidgetUtilService', function (PropertiesFactory, $templateCache, WidgetUtilService) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.slider', ['wm.base', 'wm.base.editors', 'wm.base.events.change']);
        return {
            'restrict': 'E',
            'replace': true,
            'scope': {
                'onChange': '&'
            },
            'template': function (tElement, tAttrs) {
                var template = WM.element($templateCache.get('template/widget/form/slider.html'));
                template.find('input').attr('name', tAttrs.name);
                return template[0].outerHTML;
            },
            'compile': function () {
                return {
                    'pre': function (scope) {
                        /*Applying widget properties to directive scope*/
                        scope.widgetProps = widgetProps;
                    },
                    'post': function (scope, element, attrs) {

                        /*Called from form reset when users clicks on form reset*/
                        scope.reset = function () {
                            //TODO implement custom reset logic here
                            scope._model_ = '';
                        };

                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.widgets.form.directive:wmSlider
 * @restrict E
 *
 * @description
 * The `wmSlider` directive defines the slider widget.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires $rootScope
 * @requires $templateCache
 * @requires WidgetUtilService
 *
 * @param {string=} name
 *                  Name of the slider widget.
 * @param {string=} hint
 *                  Title/hint for the slider. <br>
 *                  This property is bindable.
 * @param {string=} width
 *                  Width of the slider.
 * @param {string=} height
 *                  Height of the slider.
 * @param {string=} scopedatavalue
 *                  This property accepts the value for the slider widget from a variable defined in the script workspace. <br>
 *                  The scope variable is updated whenever there is a change in the slider value.
 * @param {string=} datavalue
 *                  Value of the slider widget. Accepts the value from a studio variable or from another widget's value.<br>
 *                  This property is bindable.
 * @param {number=} minvalue
 *                  This property represents the start value of slider. <br>
 *                  This property is bindable.
 * @param {number=} maxvalue
 *                  This property represents the end value of slider. <br>
 *                  This property is bindable.
 * @param {number=} step
 *                  This property represents the no of steps the range is divided.
 * @param {boolean=} readonly
 *                   Readonly is a bindable property. <br>
 *                   This property will be used to make the slider widget non-editable on the web page. <br>
 *                   Default value: `false`. <br>
 * @param {boolean=} show
 *                  Show is a bindable property. <br>
 *                  This property will be used to show/hide the slider widget on the web page. <br>
 *                  Default value: `true`. <br>
 * @param {boolean=} disabled
 *                  Disabled is a bindable property. <br>
 *                  This property will be used to disable/enable the slider widget on the web page. <br>
 *                  Default value: `false`. <br>
 * @param {string=} on-change
 *                  Callback function which will be triggered when the widget value is changed.
 * @example
 *   <example module="wmCore">
 *       <file name="index.html">
 *           <div data-ng-controller="Ctrl" class="wm-app">
 *               <div>focus count: {{focusCount}}</div>
 *               <div>blur count: {{blurCount}}</div>
 *               <wm-slider
 *                   caption="{{caption}}"
 *                   hint="hint/title for slider" *
 *                   width="{{width}}"
 *                   height="{{height}}"
 *                   color="{{color}}"
 *                   iconname="{{icon}}">
 *               </wm-slider><br>
 *               <wm-composite>
 *                   <wm-label caption="caption:"></wm-label>
 *                   <wm-text scopedatavalue="caption"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="width:"></wm-label>
 *                   <wm-text scopedatavalue="width"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="height:"></wm-label>
 *                   <wm-text scopedatavalue="height"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="color:"></wm-label>
 *                   <wm-select scopedatavalue="color" scopedataset="colors"></wm-select>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="icon:"></wm-label>
 *                   <wm-select scopedatavalue="icon" scopedataset="icons"></wm-select>
 *               </wm-composite>
 *           </div>
 *       </file>
 *       <file name="script.js">
 *          function Ctrl($scope) {
 *              $scope.clickCount =
 *              $scope.focusCount =
 *              $scope.blurCount = 0;
 *
 *              $scope.width = "100px";
 *              $scope.height= "30px";
 *              $scope.caption = " Slide Me! ";
 *              $scope.color = "crimson";
 *
 *              $scope.colors = ["crimson", "green", "orange", "red"];
 *
 *              $scope.f = function (eventtype) {
 *                  $scope[eventtype + 'Count']++;
 *              }
 *           }
 *       </file>
 *   </example>
 */


/*global WM, _*/
/*Directive for checkbox */

WM.module('wm.widgets.form')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        /*
        * TODO: ng-required is removed as the current angular version(v1.2.13) is having issues
        * with updating checkbox checked state based on initial dataValue if ng-checked-value is set
        * on updating angular version, ng-required attribute can be kept in the template
        * note: attribute 'ng-checked' removed as it is conflicting with the new property 'datavalue'
        */
        $templateCache.put('template/widget/form/checkbox.html',
            '<div class="app-checkbox checkbox" data-ng-class="{\'app-toggle\' : (type === \'toggle\')}" init-widget has-model data-ng-show="show" title="{{hint}}" role="input">' +
                '<label data-ng-class="{\'disabled\':disabled,\'unchecked\': (_model_=== uncheckedvalue || _model_ === false || _model_ === null)}" apply-styles role="button">' +
                    '<input type="checkbox" ' +
                        ' data-ng-model="_model_"' + /* _model_ is a private variable inside this scope */
                        ' data-ng-readonly="readonly" ' +
                        ' data-ng-required="required"' +
                        ' data-ng-disabled="disabled" ' +
                        ' accesskey="{{shortcutkey}}"' +
                        ' data-ng-change="_onChange({$event: $event, $scope: this})">' +
                    '</input>' +
                '<span class="caption">{{caption || "&nbsp;"}}</span>' +
                '<img src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class="switch"/>' +
                '</label>' +
                /*Holder for the model for submitting values in a form*/
                '<input type="hidden" class="ng-hide model-holder" data-ng-disabled="disabled" value="{{_model_}}">' +
            '</div>'
            );
    }])
    .directive('wmCheckbox', ['PropertiesFactory', 'WidgetUtilService', 'CONSTANTS', '$templateCache', 'FormWidgetUtils', function (PropertiesFactory, WidgetUtilService, CONSTANTS, $templateCache, FormWidgetUtils) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.checkbox', ['wm.base', 'wm.base.editors', 'wm.base.editors.abstracteditors']),
            notifyFor = {
                'readonly': true
            };

        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
        function propertyChangeHandler(scope, key, newVal) {
            switch (key) {
            case 'readonly':
                scope.disabled = newVal;
                break;
            }
        }

        return {
            'restrict': 'E',
            'scope': {},
            'replace': true,
            'template': function (tElement, tAttrs) {
                var template = WM.element($templateCache.get('template/widget/form/checkbox.html')),
                    checkbox,
                    isWidgetInsideCanvas = tAttrs.hasOwnProperty('widgetid');
                checkbox = template.find('input[type=checkbox]');
                if (tAttrs.checkedvalue) {
                    checkbox.attr('data-ng-true-value', "'" + tAttrs.checkedvalue + "'");
                }
                if (tAttrs.uncheckedvalue) {
                    checkbox.attr('data-ng-false-value', "'" + tAttrs.uncheckedvalue + "'");
                }
                if (!isWidgetInsideCanvas) {
                    WidgetUtilService.addEventAttributes(template, tAttrs, FormWidgetUtils.getProxyEventsMap());
                    WidgetUtilService.addEventAttributes(checkbox, tAttrs, FormWidgetUtils.getFocusBlurEvents());
                }
                /*Set name for the model-holder, to ease submitting a form*/
                template.find('.model-holder').attr('name', tAttrs.name);

                return template[0].outerHTML;
            },
            'compile': function () {
                return {
                    'pre': function (scope, element, attrs) {
                        /*Applying widget properties to directive scope*/
                        scope.widgetProps = widgetProps;
                        if (!attrs.datavalue && !attrs.scopedatavalue) {
                            scope._model_ = attrs.uncheckedvalue || false;
                        }

                    },
                    'post': function (scope, element, attrs) {
                        scope.eventProxy = FormWidgetUtils.eventProxy.bind(undefined, scope);
                        /* register the property change handler */
                        WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, scope), scope, notifyFor);

                        /*Called from form reset when users clicks on form reset*/
                        scope.reset = function () {
                            scope._model_ = false;
                        };
                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.widgets.form.directive:wmCheckbox
 * @restrict E
 *
 * @description
 * The `wmCheckbox` directive defines the checkbox widget.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 * @requires CONSTANTS
 *
 * @param {string=} caption
 *                  Caption / Label for the Checkbox widget. <br>
 *                  This property is bindable
 * @param {string=} name
 *                  Name of the checkbox widget.
 * @param {string=} hint
 *                  Title/hint for the checkbox. <br>
 *                  This property is bindable.
 * @param {number=} tabindex
 *                  This property specifies the tab order of Checkbox widget. <br>
 *                  Default value : 0
 * @param {string=} width
 *                  Width of the checkbox.
 * @param {string=} height
 *                  Height of the checkbox.
 * @param {string=} scopedatavalue
 *                  This property accepts the initial value for the checkbox widget from a variable defined in the script workspace. <br>
 * $param {string=} datavalue
 *                  The value of the Checkbox widget <br>
 *                  This property is bindable.
 *                  Default value : 'false'
 * @param {string=} checkedvalue
 *                  This property defines the value of the checkbox widget when the widget is in the checked state.<br>
 *                  Default value: `false`. <br>
 * @param {string=} uncheckedvalue
 *                  This property defines the value of the checkbox widget when the widget is in the unchecked state.<br>
 * @param {boolean=} required
 *                   This property will be used to validate the state of the checkbox widget when used inside a form widget. <br>
 *                   Default value: `false`. <br>
 * @param {boolean=} show
 *                  Show is a bindable property. <br>
 *                  This property will be used to show/hide the checkbox widget on the web page. <br>
 *                  Default value: `true`. <br>
 * @param {boolean=} disabled
 *                   Disabled is a bindable property. <br>
 *                   This property will be used to disable/enable the checkbox widget on the web page. <br>
 *                   Default value: `false`. <br>
 * @param {string=} on-change
 *                  Callback function which will be triggered when the widget value is changed.
 * @param {string=} on-focus
 *                  Callback function which will be triggered when the widget gets focused.
 * @param {string=} on-blur
 *                  Callback function which will be triggered when the widget loses focus.
 * @param {string=} on-click
 *                  Callback function which will be triggered when the widget is clicked.
 * @param {string=} on-mouseenter
 *                  Callback function which will be triggered when the mouse enters the widget.
 * @param {string=} on-mouseleave
 *                  Callback function which will be triggered when the mouse leaves the widget.
 * @example
 *   <example module="wmCore">
 *       <file name="index.html">
 *           <div data-ng-controller="Ctrl" class="wm-app">
 *               <div>single click count: {{clickCount}}</div>
 *               <div>change count: {{changeCount}}</div>
 *               <div>mouse enter count: {{mouseenterCount}}</div>
 *               <div>mouse leave count: {{mouseleaveCount}}</div>
 *               <div>focus count: {{focusCount}}</div>
 *               <div>blur count: {{blurCount}}</div>
 *
 *               <wm-composite>
 *                   <wm-label caption="{{check1caption}}"></wm-label>
 *                   <wm-checkbox
 *                       hint="hint/title for checkbox"
 *                       checkedvalue="RED"
 *                       scopedatavalue="favitem1"
 *                       on-click="f('click');"
 *                       on-change="f('change');"
 *                       on-focus="f('focus');"
 *                       on-blur="f('blur');"
 *                       on-mouseenter="f('mouseenter');"
 *                       on-mouseleave="f('mouseleave')"
 *                       width="{{width}}"
 *                       height="{{height}}">
 *               </wm-composite>
 *
 *               <div>{{favitem1}}</div>
 *
 *               <wm-composite>
 *                   <wm-label caption="{{check2caption}}"></wm-label>
 *                   <wm-checkbox
 *                       hint="hint/title for checkbox"
 *                       checkedvalue="GREEN"
 *                       scopedatavalue="favitem2"
 *                       on-click="f('click');"
 *                       on-change="f('change');"
 *                       on-focus="f('focus');"
 *                       on-blur="f('blur');"
 *                       on-mouseenter="f('mouseenter');"
 *                       on-mouseleave="f('mouseleave')"
 *                       width="{{width}}"
 *                       height="{{height}}">
 *               </wm-composite>
 *
 *               <div>{{favitem2}}</div>
 *
 *               <wm-composite>
 *                   <wm-label caption="{{check3caption}}"></wm-label>
 *                   <wm-checkbox type="toggle"
 *                       hint="hint/title for checkbox"
 *                       checkedvalue="BLUE"
 *                       scopedatavalue="favitem3"
 *                       on-click="f('click');"
 *                       on-change="f('change');"
 *                       on-focus="f('focus');"
 *                       on-blur="f('blur');"
 *                       on-mouseenter="f('mouseenter');"
 *                       on-mouseleave="f('mouseleave')"
 *                       width="{{width}}"
 *                       height="{{height}}">
 *               </wm-composite>
 *
 *               <div>{{favitem3}}</div>
 *
 *               <wm-composite>
 *                   <wm-label caption="Item 1:"></wm-label>
 *                   <wm-text scopedatavalue="check1caption"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="Item 2:"></wm-label>
 *                   <wm-text scopedatavalue="check2caption"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="Item 3:"></wm-label>
 *                   <wm-text scopedatavalue="check3caption"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="width:"></wm-label>
 *                   <wm-text scopedatavalue="width"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="height:"></wm-label>
 *                   <wm-text scopedatavalue="height"></wm-text>
 *               </wm-composite>
 *           </div>
 *       </file>
 *       <file name="script.js">
 *          function Ctrl($scope) {
 *              $scope.clickCount =
 *              $scope.changeCount =
 *              $scope.mouseenterCount =
 *              $scope.mouseleaveCount =
 *              $scope.focusCount =
 *              $scope.blurCount = 0;
 *              $scope.favcolors = [];
 *
 *              $scope.width = "50px";
 *              $scope.height= "20px";
 *
 *              $scope.check1caption = "RED";
 *              $scope.check2caption = "GREEN";
 *              $scope.check3caption = "BLUE";
 *
 *              $scope.isChecked = "true";
 *
 *              $scope.f = function (eventtype) {
 *                  $scope[eventtype + 'Count']++;
 *              }
 *           }
 *       </file>
 *   </example>
 */

/*global WM, _ */
/*Directive for checkboxset */

WM.module('wm.widgets.form')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/widget/form/checkboxset.html',
            '<ul class="app-checkboxset list-group {{layout}}" init-widget has-model apply-styles role="input"' +
                ' title="{{hint}}" ' +
                ' data-ng-model="_model_"' + /* _model_ is a private variable inside this scope */
                ' data-ng-show="show" ' +
                ' data-ng-change="_onChange({$event: $event, $scope: this})">' +
                '</ul>'
            );
    }])
    .directive('wmCheckboxset', ['PropertiesFactory', 'WidgetUtilService', '$compile', 'CONSTANTS', 'Utils', 'FormWidgetUtils', '$templateCache', function (PropertiesFactory, WidgetUtilService, $compile, CONSTANTS, Utils, FormWidgetUtils, $templateCache) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.checkboxset', ['wm.base', 'wm.booleaneditors']),
            notifyFor = {
                'dataset'       : true,
                'displayfield'  : true,
                'datafield'     : true,
                'usekeys'       : true,
                'selectedvalues': true,
                'disabled'      : true
            };

        /*function to assign the values to the model variable based on the selectedvalue as provided.*/
        function assignModelValue(scope, dataSet, checkboxValue) {
            var selectedValues = [];
            /*if checkboxValue is provided use that to assign model value else use the selectedvalue property if provided*/
            if (checkboxValue) {
                selectedValues.push(checkboxValue);
            } else if (scope.selectedvalues) {
                if (WM.isString(scope.selectedvalues) && scope.selectedvalues !== '') {
                    selectedValues = scope.selectedvalues.split(',');
                } else if (WM.isArray(scope.selectedvalues)) {
                    selectedValues = scope.selectedvalues;
                }
                scope._model_ = [];
            } else {
                if ((!selectedValues || selectedValues.length === 0) && !WM.isDefined(scope._model_)) {
                    scope._model_ = [];
                } else if (WM.isDefined(scope._model_)) {
                    if (WM.isString(scope._model_)) {
                        scope._model_ = scope._model_.split(',');
                    } else if (!WM.isArray(scope._model_)) {
                        scope._model_ = [scope._model_];
                    }
                } else {
                    scope._model_ = [];
                }
            }
            /*iterating over the selectedvalues to push to model*/
            _.forEach(selectedValues, function (value) {
                scope._model_.push(FormWidgetUtils.getModelValue(scope, dataSet, value, checkboxValue));
            });
        }

        function constructCheckboxSet(scope, element, dataSet) {
            var template,
                compiledTemplate;
            scope.dataObject = {};
            scope.dataKeys = [];
            scope.checkedValues = {};
            dataSet = FormWidgetUtils.getParsedDataSet(dataSet, scope, element);
            /*creating dataKeys using the dataSet*/
            FormWidgetUtils.createDataKeys(scope, dataSet);
            /*assigning the value to the model, if selectedvalues are provided*/
            assignModelValue(scope, dataSet);
            /*creating the template for the widget*/
            template = FormWidgetUtils.getRadiosetCheckboxsetTemplate(scope, 'checkboxset');
            compiledTemplate = $compile(template)(scope);
            element.empty().append(compiledTemplate);
            /*register a click event handler for the radio*/
            element.find('.app-checkboxset-label').on('click', function (evt) {
                /*If the target has class, return here*/
                if (_.includes(evt.target.classList, 'caption')) {
                    return;
                }
                var checkedOption,
                    inputElements = element.find('input:checked');
                scope._model_ = [];

                inputElements.each(function () {
                    checkedOption = WM.element(this).val();
                    assignModelValue(scope, dataSet, checkedOption);
                });

                /*updating the selectedvalues if the model array has values*/
                /* TODO - to remove this condition (temporary fix to support chart properties in studio mode)*/
                if (CONSTANTS.isStudioMode) {
                    scope.selectedvalues = scope._model_.join(',');
                }

                /*triggering the change event of the input*/
                Utils.triggerFn(scope._onChange, evt);
                scope.$root.$safeApply(scope);
            });
        }

        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
        function propertyChangeHandler(scope, element, key, newVal) {
            var dataSet,
                isBoundToServiceVariable;

            if (key === 'dataset' && WM.isString(newVal) && newVal.length) {
                scope.dataset = newVal = newVal.split(',').map(function (val) { return val.trim(); });
            }

            dataSet = scope.dataset;

            /*Checking if widget is bound to service variable*/
            if (CONSTANTS.isStudioMode && scope.binddataset) {
                isBoundToServiceVariable = FormWidgetUtils.getBoundVariableCategory(scope) === "wm.ServiceVariable";
            }
            /*Monitoring changes for properties and accordingly handling respective changes.*/
            switch (key) {
            case 'dataset':
                /*if studio-mode, then update the displayField & dataField in property panel*/
                if (scope.widgetid && WM.isDefined(newVal) && newVal !== null) {
                    FormWidgetUtils.updatePropertyPanelOptions(newVal.data || newVal, newVal.propertiesMap, scope, true);
                }
                /*Displaying no data message when bound to service variable in studio mode*/
                if (isBoundToServiceVariable && CONSTANTS.isStudioMode) {
                    FormWidgetUtils.appendMessage(element);
                } else {
                    /*generating the checkboxSet based on the values provided*/
                    constructCheckboxSet(scope, element, newVal);
                }
                break;
            case 'displayfield':
            case 'datafield':
            case 'usekeys':
                if (CONSTANTS.isRunMode || !isBoundToServiceVariable) {
                    constructCheckboxSet(scope, element, dataSet);
                }
                break;
            case 'selectedvalues':
                dataSet = FormWidgetUtils.getParsedDataSet(dataSet, scope, element);
                assignModelValue(scope, dataSet);
                break;
            case 'disabled':
                element.find('input[type="checkbox"]').attr('disabled', newVal);
                break;
            }
        }
        /* checks if the given value object is in the given model array of objects */
        function valueInModel(model, value, dataObject) {
            /*If the value is in model, return true*/
            if (model && model.indexOf(value) !== -1) {
                return true;
            }
            /*If model is equal to value, return true*/
            if (model === value) {
                return true;
            }
            /*If the dataobject is present in model, return true*/
            return (dataObject && WM.isArray(model) && model.some(function (el) {
                return WM.equals(dataObject, el);
            }));
        }

        return {
            'restrict': 'E',
            'scope': {
                'scopedataset': '=?'
            },
            'replace': true,
            'template': function (tElement, tAttrs) {
                var template = WM.element($templateCache.get('template/widget/form/checkboxset.html')),
                    isWidgetInsideCanvas = tAttrs.hasOwnProperty('widgetid');
                if (!isWidgetInsideCanvas) {
                    WidgetUtilService.addEventAttributes(template, tAttrs, FormWidgetUtils.getProxyEventsMap());
                }
                return template[0].outerHTML;
            },
            'compile': function () {
                return {
                    'pre': function (iScope) {
                        if (CONSTANTS.isStudioMode) {
                            iScope.widgetProps = Utils.getClonedObject(widgetProps);
                        } else {
                            iScope.widgetProps = widgetProps;
                        }
                    },
                    'post': function (scope, element, attrs) {
                        scope.eventProxy = FormWidgetUtils.eventProxy.bind(undefined, scope);
                        /* register the property change handler */
                        WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, scope, element), scope, notifyFor);

                        /* fields defined in scope: {} MUST be watched explicitly */
                        /*watching scopedataset attribute to create options for the checkboxset element.*/
                        if (!attrs.widgetid && attrs.scopedataset) {
                            scope.$watch('scopedataset', function () {
                                if (scope.scopedataset) {
                                    scope.dataset = scope.scopedataset;
                                }
                            }, true);
                        }
                        /*Watch on the model, to check or uncheck the values of checkboxset*/
                        scope.$watch('_model_', function () {
                            if (scope.dataKeys && scope.checkedValues) {
                                var model = scope._model_;
                                if (WM.isString(model) && model !== '') {
                                    model = model.split(',');
                                }
                                _.forEach(scope.dataKeys, function (dataKey) {
                                    scope.checkedValues[dataKey] = valueInModel(model, dataKey, scope.dataObject[dataKey]);
                                });
                            }
                        }, false);

                        /*Called from form reset when users clicks on form reset*/
                        scope.reset = function () {
                            scope._model_ = [];
                        };

                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.widgets.form.directive:wmCheckboxset
 * @restrict E
 *
 * @description
 * The `wmCheckboxset` directive defines the checkboxset widget.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 * @requires $compile
 * @requires CONSTANTS
 * @requires Utils
 *
 * @param {string=} name
 *                  Name of the checkboxset widget.
 * @param {string=} hint
 *                  Title/hint for the checkboxset. <br>
 *                  This property is bindable.
 * @param {number=} tabindex
 *                  This property specifies the tab order of Checkboxset widget. <br>
 *                  Default value : 0
 * @param {string=} width
 *                  Width of the checkboxset.
 * @param {string=} height
 *                  Height of the checkboxset.
 * @param {string=} layout
 *                  This property controls how contained checkboxes are displayed within the widget container. <br>
 *                  Possible values are "inline", "stacked"
 * @param {string=} scopedatavalue
 *                  This property accepts the initial value for the Checkboxset widget from a variable defined in the script workspace. <br>
 * @param {string=} selectedvalues
 *                  This property defines the initial selected values of the checkboxset widget. <br>
 *                  Defined variable can hold a comma separated string or an array.
 * @param {object||string=} scopedataset
 *                  This property accepts the options to create the checkboxset widget from a variable defined in the script workspace.<br>
 *                  Defined variable can hold a comma separated string or an array.
 * @param {string=} dataset
 *                  This property accepts the options to create the checkboxset widget from a wavemaker studio variable (live or static) which can hold object, array or string data.
 * @param {boolean=} usekeys
 *                   Use the keys of the live variable object as checkboxset options.
 * @param {string=} datafield
 *                  This property sets the dataValue to be returned by a checkboxset widget when the list is populated using the dataSet property.
 * @param {string=} displayfield
 *                  This property sets the displayValue to show in the checkboxset widget when the list is populated using the dataSet property.
 * @param {expression=} displayexpression
 *                      This is an advanced property that gives more control over what is displayed in the checkboxset widget. <br>
 *                      A Display Expression uses a Javascript expression to format exactly what is shown. <br>
 *                      This property is bindable.
 * @param {boolean=} readonly
 *                   Readonly is a bindable property. <br>
 *                   This property will be used to make the checkboxset widget readonly on the web page. <br>
 *                   Default value: `false`. <br>
 * @param {boolean=} show
 *                  Show is a bindable property. <br>
 *                  This property will be used to show/hide the checkboxset widget on the web page. <br>
 *                  Default value: `true`. <br>
 * @param {boolean=} disabled
 *                  Disabled is a bindable property. <br>
 *                  This property will be used to disable/enable the checkboxset widget on the web page. <br>
 *                  Default value: `false`. <br>
 * @param {string=} on-change
 *                  Callback function which will be triggered when the widget value is changed.
 * @param {string=} on-focus
 *                  Callback function which will be triggered when the widget gets focused.
 * @param {string=} on-blur
 *                  Callback function which will be triggered when the widget loses focus.
 * @param {string=} on-click
 *                  Callback function which will be triggered when the widget is clicked.
 * @param {string=} on-mouseenter
 *                  Callback function which will be triggered when the mouse enters the widget.
 * @param {string=} on-mouseleave
 *                  Callback function which will be triggered when the mouse leaves the widget.
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
                <div>single click count: {{clickCount}}</div>
                <div>change count: {{changeCount}}</div>
                <div>mouse enter count: {{mouseenterCount}}</div>
                <div>mouse leave count: {{mouseleaveCount}}</div>
                <div>focus count: {{focusCount}}</div>
                <div>blur count: {{blurCount}}</div>

                <wm-composite>
                    <wm-label caption="Colors: "></wm-label>
                    <wm-checkboxset scopedatavalue="color" scopedataset=colors></wm-checkboxset>
                </wm-composite><br>
                <wm-composite>
                    <wm-label caption="Framework: "></wm-label>
                    <wm-checkboxset scopedatavalue="selectedItem" dataset="Backbone, CoffeeScript, Angular"></wm-checkboxset>
                </wm-composite><br>

                <div>
                    <div style="font-weight: bold; color: {{color[0]}};">{{selectedItem}}</div>
                 </div>
            </div>
        </file>
        <file name="script.js">
           function Ctrl($scope) {
               $scope.clickCount =
               $scope.changeCount =
               $scope.mouseenterCount =
               $scope.mouseleaveCount =
               $scope.focusCount =
               $scope.blurCount = 0;

               $scope.width = "100px";
               $scope.height= "30px";

               $scope.colors = ["crimson", "green", "orange", "red"];

               $scope.f = function (eventtype) {
                   $scope[eventtype + 'Count']++;
               }
            }
        </file>
   </example>
 */

/*global WM, */
/*Directive for Colorpicker */

WM.module('wm.widgets.form').requires = WM.module('wm.widgets.form').requires.concat(['colorpicker.module']);
/*Registering the colorpicker widget as a module.*/
WM.module('wm.widgets.form')
    /*Saving the colorpicker widget template using the $templateCache service.*/
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        /*Assigning the template to an identifier.*/
        $templateCache.put('template/widget/form/colorpicker.html',
            '<div title="{{hint}}" class="input-group app-colorpicker" data-ng-show="show" init-widget has-model role="input">' +
                '<input colorpicker colorpicker-parent="true" class="form-control app-textbox" ' +
                ' data-ng-disabled="readonly || disabled"' +
                ' data-ng-required="required"' +
                ' data-ng-model="_model_"' +
                ' data-ng-change="_onChange({$event: $event, $scope: this})"' +
                ' accesskey="{{shortcutkey}}"' +
                '><span class="input-group-addon" data-ng-style="{backgroundColor:_model_}">&nbsp;</span></div>');
    }])
    /*Colorpicker widget directive definition*/
    .directive('wmColorpicker', ['PropertiesFactory', '$templateCache', 'WidgetUtilService', function (PropertiesFactory, $templateCache, WidgetUtilService) {
        'use strict';
        /*Obtaining the widget properties from the Base configurations, by combining widget properties and it's parent group's properties.*/
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.colorpicker', ['wm.base', 'wm.base.events', 'wm.base.events.focus', 'wm.base.events.change']);

        return {
            'restrict': 'E',
            'scope': {},
            'replace': true,
            'template': function (tElement, tAttrs) {
                var isWidgetInsideCanvas = tAttrs.hasOwnProperty('widgetid'),
                    template = WM.element($templateCache.get('template/widget/form/colorpicker.html')),
                    target = template.children().first();

                /*setting the color picker widget name attribute to the inner input element*/
                template.find('input').attr('name', tAttrs.name);

                if (!isWidgetInsideCanvas) {
                    if (tAttrs.hasOwnProperty('onClick')) {
                        target.attr('data-ng-click', 'onClick({$event: $event, $scope: this})');
                    }

                    if (tAttrs.hasOwnProperty('onMouseenter')) {
                        target.attr('data-ng-mouseenter', 'onMouseenter({$event: $event, $scope: this})');
                    }

                    if (tAttrs.hasOwnProperty('onMouseleave')) {
                        target.attr('data-ng-mouseleave', 'onMouseleave({$event: $event, $scope: this})');
                    }

                    if (tAttrs.hasOwnProperty('onFocus')) {
                        target.attr('data-ng-focus', 'onFocus({$event: $event, $scope: this})');
                    }

                    if (tAttrs.hasOwnProperty('onBlur')) {
                        target.attr('data-ng-blur', 'onBlur({$event: $event, $scope: this})');
                    }
                }
                return template[0].outerHTML;
            },
            'compile': function () {
                return {
                    'pre': function (scope) {
                        /*Assigning the obtained widgetProps to the widget scope.*/
                        scope.widgetProps = widgetProps;
                    },
                    'post': function (scope, element, attrs) {
                        /*Called from form reset when users clicks on form reset*/
                        scope.reset = function () {
                            //TODO implement custom reset logic here
                            scope._model_ = '';
                        };
                        /*Executing WidgetUtilService method to initialize the widget with the essential configurations needed.*/
                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };

    }]);

/**
 * @ngdoc directive
 * @name wm.widgets.form.directive:wmColorpicker
 * @restrict E
 *
 * @description
 * The `wmColorpicker` directive defines the colorpicker widget.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires $templateCache
 * @requires WidgetUtilService
 *
 * @param {string=} name
 *                  Name of the colorpicker widget.
 * @param {string=} placeholder
 *                  Placeholder text for the widget. <br>
 * @param {number=} tabindex
 *                 This property specifies the tab order of Colorpicker widget. <br>
 *                  Default value : 0
 * @param {string=} scopedatavalue
 *                  This property accepts the value for the colorpicker widget from a variable defined in the script workspace. <br>
 *                  The scope variable is updated whenever there is a change in the colorpicker value.
 * @param {string=} datavalue
 *                  Value of the colorpicker widget. Accepts the value from a studio variable or from another widget's value.<br>
 *                  This property is bindable.
 * @param {boolean=} readonly
 *                   Readonly is a bindable property. <br>
 *                   This property will be used to make the colorpicker widget non-editable on the web page. <br>
 *                   Default value: `false`. <br>
 * @param {boolean=} show
 *                  Show is a bindable property. <br>
 *                  This property will be used to show/hide the colorpicker widget on the web page. <br>
 *                  Default value: `true`. <br>
 * @param {boolean=} disabled
 *                  Disabled is a bindable property. <br>
 *                  This property will be used to disable/enable the widget on the web page. <br>
 *                  Default value: `false`.
 * @param {string=} on-change
 *                  Callback function which will be triggered when the widget value is changed.
 * @param {string=} on-focus
 *                  Callback function which will be triggered when the widget gets focused.
 * @param {string=} on-blur
 *                  Callback function which will be triggered when the widget loses focus.
 * @param {string=} on-click
 *                  Callback function which will be triggered when the widget is clicked.
 * @param {string=} on-dblclick
 *                  Callback function which will be triggered when the widget is double clicked.
 * @param {string=} on-mouseenter
 *                  Callback function which will be triggered when the mouse enters the widget.
 * @param {string=} on-mouseleave
 *                  Callback function which will be triggered when the mouse leaves the widget.
 * @example
 *   <example module="wmCore">
 *       <file name="index.html">
 *           <div data-ng-controller="Ctrl" class="wm-app">
 *               <div>single click count: {{clickCount}}</div>
 *               <div>change count: {{changeCount}}</div>
 *               <div>mouse enter count: {{mouseenterCount}}</div>
 *               <div>mouse leave count: {{mouseleaveCount}}</div>
 *               <div>focus count: {{focusCount}}</div>
 *               <div>blur count: {{blurCount}}</div>
 *
 *               <div style="width:100px; height:100px; background-color: {{color}}">
 *               </div><br>
 *
 *               <div>colorpicker value: <span style="font-weight: bold; color: {{color}};">{{color}}</span></div><br>
 *
 *               <div style="font-weight: bold; color: {{color}};">Hello there. Change the way I look using the colorpicker widget.</div><br>
 *
 *               <wm-colorpicker
 *                   scopedatavalue="color"
 *                   on-click="f('click');"
 *                   on-change="f('change');"
 *                   on-focus="f('focus');"
 *                   on-blur="f('blur');"
 *                   on-mouseenter="f('mouseenter');"
 *                   on-mouseleave="f('mouseleave')">
 *               </wm-colorpicker><br>
 *           </div>
 *       </file>
 *       <file name="script.js">
 *          function Ctrl($scope) {
 *              $scope.clickCount =
 *              $scope.changeCount =
 *              $scope.mouseenterCount =
 *              $scope.mouseleaveCount =
 *              $scope.focusCount =
 *              $scope.blurCount = 0;
 *
 *              $scope.color = "blue";
 *
 *              $scope.f = function (eventtype) {
 *                  $scope[eventtype + 'Count']++;
 *              }
 *           }
 *       </file>
 *   </example>
 */

/*global WM, */
/*Directive for composite container */

WM.module('wm.widgets.form')
    .run(['$templateCache', function ($templateCache) {
        'use strict';

        $templateCache.put('template/widget/form/composite.html',
                '<div class="form-group app-composite-widget clearfix" init-widget apply-styles="container" role="input"' +
                ' data-ng-class="{\'caption-left\': captionposition == \'left\',\'caption-right\': captionposition == \'right\',\'caption-top\': captionposition == \'top\'}"' +
                ' title="{{hint}}"' +
                ' data-ng-disabled="disabled"' +
                ' data-ng-show="show"' +
                ' wmtransclude></div>'
            );
    }])
    .directive('wmComposite', ['PropertiesFactory', '$templateCache', 'WidgetUtilService', function (PropertiesFactory, $templateCache, WidgetUtilService) {
        'use strict';
        /*Obtaining properties specific to select widget by extending from all editor related widget properties*/
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.composite', ['wm.base', 'wm.layouts']),
            notifyFor = {
                'required': true
            };
        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
        function propertyChangeHandler(element, key, newVal) {
            switch (key) {
            case 'required':
                /*When a composite widget is set to required then it's label and input also set to required*/
                var labelEle = element.find('.control-label.ng-isolate-scope'),
                    inputEle = element.find('.form-control.ng-isolate-scope');
                WM.element(labelEle).isolateScope().required = newVal;
                WM.element(inputEle).isolateScope().required = newVal;
                break;
            }
        }

        return {
            'restrict': 'E',
            'replace': true,
            'transclude': true,
            'scope': {},
            'template': $templateCache.get('template/widget/form/composite.html'),
            'compile': function () {
                return {
                    'pre': function (scope) {
                        scope.widgetProps = widgetProps;
                    },
                    'post': function (scope, element, attrs) {

                        /* register the property change handler */
                        WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, element), scope, notifyFor);

                        //if the widget is not inside canvas.
                        if (!scope.widgetid) {
                            /* add for attribute for label and id attribute for the input elements */
                            var labelEl = element.find('label'),
                                inputEl = element.find('input, select, textarea'),
                                inputName;

                            if (labelEl.length === 1 && inputEl.length === 1) {
                                inputName = inputEl.attr('name');
                                inputEl.attr('id', inputName);
                                labelEl.attr('for', inputName);
                            }
                        }

                        /*Called from form reset when users clicks on form reset*/
                        scope.reset = function () {
                            //TODO implement custom reset logic here
                        };

                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]);


/**
 * @ngdoc directive
 * @name wm.widgets.form.directive:wmComposite
 * @restrict E
 *
 * @description
 * The directive defines a composite container which wraps our basic widgets inside.
 *
 * @scope
 *
 * @requires PropertiesFactory
 *
 * @param {string=} name
 *                  Name of the composite container.
 * @param {string=} hint
 *                  Title/hint for the container <br>
 *                  This property is bindable.
 * @param {boolean=} required
 *                  Required is a bindable property. <br>
 *                  This property determines required validation for a field. <br>
 *                  Default value: `false`.
 * @param {list=} captionposition
 *                 This property determines where is caption appears with respect to the field. <br>
 * @param {boolean=} show
 *                  Show is a bindable property. <br>
 *                  This property will be used to show/hide the container and the widgets inside, on the web page. <br>
 *                  Default value: `true`.
 * @param {string=} horizontalalign
 *                  Sets the alignment for the widgets inside the container. <br>
 *                  Possible values are ["left", "center", "top"] <br>
 *                  Default Value : 'left'
 *  @example
 *   <example module="wmCore">
 *       <file name="index.html">
 *           <div data-ng-controller="Ctrl" class="wm-app">
 *               <div>hint: {{hint}}</div>
 *               <wm-composite widget="text" name="Composite" hint="{{hint}}" horizontalalign="{{horizontalalign}}" bordercolor="#912121" borderstyle="solid" borderleft="1" bordertop="1" borderright="1" borderbottom="1" borderunit="px">
 *                  <wm-label name="label"></wm-label>
 *                  <wm-text name="text"></wm-text>
 *               </wm-composite><br>
 *
 *               <wm-composite>
 *                   <wm-label caption="Hint:"></wm-label>
 *                   <wm-text scopedatavalue="hint"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="Horizontal Align:"></wm-label>
 *                   <wm-text scopedatavalue="horizontalalign"></wm-text>
 *               </wm-composite>
 *
 *           </div>
 *       </file>
 *       <file name="script.js">
 *          function Ctrl($scope) {
 *              $scope.hint = "Text";
 *              $scope.horizontalalign = "center";
 *           }
 *       </file>
 *   </example>
 */

/*global WM */
/*Directive for currency */

WM.module('wm.widgets.form')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/widget/form/currency.html',
            '<div init-widget has-model class="input-group app-currency" data-ng-show="show" role="input"><span class="input-group-addon">{{currencysymbol}}</span>' +
                '<input type="number" class="form-control app-textbox app-currency-input" title="{{hint}}" apply-styles' +
                ' data-ng-model="_model_"' + /* _model_ is a private variable inside this scope */
                ' data-ng-readonly="readonly" ' +
                ' data-ng-required="required" ' +
                ' data-ng-disabled="disabled" ' +
                ' accesskey="{{shortcutkey}}"' +
                ' data-ng-change="_onChange({$event: $event, $scope: this})">' +
                '</div>'
            );
    }])
    .directive('wmCurrency', ['PropertiesFactory', '$templateCache', 'WidgetUtilService', '$locale', 'CURRENCYCONSTANTS', function (PropertiesFactory, $templateCache, WidgetUtilService, $locale, CURRENCYCONSTANTS) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.currency', ['wm.base', 'wm.base.editors.abstracteditors']),
            notifyFor = {
                'currency': true
            };

        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
        function propertyChangeHandler(scope, key, newVal) {
            switch (key) {
            case 'currency':
                if (CURRENCYCONSTANTS[newVal]) {
                    scope.currencysymbol = CURRENCYCONSTANTS[newVal].symbol;
                }
                break;
            }
        }

        return {
            'restrict': 'E',
            'replace': true,
            'scope': {},
            'template': function (tElement, tAttrs) {

                var isWidgetInsideCanvas = tAttrs.hasOwnProperty('widgetid'),
                    template = WM.element($templateCache.get('template/widget/form/currency.html')),
                    target = template.children().last();

                /*setting the currency widget name attribute to the inner input element*/
                target.attr('name', tAttrs.name);

                if (!isWidgetInsideCanvas) {

                    if (tAttrs.hasOwnProperty('minvalue')) {
                        target.attr('min', '{{minvalue}}');
                    }

                    if (tAttrs.hasOwnProperty('maxchars')) {
                        target.attr('maxlength', '{{maxchars}}');
                    }

                    if (tAttrs.hasOwnProperty('maxvalue')) {
                        target.attr('max', '{{maxvalue}}');
                    }

                    if (tAttrs.hasOwnProperty('onClick')) {
                        target.attr('data-ng-click', 'onClick({$event: $event, $scope: this})');
                    }

                    if (tAttrs.hasOwnProperty('onMouseenter')) {
                        target.attr('data-ng-mouseenter', 'onMouseenter({$event: $event, $scope: this})');
                    }

                    if (tAttrs.hasOwnProperty('onMouseleave')) {
                        target.attr('data-ng-mouseleave', 'onMouseleave({$event: $event, $scope: this})');
                    }

                    if (tAttrs.hasOwnProperty('onFocus')) {
                        target.attr('data-ng-focus', 'onFocus({$event: $event, $scope: this})');
                    }

                    if (tAttrs.hasOwnProperty('onBlur')) {
                        target.attr('data-ng-blur', 'onBlur({$event: $event, $scope: this})');
                    }
                }

                return template[0].outerHTML;
            },
            'compile': function () {
                return {
                    'pre': function (scope) {
                        scope.widgetProps = widgetProps;
                    },
                    'post': function (scope, element, attrs) {
                        /* to get the currency symbol from current locale*/
                        scope.$locale = $locale;

                        /* register the property change handler */
                        WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, scope), scope, notifyFor);

                        /*Called from form reset when users clicks on form reset*/
                        scope.reset = function () {
                            //TODO implement custom reset logic here
                            scope._model_ = '';
                        };

                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.widgets.form.directive:wmCurrency
 * @restrict E
 *
 * @description
 * The `wmCurrency` directive defines the currency widget.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires $templateCache
 * @requires WidgetUtilService
 * @requires $locale
 * @requires CURRENCYCONSTANTS
 *
 * @param {string=} name
 *                  Name of the currency widget.
 * @param {string=} placeholder
 *                  Placeholder for the currency.
 * @param {string=} currency
 *                  Currency symbol to be shown in the currency<br>
 *                  Default value: `USD`. <br>
 * @param {string=} hint
 *                  Title/hint for the currency. <br>
 *                  This is a bindable property.
 * @param {number=} tabindex
 *                  This property specifies the tab order of the currency widget.
 * @param {string=} width
 *                  Width of the currency.
 * @param {string=} height
 *                  Height of the currency.
 * @param {string=} scopedatavalue
 *                  variable defined in controller scope. The value of this variable is set as the value to be shown in the currency.
 * @param {string=} datavalue
 *                  Value to be shown in the currency. <br>
 *                  This is a bindable property.
 * @param {number=} minvalue
 *                  Minimum value for currency.
 * @param {number=} maxvalue
 *                  Maximum value for currency.
 * @param {boolean=} required
 *                  This property defines if the currency is a required field while form submission. <br>
 *                  Default value: `false`. <br>
 *                  The value of this variable is set as the value to be shown in the currency.
 * @param {boolean=} readonly
 *                  This property will be used to make the currency widget readonly on the web page. <br>
 *                  Default value: `false`. <br>
 * @param {boolean=} show
 *                  This is a bindable property. <br>
 *                  This property will be used to show/hide the currency widget on the web page. <br>
 *                  Default value: `true`. <br>
 * @param {boolean=} disabled
 *                  This is a bindable property. <br>
 *                  This property will be used to disable/enable the currency widget on the web page. <br>
 *                  Default value: `false`. <br>
 * @param {string=} on-change
 *                  Callback function which will be triggered when the widget value is changed.
 * @param {string=} on-focus
 *                  Callback function which will be triggered when the widget gets focused.
 * @param {string=} on-blur
 *                  Callback function which will be triggered when the widget loses focus.
 * @param {string=} on-click
 *                  Callback function which will be triggered when the widget is clicked.
 * @param {string=} on-mouseenter.
 *                  Callback function which will be triggered when the mouse enters the widget.
 * @param {string=} on-mouseleave
 *                  Callback function which will be triggered when the mouse leaves the widget.
 * @example
 *   <example module="wmCore">
 *       <file name="index.html">
 *           <div data-ng-controller="Ctrl" class="wm-app">
 *               <div>single click count: {{clickCount}}</div>
 *               <div>change count: {{changeCount}}</div>
 *               <div>mouse enter count: {{mouseenterCount}}</div>
 *               <div>mouse leave count: {{mouseleaveCount}}</div>
 *               <div>focus count: {{focusCount}}</div>
 *               <div>blur count: {{blurCount}}</div>
 *               <div>
 *                   <span style="font-weight:bold">Currency Amount:<span>
 *                   <span style="font-style:italic">{{amount}}</span>
 *               </div><br>
 *               <wm-currency
 *                  name="currency1"
 *                  hint="test"
 *                  scopedatavalue="amount"
 *                  minvalue="{{minvalue}}"
 *                  placeholder="{{placeholder}}"
 *                  currency="{{currency}}"
 *                  on-click="f('click');"
 *                  on-change="f('change');"
 *                  on-focus="f('focus');"
 *                  on-blur="f('blur');"
 *                  on-mouseenter="f('mouseenter');"
 *                  on-mouseleave="f('mouseleave')"
 *                  width="{{width}}"
 *                  height="{{height}}">
 *                </wm-currency><br><br>
 *               <wm-composite>
 *                   <wm-label caption="width:"></wm-label>
 *                   <wm-text scopedatavalue="width"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="height:"></wm-label>
 *                   <wm-text scopedatavalue="height"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="placeholder:"></wm-label>
 *                   <wm-text scopedatavalue="placeholder"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="minvalue:"></wm-label>
 *                   <wm-text type="number" scopedatavalue="minvalue"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="currency:"></wm-label>
 *                   <wm-select scopedatavalue="currency" scopedataset="currencysymbol"></wm-select>
 *               </wm-composite>
 *           </div>
 *       </file>
 *       <file name="script.js">
 *          function Ctrl($scope) {
 *              $scope.clickCount =
 *              $scope.changeCount =
 *              $scope.mouseenterCount =
 *              $scope.mouseleaveCount =
 *              $scope.focusCount =
 *              $scope.blurCount = 0;
 *              $scope.amount = 10;
 *              $scope.placeholder = "sample currency";
 *              $scope.width = "200px";
 *              $scope.height= "30px";
 *              $scope.currency= "USD";
 *              $scope.currencysymbol = ["USD", "INR", "EUR"];

 *
 *
 *              $scope.f = function (eventtype) {
 *                  $scope[eventtype + 'Count']++;
 *              }
 *           }
 *       </file>
 *   </example>
 */

/*global WM, _, moment */
/*Directive for date */

WM.module('wm.widgets.form')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/widget/form/date.html',
            '<div class="app-date input-group" init-widget has-model data-ng-show="show" role="input" apply-styles>' +
                '<input class="form-control app-textbox app-dateinput" uib-datepicker-popup={{datepattern}} date-disabled="excludeDays(date, mode) || excludeDates(date, mode)" ' +
                    ' title="{{hint}}" ' +
                    ' min-date=mindate max-date=maxdate is-open=isOpen' +
                    ' data-ng-model="_proxyModel" ' + /* _proxyModel is a private variable inside this scope */
                    ' data-ng-readonly="readonly" ' +
                    ' data-ng-required="required" ' +
                    ' data-ng-disabled="disabled" ' +
                    ' show-weeks={{showweeks}} ' +
                    ' accesskey="{{shortcutkey}}"' +
                    ' data-ng-change="_onChange({$event: $event, $scope: this})">' +
                '</input>' +
                /*Holder for the model for submitting values in a form*/
                '<input class="model-holder ng-hide" data-ng-disabled="disabled" data-ng-model="_model_">' +
                '<span class="input-group-btn">' +
                    '<button type="button" class="btn btn-default btn-date"><i class="glyphicon glyphicon-calendar"></i></button>' +
                '</span>' +
            '</div>'
            );
        $templateCache.put('template/device/widget/form/date.html',
            '<input type="date" class="form-control app-textbox app-dateinput" init-widget has-model role="input"' +
            ' step="any" ' +
            ' data-ng-model="_proxyModel" ' +
            ' data-ng-show="show" ' +
            ' data-ng-readonly="readonly" ' +
            ' data-ng-required="required" ' +
            ' data-ng-disabled="disabled" ' +
            ' data-ng-change="updateModel();_onChange({$event: $event, $scope: this});"> '
            );
    }])
    .directive('wmDate', ['$rootScope', 'PropertiesFactory', 'WidgetUtilService', '$templateCache', '$filter', 'FormWidgetUtils', function ($rs, PropertiesFactory, WidgetUtilService, $templateCache, $filter, FormWidgetUtils) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.date', ['wm.base', 'wm.base.editors.abstracteditors', 'wm.base.datetime']),
            notifyFor = {
                'readonly': true,
                'disabled': true,
                'timestamp': true,
                'autofocus': true,
                'excludedates': true
            };

        if ($rs.isMobileApplicationType) {
            /*date pattern is not supported for native date widget*/
            widgetProps.datepattern.show = false;
            widgetProps.excludedates.show = false;
            widgetProps.excludedays.show = false;
        }

        function propertyChangeHandler(scope, element, key, newVal, oldVal) {
            switch (key) {
            case 'readonly':
            case 'disabled':
                // prevent the click events on decrement/increment buttons
                element.css('pointer-events', newVal ? 'none' : 'all');
                break;
            case 'timestamp':
                /*Single equal is used not to update model if newVal and oldVal have same values with string and integer types*/
                if (newVal != oldVal) {
                    scope._model_ = newVal;
                }
                break;
            case 'excludedates':
                scope.proxyExcludeDates = FormWidgetUtils.getProxyExcludeDates(newVal);
                break;
            }
        }

        function getTimeStamp(val) {
            var epoch;
            if (val) {
                if (WM.isDate(val)) {
                    epoch = val.getTime();
                } else {
                    if (!isNaN(val)) {
                        val = parseInt(val, 10);
                    }
                    epoch = moment(val).valueOf();
                    epoch = isNaN(epoch) ? undefined : epoch;
                }
            }
            return epoch;
        }

        function _onClick(scope, evt) {
            scope.isOpen = !scope.isOpen;
            if (scope.onClick) {
                scope.onClick({$event: evt, $scope: scope});
            }
        }

        return {
            'restrict': 'E',
            'replace': true,
            'scope': {},
            'template': function (tElement, tAttrs) {
                var template = '',
                    isWidgetInsideCanvas,
                    target;

                if ($rs.isMobileApplicationType) {
                    template = WM.element(WidgetUtilService.getPreparedTemplate('template/device/widget/form/date.html', tElement, tAttrs));
                    return template[0].outerHTML;
                }

                template = WM.element($templateCache.get('template/widget/form/date.html'));
                isWidgetInsideCanvas = tAttrs.hasOwnProperty('widgetid');
                target = template.children('input.form-control');

                /*Set name for the model-holder, to ease submitting a form*/
                template.find('.model-holder').attr('name', tAttrs.name);
                if (!isWidgetInsideCanvas) {

                    template.find('.btn-date').attr('data-ng-click', '_onClick($event)');
                    template.find('.app-dateinput').attr('data-ng-click', '_onClick($event)');

                    if (tAttrs.hasOwnProperty('onMouseenter')) {
                        template.attr('data-ng-mouseenter', 'onMouseenter({$event: $event, $scope: this})');
                    }

                    if (tAttrs.hasOwnProperty('onMouseleave')) {
                        template.attr('data-ng-mouseleave', 'onMouseleave({$event: $event, $scope: this})');
                    }

                    if (tAttrs.hasOwnProperty('onFocus')) {
                        target.attr('data-ng-focus', 'onFocus({$event: $event, $scope: this})');
                    }

                    if (tAttrs.hasOwnProperty('onBlur')) {
                        target.attr('data-ng-blur', 'onBlur({$event: $event, $scope: this})');
                    }
                }

                return template[0].outerHTML;
            },
            'compile': function () {
                return {
                    'pre': function (scope) {
                        scope.widgetProps = widgetProps;
                        if ($rs.isMobileApplicationType) {
                            scope._nativeMode = true;
                        }
                    },
                    'post': function (scope, element, attrs) {
                        var onPropertyChange = propertyChangeHandler.bind(undefined, scope, element);

                        /* register the property change handler */
                        WidgetUtilService.registerPropertyChangeListener(onPropertyChange, scope, notifyFor);
                        WidgetUtilService.postWidgetCreate(scope, element, attrs);

                        scope._onClick = _onClick.bind(undefined, scope);

                        /*update the model when the device date is changed*/
                        scope.updateModel = function () {
                            scope._model_ = FormWidgetUtils.getUpdatedModel(scope.mindate, scope.maxdate, scope._model_, scope._proxyModel, scope._prevDate);
                            scope._prevDate = scope._model_;
                        };

                        /*Called from form reset when users clicks on form reset*/
                        scope.reset = function () {
                            //TODO implement custom reset logic here
                            scope._model_ = '';
                        };

                        /* _model_ acts as a converter for _proxyModel
                         * read operation of _model_/datavalue will return epoch format of the date
                         * write operation of _model_ will update _proxyModel with Date object.
                         *  */
                        Object.defineProperty(scope, '_model_', {
                            get: function () {
                                var timestamp = this._proxyModel ?  this._proxyModel.valueOf() : undefined;
                                this.timestamp = timestamp;
                                if (this.outputformat === "timestamp") {
                                    return timestamp;
                                }
                                if (!this.outputformat) {
                                    this.outputformat = 'yyyy-MM-dd';
                                }
                                return this._proxyModel ? $filter('date')(this._proxyModel, this.outputformat) : undefined;
                            },
                            set: function (val) {
                                var timestamp;
                                if (scope._nativeMode) {
                                    if (val) {
                                        /*set the proxymodel and timestamp if val exists*/
                                        timestamp = getTimeStamp(val);
                                        this._proxyModel = new Date(timestamp);
                                        this.timestamp = timestamp;
                                    } else {
                                        this._proxyModel = undefined;
                                    }
                                } else {
                                    this._proxyModel = val ? new Date(getTimeStamp(val)) : undefined;
                                }
                            }
                        });

                        scope.excludeDays = function (date, mode) {
                            return mode === 'day' && _.includes(attrs.excludedays, date.getDay());
                        };
                        scope.excludeDates = function (date, mode) {
                            return mode === 'day' && _.includes(scope.proxyExcludeDates, Date.parse(date));
                        };

                        /*set the default value*/
                        if (!attrs.datavalue && !attrs.scopedatavalue) {
                            if (scope._nativeMode) {
                                /*prevDate is used to keep a copy of prev selected date*/
                                scope._prevDate = scope._proxyModel = new Date();
                                scope.timestamp = getTimeStamp(scope._proxyModel);
                            } else {
                                scope._model_ = Date.now();
                            }
                        }
                        /*if datavalue exists set the model*/
                        if (attrs.datavalue) {
                            scope._model_ = attrs.datavalue;
                            if (scope._nativeMode) {
                                scope._proxyModel = new Date(attrs.datavalue);
                            }
                        }
                    }
                };
            }
        };
    }]);


/**
 * @ngdoc directive
 * @name wm.widgets.form.directive:wmDate
 * @restrict E
 *
 * @description
 * The directive defines a date  widget.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 * @requires $templateCache
 *
 * @param {string=} name
 *                  Name of the date widget.
 * @param {string=} placeholder
 *                  Placeholder for the date field
 * @param {string=} hint
 *                  Title/hint for the date <br>
 *                  This property is bindable.
 * @param {number=} tabindex
 *                  This property specifies the tab order for Date widget. <br>
 *                  Default value : 0
 * @param {string=} width
 *                  Width of the date widget.
 * @param {string=} scopedatavalue
 *                  This property accepts the value for the  Date widget from a variable defined in the script workspace. <br>
 * @param {string=} datavalue
 *                  This property defines the value of the date widget in pattern mm/dd/yyyy. <br>
 *                  This property is bindable.
 * @param {string=} datepattern
 *                  display pattern of dates. <br>
 *                  This property is bindable. <br>
 *                  Default value : 'dd-MM-yyyy'
 * @param {string=} outputformat
 *                  output format of the widget. <br>
 *                  Default value : 'yyyy-MM-dd'
 *@param {boolean=} required
 *                  required is a bindable property. <br>
 *                  if the required property is set to true, `required` class is applied to the label[an asterik will be displayed next to the content of the label']. <br>
 *                  Default value: `false`.
 * @param {string=} mindate
 *                  MinDate is the minimum date to start with. <br>
 *                  The default input pattern is mm/dd/yyyy
 * @param {string=} maxdate
 *                  MaxDate is the maximum date to end with. <br>
 *                  The default input pattern is mm/dd/yyyy
 * @param {string=} excludedays
 *                  Days which are to be excluded.<br>
 *                  Hint : sunday-0, saturday-6.
 * @param {string=} excludedates
 *                  Dates which are to be excluded.<br>
 *                  Hint : 'YYYY-MM-DD'.
 * @param {boolean=} autofocus
 *                   This property makes the widget get focused automatically when the page loads.
 * @param {boolean=} showweeks
 *                   When set, week number will be displayed in date-picker UI.<br>
 *                   Default value: `false`
 * @param {boolean=} readonly
 *                   Readonly is a bindable property. <br>
 *                   This property will be used to make the date widget non-editable on the web page. <br>
 *                   Default value: `false`. <br>
 * @param {boolean=} show
 *                  Show is a bindable property. <br>
 *                  This property will be used to show/hide the widget on the web page. <br>
 *                  Default value: `true`.
 * @param {boolean=} disabled
 *                  Disabled is a bindable property. <br>
 *                  This property will be used to disable/enable the widget on the web page. <br>
 *                  Default value: `false`.
 * @param {string=} on-change
 *                  Callback function which will be triggered when the widget value is changed.
 * @param {string=} on-focus
 *                  Callback function which will be triggered when the widget gets focused.
 * @param {string=} on-blur
 *                  Callback function which will be triggered when the widget loses focus.
 * @param {string=} on-click
 *                  Callback function which will be triggered when the widget is clicked.
 * @param {string=} on-mouseenter
 *                  Callback function which will be triggered when the mouse enters the widget.
 * @param {string=} on-mouseleave
 *                  Callback function which will be triggered when the mouse leaves the widget.
 * @example
 *   <example module="wmCore">
 *       <file name="index.html">
 *           <div data-ng-controller="Ctrl" class="wm-app">
 *               <wm-date name="date1"
 *                   on-change="f($event, $scope)"
 *                   placeholder="{{placeholder}}"
 *                   hint="Add a date"
 *                   datepattern="{{datepattern}}"
 *                   outputformat="{{outputformat}}"
 *                   mindate="{{mindate}}"
 *                  maxdate="{{maxdate}}"
 *                  excludedays="{{excludedays}}"
 *                  excludedates="{{excludedates}}">
 *               </wm-date><br>
 *               <div>Selected Date: {{currentDate}}</div><br>
 *               <div>timestamp: {{currentTimestamp}}</div><br>
 *               <wm-composite>
 *                   <wm-label caption="placeholder:"></wm-label>
 *                   <wm-text scopedatavalue="placeholder"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="datepattern:"></wm-label>
 *                   <wm-text scopedatavalue="datepattern"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="output format:"></wm-label>
 *                   <wm-text scopedatavalue="outputformat"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="mindate:"></wm-label>
 *                   <wm-text scopedatavalue="mindate"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="maxdate:"></wm-label>
 *                   <wm-text scopedatavalue="maxdate"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="excludedates:"></wm-label>
 *                   <wm-text scopedatavalue="excludedates"></wm-text>
 *               </wm-composite>
 *                <wm-composite>
 *                   <wm-label caption="excludedays:"></wm-label>
 *                   <wm-text scopedatavalue="excludedays"></wm-text>
 *               </wm-composite>
 *           </div>
 *       </file>
 *       <file name="script.js">
 *          function Ctrl($scope) {
 *              $scope.placeholder="Fix a date"
 *              $scope.datepattern="dd-MM-yy"
 *              $scope.outputformat = "yyyy, dd MMMM"
 *              $scope.mindate="01-01-2015"
 *              $scope.maxdate="01-01-2020"
 *              $scope.excludedates="2015-05-18, 2015-10-27"
 *              $scope.excludedays="0,6"
 *              $scope.f = function (event, scope) {
 *                  $scope.currentDate = scope.datavalue;
 *                  $scope.currentTimestamp = scope.timestamp;
 *              }
 *           }
 *       </file>
 *   </example>
 */

/*global WM, moment, _, document */
/*Directive for datetime */

WM.module('wm.widgets.form')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/widget/form/datetime.html',
            '<div class="app-datetime input-group" init-widget has-model apply-styles role="input"' +
            ' title="{{hint}}" data-ng-show="show" data-ng-model="_proxyModel">' + /* _proxyModel is a private variable inside this scope */
                '<input class="form-control app-textbox display-input" data-ng-model="_displayModel" accesskey="{{shortcutkey}}">' +
                '<input class="form-control app-textbox app-dateinput ng-hide" data-ng-change="selectDate($event)" date-disabled="excludeDays(date) || excludeDates(date)" data-ng-model="_dateModel" ' +
                    ' uib-datepicker-popup min-date=mindate max-date=maxdate is-open="isDateOpen" show-weeks="{{showweeks}}">' +
                '<div uib-dropdown is-open="isTimeOpen" class="dropdown">' +
                    '<div uib-dropdown-menu>' +
                        '<uib-timepicker data-ng-model="_timeModel" hour-step="hourstep" minute-step="minutestep" show-meridian="ismeridian" show-seconds="showseconds" data-ng-change="selectTime($event)"></uib-timepicker>' +
                    '</div>' +
                '</div>' +
                /*Holder for the model for submitting values in a form*/
                '<input class="model-holder ng-hide" data-ng-disabled="disabled" data-ng-model="_model_">' +
                '<span class="input-group-btn">' +
                    '<button type="button" class="btn btn-default btn-date"><i class="glyphicon glyphicon-calendar"></i></button>' +
                    '<button type="button" class="btn btn-default btn-time uib-dropdown-toggle"><i class="glyphicon glyphicon-time"></i></button>' +
                '</span>' +
            '</div>'
            );
        $templateCache.put('template/device/widget/form/datetime.html',
            '<input type="datetime-local" class="form-control app-textbox app-dateinput" init-widget has-model role="input"' +
            ' step="any" ' +
            ' data-ng-model="_proxyModel" ' +
            ' data-ng-show="show" ' +
            ' data-ng-readonly="readonly" ' +
            ' data-ng-required="required" ' +
            ' data-ng-disabled="disabled" ' +
            ' data-ng-change="updateModel();_onChange({$event: $event, $scope: this});"> '
            );
    }]).directive('wmDatetime', ['$rootScope', 'PropertiesFactory', 'WidgetUtilService', '$timeout', '$templateCache', '$filter', 'FormWidgetUtils', function ($rs, PropertiesFactory, WidgetUtilService, $timeout, $templateCache, $filter, FormWidgetUtils) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.datetime', ['wm.base', 'wm.base.editors.abstracteditors', 'wm.base.datetime']),
            notifyFor = {
                'readonly': true,
                'disabled': true,
                'autofocus': true,
                'timestamp': true,
                'excludedates': true,
                'datepattern': true
            };

        if ($rs.isMobileApplicationType) {
            /*date pattern is not supported for native date widget*/
            widgetProps.datepattern.show = false;
            widgetProps.hourstep.show = false;
            widgetProps.minutestep.show = false;
        }

        function _formatDateTime(scope) {
            var date,
                time,
                dateString,
                timeString,
                value;
            if (scope._timeModel || scope._dateModel) {
                time = scope._timeModel ? new Date(scope._timeModel) : new Date();
                date = scope._dateModel ? new Date(scope._dateModel) : new Date();
                dateString = $filter('date')(date, 'yyyy-MM-dd');
                timeString = $filter('date')(time, 'HH:mm:ss');
                value = moment(dateString + ' ' + timeString).valueOf();
                scope.timestamp = value;
                if (scope.datepattern && scope.datepattern !== 'timestamp') {
                    scope._displayModel = $filter('date')(value, scope.datepattern);
                } else {
                    scope._displayModel = value;
                }
                if (scope.outputformat && scope.outputformat !== 'timestamp') {
                    scope._proxyModel = $filter('date')(value, scope.outputformat);
                } else {
                    scope._proxyModel = value;
                }
            } else {
                scope._displayModel = undefined;
                scope._proxyModel = undefined;
            }
        }

        function propertyChangeHandler(scope, element, key, newVal, oldVal) {
            var inputEl = element.find('input'),
                buttonEl = element.find('button');
            switch (key) {
            case 'readonly':
            case 'disabled':
                inputEl.attr(key, newVal);
                buttonEl.attr('disabled', newVal);
                // prevent the click events on decrement/increment buttons
                element.css('pointer-events', newVal ? 'none' : 'all');
                break;
            case 'autofocus':
                inputEl.first().attr(key, newVal);
                break;
            case 'timestamp':
                /*Single equal is used not to update model if newVal and oldVal have same values with string and integer types*/
                if (newVal != oldVal) {
                    scope._model_ = newVal;
                }
                break;
            case 'excludedates':
                scope.proxyExcludeDates = FormWidgetUtils.getProxyExcludeDates(newVal);
                break;
            case 'datepattern':
                scope.showseconds = _.includes(newVal, 'ss');
                scope.ismeridian  = _.includes(newVal, 'hh');
                _formatDateTime(scope);
                break;
            }
        }

        function _onClick(scope, evt) {
            evt.stopPropagation();
            if (scope.onClick) {
                scope.onClick({$event: evt, $scope: scope});
            }
        }

        /*On click of date icon button, open the date picker popup*/
        function _onDateClick(scope, evt) {
            evt.stopPropagation();
            var dateOpen = scope.isDateOpen;
            $timeout(function () {
                WM.element(document).trigger('click');
                scope.isDateOpen = !dateOpen;
                scope.isTimeOpen = false;
            });
        }

        /*On click of time icon button, open the time picker popup*/
        function _onTimeClick(scope, evt) {
            evt.stopPropagation();
            var TimeOpen = scope.isTimeOpen;
            $timeout(function () {
                WM.element(document).trigger('click');
                scope.isTimeOpen = !TimeOpen;
                scope.isDateOpen = false;
            });
        }

        /* this function returns date object. If val is undefined it returns invalid date */
        function parseDateTime(val) {
            /* check if the val is date object */
            if (WM.isDate(val)) {
                return val;
            }
            /*if the value is a timestamp string, convert it to a number*/
            if (!isNaN(val)) {
                val = parseInt(val, 10);
            }
            return new Date(moment(val).valueOf());
        }

        return {
            restrict: 'E',
            replace: true,
            scope: {},
            template: function (tElement, tAttrs) {
                var template = '',
                    isWidgetInsideCanvas,
                    target;

                if ($rs.isMobileApplicationType) {
                    template = WM.element(WidgetUtilService.getPreparedTemplate('template/device/widget/form/datetime.html', tElement, tAttrs));
                    return template[0].outerHTML;
                }

                template = WM.element($templateCache.get('template/widget/form/datetime.html', tElement, tAttrs));
                isWidgetInsideCanvas = tAttrs.hasOwnProperty('widgetid');
                target = template.children('input.form-control');

                /*Set name for the model-holder, to ease submitting a form*/
                template.find('.model-holder').attr('name', tAttrs.name);
                if (!isWidgetInsideCanvas) {
                    template.attr('data-ng-click', '_onClick($event)');
                    template.find('.btn-date').attr('data-ng-click', '_onDateClick($event)');
                    template.find('.display-input').attr('data-ng-click', '_onDateClick($event)');
                    template.find('.btn-time').attr('data-ng-click', '_onTimeClick($event)');

                    if (tAttrs.hasOwnProperty('onMouseenter')) {
                        template.attr('data-ng-mouseenter', 'onMouseenter({$event: $event, $scope: this})');
                    }

                    if (tAttrs.hasOwnProperty('onMouseleave')) {
                        template.attr('data-ng-mouseleave', 'onMouseleave({$event: $event, $scope: this})');
                    }

                    if (tAttrs.hasOwnProperty('onFocus')) {
                        target.attr('data-ng-focus', 'onFocus({$event: $event, $scope: this})');
                    }

                    if (tAttrs.hasOwnProperty('onBlur')) {
                        target.attr('data-ng-blur', 'onBlur({$event: $event, $scope: this})');
                    }
                }

                return template[0].outerHTML;
            },
            compile: function () {
                return {
                    pre: function (scope) {
                        scope.widgetProps = widgetProps;
                        if ($rs.isMobileApplicationType) {
                            scope._nativeMode = true;
                        }
                    },
                    post: function (scope, element, attrs) {
                        var onPropertyChange = propertyChangeHandler.bind(undefined, scope, element);
                        /* register the property change handler */
                        WidgetUtilService.registerPropertyChangeListener(onPropertyChange, scope, notifyFor);
                        WidgetUtilService.postWidgetCreate(scope, element, attrs);

                        scope.formatDateTime = _formatDateTime.bind(undefined, scope);
                        scope._onClick = _onClick.bind(undefined, scope);
                        scope._onDateClick = _onDateClick.bind(undefined, scope);
                        scope._onTimeClick = _onTimeClick.bind(undefined, scope);

                        /*
                         * Backward compatibility for ismeridian property which is deprecated.
                         * if ismeridian is false then time is set as 24hr clock format.
                         */
                        if (attrs.ismeridian === 'false' && !attrs.datepattern) {
                            scope.datepattern = scope.datepattern.replace('hh', 'HH').replace(' a', '');
                        }

                        /*On selection of a date, open the time picker popup*/
                        scope.selectDate = function (event) {
                            if (scope.isDateOpen) {
                                scope.isTimeOpen = true;
                            }
                            scope.formatDateTime();
                            scope._onChange({$event: event, $scope: scope});
                        };
                        scope.selectTime = function (event) {
                            scope.formatDateTime();
                            scope._onChange({$event: event, $scope: scope});
                        };
                        /* handle initial readonly/disabled values */
                        $timeout(function () {
                            onPropertyChange('disabled', scope.disabled);
                            onPropertyChange('readonly', scope.readonly);
                        });

                        /*update the model with device datetime value*/
                        scope.updateModel = function () {
                            scope._model_ = FormWidgetUtils.getUpdatedModel(scope.mindate, scope.maxdate, scope._model_, scope._proxyModel, scope._prevDateTime);
                            scope._prevDateTime = scope._model_;
                        };

                        /*Called from form reset when users clicks on form reset*/
                        scope.reset = function () {
                            //TODO implement custom reset logic here
                            scope._model_ = '';
                        };

                        /* _model_ acts as a converter for _proxyModel
                         * read operation of _model_/datavalue will return epoch format of the date
                         * write operation of _model_ will update _proxyModel with Date object.
                         *  */
                        Object.defineProperty(scope, '_model_', {
                            get: function () {
                                if (!scope._nativeMode) {
                                    return this._proxyModel;
                                }
                                var timestamp = this._proxyModel ?  this._proxyModel.valueOf() : undefined;
                                this.timestamp = timestamp;
                                if (this.outputformat === "timestamp") {
                                    return timestamp;
                                }
                                if (!this.outputformat) {
                                    this.outputformat = 'yyyy-MM-dd';
                                }
                                return this._proxyModel ? $filter('date')(this._proxyModel, this.outputformat) : undefined;
                            },
                            set: function (val) {
                                var dateTime;
                                if (scope._nativeMode) {
                                    if (val) {
                                        dateTime = parseDateTime(val);
                                        this._proxyModel = new Date(dateTime.getFullYear(), dateTime.getMonth(), dateTime.getDate(), dateTime.getHours(), dateTime.getMinutes(), dateTime.getSeconds());
                                        this.timestamp = this._proxyModel.getTime();
                                    } else {
                                        this._proxyModel = undefined;
                                    }
                                } else {
                                    if (val) {
                                        dateTime = parseDateTime(val);
                                        if (dateTime.getTime()) {
                                            this._proxyModel = this._timeModel = dateTime.getTime();
                                            this._dateModel  = new Date(this._proxyModel);
                                        } else {
                                            this._proxyModel = this._dateModel = this._timeModel = undefined;
                                        }
                                    } else {
                                        this._proxyModel = this._dateModel = this._timeModel = undefined;
                                    }
                                    scope.formatDateTime();
                                }
                            }
                        });


                        scope.excludeDays = function (date) {
                            return _.includes(attrs.excludedays, date.getDay());
                        };

                        scope.excludeDates = function (date) {
                            return _.includes(scope.proxyExcludeDates, Date.parse(date));
                        };

                        /*Set the model if datavalue doesnt exists*/
                        if (!attrs.datavalue && !attrs.scopedatavalue) {
                            if (scope._nativeMode) {
                                scope._prevDateTime = scope._proxyModel = new Date();
                                scope.timestamp = scope._proxyModel.getTime();
                            } else {
                                scope._model_ = Date.now();
                            }
                        }

                        /*Set the model if datavalue exists*/
                        if (attrs.datavalue) {
                            scope._model_ = attrs.datavalue;
                            if (scope._nativeMode) {
                                scope._proxyModel = new Date(attrs.datavalue);
                            }
                        }
                    }
                };
            }
        };

    }]);


/**
 * @ngdoc directive
 * @name wm.widgets.form.directive:wmDatetime
 * @restrict E
 *
 * @description
 * The directive defines a date time  widget.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 * @requires $timeout
 *
 * @param {string=} name
 *                  Name of the time widget.
 * @param {string=} placeholder
 *                  Placeholder for the input field
 * @param {string=} hint
 *                  Title/hint for the time widget <br>
 *                  This property is bindable.
 * @param {number=} tabindex
 *                  This property specifies the tab order of time widget. <br>
 *                  Default value : 0
 * @param {string=} scopedatavalue
 *                  This property accepts the value for the  widget from a variable defined in the script workspace. <br>
 * @param {string=} datavalue
 *                  This property defines the value of the time widget. <br>
 *                  This property is bindable
 * @param {string=} timestamp
 *                  This property returns the unix timestamp (epoch) of the datavalue. <br>
 *                  This property can be used for intermediate calculations and validations. <br>
 * @param {string=} ismeridian
 *                  whether do display 12H or 24H. <br>
 * @param {string=} hourstep
 *                  Number of hours to increase or decrease
 * @param {string=} minutestep
 *                  Number of minutes to increase or decrease.
 * @param {string=} datepattern
 *                  display pattern of the date. <br>
 *                  This property is bindable. <br>
 *                  Default value : 'dd-MM-yyyy'
 * @param {string=} outputformat
 *                  output format of the widget. <br>
 *                  Default value : 'timestamp'
 * @param {string=} mindate
 *                  MinDate is the minimum date to start with. <br>
 *                  The default input pattern is mm/dd/yyyy
 * @param {string=} maxdate
 *                  MaxDate is the maximum date to end with. <br>
 *                  The default input pattern is mm/dd/yyyy
 * @param {string=} excludedays
 *                  Days which are to be excluded.<br>
 *                  Hint : sunday-0, saturday-6.
 * @param {string=} excludedates
 *                  Dates which are to be excluded.<br>
 *                  Hint : 'YYYY-MM-DD'.
 *@param {boolean=} required
 *                  required is a bindable property. <br>
 *                  if the required property is set to true, `required` class is applied to the label[an asterik will be displayed next to the content of the label']. <br>
 *                  Default value: `false`.
 * @param {boolean=} autofocus
 *                   This property makes the widget get focused automatically when the page loads.
 * @param {boolean=} showweeks
 *                   When set, week number will be displayed in date-picker UI.<br>
 *                   Default value: `false`
 * @param {boolean=} readonly
 *                   Readonly is a bindable property. <br>
 *                   This property will be used to make the time widget readonly on the web page. <br>
 *                   Default value: `false`. <br>
 * @param {boolean=} show
 *                  Show is a bindable property. <br>
 *                  This property will be used to show/hide the widget on the web page. <br>
 *                  Default value: `true`.
 * @param {boolean=} disabled
 *                  Disabled is a bindable property. <br>
 *                  This property will be used to disable/enable the widget on the web page. <br>
 *                  Default value: `false`.
 * @param {string=} on-change
 *                  Callback function which will be triggered when the widget value is changed.
 * @param {string=} on-focus
 *                  Callback function which will be triggered when the widget gets focused.
 * @param {string=} on-blur
 *                  Callback function which will be triggered when the widget loses focus.
 * @param {string=} on-click
 *                  Callback function which will be triggered when the widget is clicked.
 * @param {string=} on-mouseenter
 *                  Callback function which will be triggered when the mouse enters the widget.
 * @param {string=} on-mouseleave
 *                  Callback function which will be triggered when the mouse leaves the widget.
 * @example
 *   <example module="wmCore">
 *       <file name="index.html">
 *           <div data-ng-controller="Ctrl" class="wm-app">
 *               <wm-datetime
 *                  on-change="f($event, $scope)"
 *                  name="time1"
 *                  placeholder="set the time"
 *                  hourstep="{{hourstep}}"
 *                  minutestep="{{minutestep}}"
 *                  ismeridian="{{ismeridian}}"
 *                  datepattern="{{datepattern}}"
 *                  outputformat="{{outputformat}}"
 *                  mindate="{{mindate}}"
 *                  maxdate="{{maxdate}}"
 *                  excludedays="{{excludedays}}"
 *                  excludedates="{{excludedates}}">
 *               </wm-datetime><br>
 *
 *               <div>Selected Time: {{currentTime}}</div><br>
 *               <div>timestamp: {{currentTimestamp}}</div><br>
 *               <wm-composite>
 *                   <wm-label caption="datepattern:"></wm-label>
 *                   <wm-text scopedatavalue="datepattern"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="output format:"></wm-label>
 *                   <wm-text scopedatavalue="outputformat"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="mindate:"></wm-label>
 *                   <wm-text scopedatavalue="mindate"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="maxdate:"></wm-label>
 *                   <wm-text scopedatavalue="maxdate"></wm-text>
 *               </wm-composite>
 *                <wm-composite>
 *                   <wm-label caption="excludedates:"></wm-label>
 *                   <wm-text scopedatavalue="excludedates"></wm-text>
 *               </wm-composite>
 *                <wm-composite>
 *                   <wm-label caption="excludedays:"></wm-label>
 *                   <wm-text scopedatavalue="excludedays"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="ismeridian :"></wm-label>
 *                   <wm-text scopedatavalue="ismeridian"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="hourstep:"></wm-label>
 *                   <wm-text scopedatavalue="hourstep"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="minutestep:"></wm-label>
 *                   <wm-text scopedatavalue="minutestep"></wm-text>
 *               </wm-composite>
 *
 *           </div>
 *       </file>
 *       <file name="script.js">
 *          function Ctrl($scope) {
 *              $scope.ismeridian="true"
 *              $scope.hourstep="2"
 *              $scope.minutestep="4"
*               $scope.datepattern="dd-MM-yy hh:mm a"
 *              $scope.outputformat = "yyyy, dd MMMM hh:mm a"
 *              $scope.mindate="01-01-2015"
 *              $scope.maxdate="01-01-2020"
 *              $scope.excludedates="2015-05-18, 2015-10-27"
 *              $scope.excludedays="0,6"
 *              $scope.f = function (event,scope) {
 *                  $scope.currentTime = scope.datavalue;
 *                  $scope.currentTimestamp = scope.timestamp;
 *              }
 *           }
 *       </file>
 *   </example>
 */


/*global WM,document,FormData, _*/
/*jslint sub: true */
/*global window*/
/*Directive for fileupload */

WM.module('wm.widgets.form')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/widget/form/fileupload.html',
                '<div data-ng-show="show" class="app-fileupload" init-widget apply-styles="shell" role="input">' +
                    /* drag and drop files UI in web */
                    '<div data-ng-show="multiple" class="app-multi-file-upload" data-ng-if="!_isMobileType">' +
                        '<div class="drop-box" drag-files="onFileSelect($event,$files)">' +
                            '<i class="{{iconclass}}"/>' +
                            '<div class="message">' +
                                '<label data-ng-bind="caption"></label>' +
                                    '<form class="form-horizontal" name="{{scope.formName}}">' +
                                        '<input class="file-input" type="file" name="files" on-file-select="onFileSelect($event, $files)" data-ng-attr-accept="{{chooseFilter}}" multiple data-ng-disabled="disabled">' +
                                        '<a href="javascript:void(0);" class="app-anchor" data-ng-bind="fileuploadmessage"></a>' +
                                    '</form>' +
                            '</div>' +
                        '</div>' +
                    '</div>' +
                    /* single file upload in web and single , multiple file upload UI in mobile runmode*/
                    '<div class="app-single-file-upload" data-ng-show="!multiple || _isMobileType" data-ng-if="!_isCordova">' +
                        '<div class="app-button-wrapper">' +
                            '<form class="form-horizontal" name="{{scope.formName}}">' +
                            /* support for file upload in Mobileapp in its runmode (Web) */
                                '<input class="file-input" type="file" name="files" data-ng-if="multiple" on-file-select="onFileSelect($event, $files)" data-ng-attr-accept="{{chooseFilter}}" data-ng-disabled="disabled" multiple>' +
                                '<input class="file-input" type="file" name="files" data-ng-if="!multiple" on-file-select="onFileSelect($event, $files)" data-ng-attr-accept="{{chooseFilter}}" data-ng-disabled="disabled">' +
                                '<button class="app-button btn btn-default">' +
                                    '<i class="{{iconclass}}"></i> ' +
                                    '<span>{{caption}}</span>' +
                                '</button>' +
                            '</form>' +
                        '</div>' +
                        '<div class="app-files-upload-status single"></div>' +
                    '</div>' +
                    /* support for file upload in Mobile Application (device) */
                    '<button data-ng-if="_isCordova" class="app-button btn btn-default" data-ng-click="openFileSelector()" data-ng-disabled="disabled">' +
                        '<i class="{{iconclass}}"></i> ' +
                        '<span>{{caption}}</span>' +
                    '</button>' +
                    /* list of selectedfiles UI */
                    '<ul class="list-group file-upload" data-ng-style="{height: height, overflow: overflow}" data-ng-if="selectedFiles.length > 0 && mode === \'Select\'" >' +
                        '<li class="list-group-item file-upload-status container" data-ng-repeat="ft in selectedFiles" >' +
                            '<div class="media upload-file-list">' +
                                '<div class="media-left media-middle file-icon {{getFileExtension(ft.name) | fileIconClass}}" title="{{getFileExtension(ft.name)}}"></div>' +
                                '<div class="media-body media-middle file-details">' +
                                    '<label class="upload-title">{{ft.name}}</label><br/>' +
                                    '<span class="filesize" data-ng-if="ft.fileLength  !== 0">{{ft.size | filesize:0}}</span>' +
                                '</div>' +
                            '</div>' +
                        '</li>' +
                    '</ul>' +
                    /* list of uploadedfiles UI */
                    '<ul class="list-group file-upload"  data-ng-style="{height: height, overflow: overflow}" data-ng-if="fileTransfers.length > 0 && mode === \'Upload\'" >' +
                        '<li class="list-group-item file-upload-status container {{ft.status}}" data-ng-hide="ft.status === \'abort\'" data-ng-repeat="ft in fileTransfers | filter : {status : \'!abort\'}" >' +
                            '<div class="media upload-file-list">' +
                                '<div class="media-left media-middle file-icon {{getFileExtension(ft.name) | fileIconClass}}" title="{{getFileExtension(ft.name)}}">' +
                                '</div>' +
                                '<div class="media-body media-middle file-details">' +
                                    '<div class="file-detail">' +
                                        '<p class="uploaddetails">' +
                                            '<label class="upload-title col-xs-8">{{ft.name}}</label>' +
                                            '<span class="text-muted filesize" data-ng-if="ft.fileLength  !== 0">{{ft.size | filesize:0}}</span>' +
                                        '</p>' +
                                        '<div class="progress" data-ng-show="ft.status === \'inprogress\'">' +
                                            '<div class="progress-bar progress-bar-striped progress-bar-info" data-ng-style="{width: (ft.progress +\'%\')}"></div>' +
                                        '</div>' +
                                    '</div>' +
                                '</div>' +
                                '<div class="media-right media-middle" data-ng-if="ft.status === \'inprogress\' || ft.status === \'queued\'">' +
                                    '<a class="btn btn-transparent" type="button" ng-click="abortUpload($event, ft)">' +
                                        '<i class="fa fa-remove"></i>' +
                                    '</a>' +
                                '</div>' +
                                '<div class="media-right media-middle status" data-ng-if="mode === \'Upload\'" data-ng-hide="ft.status === \'abort\' || ft.status === \'inprogress\'">' +
                                    '<span class="status-icon {{ft.status | stateClass }}"></span>' +
                                '</div>' +
                            '</div>' +
                        '</li>' +
                    '</ul>' +
                '</div>');
    }])
    .directive('onFileSelect', ['$parse', '$timeout', function ($parse, $timeout) {
        'use strict';
        return function (scope, elem, attrs) {
            /*get the function reference from the directive*/
            var fn = $parse(attrs['onFileSelect']);
            elem.bind('change', function (evt) {
                /* get the selected file references */
                var files = [], fileList, i;
                if (window.FormData) {
                    fileList = evt.target.files;
                    if (fileList.length !== null) {
                        for (i = 0; i < fileList.length; i += 1) {
                            files[i] = fileList.item(i);
                        }
                    }
                } else { // for IE9, IE9 doesn't have FormData File API
                    files = [this.value];
                }
                /* call the function by passing file references */
                $timeout(function () {
                    fn(scope, {
                        $files: files,
                        $event: evt
                    });
                });
            });
            /* make previous value to null if user selects files again */
            elem.bind('click', function () {
                this.value = null;
            });
        };
    }])
    /* Test directive to test drag and drop test of browser */
    .directive('dropAvailable', ['$parse', '$timeout', function ($parse, $timeout) {
        'use strict';
        return function (scope, elem, attrs) {
            /*check whether dom element contains draggable element*/
            if (document.createElement('span').hasOwnProperty('draggable')) {
                var fn = $parse(attrs['dropAvailable']);
                $timeout(function () {
                    fn(scope);
                });
            }
        };
    }])
    .directive('dragFiles', ['$parse', '$timeout', function ($parse, $timeout) {
        'use strict';
        return function (scope, elem, attrs) {
            /*check whether dom element contains draggable element*/
            var div = document.createElement('div'), fn,
                dragDropSupport = ('draggable' in div) || ('ondragstart' in div && 'ondrop' in div);
            if (dragDropSupport) {
                fn = $parse(attrs['dragFiles']);
                elem.bind('dragenter', function (evt) {
                    evt.preventDefault();
                });
                elem.bind('dragover', function (evt) {
                    evt.stopPropagation();
                    evt.preventDefault();
                    /*add specific class for styling when user dragged into drop box*/
                    elem.addClass('file-dragover');
                });
                elem.bind('dragleave', function () {
                    elem.removeClass('file-dragover');
                });
                elem.bind('drop', function (evt) {
                    evt.stopPropagation();
                    evt.preventDefault();
                    elem.removeClass('file-dragover');
                    /* get the dropped file references */
                    var files = [],
                        fileList = evt.originalEvent.dataTransfer.files,
                        i;
                    if (fileList !== null) {
                        for (i = 0; i < fileList.length; i += 1) {
                            files.push(fileList.item(i));
                        }
                    }
                    /* pass the file references to parsed function and invocate it*/
                    $timeout(function () {
                        fn(scope, {
                            $files: files,
                            $event: evt
                        });
                    });
                });

            }
        };
    }])
    .directive('wmFileupload', ['PropertiesFactory', '$templateCache', 'WidgetUtilService', '$compile', '$timeout', 'wmToaster', 'Utils', 'Variables', 'ServiceFactory', '$rootScope', 'VARIABLE_CONSTANTS', '$servicevariable', 'CONSTANTS', 'DialogService', 'FileUploadService', 'FileSelectorService', function (PropertiesFactory, $templateCache, WidgetUtilService, $compile, $timeout, wmToaster, Utils, Variables, ServiceFactory, $rootScope, VARIABLE_CONSTANTS, $servicevariable, CONSTANTS, DialogService, FileUploadService, FileSelectorService) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.fileupload', ['wm.base', 'wm.base.editors', 'wm.base.events.successerror']),
            selectedUploadTypePath,
            notifyFor = {
                'uploadpath': true,
                'contenttype': true,
                'service': true,
                'operation': true,
                'mode': true,
                'multiple': true
            },
            MODE = {
                'SELECT' : 'Select',
                'UPLOAD' : 'Upload'
            },
            DEFAULT_CAPTIONS = {
                'MULTIPLE_UPLOAD'   : "Drop your files here to start uploading.",
                'MULTIPLE_SELECT'   : "Drop your files here.",
                'UPLOAD'            : 'Upload',
                'SELECT'            : 'Select'
            },
            FILESIZE_MB = 1048576;

        /* this function returns the uploadUrl */
        function constructUrl(uploadUriPrefix, service, operation, destination) {
            var uploadUrl = '/file/uploadFile',
                variableObject,
                variableFilterData = {
                    'service'   : service,
                    'operation' : operation,
                    'category'  : 'wm.ServiceVariable'
                };
            uploadUriPrefix = uploadUriPrefix || '';
            destination     = destination ? '?relativePath=' + destination : '';
            /*fetching the variable object with service, operation*/
            variableObject = Variables.filterByVariableKeys(variableFilterData, true)[0];
            if (variableObject) {
                uploadUrl = variableObject.wmServiceOperationInfo.relativePath;
            }
            return uploadUriPrefix + uploadUrl + destination;
        }

        function getAllServices(onSuccess) {
            ServiceFactory.getServicesWithType(function (response) {
                Utils.triggerFn(onSuccess, _.map(response, 'name'));
            });
        }

        /*emit event to workspace to create a service variable*/
        function createVariable(widgetId, service, operation) {
            var serviceType = ServiceFactory.getServiceObjectByName(service).type;
            $rootScope.$emit("create-service-variable", service, serviceType, operation);
            /*Saving service and operation in markup*/
            $rootScope.$emit("set-markup-attr", widgetId, {'service': service, 'operation': operation});
        }

        /* function to call user-defined on-error fn*/
        function onUploadError(scope, event) {
            Utils.triggerFn(scope.onError, {'$event': event, '$scope': scope});
            if (!scope.multiple) {
                wmToaster.show('error',  'File upload failed');
            }
        }

        /* upload progress callback , called when upload is progress */
        function onUploadProgress(scope, event) {
            Utils.triggerFn(scope.onProgress, {'$event': event, '$scope': scope});
        }

        /* when upload cancelled by user, this callback will be called */
        function onUploadAbort(scope, event) {
            Utils.triggerFn(scope.onAbort, {'$event': event, '$scope': scope});
        }

        /* this function returns the response on upload success */
        function getSuccessResponse(event) {
            var response;
            if (event.target.status === 200) {
                /* Checking for empty error String from server response*/
                response = Utils.getValidJSON(event.target.response);
                if (response && response.result && response.result.error) {
                    /* Faking Internal Server Error (500) */
                    event.target.status = 500;
                    response = undefined;
                }
            }
            return response;
        }

        /* upload success callback , called when upload is sucess */
        function onUploadSuccess(scope, event) {
            if (window.FormData) { // Check for IE9
                var response = getSuccessResponse(event);
                if (response) {
                    scope.filename = _.map(response, 'fileName').join(scope.fileNameSeperator);
                    scope.filepath = _.map(response, 'path').join(scope.fileNameSeperator);
                    scope.uploadedFiles = response;
                } else {
                    onUploadError(scope, event);
                    return;
                }
            }
            Utils.triggerFn(scope.onSuccess, {'$event': event, '$scope': scope});
            if (!scope.multiple) {
                wmToaster.show('success', 'File Uploaded');
            }
        }

        /* Checking if the selected file is valid for the choosen filter type */
        function isValidFile(filename, contenttype, extensionName) {
            var isValid,
                contentTypes;
            if (!contenttype) {
                return true;
            }
            contentTypes = contenttype.split(',');

            if (_.includes(contentTypes, 'image/*')) {
                isValid = Utils.isImageFile(filename);
                /*If one of the content type chosen is image/* and user uploads image it is valid file*/
                if (isValid) {
                    return isValid;
                }
            }
            if (_.includes(contentTypes, 'audio/*')) {
                isValid = Utils.isAudioFile(filename);
                /*If one of the content type chosen is audio/* and user uploads audio it is valid file*/
                if (isValid) {
                    return isValid;
                }
            }
            if (_.includes(contentTypes, 'video/*')) {
                isValid = Utils.isVideoFile(filename);
                /*If one of the content type chosen is video/* and user uploads video it is valid file*/
                if (isValid) {
                    return isValid;
                }
            }
            /*content type and the uploaded file extension should be same*/
            if (_.includes(contentTypes, '.' + extensionName)) {
                isValid = true;
            }
            return isValid;
        }

        /* this return the array of files which are having the file size not more than maxfilesize and filters based on contenttype */
        function getValidFiles($files, scope) {
            var validFiles = [],
                MAXFILEUPLOAD_SIZE = parseInt(scope.maxfilesize, 10) * FILESIZE_MB || FILESIZE_MB,
                MAX_FILE_UPLOAD_FORMATTED_SIZE = (scope.maxfilesize || '1') + 'MB';

            _.forEach($files, function (file) {
                /* check for the file content type before uploading */
                if (!isValidFile(file.name, scope.chooseFilter, scope.getFileExtension(file.name))) {
                    Utils.triggerFn(scope.onError);
                    wmToaster.show('error', 'Expected a ' + scope.contenttype + ' file');
                    return;
                }
                if (file.size > MAXFILEUPLOAD_SIZE) {
                    Utils.triggerFn(scope.onError);
                    wmToaster.show('error', 'File size exceeded limit. Max upload size is ' + MAX_FILE_UPLOAD_FORMATTED_SIZE);
                    return;
                }
                validFiles.push(file);
            });
            return validFiles;
        }

        /* this function uploads the validfiles */
        function uploadFiles($files, scope, uploadOptions) {
            var uploadUrl = constructUrl(scope.uploadUrl, scope.service, scope.operation, scope.destination);
            scope.fileTransfers = FileUploadService.upload($files, uploadUrl, uploadOptions);
            _.map(scope.fileTransfers, function (ft) {
                ft.then(onUploadSuccess.bind(undefined, scope),
                    onUploadError.bind(undefined, scope),
                    onUploadProgress.bind(undefined, scope));
            });
        }

        /*Overwrite the caption only if they are default*/
        function getCaption(caption, mode, isMultiple, isMobileType) {
            if (_.includes(DEFAULT_CAPTIONS, caption)) {
                if (mode === MODE.UPLOAD) {
                    return isMultiple && !isMobileType ? DEFAULT_CAPTIONS.MULTIPLE_UPLOAD : DEFAULT_CAPTIONS.UPLOAD;
                }
                if (mode === MODE.SELECT) {
                    return isMultiple && !isMobileType ? DEFAULT_CAPTIONS.MULTIPLE_SELECT : DEFAULT_CAPTIONS.SELECT;
                }
            }
            return caption;
        }

        return {
            restrict: 'E',
            replace: true,
            scope: {
                'onSelect': '&',
                'onSuccess': '&',
                'onError': '&',
                'onProgress': '&',
                'onAbort': '&'
            },
            template: $templateCache.get('template/widget/form/fileupload.html'),
            compile: function () {
                return {
                    pre: function (scope) {
                        /*Applying widget properties to directive scope*/
                        scope.widgetProps = widgetProps;
                        scope._isMobileType = $rootScope.isMobileApplicationType;
                        scope._isCordova = CONSTANTS.hasCordova;
                    },

                    post: function (scope, element, attrs) {
                        /*if the fileupload widget is inside prefab, then widget id will not be present.*/
                        var isStudioMode = CONSTANTS.isStudioMode && scope.widgetid,
                            parentPrefabScope = element.closest('.app-prefab').isolateScope(),
                            CONSTANT_FILE_SERVICE = 'FileService';
                        scope.uploadData = {
                            file: undefined,
                            uploadPath: undefined
                        };
                        scope.formName = scope.name + (scope.multiple ? '-multiple-fileupload' : '-single-fileupload');
                        scope.chooseFilter = '';
                        scope.fileNameSeperator = ";";
                        scope.uploadedFiles = {
                            "fileName": "",
                            "path": "",
                            "length": "",
                            "status": ""
                        };
                        scope.reset = function () {
                            scope.uploadedFiles = [];
                        };
                        scope.uploadUrl = (parentPrefabScope && parentPrefabScope.prefabname) ? ('prefabs/' + parentPrefabScope.prefabname) : 'services';
                        /*fetching the list of the services only in studio mode for properties panel*/
                        if (isStudioMode) {
                            getAllServices(function (services) {
                                scope.widgetProps.service.options = services;
                            });
                            $rootScope.$on('update-fileupload', function (event, widgetId, serviceId) {
                                if (scope.widgetid === widgetId) {
                                    scope.service = serviceId;
                                    getAllServices(function (services) {
                                        scope.widgetProps.service.options = services;
                                    });
                                }
                            });
                        }
                        /* BOYINA: Need to check why we need this.
                        scope.uploadData = _.map(files, function (f) {
                            return {
                                file: f,
                                uploadPath: selectedUploadTypePath
                            };
                        });*/

                        /* change server path based on user option */
                        scope.changeServerUploadPath = function (path) {
                            selectedUploadTypePath = path;
                        };

                        /* this function aborts the file transfer */
                        scope.abortUpload = function (event, ft) {
                            ft.abort();
                            onUploadAbort(scope, event);
                        };

                        //Need this only in mobile
                        if (CONSTANTS.hasCordova) {
                            scope.openFileSelector = function () {
                                var uploadOptions = {formName: scope.formName};
                                /* open the file selector */
                                FileSelectorService.open({multiple: scope.multiple}, function (files) {
                                    /* check if the files are having not more than maxfilesize */
                                    files = getValidFiles(files, scope);

                                    if (scope.mode === MODE.SELECT) {
                                        scope.selectedFiles = files;
                                        return;
                                    }
                                    uploadFiles(files, scope, uploadOptions);
                                });
                            };
                        }
                        /* this function returns the fileextension */
                        scope.getFileExtension = function (fileName) {
                            if (fileName && _.includes(fileName, '.')) {
                                return fileName.substring(fileName.lastIndexOf('.') + 1);
                            }
                            return 'file';
                        };

                        /*this function to append upload status dom elements to widget */
                        scope.onFileSelect = function ($event, $files) {
                            var uploadOptions = { formName : scope.formName};
                            scope.onSelect({
                                $event: WM.extend($event.$files || {}, $files),
                                $scope: scope
                            });
                            $files = getValidFiles($files, scope);
                            if (scope.mode === MODE.UPLOAD) {
                                uploadFiles($files, scope, uploadOptions);
                            } else {
                                scope.selectedFiles = $files;
                            }
                        };

                        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
                        function propertyChangeHandler(key, newVal) {
                            /*Monitoring changes for styles or properties and accordingly handling respective changes.*/
                            switch (key) {
                            case 'uploadpath':
                                //BOYINA: why do we need uploadpath
                                scope.changeServerUploadPath(newVal);
                                break;
                            case 'contenttype':
                                scope.chooseFilter = newVal.split(" ").join(",");
                                break;
                            case 'service':
                                if (isStudioMode) {
                                    if (scope.service === CONSTANT_FILE_SERVICE && !scope.operation) {
                                        scope.operation = 'uploadFile';
                                    }
                                    ServiceFactory.getServiceOperations(scope.service, function (response) {
                                        /*Pushing the operation options into the widget properties*/
                                        scope.widgetProps.operation.options = _.map(response, 'name');
                                    });
                                }
                                break;
                            case 'operation':
                                if (isStudioMode &&  scope.service && scope.operation) {
                                    createVariable(scope.widgetid, scope.service, scope.operation);
                                }
                                break;
                            case 'mode':
                            case 'multiple':
                                scope.formName = scope.name + (scope.multiple ? '-multiple-fileupload' : '-single-fileupload');
                                scope.caption = getCaption(scope.caption, scope.mode, scope.multiple, scope._isMobileType);
                                break;
                            }
                        }
                        /* register the property change handler */
                        WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler, scope, notifyFor);

                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };

    }])
    /* custom filter returns the filesize along with units */
    .filter('filesize', ['wmToaster', 'Utils', function () {
        'use strict';
        var units = [
            'bytes',
            'KB',
            'MB',
            'GB',
            'TB',
            'PB'
        ];

        return function (bytes, precision) {
            if (isNaN(parseFloat(bytes)) || !isFinite(bytes)) {
                return '?';
            }
            var unit = 0;
            while (bytes >= 1024) {
                bytes /= 1024;
                unit++;
            }
            return bytes.toFixed(+precision) + ' ' + units[unit];
        };
    }])
    /* custom filter returns the icons depending on file upload status*/
    .filter('stateClass', function () {
        'use strict';
        var stateClassMap = {
            'success'   : 'glyphicon glyphicon-ok-sign text-success',
            'error'     : 'glyphicon glyphicon-remove-sign text-danger'
        };
        return function (state) {
            return stateClassMap[state.toLowerCase()];
        };
    })
    /* custom filter returns the fileicons depending on the fileextension */
    .filter('fileIconClass', function () {
        'use strict';
        var fileClassMapping = {
            'zip'       :   'fa-file-zip-o',
            'pdf'       :   'fa-file-pdf-o',
            'rar'       :   'fa-file-archive-o',
            'txt'       :   'fa-file-text-o',
            'ppt'       :   'fa-file-powerpoint-o',
            'pot'       :   'fa-file-powerpoint-o',
            'pps'       :   'fa-file-powerpoint-o',
            'pptx'      :   'fa-file-powerpoint-o',
            'potx'      :   'fa-file-powerpoint-o',
            'ppsx'      :   'fa-file-powerpoint-o',
            'mpg'       :   'fa-file-movie-o',
            'mp4'       :   'fa-file-movie-o',
            'mov'       :   'fa-file-movie-o',
            'avi'       :   'fa-file-movie-o',
            'mp3'       :   'fa-file-audio-o',
            'docx'      :   'fa-file-word-o',
            'js'        :   'fa-file-code-o',
            'md'        :   'fa-file-code-o',
            'html'      :   'fa-file-code-o',
            'css'       :   'fa-file-code-o',
            'xlsx'      :   'fa-file-excel-o',
            'png'       :   'fa-file-image-o',
            'jpg'       :   'fa-file-image-o',
            'jpeg'      :   'fa-file-image-o',
            'file'      :   'fa-file-o',
            'default'   :   'fa-file-o'
        };
        return function (fileExtension) {
            return 'fa ' + (fileClassMapping[fileExtension] || 'fa-file-o');
        };
    });
/*Directive for FileUpload */
/**
 * @ngdoc directive
 * @name wm.widgets.form.directive:wmFileupload
 * @restrict E
 *
 * @description
 * The `wmFileupload` directive is used to upload single/upload multiple files. It gives the drag and drop options form multiple fileupload.
 * fileupload widget shows the progress bar and preview of the fileupload,also one can abort the upload when the upload is progress.
 *
 * @requires PropertiesFactory
 * @requires $rootScope
 * @requires $templateCache
 * @requires WidgetUtilService
 * @requires $location
 * @requires $compile
 * @requires $timeout
 * @requires $parse
 * @requires DialogService
 * @requires Utils
 * @requires wmToaster
 *
 * @param {string=} name
 *                  Name of the fileupload widget.
 * @param {string=} caption
 *                  Caption/Label for the fileupload widget. <br>
 *                  This is a bindable property.
 * @param {number=} tabindex
 *                  This property specifies the tab order of the fileupload widget.
 * @param {string=} width
 *                  Width of the fileupload widget.
 * @param {string=} height
 *                  Height of the file upload widget.
 * @param {string=} title
 *                  Title of the Fileuplaod widget. <br>
 *                  Default value: `Drop your files here to start uploading`
 * @param {string=} message
 *                  Message of the Fileuplaod widget. <br>
 *                  Default value: `You can also browse for files`
 * @param {boolean=} singlefileupload
 *                  Switch to single to multiple or multiple to single  file upload widgets. <br>
 *                  Default value: `false`.
 * @param {boolean=} show
 *                  This is a bindable property. <br>
 *                  This property will be used to show/hide the file upload widget on the web page. <br>
 *                  Default value: `true`. <br>
 * @param {string=} filtertype
 *                  filters for the file input. <br>
 *                  Possible values are `all`, `audio`, `image`, and `video`. <br>
 *                  Default value: `all`.
 * @param {string=} uploadpath
 *                  path to the folder in server where to store. <br>
 *                  By default it stores in 'resources' folder in server. <br>
 *                  This is a bindable property.
 * @param {string=} iconclass
 *                  This property defines the class of the icon that is applied to the button. <br>
 *                  This is a bindable property.
 * @param {string=} on-success
 *                  Callback function which will be triggered when the file upload is success.
 * @param {string=} on-error
 *                  Callback function which will be triggered when the file upload results in an error.
 * @param {string=} on-select
 *                  Callback function which will be triggered when the tab is selected.
 * @param {string=} on-progress
 *                  Callback function which will be triggered when the file upload operation is in progress.
 * @param {string=} on-abort
 *                  Callback function which will be triggered when the file upload operation is aborted.
 *
 * @example
 *   <example module="wmCore">
 *       <file name="index.html">
 *           <div data-ng-controller="Ctrl" class="wm-app">
 *               <wm-fileupload on-success="success($event)" on-fail="fail($event)"></wm-fileupload>
 *               <toaster-container toaster-options="{'limit': 1,'time-out': 2000, 'position-class': 'toast-bottom-right'}"></toaster-container>
 *           </div>
 *       </file>
 *       <file name="script.js">
 *          function Ctrl($scope,wmToaster) {
 *              $scope.success = function ($event) {
 *                 wmToaster.show("success", "SUCCESS", "successfully uploaded");
 *              }
 *              $scope.fail=function($event){
 *                wmToaster.show("error", "ERROR", "upload failed");
 *              }
 *           }
 *       </file>
 *   </example>
 */

/*global WM, _*/
/*Directive for Radio */

WM.module('wm.widgets.form')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/widget/form/radio.html',
            '<div class="radio app-radio" init-widget has-model data-ng-show="show" title="{{hint}}" role="input">' +
                '<label apply-styles>' +
                    '<input type="radio" class="app-radiobutton"' +
                        ' value="{{checkedvalue}}"' +
                        ' data-ng-model="_model_"' + /* _model_ is a private variable inside this scope */
                        ' data-ng-readonly="readonly" ' +
                        ' data-ng-required="required" ' +
                        ' data-ng-disabled="disabled" ' +
                        ' accesskey="{{shortcutkey}}"' +
                        ' data-ng-change="_onChange({$event: $event, $scope: this})" ' + /* private method defined in this scope */
                    '/>' +
                    '<span class="caption">{{caption || "&nbsp;"}}</span>' +
                '</label>' +
            '</div>'
            );
    }])
    .directive('wmRadio', ['PropertiesFactory', 'WidgetUtilService', '$templateCache',  'FormWidgetUtils', function (PropertiesFactory, WidgetUtilService, $templateCache,  FormWidgetUtils) {
        'use strict';
        /*Obtaining properties specific to radio widget by extending from all editor related widget properties*/
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.radio', ['wm.base', 'wm.base.editors', 'wm.base.editors.abstracteditors']),
            notifyFor = {
                'height': true,
                'radiogroup': true
            };

        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
        function propertyChangeHandler(radtioBtn, key, newVal) {
            switch (key) {
            /*case 'height':
                scope.lineheight = (scope.height === 'undefined' || scope.height === '') ? '24px' : (parseInt(scope.height, 10) - (parseInt(scope.bordertop, 10) + parseInt(scope.borderbottom, 10) + parseInt(scope.paddingtop, 10) + parseInt(scope.paddingbottom, 10))) + 'px';
                break;*/
            case 'radiogroup':
                radtioBtn.attr('name', newVal);
                break;
            }
        }

        return {
            'restrict': 'E',
            'scope': {},
            'replace': true,
            'template': function (tElement, tAttrs) {
                var template = WM.element($templateCache.get('template/widget/form/radio.html')),
                    radioBtn,
                    isWidgetInsideCanvas = tAttrs.hasOwnProperty('widgetid');
                radioBtn = template.find('input[type=radio]');

                if (!isWidgetInsideCanvas) {
                    WidgetUtilService.addEventAttributes(template, tAttrs, FormWidgetUtils.getProxyEventsMap());
                    WidgetUtilService.addEventAttributes(radioBtn, tAttrs, FormWidgetUtils.getFocusBlurEvents());
                }
                /*Set name for the model-holder, to ease submitting a form*/
                radioBtn.attr('name', tAttrs.name);

                return template[0].outerHTML;
            },
            'compile': function () {
                return {
                    'pre': function (scope) {
                        scope.widgetProps = widgetProps;
                    },
                    'post': function (scope, element, attrs) {
                        scope.eventProxy = FormWidgetUtils.eventProxy.bind(undefined, scope);
                        /* register the property change handler */
                        var radtioBtn = element.find('input[type=radio]');
                        WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, radtioBtn), scope, notifyFor);

                        /*Called from form reset when users clicks on form reset*/
                        scope.reset = function () {
                            //TODO implement custom reset logic here
                            scope._model_ = undefined;
                        };

                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.widgets.form.directive:wmRadio
 * @restrict E
 *
 * @description
 * The `wmRadio` directive defines the radio widget.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 *
 * @param {string=} caption
 *                  Caption / Label of the Radio widget <br>
 *                  This property is bindable
 * @param {string=} name
 *                  Name of the radio widget.
 * @param {string=} hint
 *                  Title/hint for the radio. <br>
 *                  This property is bindable.
 * @param {number=} tabindex
 *                  This property specifies the tab order of Radio widget. <br>
 *                  Default value : 0
 * @param {string=} width
 *                  Width of the radio.
 * @param {string=} height
 *                  Height of the radio.
 * @param {string=} scopedatavalue
 *                  This property accepts the initial value for the Radio widget from a variable defined in the script workspace. <br>
 *                  The scope variable is updated whenever there is a change in the radio value.
 * @param {string=} datavalue
 *                  This property populates the value for the radio widget. <br>
 *                  This property is bindable
 * @param {string=} checkedvalue
 *                  This property defines the value of the Radio widget when the widget is in the checked state. Mandatory for displaying widget value.<br>
 *                  Default value: `false`. <br>
 * @param {boolean=} required
 *                  This property will be used to validate the state of the Radio widget when used inside a form widget.
 * @param {string=} radiogroup
 *                  This property allows you to assign several radioButton widgets to the same group. <br>
 *                  The radiogroup property will be the same for all the radioButtons that have the same radiogroup property value.
 * @param {boolean=} autofocus
 *                   This property makes the Radio widget get focused automatically when the page loads.
 * @param {boolean=} show
 *                  Show is a bindable property. <br>
 *                  This property will be used to show/hide the radio widget on the web page. <br>
 *                  Default value: `true`. <br>
 * @param {boolean=} disabled
 *                  Disabled is a bindable property. <br>
 *                  This property will be used to disable/enable the radio widget on the web page. <br>
 *                  Default value: `false`. <br>
 * @param {string=} on-change
 *                  Callback function which will be triggered when the widget value is changed.
 * @param {string=} on-focus
 *                  Callback function which will be triggered when the widget gets focused.
 * @param {string=} on-blur
 *                  Callback function which will be triggered when the widget loses focus.
 * @param {string=} on-click
 *                  Callback function which will be triggered when the widget is clicked.
 * @param {string=} on-mouseenter
 *                  Callback function which will be triggered when the mouse enters the widget.
 * @param {string=} on-mouseleave
 *                  Callback function which will be triggered when the mouse leaves the widget.
 * @example
 *   <example module="wmCore">
 *       <file name="index.html">
 *           <div data-ng-controller="Ctrl" class="wm-app">
 *               <div>single click count: {{clickCount}}</div>
 *               <div>change count: {{changeCount}}</div>
 *               <div>mouse enter count: {{mouseenterCount}}</div>
 *               <div>mouse leave count: {{mouseleaveCount}}</div>
 *               <div>focus count: {{focusCount}}</div>
 *               <div>blur count: {{blurCount}}</div>
 *               <wm-composite>
 *                   <wm-label caption="{{rad1caption}}"></wm-label>
 *                   <wm-radio
 *                       hint="hint/title for radio"
 *                       radiogroup="{{radiogroup}}"
 *                       checkedvalue="Yes"
 *                       scopedatavalue="selectedvalue"
 *                       on-click="f('click');"
 *                       on-change="f('change');"
 *                       on-focus="f('focus');"
 *                       on-blur="f('blur');"
 *                       on-mouseenter="f('mouseenter');"
 *                       on-mouseleave="f('mouseleave')"
 *                       width="{{width}}"
 *                       height="{{height}}">
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="{{rad2caption}}"></wm-label>
 *                   <wm-radio
 *                       hint="hint/title for radio"
 *                       radiogroup="{{radiogroup}}"
 *                       checkedvalue="No"
 *                       scopedatavalue="selectedvalue"
 *                       on-click="f('click');"
 *                       on-change="f('change');"
 *                       on-focus="f('focus');"
 *                       on-blur="f('blur');"
 *                       on-mouseenter="f('mouseenter');"
 *                       on-mouseleave="f('mouseleave')"
 *                       width="{{width}}"
 *                       height="{{height}}">
 *               </wm-composite>
 *               <br>
 *
 *               <div> Selected Value: <span style="font-weight: bold;">{{selectedvalue}}</span></div>
 *
 *               <wm-composite>
 *                   <wm-label caption="Radio1 Caption:"></wm-label>
 *                   <wm-text scopedatavalue="rad1caption"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="Radio2 Caption:"></wm-label>
 *                   <wm-text scopedatavalue="rad2caption"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="Radio Group:"></wm-label>
 *                   <wm-text scopedatavalue="radiogroup"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="width:"></wm-label>
 *                   <wm-text scopedatavalue="width"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="height:"></wm-label>
 *                   <wm-text scopedatavalue="height"></wm-text>
 *               </wm-composite>
 *           </div>
 *       </file>
 *       <file name="script.js">
 *          function Ctrl($scope) {
 *              $scope.clickCount =
 *              $scope.changeCount =
 *              $scope.mouseenterCount =
 *              $scope.mouseleaveCount =
 *              $scope.focusCount =
 *              $scope.blurCount = 0;
 *
 *              $scope.rad1caption = "MALE";
 *              $scope.rad2caption = "FEMALE";
 *
 *              $scope.radiogroup = "gender";
 *
 *              $scope.width = "50px";
 *              $scope.height= "20px";
 *
 *              $scope.f = function (eventtype) {
 *                  $scope[eventtype + 'Count']++;
 *              }
 *           }
 *       </file>
 *   </example>
 */

/*global WM, _ */
/*Directive for radioset */

WM.module('wm.widgets.form')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/widget/form/radioset.html',
            '<ul class="app-radioset list-group {{layout}}" init-widget has-model apply-styles role="input"' +
                ' title="{{hint}}" data-ng-model="_model_" data-ng-show="show"' +
                ' data-ng-change="_onChange({$event: $event, $scope: this})">' +
                '</ul>'
            );
    }])
    .directive('wmRadioset', ['PropertiesFactory', 'WidgetUtilService', '$compile', 'CONSTANTS', 'Utils', 'FormWidgetUtils', '$templateCache', function (PropertiesFactory, WidgetUtilService, $compile, CONSTANTS, Utils, FormWidgetUtils, $templateCache) {
        'use strict';
        /*getting widget properties for the specific widget*/
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.radioset', ['wm.base', 'wm.booleaneditors']),
            notifyFor = {
                'dataset': true,
                'displayfield': true,
                'datafield': true,
                'usekeys': true,
                'selectedvalue': true,
                'disabled': true
            };

        /*function to assign the values to the model variable based on the selectedvalue as provided.*/
        function assignModelValue(scope, dataSet, radioValue) {
            var selectedValue;
            /*if radioValue is provided use that to assign model value else use the selectedvalue property if provided*/
            /*Handling the case where the selected value itself is false*/
            if (radioValue || radioValue === false) {
                selectedValue = radioValue;
            } else {
                selectedValue = scope.selectedvalue || (WM.isDefined(scope._model_) ? scope._model_ : '');
            }

            scope._model_ = FormWidgetUtils.getModelValue(scope, dataSet, selectedValue, radioValue);
        }

        /*Function to build the radioset with the dataset*/
        function constructRadioSet(scope, element, dataSet) {
            var template,
                compiledTemplate;
            scope.dataObject = {};
            scope.dataKeys = [];
            scope.checkedValues = {};
            dataSet = FormWidgetUtils.getParsedDataSet(dataSet, scope, element);
            /*creating the dataKeys for the radioset*/
            FormWidgetUtils.createDataKeys(scope, dataSet);
            /*assigning value to the model if selectedvalue is provided*/
            assignModelValue(scope, dataSet);
            /*creating the template based on the dataKeys created*/
            template = FormWidgetUtils.getRadiosetCheckboxsetTemplate(scope, 'radioset');
            /*compiling the appended template*/
            compiledTemplate = $compile(template)(scope);
            element.empty().append(compiledTemplate);
            /*register a click event handler for the radio*/
            element.find('.app-radioset-label').on('click', function (evt) {
                if (scope.disabled || scope.readonly || _.includes(evt.target.classList, 'caption')) {
                    return;
                }
                var radioOption;
                /*The input has id in the format scope.$id + index, so parse it and take the corresponding radioOption
                from the dataKeys array*/
                radioOption = WM.element(this).find('input').attr('data-attr-index');
                radioOption = scope.dataKeys[radioOption];
                assignModelValue(scope, dataSet, radioOption);

                Utils.triggerFn(scope._onChange, evt);
                scope.$root.$safeApply(scope);
            });
        }

        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
        function propertyChangeHandler(scope, element, key, newVal) {
            var dataSet = scope.dataset || scope.scopedataset,
                isBoundToServiceVariable;
            /*Checking if widget is bound to service variable*/
            if (CONSTANTS.isStudioMode && scope.binddataset) {
                isBoundToServiceVariable = FormWidgetUtils.getBoundVariableCategory(scope) === "wm.ServiceVariable";
            }
            /*Monitoring changes for properties and accordingly handling respective changes.*/
            switch (key) {
            case 'dataset':
                /*if studio-mode, then update the displayField & dataField in property panel*/
                if (scope.widgetid && WM.isDefined(newVal) && newVal !== null) {
                    FormWidgetUtils.updatePropertyPanelOptions(newVal.data || newVal, newVal.propertiesMap, scope, true);
                }
                /*Displaying no data message when bound to service variable in studio mode*/
                if (isBoundToServiceVariable && CONSTANTS.isStudioMode) {
                    FormWidgetUtils.appendMessage(element);
                } else {
                    /*generating the radioset based on the values provided*/
                    constructRadioSet(scope, element, newVal);
                }
                break;
            case 'displayfield':
            case 'datafield':
            case 'usekeys':
                if (CONSTANTS.isRunMode || !isBoundToServiceVariable) {
                    /*generating the radioset based on the values provided*/
                    constructRadioSet(scope, element, dataSet);
                }
                break;
            case 'selectedvalue':
                /*generating the radioset based on the values provided*/
                dataSet = FormWidgetUtils.getParsedDataSet(dataSet, scope, element);
                assignModelValue(scope, dataSet);
                break;
            case 'disabled':
                element.find('input[type="radio"]').attr('disabled', newVal);
                break;

            }
        }
        /* checks if the given value object is in the given model array of objects */
        function valueInModel(model, value, dataObject) {
            /*If model is equal to value, return true*/
            if (model === value) {
                return true;
            }
            /*If the dataobject is equal in model, return true*/
            return (WM.equals(model, dataObject));
        }

        return {
            'restrict': 'E',
            'scope': {
                'scopedataset': '=?'
            },
            'replace': true,
            'template': function (tElement, tAttrs) {
                var template = WM.element($templateCache.get('template/widget/form/radioset.html')),
                    isWidgetInsideCanvas = tAttrs.hasOwnProperty('widgetid');
                if (!isWidgetInsideCanvas) {
                    WidgetUtilService.addEventAttributes(template, tAttrs, FormWidgetUtils.getProxyEventsMap());
                }
                return template[0].outerHTML;
            },
            'compile': function () {
                return {
                    'pre': function (iScope) {
                        if (CONSTANTS.isStudioMode) {
                            iScope.widgetProps = Utils.getClonedObject(widgetProps);
                        } else {
                            iScope.widgetProps = widgetProps;
                        }
                    },
                    'post': function (scope, element, attrs) {
                        scope.eventProxy = FormWidgetUtils.eventProxy.bind(undefined, scope);
                        /* register the property change handler */
                        WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, scope, element), scope, notifyFor);

                        /* fields defined in scope: {} MUST be watched explicitly */
                        /*watching scopedataset attribute to create options for the checkboxset element.*/
                        scope.$watch('scopedataset', function () {
                            if (scope.scopedataset) {
                                /*generating the radioset based on the values provided*/
                                constructRadioSet(scope, element, scope.scopedataset);
                            }
                        });
                        /*Watch on the model, to check or uncheck the values of checkboxset*/
                        scope.$watch('_model_', function () {
                            if (scope.dataKeys && scope.checkedValues) {
                                _.forEach(scope.dataKeys, function (dataKey) {
                                    scope.checkedValues[dataKey] = valueInModel(scope._model_, dataKey, scope.dataObject[dataKey]);
                                });
                            }
                        }, false);

                        /*Called from form reset when users clicks on form reset*/
                        scope.reset = function () {
                            scope._model_ = [];
                        };

                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.widgets.form.directive:wmRadioset
 * @restrict E
 *
 * @description
 * The `wmRadioset` directive defines the radioset widget.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 * @requires $compile
 * @requires CONSTANTS
 * @requires Utils
 *
 * @param {string=} name
 *                  Name of the radioset widget.
 * @param {string=} hint
 *                  Title/hint for the radioset. <br>
 *                  This property is bindable.
 * @param {number=} tabindex
 *                  This property specifies the tab order of Radioset widget. <br>
 *                  Default value : 0
 * @param {string=} width
 *                  Width of the radioset.
 * @param {string=} height
 *                  Height of the radioset.
 * @param {string=} layout
 *                  This property controls how contained widgets are displayed within this widget container. <br>
 *                  Possible values are "inline", "stacked".
 * @param {string=} scopedatavalue
 *                  This property accepts the initial value for the Radioset widget from a variable defined in the script workspace. <br>
 * @param {string=} selectedvalue
 *                  This property defines the initial selected value of the Radioset widget.
 * @param {boolean=} usekeys
 *                   Use the keys of the live variable object as Radioset options.
 * @param {array||string=} scopedataset
 *                  This property accepts the options to create the Radioset widget from a variable defined in the script workspace.<br>
 *                  Defined variable can hold a comma separated string or an array.
 * @param {string=} dataset
 *                  This property accepts the options to create the Radioset widget from a wavemaker studio variable (live or static) which can hold object, array or string data.
 * @param {string=} datafield
 *                  This property sets the dataValue to be returned by a Radioset widget when the list is populated using the dataSet property.
 * @param {string=} displayfield
 *                  This property sets the displayValue to show in the Radioset widget when the list is populated using the dataSet property.
 * @param {expression=} displayexpression
 *                      This is an advanced property that gives more control over what is displayed in the Radioset widget. <br>
 *                      A Display Expression uses a Javascript expression to format exactly what is shown. <br>
 *                      This property is bindable.
 * @param {boolean=} readonly
 *                   Readonly is a bindable property. <br>
 *                   This property will be used to make the radio widget readonly on the web page. <br>
 *                   Default value: `false`. <br>
 * @param {boolean=} show
 *                  Show is a bindable property. <br>
 *                  This property will be used to show/hide the Radioset widget on the web page. <br>
 *                  Default value: `true`. <br>
 * @param {boolean=} disabled
 *                  Disabled is a bindable property. <br>
 *                  This property will be used to disable/enable the Radioset widget on the web page. <br>
 *                  Default value: `false`. <br>
 * @param {string=} on-change
 *                  Callback function which will be triggered when the widget value is changed.
 * @param {string=} on-focus
 *                  Callback function which will be triggered when the widget gets focused.
 * @param {string=} on-blur
 *                  Callback function which will be triggered when the widget loses focus.
 * @param {string=} on-click
 *                  Callback function which will be triggered when the widget is clicked.
 * @param {string=} on-mouseenter
 *                  Callback function which will be triggered when the mouse enters the widget.
 * @param {string=} on-mouseleave
 *                  Callback function which will be triggered when the mouse leaves the widget.
 * @example
 *   <example module="wmCore">
 *       <file name="index.html">
 *           <div data-ng-controller="Ctrl" class="wm-app">
 *               <div>single click count: {{clickCount}}</div>
 *               <div>change count: {{changeCount}}</div>
 *               <div>mouse enter count: {{mouseenterCount}}</div>
 *               <div>mouse leave count: {{mouseleaveCount}}</div>
 *               <div>focus count: {{focusCount}}</div>
 *               <div>blur count: {{blurCount}}</div>
 *
 *               <wm-composite>
 *                   <wm-label caption="Colors: "></wm-label>
 *                   <wm-radioset name="colorRadio" scopedatavalue="color" scopedataset=colors></wm-radioset>
 *               </wm-composite><br>
 *               <wm-composite>
 *                   <wm-label caption="Framework: "></wm-label>
 *                   <wm-radioset name="jsRadio" scopedatavalue="selectedItem" dataset="Backbone, CoffeeScript, Angular"></wm-radioset>
 *               </wm-composite><br>
 *
 *               <div>
 *                   <div style="font-weight: bold; color: {{color[0]}};">{{selectedItem}}</div>
 *                </div>
 *           </div>
 *       </file>
 *       <file name="script.js">
 *          function Ctrl($scope) {
 *              $scope.clickCount =
 *              $scope.changeCount =
 *              $scope.mouseenterCount =
 *              $scope.mouseleaveCount =
 *              $scope.focusCount =
 *              $scope.blurCount = 0;
 *
 *              $scope.width = "100px";
 *              $scope.height= "30px";
 *
 *              $scope.colors = ["crimson", "green", "orange", "red"];
 *
 *              $scope.f = function (eventtype) {
 *                  $scope[eventtype + 'Count']++;
 *              }
 *           }
 *       </file>
 *   </example>
 */

/*global WM, _ */
/*jslint nomen:true*/
/*Directive for Select */

WM.module('wm.widgets.form')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/widget/form/select.html',
            '<select init-widget has-model class="form-control app-select" apply-styles role="input"' +
                ' data-ng-model="modelProxy"' + /* proxy-object is updated in the onChangeProxy function*/
                ' title="{{hint}}"' +
                ' data-ng-show="show"' +
                ' data-ng-readonly="readonly" ' +
                ' data-ng-disabled="disabled"' +
                ' data-ng-required="required"' +
                ' accesskey="{{shortcutkey}}"' +
                ' data-ng-change="onChangeProxy({$event: $event, $scope: this})"' + /* wrapper to _onChange function to update the model-proxy*/
                ' data-ng-options="option.key as $root.locale[option.value] || option.value for option in selectOptions">' +
                '<option selected value="" ng-if="placeholder">{{placeholder}}</option>' +
            '</select>'
                );
    }])
    .directive('wmSelect', ['PropertiesFactory', 'WidgetUtilService', 'CONSTANTS', 'FormWidgetUtils', 'Utils', function (PropertiesFactory, WidgetUtilService, CONSTANTS, FormWidgetUtils, Utils) {
        'use strict';

        /*Obtaining properties specific to select widget by extending from all editor related widget properties*/
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.select', ['wm.base', 'wm.base.editors', 'wm.base.editors.abstracteditors', 'wm.base.editors.dataseteditors', 'wm.base.events.keyboard']),
            notifyFor = {
                'dataset': true,
                'multiple': true,
                'active': true
            },

        /** store the whole object of the selected option - in '_dataSetModelProxyMap' */
            _dataSetModelProxyMap = {},
            _dataSetModelMap = {},
            _modelChangedManually = {},
            ALLFIELDS = 'All Fields';

        /*
         * gets the key to map the select options out of dataSet
         * if only one key is there in the option object it returns that key
         * else the default key to be looked is 'dataValue'
         */
        function getKey(optionObject) {
            var keys = Object.keys(optionObject);
            /* if only one key, return it (can be anything other than 'dataValue' as well */
            if (keys.length === 1) {
                return keys[0];
            }

            /* return dataValue to be the default key */
            return 'dataValue';
        }

        /*
         * watch the model
         * and update the modelProxy,
         * */
        function updateModelProxy(scope, _model_) {
            /* to check if the function is not triggered from onChangeProxy */
            if (!_modelChangedManually[scope.$id]) {
                if (scope.datafield !== ALLFIELDS) {
                    scope.modelProxy = WM.isObject(_model_) ? _model_ : _model_ && _model_.toString();
                } else if (_dataSetModelMap[scope.$id]) {  /* check for sanity */
                    scope.modelProxy = _dataSetModelMap[scope.$id][WM.toJson(_model_)];
                }
            }
            /* reset the value */
            _modelChangedManually[scope.$id] = false;
        }

        /*
         * parse dataSet to filter the options based on the datafield, displayfield & displayexpression
         */
        function parseDataSet(dataSet, scope) {
            /*store parsed data in 'data'*/
            var data = dataSet,
                dataField = scope.datafield,
                displayField = FormWidgetUtils.getDisplayField(dataSet, scope.displayfield || scope.datafield);

            /*initialize the data, for 'All Fields'*/
            _dataSetModelProxyMap[scope.$id] = {};
            _dataSetModelMap[scope.$id] = {};
            /*if filter dataSet if dataField is selected other than 'All Fields'*/
            if (dataField && dataField !== ALLFIELDS) {
                data = {};
                //Widget selected item dataset will be object instead of array.
                if (WM.isObject(dataSet) && !WM.isArray(dataSet)) {
                    data[WidgetUtilService.getObjValueByKey(dataSet, dataField)] = WidgetUtilService.getEvaluatedData(scope, dataSet, {fieldName: 'displayfield', expressionName: 'displayexpression'}, displayField);
                } else {
                    _.forEach(dataSet, function (option) {
                        data[WidgetUtilService.getObjValueByKey(option, dataField)] = WidgetUtilService.getEvaluatedData(scope, option, {fieldName: 'displayfield', expressionName: 'displayexpression'}, displayField);
                    });
                }

            } else {
                data = {};
                if (!WM.isArray(dataSet) && scope.binddataset && scope.binddataset.indexOf('selecteditem') > -1 ) {
                    data[0] = WidgetUtilService.getEvaluatedData(scope, dataSet, {fieldName: 'displayfield', expressionName: 'displayexpression'}, displayField);
                    /*store parsed dataSet in scope*/
                    _dataSetModelProxyMap[scope.$id][0] = dataSet;
                    _dataSetModelMap[scope.$id][JSON.stringify(dataSet)] = '0';
                } else {
                    _.forEach(dataSet, function (option, index) {
                        if (WM.isObject(option)) {
                            if (scope.datafield === ALLFIELDS) {
                                data[index] = WidgetUtilService.getEvaluatedData(scope, option, {fieldName: 'displayfield', expressionName: 'displayexpression'}, displayField);
                                /*store parsed dataSet in scope*/
                                _dataSetModelProxyMap[scope.$id][index] = option;
                                _dataSetModelMap[scope.$id][JSON.stringify(option)] = index.toString();
                            } else {
                                data[WidgetUtilService.getObjValueByKey(option, dataField)] = WidgetUtilService.getEvaluatedData(scope, option, {fieldName: 'displayfield', expressionName: 'displayexpression'}, displayField);
                            }
                        } else {
                            if (WM.isArray(dataSet)) {
                                data[option] = option;
                            } else {
                                data[index] = option;
                            }
                        }
                    });
                }
            }
            return data;
        }


        /*function to create the options for the select widget, based on the different configurations that can be provided.
         Options can be provided as
         * 1. comma separated string, which is captured in the options property of the scope
         * 2. application scope variable which is assigned to the dataSet attribute of the select widget from the studio.
         * 3. a wm-studio-variable which is bound to the widget's dataSet property.*/
        function createSelectOptions(dataset, scope, element) {
            /* check for dataSet*/
            if (!dataset) {
                return;
            }
            /*assign dataSet according to liveVariable or other variable*/
            dataset = dataset.hasOwnProperty('data') ? dataset.data : dataset;
            var key;
            /*checking if dataSet is present and it is not a string.*/
            if (dataset && dataset.dataValue !== '') {
                /*initializing select options*/
                scope.selectOptions = [];
                /*check if dataset is array*/
                if (WM.isArray(dataset)) {
                    /*filter the dataSet based on datafield & displayfield*/
                    dataset = parseDataSet(dataset, scope);
                    /* if dataSet is an array of objects, convert it to object */
                    if (WM.isObject(dataset[0])) {
                        key = getKey(dataset[0]);
                        /* if dataSet is an array, convert it to object */
                        _.forEach(dataset, function (option) {
                            scope.selectOptions.push({'key': key, 'value': option.name || option[key]});
                        });
                    } else if (WM.isArray(dataset)) {
                        /* if dataSet is an array, convert it to object */
                        _.forEach(dataset, function (option) {
                            scope.selectOptions.push({"key": option, "value": option});
                        });
                    } else if (WM.isObject(dataset)) {
                        _.forEach(dataset, function (val, key) {
                            scope.selectOptions.push({"key": key, "value": val});
                        });
                    }
                } else if (WM.isObject(dataset)) {
                    /*filter the dataSet based on datafield & displayfield*/
                    dataset = parseDataSet(dataset, scope);
                    _.forEach(dataset, function (val, key) {
                        scope.selectOptions.push({"key": key, "value": val});
                    });
                } else {
                    /* if dataSet is an string, convert it to object */
                    if (WM.isString(dataset)) {
                        _.forEach(dataset.split(','), function (opt) {
                            opt = opt.trim();
                            scope.selectOptions.push({"key": opt, "value": opt});
                        });
                    } else {
                        scope.selectOptions.push({"key": dataset, "value": dataset});
                    }
                }
                updateModelProxy(scope, scope._model_);
            }
        }

        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
        function propertyChangeHandler(scope, element, attrs, key, newVal) {
            var variable,
                eleScope = element.scope();
            switch (key) {
            case 'dataset':
                /*if studio-mode, then update the displayField & dataField in property panel*/
                if (scope.widgetid && WM.isDefined(newVal) && newVal !== null) {
                    //Get variable and properties map only on binddataset change
                    if (scope.oldBindDataSet !== scope.binddataset) {
                        if (!WM.isString(newVal)) {
                            variable = Utils.getVariableName(scope, eleScope);
                            if (eleScope.Variables[variable].category === 'wm.LiveVariable') {
                                newVal.propertiesMap = eleScope.Variables[variable].propertiesMap;
                            }
                        }
                        scope.oldBindDataSet = scope.binddataset;
                    }
                    FormWidgetUtils.updatePropertyPanelOptions(newVal.data || newVal, newVal.propertiesMap, scope, false);
                }
                /*creating options for the select element, whenever the property value changes*/
                createSelectOptions(scope.dataset, scope, element);
                break;
            case 'multiple':
                attrs.$set('multiple', newVal);
                break;
            case 'active':
                /*listening on 'active' property, as losing the properties during page switch*/
                /*if studio-mode, then update the displayField & dataField in property panel*/
                if (scope.widgetid && scope.dataset && newVal) {
                    FormWidgetUtils.updatePropertyPanelOptions(scope.dataset.data || scope.dataset, scope.dataset.propertiesMap, scope, false);
                }
                break;
            }
        }

        /* proxy method for onChange event */
        function onChangeProxy(scope, args) {
            /*if "All Fields" is found in the widget mark up, then make the '_model_', an object*/
            /*checking with 'attrs' for "backward compatibility", as displayField & dataField are implemented later*/
            if (scope.readonly) {
                scope.modelProxy = scope._model_;
                return;
            }

            /* assign the modelProxy to the model when the selected datafield isn't all-fields*/
            if (scope.datafield !== ALLFIELDS) {
                scope._model_ = scope.modelProxy;
            } else if (_dataSetModelProxyMap[scope.$id]) { /* check for sanity */
                if (scope.multiple) {
                    /*For multiple select with data field as All Fields, set model as array of objects*/
                    var modelHolder = [];
                    _.each(scope.modelProxy, function (proxy) {
                        modelHolder.push(_dataSetModelProxyMap[scope.$id][proxy]);
                    });
                    scope._model_ = modelHolder;
                } else {
                    scope._model_ = _dataSetModelProxyMap[scope.$id][scope.modelProxy];
                }
            }
            _modelChangedManually[scope.$id] = true;
            scope._onChange({$event: args.$event, $scope: args.$scope});
        }

        /* function which will be triggered on change of scopedataset */
        function scopeDatasetWatcher(scope, element) {
            /*if studio-mode, then update the displayField & dataField in property panel*/
            if (scope.widgetid) {
                FormWidgetUtils.updatePropertyPanelOptions(scope.scopedataset, scope, false);
            }
            createSelectOptions(scope.scopedataset, scope, element);
        }

        return {
            'restrict': 'E',
            'replace': true,
            'scope': {
                'scopedataset': '=?'
            },
            'template': WidgetUtilService.getPreparedTemplate.bind(undefined, 'template/widget/form/select.html'),
            'compile': function () {
                return {
                    'pre': function (iScope) {
                        if (CONSTANTS.isStudioMode) {
                            iScope.widgetProps = Utils.getClonedObject(widgetProps);
                        } else {
                            iScope.widgetProps = widgetProps;
                        }
                    },
                    'post': function (iScope, element, attrs) {

                        // expose the `changeLocale` method defined on $rootScope as `changeAppLocale` on widget scope.
                        var scope = element.scope();
                        scope.changeAppLocale = scope.$root.changeLocale;

                        /* register the property change handler */
                        WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, iScope, element, attrs), iScope, notifyFor);

                        /* fields defined in scope: {} MUST be watched explicitly */
                        /*watching scopedataset attribute to create options for the select element.*/
                        if (!attrs.widgetid) {
                            iScope.$watch('scopedataset', scopeDatasetWatcher.bind(undefined, iScope, element));
                            iScope.$watch('_model_', updateModelProxy.bind(undefined, iScope));
                        }

                        /*decorate onChange function*/
                        iScope.onChangeProxy = onChangeProxy.bind(undefined, iScope);

                        /*Called from form reset when users clicks on form reset*/
                        iScope.reset = function () {
                            //TODO implement custom reset logic here
                            iScope._model_ = '';
                        };

                        /*Executing WidgetUtilService method to initialize the widget with the essential configurations.*/
                        WidgetUtilService.postWidgetCreate(iScope, element, attrs);
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.widgets.form.directive:wmSelect
 * @restrict E
 *
 * @description
 * The `wmSelect` directive defines the select widget.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires $rootScope
 * @requires $templateCache
 * @requires WidgetUtilService
 * @requires $timeout
 *
 * @param {string=} name
 *                  Name of the select widget.
 * @param {string=} hint
 *                  Title/hint for the select. <br>
 *                  This property is bindable.
 * @param {number=} tabindex
 *                  This property specifies the tab order of select widget. <br>
 *                  Default value : 0
 * @param {string=} width
 *                  Width of the select.
 * @param {string=} height
 *                  Height of the select.
 * @param {string=} scopedatavalue
 *                  This property accepts the initial value for the select widget from a variable defined in the script workspace. <br>
 * @param {string=} datavalue
 *                  This property defines the initial selected value of the select widget.
 * @param {array||string=} scopedataset
 *                  This property accepts the options to create the select widget from a variable defined in the script workspace.<br>
 *                  Defined variable can be a comma separated string or an array.
 * @param {string=} dataset
 *                  This property accepts the options to create the select widget from a wavemaker studio variable which is of datatype entry.
 * @param {string=} datafield
 *                  This property sets the dataValue to be returned by the select widget when the list is populated using the dataSet property.
 * @param {string=} displayfield
 *                  This property sets the displayValue to show in the select widget when the list is populated using the dataSet property.
 * @param {expression=} displayexpression
 *                      This is an advanced property that gives more control over what is displayed in the  select widget drop-down list. <br>
 *                      A Display Expression uses a Javascript expression to format exactly what is shown. <br>
 *                      This property is bindable.
 * @param {boolean=} required
 *                  This property will be used to validate the state of the select widget when used inside a form widget.
 * @param {boolean=} autofocus
 *                   This property makes the widget get focused automatically when the page loads.
 * @param {boolean=} readonly
 *                  Readonly is a bindable property. <br>
 *                  This property will be used to make the select widget non-editable on the web page. <br>
 *                  Default value: `false`. <br>
 * @param {boolean=} multiple
 *                  When this value is set to true multiple options can be selected from select widget.
 * @param {boolean=} show
 *                  Show is a bindable property. <br>
 *                  This property will be used to show/hide the select widget on the web page. <br>
 *                  Default value: `true`. <br>
 * @param {boolean=} disabled
 *                  Disabled is a bindable property. <br>
 *                  This property will be used to disable/enable the select widget on the web page. <br>
 *                  Default value: `false`. <br>
 * @param {string=} on-change
 *                  Callback function which will be triggered when the widget value is changed.
 * @param {string=} on-focus
 *                  Callback function which will be triggered when the widget gets focused.
 * @param {string=} on-blur
 *                  Callback function which will be triggered when the widget loses focus.
 * @param {string=} on-click
 *                  Callback function which will be triggered when the widget is clicked.
 * @param {string=} on-mouseenter
 *                  Callback function which will be triggered when the mouse enters the widget.
 * @param {string=} on-mouseleave
 *                  Callback function which will be triggered when the mouse leaves the widget.
 * @param {string=} placeholder
 *                  Placeholder for the selectbox.
 * @example
 *   <example module="wmCore">
 *       <file name="index.html">
 *           <div data-ng-controller="Ctrl" class="wm-app">
 *               <div>single click count: {{clickCount}}</div>
 *               <div>change count: {{changeCount}}</div>
 *               <div>mouse enter count: {{mouseenterCount}}</div>
 *               <div>mouse leave count: {{mouseleaveCount}}</div>
 *               <div>focus count: {{focusCount}}</div>
 *               <div>blur count: {{blurCount}}</div>
 *
 *               <wm-composite>
 *                   <wm-label caption="Colors: "></wm-label>
 *                   <wm-select scopedatavalue="color" scopedataset=colors><wm-select>
 *               </wm-composite><br>
 *               <wm-composite>
 *                   <wm-label caption="Framework: "></wm-label>
 *                   <wm-select scopedatavalue="selectedItem" dataset="Backbone, CoffeeScript, Angular"><wm-select>
 *               </wm-composite><br>
 *
 *               <div style="width: {{width}};">
 *                   <div style="font-weight: bold; color: {{color}};">{{selectedItem}}</div>
 *                </div>
 *               <wm-composite>
 *                      <wm-label caption="placeholder:"></wm-label>
 *                      <wm-text scopedatavalue="placeholder"></wm-text>
 *                  </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="caption:"></wm-label>
 *                   <wm-text scopedatavalue="caption"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="width:"></wm-label>
 *                   <wm-text scopedatavalue="width"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="height:"></wm-label>
 *                   <wm-text scopedatavalue="height"></wm-text>
 *               </wm-composite>
 *           </div>
 *       </file>
 *       <file name="script.js">
 *          function Ctrl($scope) {
 *              $scope.clickCount =
 *              $scope.changeCount =
 *              $scope.mouseenterCount =
 *              $scope.mouseleaveCount =
 *              $scope.focusCount =
 *              $scope.blurCount = 0;
 *
 *              $scope.width = "100px";
 *              $scope.height= "30px";
 *
 *              $scope.colors = ["crimson", "green", "orange", "red"];
 *
 *              $scope.f = function (eventtype) {
 *                  $scope[eventtype + 'Count']++;
 *              }
 *           }
 *       </file>
 *   </example>
 */


/*global WM */
/*Directive for Text */

WM.module('wm.widgets.form')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/widget/form/text.html',
            '<input class="form-control app-textbox" init-widget has-model apply-styles role="input"' +
                ' title="{{hint}}" ' +
                ' data-ng-model="_model_"' + /* _model_ is a private variable inside this scope */
                ' data-ng-readonly="readonly" ' +
                ' data-ng-required="required" ' +
                ' data-ng-disabled="disabled" ' +
                ' data-ng-show="show" ' +
                ' pattern="{{regexp}}"' +
                ' accesskey="{{shortcutkey}}"' +
                ' data-ng-change="_onChange({$event: $event, $scope: this})">' +
                '</input>'
            );
    }])
    .directive('wmText', ['PropertiesFactory', 'WidgetUtilService', 'FormWidgetUtils', 'CONSTANTS', 'Utils', function (PropertiesFactory, WidgetUtilService, FormWidgetUtils, CONSTANTS, Utils) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.text', ['wm.base', 'wm.base.editors', 'wm.base.editors.abstracteditors', 'wm.base.events.keyboard']),
            notifyFor = {
                'type': true,
                'autocomplete': true
            };

        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
        function propertyChangeHandler(scope, element, attrs, key, newVal) {
            var wdgtProperties = scope.widgetProps;
            switch (key) {
            case 'type':
                FormWidgetUtils.setPropertiesTextWidget(wdgtProperties, newVal);
                break;
            case 'autocomplete':
                (newVal === true || newVal === 'true') ? element.removeAttr(key) : element.attr(key, 'off');
                break;
            }
        }

        return {
            'restrict': 'E',
            'replace': true,
            'scope': {},
            'template': function (tElement, tAttrs) {
                var isWidgetInsideCanvas = tAttrs.hasOwnProperty('widgetid'),
                    template = WM.element(WidgetUtilService.getPreparedTemplate('template/widget/form/text.html', tElement, tAttrs)),
                    updateon,
                    debounce,
                    allowInvalid;

                if (!isWidgetInsideCanvas) {

                    updateon = tAttrs.updateon || 'blur';
                    debounce = tAttrs.updatedelay || 0;
                    allowInvalid = tAttrs.allowinvalid === 'true';

                    template.attr('ng-model-options', '{ updateOn:"' + updateon + '", debounce: ' + debounce + ' ,allowInvalid: ' + allowInvalid + '}');

                    if (tAttrs.hasOwnProperty('maxchars')) {
                        template.attr('maxlength', '{{maxchars}}');
                    }

                    if (tAttrs.hasOwnProperty('minvalue')) {
                        template.attr('min', '{{minvalue}}');
                    }

                    if (tAttrs.hasOwnProperty('maxvalue')) {
                        template.attr('max', '{{maxvalue}}');
                    }
                }
                return template[0].outerHTML;
            },
            'compile': function () {
                return {
                    'pre': function (iScope) {
                        if (CONSTANTS.isStudioMode) {
                            iScope.widgetProps = Utils.getClonedObject(widgetProps);
                        } else {
                            iScope.widgetProps = widgetProps;
                        }
                    },
                    'post': function (scope, element, attrs) {

                        /* register the property change handler */
                        WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, scope, element, attrs), scope, notifyFor);

                        /*Called from form reset when users clicks on form reset*/
                        scope.reset = function () {
                            //TODO implement custom reset logic here
                            scope._model_ = '';
                        };

                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.widgets.form.directive:wmText
 * @restrict E
 *
 * @description
 * The `wmText` directive defines the text widget.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires $templateCache
 * @requires WidgetUtilService
 *
 * @param {string=} name
 *                  Name of the text widget.
 * @param {string=} type
 *                  Type of the text box. <br>
 *                  valid value is: text/number/email/url/password/date <br>
 *                  Default value: `text`
 * @param {string=} placeholder
 *                  Placeholder for the textbox.
 * @param {string=} hint
 *                  Title/hint for the text. <br>
 *                  This property is bindable.
 * @param {number=} tabindex
 *                  This property specifies the tab order of text widget. <br>
 *                  Default value : 0
 * @param {string=} width
 *                  Width of the text.
 * @param {string=} height
 *                  Height of the text.
 * @param {string=} scopedatavalue
 *                  This property accepts the value for the text widget from a variable defined in the script workspace. <br>
 * @param {string=} datavalue
 *                  Value of the text widget <br>
 *                  This property is bindable.
 * @param {number=} minvalue
 *                  Minimum value for textbox type number <br>
 *                  This property is bindable.
 * @param {number=} maxvalue
 *                  Maximum value for textbox type number <br>
 *                  This property is bindable.
 * @param {string=} updateon
 *                  Possible values are "blur", "default" <br>
 *                  If the selected value is `blur`: datavalue will be updated on blur event, `default`: datavalue will be updated on keyup.
 * @param {number=} updatedelay
 *                  The amount of delay in milliseconds to update the datavalue.
 * @param {boolean=} required
 *                  Required is a bindable property. <br>
 *                  This property defines if the text widget is a required field while form submission. <br>
 *                  Default value: `false`. <br>
 *                  The value of this variable is set as the value to be shown in the textbox
 * @param {string=} regexp
 *                  Regular expression to be used to validate user input for client-side input validation
 * @param {number=} maxchars
 *                  Maximum characters allowed in the textbox <br>
 *                  This property is bindable.
 * @param {boolean=} autofocus
 *                   This property makes the widget get focused automatically when the page loads.
 * @param {boolean=} readonly
 *                  Readonly is a bindable property. <br>
 *                  This property will be used to make the text widget non-editable on the web page. <br>
 *                  Default value: `false`. <br>
 * @param {boolean=} show
 *                  Show is a bindable property. <br>
 *                  This property will be used to show/hide the text widget on the web page. <br>
 *                  Default value: `true`. <br>
 * @param {boolean=} disabled
 *                  Disabled is a bindable property. <br>
 *                  This property will be used to disable/enable the text widget on the web page. <br>
 *                  Default value: `false`. <br>
 * @param {string=} on-change
 *                  Callback function which will be triggered when the widget value is changed.
 * @param {string=} on-focus
 *                  Callback function which will be triggered when the widget gets focused.
 * @param {string=} on-blur
 *                  Callback function which will be triggered when the widget loses focus.
 * @param {string=} on-click
 *                  Callback function which will be triggered when the widget is clicked.
 * @param {string=} on-mouseenter
 *                  Callback function which will be triggered when the mouse enters the widget.
 * @param {string=} on-mouseleave
 *                  Callback function which will be triggered when the mouse leaves the widget.
 *@param {string=} on-keypress
 *                  Callback function which will be triggered when any key is pressed while widget is focused.
 * @example
 *   <example module="wmCore">
 *       <file name="index.html">
 *           <div data-ng-controller="Ctrl" class="wm-app">
 *               <div style="display:inline-block;margin-right:200px">
 *                  <div style="font-weight:bold">Example 1:</div><br>
 *                  <div>single click count: {{clickCount}}</div>
 *                  <div>change count: {{changeCount}}</div>
 *                  <div>mouse enter count: {{mouseenterCount}}</div>
 *                  <div>mouse leave count: {{mouseleaveCount}}</div>
 *                  <div>key press count: {{keypressCount}}</div>
 *                  <div>focus count: {{focusCount}}</div>
 *                  <div>blur count: {{blurCount}}</div><br>
 *                  <wm-text
 *                      name="text1"
 *                      hint="test"
 *                      datavalue="{{value}}"
 *                      minvalue="{{minvalue}}"
 *                      maxchars="{{maxchars}}"
 *                      placeholder="{{placeholder}}"
 *                      type="{{type}}"
 *                      on-click="f('click');"
 *                      on-change="f('change');"
 *                      on-focus="f('focus');"
 *                      on-blur="f('blur');"
 *                      on-mouseenter="f('mouseenter');"
 *                      on-mouseleave="f('mouseleave');"
 *                      on-keypress="f('keypress')"
 *                      width="{{width}}"
 *                      height="{{height}}">
 *                  </wm-text><br><br>
 *                  <wm-composite>
 *                      <wm-label caption="width:"></wm-label>
 *                      <wm-text scopedatavalue="width"></wm-text>
 *                  </wm-composite>
 *                  <wm-composite>
 *                      <wm-label caption="height:"></wm-label>
 *                      <wm-text scopedatavalue="height"></wm-text>
 *                   </wm-composite>
 *                  <wm-composite>
 *                      <wm-label caption="placeholder:"></wm-label>
 *                      <wm-text scopedatavalue="placeholder"></wm-text>
 *                  </wm-composite>
 *                  <wm-composite>
 *                      <wm-label caption="datavalue:"></wm-label>
 *                      <wm-text scopedatavalue="value"></wm-text>
 *                  </wm-composite>
 *                  <wm-composite>
 *                       <wm-label caption="maxchars:"></wm-label>
 *                      <wm-text type="number" scopedatavalue="maxchars" disabled='{{!!value || type==="number"}}'></wm-text>
 *                  </wm-composite>
 *                  <wm-composite>
 *                      <wm-label caption="type:"></wm-label>
 *                      <wm-select scopedatavalue="type" scopedataset="types"></wm-select>
 *                  </wm-composite>
 *                  <wm-composite>
 *                      <wm-label caption="minvalue:"></wm-label>
 *                      <wm-text type="number" scopedatavalue="minvalue" disabled='{{ type!=="number" }}'></wm-text>
 *                  </wm-composite>
 *               </div>
 *               <div style="display:inline-block;vertical-align:top">
 *                  <div style="font-weight:bold">Example 2:</div><br>
 *                  <div style="font-weight:bold">Details:</div><br>
 *                  <div style="font-style:italic">{{person}}</div><br>
 *                  <wm-composite>
 *                      <wm-label caption="name:"></wm-label>
 *                      <wm-text scopedatavalue="person.name" type="text"></wm-text>
 *                  </wm-composite>
 *                  <wm-composite>
 *                      <wm-label caption="age:"></wm-label>
 *                      <wm-text scopedatavalue="person.age" type="number"></wm-text>
 *                  </wm-composite>
 *                  <wm-composite>
 *                      <wm-label caption="email:"></wm-label>
 *                      <wm-text scopedatavalue="person.email" type="email"></wm-text>
 *                  </wm-composite>
 *               </div>
 *           </div>
 *       </file>
 *       <file name="script.js">
 *          function Ctrl($scope) {
 *              $scope.clickCount =
 *              $scope.changeCount =
 *              $scope.mouseenterCount =
 *              $scope.mouseleaveCount =
 *              $scope.keypressCount =
 *              $scope.focusCount =
 *              $scope.blurCount = 0;
 *              $scope.type = "text";
 *              $scope.placeholder = "sample textbox";
 *              $scope.person = {};
 *              $scope.person.name = "ABC";
 *              $scope.person.age = "20";
 *              $scope.person.email = "abc@xyz.com";
 *              $scope.width = "200px";
 *              $scope.height= "30px";
 *              $scope.types = ["text", "number", "email", "url", "password", "date"];
 *
 *
 *              $scope.f = function (eventtype) {
 *                  $scope[eventtype + 'Count']++;
 *              }
 *           }
 *       </file>
 *   </example>
 */

/*global WM */
/*Directive for Textarea */

WM.module('wm.widgets.form')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/widget/form/textarea.html',
                '<textarea init-widget has-model class="form-control app-textarea" apply-styles role="input"' +
                    ' data-ng-model="_model_" title="{{hint}}"' +
                    ' data-ng-show = "show" ' +
                    ' data-ng-disabled="disabled" ' +
                    ' data-ng-readonly="readonly"' +
                    ' data-ng-required="required" ' +
                    ' accesskey="{{shortcutkey}}"' +
                    ' data-ng-change="_onChange({$event: $event, $scope: this})">' +
                '</textarea>'
            );
    }])
    .directive('wmTextarea', ['PropertiesFactory', 'WidgetUtilService', function (PropertiesFactory, WidgetUtilService) {
        'use strict';
        /*Obtaining properties specific to textarea widget by extending from all editor related widget properties*/
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.textarea', ['wm.base', 'wm.base.editors', 'wm.base.editors.abstracteditors', 'wm.base.events.keyboard']);

        return {
            'restrict': 'E',
            'replace': true,
            'scope': {},
            'template': function (tElement, tAttrs) {
                var isWidgetInsideCanvas = tAttrs.hasOwnProperty('widgetid'),
                    template = WM.element(WidgetUtilService.getPreparedTemplate('template/widget/form/textarea.html', tElement, tAttrs)),
                    updateon,
                    debounce;

                if (!isWidgetInsideCanvas) {

                    updateon = tAttrs.updateon || 'blur';
                    debounce = tAttrs.updatedelay || 0;

                    template.attr('ng-model-options', '{ updateOn:"' + updateon + '", debounce: ' + debounce + '}');

                    if (tAttrs.hasOwnProperty('maxchars')) {
                        template.attr('maxlength', '{{maxchars}}');
                    }
                }
                return template[0].outerHTML;
            },
            'compile': function () {
                return {
                    'pre': function (scope) {
                        scope.widgetProps = widgetProps;
                    },
                    'post': function (scope, element, attrs) {

                        /*Called from form reset when users clicks on form reset*/
                        scope.reset = function () {
                            //TODO implement custom reset logic here
                            scope._model_ = '';
                        };

                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.widgets.form.directive:wmTextarea
 * @restrict E
 *
 * @description
 * The `wmTextarea` directive defines the textarea widget.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 *
 * @param {string=} name
 *                  Name of the textarea widget.
 * @param {string=} placeholder
 *                  Placeholder /hint for the textarea.
 * @param {string=} hint
 *                  Title/hint for the textarea. <br>
 *                  This property is bindable.
 * @param {number=} tabindex
 *                  This property specifies the tab order of textarea widget <br>
 *                  Default value : 0
 * @param {string=} width
 *                  Width of the textarea.
 * @param {string=} height
 *                  Height of the textarea.
 * @param {string=} scopedatavalue
 *                  This property accepts the initial value for the textarea widget from a variable defined in the script workspace. <br>
 * @param {string=} datavalue
 *                  Value to be shown in the textarea widget <br>
 *                  This property is bindable.
 * @param {string=} updateon
 *                  Possible values are "blur" and "default" <br>
 *                  If the selected value is `blur`: datavalue will be updated on blur event, `default`: datavalue will be updated on keyup.
 * @param {number=} updatedelay
 *                  The amount of delay in milliseconds to update the datavalue.
 * @param {boolean=} required
 *                  Required is a bindable property. <br>
 *                  This property defines if the textarea is a required field while form submission. <br>
 *                  Default value: `false`. <br>
 * @param {number=} maxchars
 *                  Maximum characters allowed in the textarea
 * @param {boolean=} autofocus
 *                   This property makes the widget get focused automatically when the page loads.
 * @param {boolean=} readonly
 *                  Readonly is a bindable property. <br>
 *                  This property will be used to make the textarea widget readonly on the web page. <br>
 *                  Default value: `false`. <br>
 * @param {boolean=} show
 *                  Show is a bindable property. <br>
 *                  This property will be used to show/hide the textarea widget on the web page. <br>
 *                  Default value: `true`. <br>
 * @param {boolean=} disabled
 *                  Disabled is a bindable property. <br>
 *                  This property will be used to disable/enable the textarea widget on the web page. <br>
 *                  Default value: `false`. <br>
 * @param {string=} on-change
 *                  Callback function which will be triggered when the widget value is changed.
 * @param {string=} on-focus
 *                  Callback function which will be triggered when the widget gets focused.
 * @param {string=} on-blur
 *                  Callback function which will be triggered when the widget loses focus.
 * @param {string=} on-click
 *                  Callback function which will be triggered when the widget is clicked.
 * @param {string=} on-mouseenter
 *                  Callback function which will be triggered when the mouse enters the widget.
 * @param {string=} on-mouseleave
 *                  Callback function which will be triggered when the mouse leaves the widget.
 *@param {string=} on-keypress
 *                  Callback function which will be triggered when any key is pressed while widget is focused.
 * @example
 *   <example module="wmCore">
 *       <file name="index.html">
 *           <div data-ng-controller="Ctrl" class="wm-app">
 *               <div>single click count: {{clickCount}}</div>
 *               <div>change count: {{changeCount}}</div>
 *               <div>mouse enter count: {{mouseenterCount}}</div>
 *               <div>mouse leave count: {{mouseleaveCount}}</div>
 *               <div>key press count: {{keypressCount}}</div>
 *               <div>focus count: {{focusCount}}</div>
 *               <div>blur count: {{blurCount}}</div><br>
 *               <div style="font-weight:bold">Textarea content:</div><br>
 *               <div style="font-style:italic">{{content}}</div><br>
 *               <wm-textarea
 *                  name="textarea1"
 *                  hint="test"
 *                  scopedatavalue="content"
 *                  placeholder="{{placeholder}}"
 *                  maxchars="{{maxchars}}"
 *                  on-click="f('click');"
 *                  on-change="f('change');"
 *                  on-focus="f('focus');"
 *                  on-blur="f('blur');"
 *                  on-mouseenter="f('mouseenter');"
 *                  on-mouseleave="f('mouseleave')"
 *                  on-keypress="f('keypress')"
 *                  width="{{width}}"
 *                  height="{{height}}">
 *                </wm-textarea><br><br>
 *               <wm-composite>
 *                   <wm-label caption="width:"></wm-label>
 *                   <wm-text scopedatavalue="width"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="height:"></wm-label>
 *                   <wm-text scopedatavalue="height"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="placeholder:"></wm-label>
 *                   <wm-text scopedatavalue="placeholder"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="maxchars:"></wm-label>
 *                   <wm-text type="number" scopedatavalue="maxchars" disabled='{{!!value}}'></wm-text>
 *               </wm-composite>
 *       </file>
 *       <file name="script.js">
 *          function Ctrl($scope) {
 *              $scope.clickCount =
 *              $scope.changeCount =
 *              $scope.mouseenterCount =
 *              $scope.mouseleaveCount =
 *              $scope.keypressCount =
 *              $scope.focusCount =
 *              $scope.blurCount = 0;
 *              $scope.placeholder = "sample textarea";
 *              $scope.content = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vestibulum porta gravida nisi, ac volutpat nibh adipiscing et."
 *
 *              $scope.width = "300px";
 *              $scope.height= "80px";
 *
 *
 *              $scope.f = function (eventtype) {
 *                  $scope[eventtype + 'Count']++;
 *              }
 *           }
 *       </file>
 *   </example>
 */
/*global WM,moment, _, document */
/*Directive for time */

WM.module('wm.widgets.form')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/widget/form/time.html',
            '<div class="app-timeinput input-group dropdown" uib-dropdown init-widget has-model apply-styles role="input"' +
                ' title="{{hint}}" ' +
                ' data-ng-model="_proxyModel"' + /* _proxyModel is a private variable inside this scope */
                ' data-ng-show="show" ' +
                ' data-ng-change="_onChange({$event: $event, $scope: this})" >' +
                '<input class="form-control app-textbox display-input" data-ng-model="_timeModel" accesskey="{{shortcutkey}}">' +
                '<div uib-dropdown is-open="isOpen" class="dropdown">' +
                    '<div uib-dropdown-menu>' +
                        '<uib-timepicker hour-step="hourstep" minute-step="minutestep" show-meridian="ismeridian" show-seconds="showseconds"></uib-timepicker>' +
                    '</div>' +
                '</div>' +
                /*Holder for the model for submitting values in a form*/
                '<input class="model-holder ng-hide" data-ng-disabled="disabled" data-ng-model="_model_">' +
                '<span class="input-group-btn dropdown-toggle">' +
                    '<button type="button" class="btn btn-default btn-time"><i class="glyphicon glyphicon-time"></i></button>' +
                '</span>' +
            '</div>'
            );
        $templateCache.put('template/device/widget/form/time.html',
            '<input type="time" class="form-control app-textbox" init-widget has-model role="input"' +
            ' data-ng-model="_proxyModel" ' +
            ' data-ng-show="show" ' +
            ' data-ng-readonly="readonly" ' +
            ' data-ng-required="required" ' +
            ' data-ng-disabled="disabled" ' +
            ' data-ng-change="updateModel();_onChange({$event: $event, $scope: this})"> '
            );
    }]).directive('wmTime', ['$rootScope', 'PropertiesFactory', 'WidgetUtilService', '$timeout', '$templateCache', '$filter', 'Utils', function ($rs, PropertiesFactory, WidgetUtilService, $timeout, $templateCache, $filter, Utils) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.time', ['wm.base', 'wm.base.editors.abstracteditors', 'wm.base.datetime']),
            notifyFor = {
                'readonly': true,
                'disabled': true,
                'autofocus': true,
                'timestamp': true,
                'timepattern': true
            };

        if ($rs.isMobileApplicationType) {
            widgetProps.hourstep.show = false;
            widgetProps.minutestep.show = false;
        }

        function setTimeModel(scope) {
            if (scope.timepattern === 'timestamp') {
                scope._timeModel = scope._proxyModel && scope._proxyModel.getTime();
            } else {
                scope._timeModel = $filter('date')(scope._proxyModel, scope.timepattern);
            }
        }

        function propertyChangeHandler(scope, element, key, newVal, oldVal) {
            var inputEl = element.find('input'),
                buttonEl = element.find('button');
            switch (key) {
            case 'readonly':
            case 'disabled':
                inputEl.attr(key, newVal);
                buttonEl.attr('disabled', newVal);
                // prevent the click events on decrement/increment buttons
                element.css('pointer-events', newVal ? 'none' : 'all');
                break;
            case 'autofocus':
                inputEl.first().attr(key, newVal);
                break;
            case 'timestamp':
                /*Single equal is used not to update model if newVal and oldVal have same values with string and integer types*/
                if (newVal != oldVal) {
                    scope._model_ = newVal;
                }
                break;
            case 'timepattern':
                scope.showseconds = _.includes(newVal, 'ss');
                scope.ismeridian  = _.includes(newVal, 'hh');
                setTimeModel(scope);
                break;
            }
        }

        function _onClick(scope, evt) {
            evt.stopPropagation();
            if (scope.onClick) {
                scope.onClick({$event: evt, $scope: scope});
            }
        }
        function _onTimeClick(scope, evt) {
            evt.stopPropagation();
            var timeOpen = scope.isOpen;
            $timeout(function () {
                WM.element(document).trigger('click');
                scope.isOpen = !timeOpen;
            });
        }

        return {
            restrict: 'E',
            replace: true,
            scope: {},
            template: function (tElement, tAttrs) {
                var template = '',
                    isWidgetInsideCanvas,
                    target;

                if ($rs.isMobileApplicationType) {
                    template = WM.element(WidgetUtilService.getPreparedTemplate('template/device/widget/form/time.html', tElement, tAttrs));
                    return template[0].outerHTML;
                }

                template = WM.element($templateCache.get('template/widget/form/time.html', tElement, tAttrs));
                isWidgetInsideCanvas = tAttrs.hasOwnProperty('widgetid');
                target = template.children('input.form-control');

                /*Set name for the model-holder, to ease submitting a form*/
                template.find('.model-holder').attr('name', tAttrs.name);
                if (!isWidgetInsideCanvas) {

                    template.attr('data-ng-click', '_onClick($event)');
                    template.find('.btn-time').attr('data-ng-click', '_onTimeClick($event)');
                    template.find('.display-input').attr('data-ng-click', '_onTimeClick($event)');

                    if (tAttrs.hasOwnProperty('onMouseenter')) {
                        template.attr('data-ng-mouseenter', 'onMouseenter({$event: $event, $scope: this})');
                    }

                    if (tAttrs.hasOwnProperty('onMouseleave')) {
                        template.attr('data-ng-mouseleave', 'onMouseleave({$event: $event, $scope: this})');
                    }

                    if (tAttrs.hasOwnProperty('onFocus')) {
                        target.attr('data-ng-focus', 'onFocus({$event: $event, $scope: this})');
                    }

                    if (tAttrs.hasOwnProperty('onBlur')) {
                        target.attr('data-ng-blur', 'onBlur({$event: $event, $scope: this})');
                    }
                }

                return template[0].outerHTML;
            },
            compile: function () {
                return {
                    pre: function (scope) {
                        scope.widgetProps = widgetProps;
                        if ($rs.isMobileApplicationType) {
                            scope._nativeMode = true;
                        }

                    },
                    post: function (scope, element, attrs) {
                        var onPropertyChange = propertyChangeHandler.bind(undefined, scope, element);
                        /* register the property change handler */
                        WidgetUtilService.registerPropertyChangeListener(onPropertyChange, scope, notifyFor);

                        /*Called from form reset when users clicks on form reset*/
                        scope.reset = function () {
                            //TODO implement custom reset logic here
                            scope._model_ = '';
                        };

                        /*
                         * Backward compatibility for ismeridian property which is deprecated.
                         * if ismeridian is false then time is set as 24hr clock format.
                         */
                        if (attrs.ismeridian === 'false' && !attrs.timepattern) {
                            scope.timepattern = scope.timepattern.replace('hh', 'HH').replace(' a', '');
                        }
                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                        scope._onClick = _onClick.bind(undefined, scope);
                        scope._onTimeClick = _onTimeClick.bind(undefined, scope);

                        /*update the model for device time*/
                        scope.updateModel = function () {
                            scope._model_ = scope._proxyModel;
                        };
                        /* handle initial readonly/disabled values */
                        $timeout(function () {
                            onPropertyChange('disabled', scope.disabled);
                            onPropertyChange('readonly', scope.readonly);
                        });
                        /* _model_ acts as a converter for _proxyModel
                         * read operation of _model_/datavalue will return epoch format of the date
                         * write operation of _model_ will update _proxyModel with Date object.
                         *  */

                        Object.defineProperty(scope, '_model_', {
                            get: function () {
                                var timestamp = this._proxyModel ?  this._proxyModel.valueOf() : undefined;
                                this.timestamp = timestamp;
                                if (this.outputformat === "timestamp") {
                                    return timestamp;
                                }
                                if (!this.outputformat) {
                                    this.outputformat = 'HH:mm:ss';
                                }
                                return this._proxyModel ? $filter('date')(this._proxyModel, this.outputformat) : undefined;
                            },
                            set: function (val) {
                                var dateTime;
                                if (scope._nativeMode) {
                                    if (val) {
                                        dateTime = Utils.getValidDateObject(val);
                                        /*set the proxymodel and timestamp*/
                                        this._proxyModel = new Date(dateTime.getFullYear(), dateTime.getMonth(), dateTime.getDate(), dateTime.getHours(), dateTime.getMinutes(), dateTime.getSeconds());
                                        this.timestamp = this._proxyModel.getTime();
                                    } else {
                                        this._proxyModel = undefined;
                                    }
                                    return;
                                }
                                if (val) {
                                    dateTime = Utils.getValidDateObject(val);
                                    this._proxyModel = WM.isDate(dateTime) ? dateTime : undefined;
                                } else {
                                    this._proxyModel = undefined;
                                }
                                setTimeModel(scope);
                            }
                        });

                        /*set the model if datavalue doesnt exist*/
                        if (!attrs.datavalue && !attrs.scopedatavalue) {
                            if (scope._nativeMode) {
                                scope._proxyModel = new Date();
                                scope.timestamp = scope._proxyModel.getTime();
                            } else {
                                scope._model_ = Date.now();
                            }
                        }

                        /*set the model if datavalue exists */
                        if (attrs.datavalue) {
                            if (scope._nativeMode) {
                                scope._proxyModel = new Date(attrs.datavalue);
                            }
                            scope._model_ = attrs.datavalue;
                        }

                    }
                };
            }
        };
    }]);


/**
 * @ngdoc directive
 * @name wm.widgets.form.directive:wmTime
 * @restrict E
 *
 * @description
 * The directive defines a time  widget.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 * @requires $timeout
 *
 * @param {string=} name
 *                  Name of the time widget.
 * @param {string=} placeholder
 *                  Placeholder for the input field
 * @param {string=} hint
 *                  Title/hint for the time widget <br>
 *                  This property is bindable.
 * @param {number=} tabindex
 *                  This property specifies the tab order of time widget. <br>
 *                  Default value : 0
 * @param {string=} scopedatavalue
 *                  This property accepts the value for the  widget from a variable defined in the script workspace. <br>
 * @param {string=} datavalue
 *                  This property defines the value of the time widget. <br>
 *                  This property is bindable
 * @param {string=} timestamp
 *                  This property returns the unix timestamp (epoch) of the datavalue. <br>
 *                  This property can be used for intermediate calculations and validations. <br>
 * @param {string=} ismeridian
 *                  whether do display 12H or 24H. <br>
 * @param {string=} hourstep
 *                  Number of hours to increase or decrease
 * @param {string=} minutestep
 *                  Number of minutes to increase or decrease.
 *@param {boolean=} required
 *                  required is a bindable property. <br>
 *                  if the required property is set to true, `required` class is applied to the label[an asterik will be displayed next to the content of the label']. <br>
 *                  Default value: `false`.
 * @param {boolean=} autofocus
 *                   This property makes the widget get focused automatically when the page loads.
 * @param {boolean=} readonly
 *                   Readonly is a bindable property. <br>
 *                   This property will be used to make the time widget readonly on the web page. <br>
 *                   Default value: `false`. <br>
 * @param {boolean=} show
 *                  Show is a bindable property. <br>
 *                  This property will be used to show/hide the widget on the web page. <br>
 *                  Default value: `true`.
 * @param {boolean=} disabled
 *                  Disabled is a bindable property. <br>
 *                  This property will be used to disable/enable the widget on the web page. <br>
 *                  Default value: `false`.
 * @param {string=} on-change
 *                  Callback function which will be triggered when the widget value is changed.
 * @param {string=} on-focus
 *                  Callback function which will be triggered when the widget gets focused.
 * @param {string=} on-blur
 *                  Callback function which will be triggered when the widget loses focus.
 * @param {string=} on-click
 *                  Callback function which will be triggered when the widget is clicked.
 * @param {string=} on-mouseenter
 *                  Callback function which will be triggered when the mouse enters the widget.
 * @param {string=} on-mouseleave
 *                  Callback function which will be triggered when the mouse leaves the widget.
 * @example
 *   <example module="wmCore">
 *       <file name="index.html">
 *           <div data-ng-controller="Ctrl" class="wm-app">
 *               <wm-time
 *                  on-change="f($event, $scope)"
 *                  name="time1"
 *                  placeholder="set the time"
 *                  outputformat="{{outputformat}}"
 *                  hourstep="{{hourstep}}"
 *                  minutestep="{{minutestep}}"
 *                  ismeridian="{{ismeridian}}">
 *               </wm-time><br>
 *
 *               <div>Selected Time: {{currentTime}}</div><br>
 *               <div>timestamp: {{currentTimestamp}}</div><br>
 *               <wm-composite>
 *                   <wm-label caption="output format:"></wm-label>
 *                   <wm-text scopedatavalue="outputformat"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="ismeridian :"></wm-label>
 *                   <wm-text scopedatavalue="ismeridian"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="hourstep:"></wm-label>
 *                   <wm-text scopedatavalue="hourstep"></wm-text>
 *               </wm-composite>
 *               <wm-composite>
 *                   <wm-label caption="minutestep:"></wm-label>
 *                   <wm-text scopedatavalue="minutestep"></wm-text>
 *               </wm-composite>
 *
 *           </div>
 *       </file>
 *       <file name="script.js">
 *          function Ctrl($scope) {
 *              $scope.ismeridian="true"
 *              $scope.hourstep="2"
 *              $scope.minutestep="4"
 *              $scope.outputformat = "hh:mm a"
 *              $scope.f = function (event,scope) {
 *                  $scope.currentTime = scope.datavalue;
 *                  $scope.currentTimestamp = scope.timestamp;
 *              }
 *           }
 *       </file>
 *   </example>
 */


/*global WM, Event*/
/*Directive for richtexteditor */

WM.module('wm.widgets.form').requires = WM.module('wm.widgets.form').requires.concat(['textAngular']);
WM.module('wm.widgets.form')
    .run(['$templateCache', function ($tc) {
        'use strict';
        $tc.put('template/widget/richtexteditor.html',
            '<div class="app-richtexteditor clearfix" init-widget has-model apply-styles ng-show="show" role="input">' +
                '<div text-angular ng-model="_model_"></div>' +
                '<div ng-bind-html="_model_" class="ta-preview" ng-if="showpreview"></div>' +
                '<input class="model-holder ng-hide" ng-disabled="disabled">' +
            '</div>'
            );
    }])
    .directive('wmRichtexteditor', [
        'PropertiesFactory',
        '$templateCache',
        'WidgetUtilService',
        'taSelection',

        function (PropertiesFactory, $tc, WidgetUtilService, taSelection) {
            'use strict';

            var widgetProps = PropertiesFactory.getPropertiesOf('wm.richtexteditor', ['wm.base', 'wm.base.editors']),
                notifyFor = {
                    'placeholder': true,
                    'showpreview': true,
                    'readonly': true
                };

            /* Define the property change handler. This function will be triggered when there is a change in the widget property */
            function propertyChangeHandler($is, editorElement, btnElements, key, nv) {
                switch (key) {
                case 'placeholder':
                    $is._model_ = nv;
                    break;
                case 'showpreview':
                    $is.showpreview = nv;
                    break;
                case 'readonly':
                    if (nv === true) {
                        /*listen on keypress, prevent default action*/
                        editorElement.on('keypress.readOnlyEvent', function (event) {
                            event.preventDefault();
                        });
                        editorElement.on('click.readOnlyEvent', function (event) {
                            event.preventDefault();
                            /*to enable/disable picture, link, unlink & YouTube buttons*/
                            btnElements.attr('disabled', nv === true);
                        });
                    } else {
                        /*unbind readOnlyEvent keypress action*/
                        editorElement.off('.readOnlyEvent');
                    }
                    break;
                }
            }

            function getCursorPosition() {
                var selection,
                    retObj;
                try {
                    selection  = taSelection.getSelection();
                    retObj     = {
                        'start': selection.start.offset,
                        'end'  : selection.end.offset
                    };
                } catch (e) {
                    retObj = {};
                }
                return retObj;
            }

            return {
                'restrict': 'E',
                'scope': {},
                'replace': true,
                'template': function (tElement, tAttrs) {
                    var template = WM.element($tc.get('template/widget/richtexteditor.html'));
                    /*Set name for the model-holder, to ease submitting a form*/
                    template.find('.model-holder').attr('name', tAttrs.name);
                    return template[0].outerHTML;
                },
                'link': {
                    'pre': function ($is) {
                        $is.widgetProps = widgetProps;
                    },
                    'post': function ($is, $el, attrs) {
                        /* register the property change handler */
                        WidgetUtilService.registerPropertyChangeListener(
                            propertyChangeHandler.bind(undefined, $is, $el.find('.ta-editor'), $el.find('.fa-picture-o, .fa-link, .fa-unlink, .fa-youtube-play, .fa-code').parent('.btn')),
                            $is,
                            notifyFor
                        );

                        var hiddenInputEl = $el.children('input'),
                            ngModelCtrl;

                        if (!attrs.widgetid && attrs.scopedatavalue) {
                            $is.$on('$destroy', $is.$watch('_model_', function (newVal) {
                                hiddenInputEl.val(newVal);
                            }));
                        }

                        ngModelCtrl = $el.children('[text-angular]').controller('ngModel');
                        ngModelCtrl.$viewChangeListeners.push(function () {
                            $is._onChange(new Event('change'));
                        });

                        /*Called from form reset when users clicks on form reset*/
                        $is.reset = function () {
                            //TODO implement custom reset logic here
                            $is._model_ = '';
                        };

                        $is.getCursorPosition  = getCursorPosition;

                        WidgetUtilService.postWidgetCreate($is, $el, attrs);
                    }
                }
            };
        }
    ]);


/**
 * @ngdoc directive
 * @name wm.widgets.form.directive:wmRichtexteditor
 * @restrict E
 *
 * @description
 * The `wmRichtexteditor` directive defines a rich text editor widget. <br>
 *
 * <strong>method:</strong> <em>getCursorPosition</em> <br>
 * Returns the position of the cursor if the cursor is inside the editor. <br>
 * Returned object contains the start and end offsets. <br>
 * ```js
 * var position = widget.getCursorPosition(); // widget is the isolateScope of the richTextEditor widget.
 * // In run mode widgets can be accessed as -- $scope.Widgets._widgetName_
 * console.log(position); // prints {start: 4, end: 10}
 * ```
 * @scope
 *
 * @requires PropertiesFactory
 * @requires $templateCache
 * @requires WidgetUtilService
 *
 * @param {string=}  name
 *                   Name of the rich-text-editor widget.
 * @param {string=}  placeholder
 *                   Initial text in the rich-text-editor widget.
 * @param {number=} tabindex
 *                  This property specifies the tab order of the rich-text-editor widget.
 * @param {string=} width
 *                  Width of the rich-text-editor widget.
 * @param {string=} height
 *                  Height of the rich-text-editor widget.
 * @param {string=} scopedatavalue
 *                  The script variable that contains the data to be displayed on rich-text-editor widget.
 * @param {string=} datavalue
 *                  This is the default value to  be displayed on rich-text-editor widget. <br>
 *                  Note that the display value is just what the user sees initially, and is not always the dataValue returned by the widget. <br>
 *                  This is a bindable property.
 * @param {boolean=} readonly
 *                   Selecting this checkbox property prevents the user from being able to change the data value of a widget. <br>
 *                   Default value: `false`.
 * @param {boolean=} show
 *                   This is a bindable property. <br>
 *                   This property will be used to show/hide the rich-text-editor widget on the web page. <br>
 *                   Default value: `true`.
 * @param {boolean=} showpreview
 *                   To show or hide the preview part of the rich-text-editor widget. <br>
 *                   Default value: `false`.
 * @param {string=}  on-change
 *                   Callback function which will be triggered when the widget value is changed.
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
                <wm-composite>
                    <wm-label caption="Placeholder:"></wm-label>
                    <wm-text scopedatavalue="placeholder"></wm-text>
                </wm-composite>
                <wm-composite>
                    <wm-label caption="Show:"></wm-label>
                    <wm-checkbox name="checkbox1" scopedatavalue="show" checked="checked"></wm-checkbox>
                </wm-composite>
                <wm-composite>
                    <wm-label caption="Show Preview:"></wm-label>
                    <wm-checkbox name="checkbox1" scopedatavalue="preview"></wm-checkbox>
                </wm-composite>
                <wm-richtexteditor name="example-richtexteditor" show='{{show}}' placeholder='{{placeholder}}' showpreview='{{preview}}'>
                </wm-richtexteditor>
            </div>
        </file>
        <file name="script.js">
           function Ctrl($scope) {
               $scope.show=true;
               $scope.placeholder = "Sample Text";
           }
        </file>
    </example>
 */

/*global WM, wmGrid, confirm, window, wm, _*/
/*jslint sub: true */
/*jslint todo: true */

/**
 * @ngdoc directive
 * @name wm.widgets.grid.directive:wmGrid
 * @restrict E
 *
 * @description
 * The `wmGrid` is the data grid used to display data in a tabular manner.<br>
 * `wmGrid` can be bound to variables and display the data associated with them.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 * @requires $compile
 * @requires $controller
 * @requires CONSTANTS
 * @requires $rootScope
 *
 * @param {string=} caption
 *                  Caption of the grid.
 * @param {string=} name
 *                  Sets the name of the grid.
 * @param {string=} width
 *                  Sets the width of the grid.
 * @param {string=} height
 *                  Sets the height of the live grid.
 * @param {boolean=} showheader
 *                  This property determines if the header has to be shown/hidden. <br>
 *                  Defualt value: `true`. <br>
 * @param {string=} scopedataset
 *                  This property accepts the value for the grid widget from a variable defined in the controller page. <br>
 * @param {string=} dataset
 *                  This property determines the list of values to display for the grid. It is a bindable property.
 * @param {string=} editcolumns
 *                  This property determines the columns to edit for the grid.
 * @param {boolean=} readonlygrid
 *                  This property determines if the grid has read-only behaviour. <br>
 *                  Default value: `true`. <br>
 * @param {boolean=} show
 *                  This property determines whether the grid widget is visible or not. It is a bindable property.
 *                  Default value: `true`. <br>
 * @param {boolean=} showtotalrecords
 *                  This property controls whether the total record count is displayed in the data navigator or not. <br>
 *                  Default value: `true`. <br>
 * @param {boolean=} multiselect
                    Show a multiselect checkbox column in grid widget.
 * @param {boolean=} radiocolumn
 *                  Show a radio column in grid widget.
 * @param {boolean=} enablesearch
 *                  Show search box for searching in grid widget.
 * @param {boolean=} searchlabel
 *                  The search label to show for the search box.
 * @param {boolean=} showrowindex
 *                  Show row index column in the grid widget
 * @param {boolean=} selectfirstrecord
 *                  If this property is checked, the first record of the grid will be selected automatically when the grid is displayed.
 * @param {string=} click
 *                  Callback function which will be triggered on clicking the grid.
 * @param {string=} enterpresskey
 *                  Callback function which will be triggered on pressing the Enter key.
 * @param {string=} show
 *                  Callback function which will be triggered  any time a widget is shown due to changes in its parent's state.
 * @param {string=} hide
 *                  Callback function which will be triggered  any time a widget is hidden due to changes in its parent's state
 * @param {string=} onselect
 *                  Callback function which will be triggered when the grid is selected.
 * @param {string=} ondeselect
 *                  Callback function which will be triggered when the grid is unselected.
 * @param {string=} datasort
 *                  Callback function which will be triggered when the user clicks the grid headers to sort your grid.
 * @param {string=} headerclick
 *                  Callback function which will be triggered when the user clicks the grid headers.
 * @param {string=} rowclick
 *                  Callback function which will be triggered when the user clicks the rows in the grid.
 * @param {string=} columnselect
 *                  Callback function which will be triggered when the user selects a column.
 * @param {string=} columndeselect
 *                  Callback function which will be triggered when the user deselects a column.
 * @param {string=} recorddelete
 *                  Callback function which will be triggered when the user deletes a row.
 * @param {string=} beforerecordinsert
 *                  Callback function which will be triggered before a new row in inserted into the grid.
 * @param {string=} afterrecordinsert
 *                  Callback function which will be triggered after a new row in inserted into the grid.
 * @param {string=} beforerecordsupdate
 *                  Callback function which will be triggered when the record is set using the data-navigator.
 * @example
   <example module="wmCore">
       <file name="index.html">
           <div data-ng-controller="Ctrl" class="wm-app" style="height: 100%;">
               <wm-grid readonlygrid="false" name="grid3" dataset="{{data}}" shownavigation="false" enablesort="false">
               </wm-grid>
           </div>
       </file>
       <file name="script.js">
           function Ctrl($scope) {
               $scope.data = [{"deptid":1,"name":"Engineering","budget":1936760,"q1":445455,"q2":522925,"q3":426087,"q4":542293,"deptcode":"Eng","location":"San Francisco","tenantid":1},{"deptid":2,"name":"Marketing","budget":1129777,"q1":225955,"q2":271146,"q3":327635,"q4":305040,"deptcode":"Mktg","location":"New York","tenantid":1},{"deptid":3,"name":"General and Admin","budget":1452570,"q1":435771,"q2":290514,"q3":348617,"q4":377668,"deptcode":"G&A","location":"San Francisco","tenantid":1},{"deptid":4,"name":"Sales","budget":2743744,"q1":493874,"q2":658499,"q3":713373,"q4":877998,"deptcode":"Sales","location":"Austin","tenantid":1},{"deptid":5,"name":"Professional Services","budget":806984,"q1":201746,"q2":201746,"q3":177536,"q4":225955,"deptcode":"PS","location":"San Francisco","tenantid":2}];
           }
       </file>
 </example>
 */
WM.module('wm.widgets.grid')
    .directive('wmGrid', ['PropertiesFactory', 'WidgetUtilService', '$compile', '$controller', 'CONSTANTS', '$rootScope', '$timeout', 'Utils', 'LiveWidgetUtils', function (PropertiesFactory, WidgetUtilService, $compile, $controller, CONSTANTS, $rootScope, $timeout, Utils, LiveWidgetUtils) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.grid', ['wm.base', 'wm.base.editors']),
            gridColumnMarkup = '',
            notifyFor = {
                'width': true,
                'height': true,
                'gridfirstrowselect': true,
                'deleterow': true,
                'updaterow': true,
                'dataset': true,
                'showheader': true,
                'shownavigation': true,
                'insertrow': true,
                'show': true,
                'gridsearch': true,
                'searchlabel': true,
                'multiselect': true,
                'radioselect': true,
                'showrowindex': true,
                'enablesort': true,
                'readonlygrid': true,
                'gridcaption': true,
                'gridclass': true,
                'nodatamessage': true,
                'loadingdatamsg': true,
                'filternullrecords': true,
                'allowinlineedit': true,
                'spacing': true
            },
            getObjectIndexInArray = function (key, value, arr) {
                var index = -1, i;
                for (i = 0; i < arr.length; i++) {
                    if (arr[i][key] === value) {
                        index = i;
                        break;
                    }
                }
                return index;
            },
            readOnlyGridAttrUpdated,
            gridColumnCount;

        return {
            "restrict": 'E',
            "scope": {
                "scopedataset": '=?',
                "onSelect": "&",
                "onDeselect": "&",
                "onSort": "&",
                "onClick": "&",
                "onHeaderclick": "&",
                "onShow": "&",
                "onHide": "&",
                "onRowdeleted": "&",
                "onRowupdated": "&",
                "onBeforerowinsert": "&",
                "onRowinsert": "&",
                "onRowclick": "&",
                "onColumnselect": "&",
                "onColumndeselect": "&",
                "onEnterkeypress": "&",
                "onSetrecord": "&"
            },
            "replace": true,
            "transclude": false,
            "controller": 'gridController',
            "template": function (element) {
                /*set the raw gridColumnMarkup to the local variable*/
                gridColumnMarkup = element.html();
                return '<div data-identifier="grid" init-widget data-ng-show="show" title="{{hint}}" class="app-grid panel panel-default" apply-styles="shell">' +
                    '<div class="panel-heading" data-ng-if="title"><h3 class="panel-title">{{title}}</h3></div>' +
                    '<div class="app-datagrid"></div>' +
                    '<div class="panel-footer clearfix" ng-show="shownavigation || actions.length">' +
                        '<div class="app-datagrid-paginator pull-left">' +
                            '<wm-datanavigator show="{{show && shownavigation}}" data-ng-class="navigationClass" showrecordcount="{{show && showrecordcount}}">' +
                            '</wm-datanavigator>' +
                        '</div>' +
                        '<div class="app-datagrid-actions pull-right" data-ng-if="actions">' +
                            '<wm-button ng-repeat="btn in actions" caption="{{btn.displayName}}" show="{{btn.show}}" class="{{btn.class}}" iconclass="{{btn.iconclass}}"' +
                                'iconname="{{btn.icon}}" on-click="{{btn.action}}"></wm-button>' +
                        '</div>' +
                    '</div></div>';
            },
            'compile': function (tElement, tAttr) {
                var contextEl = tElement.context,
                    showHeader;
                /*Backward compatibility to support "gridnoheader".*/
                if (tAttr.gridnoheader) {
                    contextEl.removeAttribute('gridnoheader');
                    if (!tAttr.showheader) {
                        showHeader = !(tAttr.gridnoheader === 'true' || tAttr.gridnoheader === true);
                        delete tAttr.gridnoheader;
                        tAttr.showheader = showHeader;
                        contextEl.setAttribute('showheader', showHeader);
                    }
                }
                /*Backward compatibility to support "readonlygrid".*/
                if (WM.isUndefined(tAttr.readonlygrid)) {
                    tAttr.readonlygrid = false;
                    contextEl.setAttribute('readonlygrid', false);
                    readOnlyGridAttrUpdated = true;
                }

                /*set the raw gridColumnMarkup to the grid attribute*/
                tAttr.gridColumnMarkup = gridColumnMarkup;
                gridColumnCount = (gridColumnMarkup.match(/<wm-grid-column/g) || []).length;
                /* in run mode there is separate controller for grid widget but not in studio mode, to prevent errors in studio mode create and empty function
                 * with particular controller name */
                if (CONSTANTS.isStudioMode) {
                    window[tAttr.name + 'Controller'] = WM.noop;
                }

                function defineSelectedItemProp(scope, items) {
                    Object.defineProperty(scope, 'selecteditem', {
                        get: function () {
                            // update the items with out changing the reference.
                            items.length = 0;
                            _.forEach(scope.datagridElement.datagrid('getSelectedRows'), function (item) {
                                items.push(item);
                            });
                            if (items && items.length === 1) {
                                return items[0];
                            }
                            return items;
                        },
                        set: function (val) {
                            /*Select the rows in the table based on the new selected items passed*/
                            scope.datagridElement.datagrid('selectRows', val);
                        }
                    });
                }

                return {
                    'pre': function (iScope, element) {
                        if (CONSTANTS.isStudioMode) {
                            iScope.widgetProps = Utils.getClonedObject(widgetProps);
                        } else {
                            iScope.widgetProps = widgetProps;
                        }
                        /*Set the "allowPageable" flag in the scope to indicate that the grid accepts Pageable objects.*/
                        iScope.allowPageable = true;

                        /*This is to make the "Variables" & "Widgets" available in the Grid scope.
                         * and "Variables", "Widgets" will not be available in that scope.
                         * element.scope() might refer to the controller scope/parent scope.*/
                        var elScope = element.scope();
                        iScope.Variables = elScope.Variables;
                        iScope.Widgets = elScope.Widgets;
                        iScope.columns = {};
                        iScope.appLocale = $rootScope.appLocale;

                        Object.defineProperty(iScope, 'selecteditem', {
                            configurable: true
                        });
                    },
                    'post': function (scope, element, attrs) {
                        var runModeInitialProperties = {
                                'showrowindex'      : 'showRowIndex',
                                'multiselect'       : 'multiselect',
                                'radioselect'       : 'showRadioColumn',
                                'filternullrecords' : 'filterNullRecords',
                                'enablesort'        : 'enableSort',
                                'showheader'        : 'showHeader'
                            },
                            handlers = [],
                            gridController;
                        /****condition for old property name for grid title*****/
                        if (attrs.gridcaption && !attrs.title) {
                            scope.title = scope.gridcaption;
                        }

                        scope.gridElement = element;
                        scope.gridColumnCount = gridColumnCount;
                        scope.displayAllFields = attrs.displayall === '';
                        scope.datagridElement = element.find('.app-datagrid');

                        scope.isPartOfLiveGrid = element.closest('.app-livegrid').length > 0;

                        scope.$on('$destroy', function () {
                            handlers.forEach(Utils.triggerFn);
                            Utils.triggerFn(scope.toggleVariableStateHandler);
                        });

                        WM.element(element).css({'position': 'relative'});
                        /*being done to trigger watch on the dataset property for first time if property is not defined(only for a simple grid not inside a live-grid)*/
                        if (scope.dataset === undefined && attrs.identifier !== 'grid') {
                            scope.watchVariableDataSet('', element);
                        }

                        /*
                         * Extend the properties from the grid controller exposed to end user in page script
                         * Kept in try/catch as the controller may not be available sometimes
                         */
                        if (CONSTANTS.isRunMode) {
                            try {
                                gridController = scope.name + 'Controller';
                                $controller(gridController, {$scope: scope});
                            } catch (ignore) {
                            }
                        }

                        scope.actions = [];

                        /* Event to update "insertrow", "updaterow" and "deleterow" properties based on "readonlygrid" value.
                         * NOTE: This is not handled in propertyChangeHandler because we have to update these properties only
                         * when user explicitly clicks readonlygrid checkbox. */
                        handlers.push($rootScope.$on('grid-action-properties-modified', function (event, scopeId, readonlygrid) {
                            /* as multiple grid directives will be listening to the event, apply readonlygrid property only for current grid */
                            if (scope.$id === scopeId) {
                                scope.deleterow = !readonlygrid;
                                scope.updaterow = !readonlygrid;
                                scope.insertrow = !readonlygrid;
                                $rootScope.$emit('set-markup-attr', scope.widgetid, {
                                    'insertrow': scope.insertrow,
                                    'updaterow': scope.updaterow,
                                    'deleterow': scope.deleterow
                                });
                            }
                        }));

                        /* event emitted on building new markup from canvasDom */
                        handlers.push($rootScope.$on('compile-grid-columns', function (event, scopeId, markup) {
                            /* as multiple grid directives will be listening to the event, apply fieldDefs only for current grid */
                            if (scope.$id === scopeId) {
                                scope.fullFieldDefs = [];
                                scope.fieldDefs = [];

                                $compile(markup)(scope);
                                /*TODO: Check if grid options can be passed.*/
                                /*Invoke the function to render the operation columns.*/
                                scope.renderOperationColumns();
                                scope.setDataGridOption('colDefs', Utils.getClonedObject(scope.fieldDefs));
                            }
                        }));
                        /* event emitted whenever grid actions are modified */
                        handlers.push($rootScope.$on('compile-grid-actions', function (event, scopeId, markup) {
                            /* as multiple grid directives will be listening to the event, apply fieldDefs only for current grid */
                            if (scope.$id === scopeId) {
                                scope.actions = [];
                                $compile(markup)(scope);
                            }
                        }));

                        /* compile all the markup tags inside the grid, resulting into setting the fieldDefs*/
                        $compile(attrs.gridColumnMarkup)(scope);

                        /*This is expose columns property to user so that he can programatically
                         * use columns to do some custom logic */
                        scope.gridOptions.colDefs.map(function (column) {
                            scope.columns[column.field] = column;
                        });

                        if (CONSTANTS.isRunMode) {
                            /**runModeInitialProperties are not triggered in property change handler in run mode.
                             * So, set these grid options based on the attribute values.
                             * This is done to prevent re-rendering of the grid for a property change in run mode**/
                            _.each(runModeInitialProperties, function (value, key) {
                                var attrValue = attrs[key];
                                if (WM.isDefined(attrValue)) {
                                    scope.gridOptions[value] = (attrValue === "true" || attrValue === true);
                                }
                            });
                            /*Set isMobile value on the datagrid*/
                            scope.gridOptions.isMobile = Utils.isMobile();
                            scope.renderOperationColumns();
                        }
                        scope.datagridElement.datagrid(scope.gridOptions);

                        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
                        function propertyChangeHandler(key, newVal) {
                            /*Monitoring changes for styles or properties and accordingly handling respective changes.*/
                            switch (key) {
                            case 'width':
                                scope.datagridElement.datagrid('setGridDimensions', 'width', newVal);
                                break;
                            case 'height':
                                scope.datagridElement.datagrid('setGridDimensions', 'height', newVal);
                                break;
                            case 'gridfirstrowselect':
                                scope.setDataGridOption('selectFirstRow', newVal);
                                break;
                            case 'deleterow':
                                if (CONSTANTS.isStudioMode) {
                                    scope.renderOperationColumns();
                                    scope.setDataGridOption('colDefs', Utils.getClonedObject(scope.fieldDefs));
                                    scope.widgetProps.confirmdelete.show = newVal;
                                    scope.widgetProps.deletemessage.show = newVal;
                                    scope.widgetProps.confirmdelete.showindesigner = newVal;
                                    scope.widgetProps.deletemessage.showindesigner = newVal;
                                }
                                break;
                            case 'updaterow':
                                if (CONSTANTS.isStudioMode) {
                                    scope.renderOperationColumns();
                                    scope.setDataGridOption('colDefs', Utils.getClonedObject(scope.fieldDefs));
                                }
                                break;
                            case 'dataset':
                                scope.watchVariableDataSet(newVal, element);
                                break;
                            case 'showheader':
                                if (CONSTANTS.isStudioMode) {
                                    scope.setDataGridOption('showHeader', newVal);
                                }
                                break;
                            case 'gridsearch':
                                scope.setDataGridOption('enableSearch', newVal);
                                if (CONSTANTS.isStudioMode) {
                                    scope.widgetProps.searchlabel.show = newVal;
                                    scope.widgetProps.searchlabel.showindesigner = newVal;
                                }
                                break;
                            case 'searchlabel':
                                scope.setDataGridOption('searchLabel', newVal);
                                break;
                            case 'multiselect':
                                if (CONSTANTS.isStudioMode) {
                                    if (newVal) {
                                        scope.radioselect = false;
                                        scope.widgetProps.radioselect.show = false;
                                        scope.widgetProps.radioselect.showindesigner = false;
                                        scope.$root.$emit('set-markup-attr', scope.widgetid, {'radioselect': false});
                                    }
                                    scope.setDataGridOption('multiselect', newVal);
                                }
                                break;
                            case 'radioselect':
                                if (CONSTANTS.isStudioMode) {
                                    if (newVal) {
                                        scope.multiselect = false;
                                        scope.widgetProps.multiselect.show = false;
                                        scope.widgetProps.multiselect.showindesigner = false;
                                        scope.$root.$emit('set-markup-attr', scope.widgetid, {'multiselect': false});
                                    }
                                    scope.setDataGridOption('showRadioColumn', newVal);
                                }
                                break;
                            case 'showrowindex':
                                if (CONSTANTS.isStudioMode) {
                                    scope.setDataGridOption('showRowIndex', newVal);
                                }
                                break;
                            case 'enablesort':
                                if (CONSTANTS.isStudioMode) {
                                    scope.setDataGridOption('enableSort', newVal);
                                }
                                break;
                            case 'shownavigation':
                                scope.enablePageNavigation();
                                /*Check for sanity*/
                                if (CONSTANTS.isStudioMode) {
                                    scope.widgetProps.showrecordcount.show = newVal;
                                }
                                break;
                            case 'insertrow':
                                scope.insertrow = (newVal === true || newVal === 'true');
                                var addNewRowButtonIndex = getObjectIndexInArray('key', 'addNewRow', scope.actions);
                                if (scope.insertrow) {
                                    // Add button definition to actions if it does not already exist.
                                    if (addNewRowButtonIndex === -1) {
                                        scope.actions.unshift(_.find(LiveWidgetUtils.getLiveWidgetButtons('GRID'), function (button) {
                                            return button.key === 'addNewRow';
                                        }));
                                    }
                                } else {
                                    if (scope.actions.length && addNewRowButtonIndex !== -1) {
                                        scope.actions.splice(addNewRowButtonIndex, 1);
                                    }
                                }
                                if (CONSTANTS.isStudioMode) {
                                    var actionsObj = {
                                        type: 'GRID',
                                        widgetName: scope.name,
                                        scopeId: scope.$id,
                                        buttonDefs: scope.actions
                                    };
                                    $rootScope.$emit('grid-defs-modified', actionsObj);
                                }
                                break;
                            case 'show':
                                /* handle show/hide events based on show property change */
                                if (newVal) {
                                    scope.onShow();
                                } else {
                                    scope.onHide();
                                }
                                break;
                            case 'readonlygrid':
                                /* For backward compatibility, if "readonlygrid" attribute is not there,
                                 * add it to the markup and save. Also set related properties - insertrow,
                                 * updaterow and deleterow to whatever their value is.
                                 * */
                                if (readOnlyGridAttrUpdated) {
                                    scope.insertrow = WM.isDefined(scope.insertrow) ? scope.insertrow : false;
                                    scope.updaterow = WM.isDefined(scope.updaterow) ? scope.updaterow : false;
                                    scope.deleterow = WM.isDefined(scope.deleterow) ? scope.deleterow : false;
                                    if (scope.widgetid) { // when the widget is in canvas
                                        $rootScope.$emit('set-markup-attr', scope.widgetid, {
                                            'readonlygrid': false,
                                            'insertrow': scope.insertrow,
                                            'updaterow': scope.updaterow,
                                            'deleterow': scope.deleterow
                                        });
                                        $rootScope.$emit('save-workspace', true);
                                    }
                                    readOnlyGridAttrUpdated = undefined;
                                }
                                if (scope.widgetid) { // when the widget is in canvas
                                    scope.widgetProps.deleterow.show = !newVal;
                                    scope.widgetProps.updaterow.show = !newVal;
                                    scope.widgetProps.insertrow.show = !newVal;
                                    scope.widgetProps.deleterow.showindesigner = !newVal;
                                    scope.widgetProps.updaterow.showindesigner = !newVal;
                                    scope.widgetProps.insertrow.showindesigner = !newVal;
                                }
                                break;
                            case 'gridclass':
                                scope.datagridElement.datagrid('option', 'cssClassNames.grid', newVal);
                                break;
                            case 'nodatamessage':
                                scope.datagridElement.datagrid('option', 'dataStates.nodata', newVal);
                                break;
                            case 'loadingdatamsg':
                                scope.datagridElement.datagrid('option', 'dataStates.loading', newVal);
                                break;
                            case 'filternullrecords':
                                if (CONSTANTS.isStudioMode) {
                                    scope.datagridElement.datagrid('option', 'filterNullRecords', newVal);
                                }
                                break;
                            case 'allowinlineedit':
                                if (!newVal || newVal === 'false') {
                                    scope.datagridElement.datagrid('option', {
                                        'allowInlineEditing': false,
                                        'multiselect': false,
                                        'allowAddNewRow': false
                                    });
                                } else {
                                    scope.datagridElement.datagrid('option', {
                                        'allowInlineEditing': true,
                                        'multiselect': true,
                                        'allowAddNewRow': true
                                    });
                                }
                                break;
                            case 'spacing':
                                scope.datagridElement.datagrid('option', 'spacing', newVal);
                                if (newVal === 'condensed') {
                                    scope.navigationClass = 'pagination-sm';
                                } else {
                                    scope.navigationClass = '';
                                }
                                break;
                            }
                        }

                        /* register the property change handler */
                        WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler, scope, notifyFor);

                        /*Register a watch on the "bindDataSet" property so that whenever the dataSet binding is changed,
                         * the "dataNavigatorWatched" value is reset.*/
                        handlers.push(scope.$watch('binddataset', function (newVal, oldVal) {
                            if (newVal !== oldVal) {
                                scope.dataNavigatorWatched = false;
                            }
                        }));

                        defineSelectedItemProp(scope, []);

                        if (CONSTANTS.isRunMode) {
                            handlers.push(scope.$watch('scopedataset', function (newVal) {
                                if (newVal && !scope.dataset) {
                                    /* decide new column defs required based on existing column defs for the grid */
                                    scope.newcolumns = !scope.columnDefsExists();
                                    scope.createGridColumns(newVal);
                                }
                            }));
                        }
                        if (WM.isDefined(scope.allowinlineedit)) {
                            if (!scope.allowinlineedit || scope.allowinlineedit === 'false') {
                                scope.datagridElement.datagrid('option', {
                                    'allowInlineEditing': false,
                                    'multiselect': false,
                                    'allowAddNewRow': false
                                });
                            } else {
                                scope.datagridElement.datagrid('option', {
                                    'allowInlineEditing': true,
                                    'multiselect': true,
                                    'allowAddNewRow': true
                                });
                            }
                        }

                        $timeout(function () {
                            scope.dataNavigator = element.find('[data-identifier=datanavigator]').isolateScope();
                            WidgetUtilService.postWidgetCreate(scope, element, attrs);
                            /*Set the default widths for the colgroup after rendering the grid*/
                            scope.datagridElement.datagrid('setColGroupWidths');
                        }, 0, false);

                        //Will be called after setting grid column property.
                        scope.reRender = function () {
                            scope.datagridElement.datagrid(scope.gridOptions);
                        };
                    }
                };
            }
        };
    }])
    .controller("gridController", [
        "$rootScope",
        "$scope",
        "$timeout",
        "$compile",
        "Variables",
        "CONSTANTS",
        "Utils",
        "dateFilter",
        "wmToaster",
        "$servicevariable",
        function ($rootScope, $scope, $timeout, $compile, Variables, CONSTANTS, Utils, dateFilter, wmToaster, $servicevariable) {
            'use strict';
            var columnObj = {
                    rowOperationsColumn: {
                        'field': 'rowOperations',
                        'type': 'custom',
                        'displayName': 'Actions',
                        'width': '80px',
                        'readonly': true,
                        'sortable': false,
                        'searchable': false,
                        'resizable': false,
                        'selectable': false,
                        'operations': [],
                        'opConfig': {}
                    }
                },
                rowOperations = {
                    'update': {
                        'config': {
                            'label': 'Update',
                            'value': 'update'
                        },
                        'property': 'updaterow'
                    },
                    'delete': {
                        'config': {
                            'label': 'Delete',
                            'value': 'delete'
                        },
                        'property': 'deleterow'
                    }
                },
                currentSearch,
                currentSort,
                isBoundToVariable,
                isBoundToWidget,
                isBoundToLiveVariable,
                isBoundToLiveVariableRoot,
                isBoundToServiceVariable,
                isBoundToStaticVariable,
                navigatorResultWatch,
                navigatorMaxResultWatch,
            /*function to transform the service data to grid acceptable data*/
                transformData = function (dataObject, variableName) {
                    var newObj,
                        tempArr,
                        keys,
                        oldKeys,
                        numKeys,
                        newObject,
                        tempObj;

                    /*data sanity testing*/
                    dataObject = dataObject || [];

                    /*if the dataObject is not an array make it an array*/
                    if (!WM.isArray(dataObject)) {
                        /*if the data returned is of type string, make it an object inside an array*/
                        if (WM.isString(dataObject)) {
                            keys = variableName.substring(variableName.indexOf(".") + 1, variableName.length).split(".");
                            oldKeys = [];
                            numKeys = keys.length;
                            newObject = {};
                            tempObj = newObject;

                            /* loop over the keys to form appropriate data object required for grid */
                            WM.forEach(keys, function (key, index) {
                                /* loop over old keys to create new object at the iterative level*/
                                WM.forEach(oldKeys, function (oldKey) {
                                    tempObj = newObject[oldKey];
                                });
                                tempObj[key] = index === numKeys - 1 ? dataObject : {};
                                oldKeys.push(key);
                            });

                            /* change the string data to the new dataObject formed*/
                            dataObject = newObject;
                        }
                        dataObject = [dataObject];
                    } else {
                        /*if the dataObject is an array and each value is a string, then lite-transform the string to an object
                         * lite-transform: just checking if the first value is string and then transforming the object, instead of traversing through the whole array
                         * */
                        if (WM.isString(dataObject[0])) {
                            tempArr = [];
                            WM.forEach(dataObject, function (str) {
                                newObj = {};
                                newObj[variableName.split('.').join('-')] = str;
                                tempArr.push(newObj);
                            });
                            dataObject = tempArr;
                        }
                    }
                    return dataObject;
                },
            /* Function to populate the grid with data. */
                populateGridData = function (serviceData) {
                    var dataValid,
                        variableName,
                        gridElement,
                        parent;

                    if ($scope.binddataset) {
                        if (isBoundToVariable) {
                            variableName = $scope.binddataset.substr($scope.binddataset.lastIndexOf("bind:Variables.") + 15);
                        } else if (isBoundToWidget) {
                            variableName = serviceData.variableName;
                        }

                        /* Retrieve the variable details specific to the project in the root-scope */
                        /* As this event is registered on rootscope, it is triggered on destroy hence the object.keys length check is put skip
                         cases when the project object doesn't have variables */
                        $scope.gridVariable = serviceData;
                        if ($scope.gridVariable && $scope.gridVariable.propertiesMap) {
                            $scope.serverData = $scope.gridVariable.data;
                        }
                        if ($scope.gridVariable.propertiesMap) {
                            dataValid = $scope.serverData && !$scope.serverData.error;
                            /* if data exists and data is not error type, and data type is object then change it to array of data*/
                            if (dataValid && !WM.isArray($scope.serverData)) {
                                $scope.serverData = [$scope.serverData];
                            }
                        } else {
                            /*Transform the data if it is a object*/
                            serviceData = transformData(serviceData, variableName);
                            $scope.serverData = serviceData;
                        }

                        /*Function to remove the empty data*/
                        $scope.serverData = serviceData;

                        /*check if new column defs required*/
                        if ($scope.columnDefsExists() && !$scope.newDefsRequired) {
                            setGridData($scope.serverData);
                        } else if (CONSTANTS.isRunMode) {
                            $scope.newcolumns = true;
                            $scope.newDefsRequired = true;
                            $scope.createGridColumns($scope.serverData);
                        }
                    } else {
                        /*Allowing when the data is directly given to the dataset*/
                        $scope.serverData = serviceData;
                        setGridData($scope.serverData);
                    }

                    /* If grid is inside a hidden tab/accordian panel, set that panel's initialized flag to false to rerender grid on panel's focus */
                    gridElement = WM.element('[data-identifier="grid"][name="' + $scope.name + '"]');
                    if (gridElement.length && !gridElement[0].getBoundingClientRect().height) {
                        parent = gridElement.closest('.app-accordion-panel, .tab-pane').isolateScope();
                        if (parent) {
                            parent.initialized = false;
                        }
                    }
                },
                searchGrid = function (searchObj) {

                    var filterFields,
                        variable = $scope.gridElement.scope().Variables[$scope.variableName];

                    /*Set the filter fields based on the search options entered.*/
                    filterFields = {};
                    /*Set the filter options only when a field/column has been selected.*/
                    if (searchObj.field) {
                        currentSearch = searchObj;
                        filterFields[searchObj.field] = {
                            'value': searchObj.value
                        };
                    }

                    variable.update({
                        "type": "wm.LiveVariable",
                        "page": 1,
                        "filterFields": filterFields,
                        "matchMode": 'anywhere',
                        "ignoreCase": true,
                        "scope": $scope.gridElement.scope()
                    }, function (data, propertiesMap, pagingOptions) {
                        $scope.serverData = data;
                        /*Check for sanity*/
                        if ($scope.dataNavigator) {
                            $scope.dataNavigator.dataset = {
                                "data": data,
                                "propertiesMap": propertiesMap,
                                "pagingOptions": pagingOptions,
                                "filterFields": filterFields,
                                "variableName": $scope.variableName
                            };

                            /*If the current page does not contain any records due to deletion, then navigate to the previous page.*/
                            if ($scope.dataNavigator.pageCount < $scope.dataNavigator.currentPage) {
                                $scope.dataNavigator.navigatePage('prev');
                            }
                        }
                        setGridData($scope.serverData);

                    }, function (error) {
                        wmToaster.show('error', 'ERROR', 'No results found.');
                        setGridData([]);
                    });
                },
                sortHandler = function (sortObj, e) {
                    var filterFields,
                        variable = $scope.gridElement.scope().Variables[$scope.variableName],
                        fieldName = variable.category === 'wm.LiveVariable' ? variable.getModifiedFieldName(sortObj.field) : sortObj.field,
                        sortOptions = fieldName + ' ' + sortObj.direction;
                    /* Update the sort info for passing to datagrid */
                    $scope.gridOptions.sortInfo.field = sortObj.field;
                    $scope.gridOptions.sortInfo.direction = sortObj.direction;

                    if (sortObj.direction) {
                        $scope.sortInfo = Utils.getClonedObject(sortObj);
                        if ($scope.gridsearch && currentSearch) {
                            /*Set the filter fields based on the search options entered.*/
                            filterFields = {};
                            /*Set the filter options only when a field/column has been selected.*/
                            if (currentSearch.field) {
                                filterFields[currentSearch.field] = {
                                    'value': currentSearch.value,
                                    'type': currentSearch.type
                                };
                            }
                        }

                        if ($scope.isBoundToFilter && $scope.widgetName) {
                            /* if Grid bound to filter, get sorted data through filter widget (with applied filters in place)*/
                            $scope.Widgets[$scope.widgetName].applyFilter({"orderBy": sortOptions});
                        } else if (variable.category === 'wm.LiveVariable') {
                            /* else get sorted data through variable */
                            variable.update({
                                'type': 'wm.LiveVariable',
                                'page': 1,
                                'filterFields': filterFields,
                                'orderBy': sortOptions,
                                'matchMode': 'anywhere',
                                'ignoreCase': true,
                                'scope': $scope.gridElement.scope()
                            }, function (data, propertiesMap, pagingOptions) {
                                /*Navigate to the first page upon sorting.*/
                                $scope.dataNavigator.navigatePage("first");
                                $scope.serverData = data;
                                /*Check for sanity*/
                                if ($scope.dataNavigator) {
                                    $scope.dataNavigator.dataset = {
                                        'data': data,
                                        'propertiesMap': propertiesMap,
                                        'pagingOptions': pagingOptions,
                                        'filterFields': filterFields,
                                        'sortOptions': sortOptions,
                                        'variableName': $scope.variableName
                                    };

                                    /*If the current page does not contain any records due to deletion, then navigate to the previous page.*/
                                    if ($scope.dataNavigator.pageCount < $scope.dataNavigator.currentPage) {
                                        $scope.dataNavigator.navigatePage('prev');
                                    }
                                }
                                setGridData($scope.serverData);

                            }, function (error) {
                                wmToaster.show('error', 'ERROR', error);
                            });
                        } else if (variable.category === "wm.ServiceVariable") {
                            /* Will be called only in case of Query service variables */
                            variable.update({
                                'orderBy': sortOptions,
                                'page': 1
                            }, function (data) {
                                /*Navigate to the first page upon sorting.*/
                                $scope.serverData = data.content;
                                /*Check for sanity*/
                                if ($scope.dataNavigator) {
                                    $scope.dataNavigator.dataset = data;

                                    /*If the current page does not contain any records due to deletion, then navigate to the previous page.*/
                                    if ($scope.dataNavigator.pageCount < $scope.dataNavigator.currentPage) {
                                        $scope.dataNavigator.navigatePage('prev');
                                    }
                                }
                                setGridData($scope.serverData);
                            }, function (error) {
                                wmToaster.show('error', 'ERROR', error);
                            })
                        }
                    }
                },
                /*Returns data filtered using searchObj*/
                getSearchResult = function (data, searchObj) {
                    if (searchObj) {
                        data = _.filter(data, function (obj) {
                            return _.includes(obj[searchObj.field], searchObj.value);
                        });
                    }
                    return data;
                },
                /*Returns data sorted using sortObj*/
                getSortResult = function (data, sortObj) {
                    if (sortObj) {
                        data = _.orderBy(data, sortObj.field, sortObj.direction);
                    }
                    return data;
                },
                /*Function to handle both sort and search operations if bound to service/static variable*/
                handleOperation = function (searchSortObj, e, type) {
                    var data = WM.copy($scope.dataset);
                    //Storing in global variables for further use
                    //While sorting previously stored search obj(current search) is used.And viceversa
                    if (type === 'search') {
                        currentSearch = searchSortObj;
                    } else {
                        currentSort = searchSortObj;
                    }
                    /*Both the functions return same 'data' if arguments are undefined*/
                    data = getSearchResult(data, currentSearch);
                    data = getSortResult(data, currentSort);
                    $scope.serverData = data;
                    $scope.dataNavigator.dataset = data;
                    setGridData($scope.serverData);
                    if (type === 'sort') {
                        //Calling 'onSort' event
                        $scope.onSort({$event: e, $data: $scope.serverData});
                    }
                },
                getCompiledTemplate = function (htm, row, colDef, refreshImg) {
                    var rowScope = $scope.$new(),
                        el = WM.element(htm),
                        ngSrc,
                        imageEl;
                    rowScope.row = row;
                    rowScope.row.getProperty = function (field) {
                        return row[field];
                    };
                    rowScope.colDef = colDef;
                    rowScope.columnValue = row[colDef.field];
                    if (refreshImg && colDef.widgetType === 'image') {
                        ngSrc = el.attr('data-ng-src');  //As url will be same but image changes in the backend after edit operation, add timestamp to src to force refresh the image
                        if (ngSrc) {
                            imageEl = el;
                        } else {
                            imageEl = el.find('img');  //If src is not present, check for the image tag inside
                            ngSrc = imageEl.attr('data-ng-src');
                        }
                        if (ngSrc) {
                            imageEl.attr('data-ng-src', ngSrc.concat('?_ts=' + new Date().getTime())); //Add the current timestamp to the src to force refresh the image.
                        }
                    }
                    return $compile(el)(rowScope);
                },
                /*Compile the templates in the grid scope*/
                compileTemplateInGridScope = function (htm) {
                    var el = WM.element(htm);
                    return $compile(el)($scope);
                },
            /* Check whether it is non-empty row. */
                isEmptyRecord = function (record) {
                    var properties = Object.keys(record),
                        data,
                        isDisplayed;

                    return properties.every(function (prop, index) {
                        data = record[prop];
                        /* If fieldDefs are missing, show all columns in data. */
                        isDisplayed = ($scope.fieldDefs.length && WM.isDefined($scope.fieldDefs[index]) && (CONSTANTS.isMobile ?
                                $scope.fieldDefs[index].mobileDisplay : $scope.fieldDefs[index].pcDisplay)) || true;
                        /*Validating only the displayed fields*/
                        if (isDisplayed) {
                            return (data === null || data === undefined || data === '');
                        }
                        return true;
                    });
                },
            /* Function to remove the empty data. */
                removeEmptyRecords = function (serviceData) {
                    var allRecords = serviceData.data || serviceData,
                        filteredData = [];
                    if (allRecords && allRecords.length) {
                        /*Comparing and pushing the non-empty data columns*/
                        filteredData = allRecords.filter(function (record) {
                            return record && !isEmptyRecord(record);
                        });
                    }
                    return filteredData;
                },
                setGridData = function (serverData) {
                    var data = serverData;
                    /*If serverData has data but is undefined, then return*/
                    if (isBoundToLiveVariableRoot || WM.isDefined(serverData.propertiesMap)) {
                        if (!serverData.data || Utils.isEmptyObject(serverData.data)) {
                            return;
                        }
                        data = serverData.data;
                    }
                    if ($scope.filternullrecords) {
                        $scope.gridData = removeEmptyRecords(data);
                    } else {
                        $scope.gridData = data;
                    }
                    if ($scope.gridData && $scope.gridData.length === 0) {
                        $scope.datagridElement.datagrid('setStatus', 'nodata', $scope.nodatamessage);
                    } else {
                        $scope.datagridElement.datagrid('setStatus', 'ready');
                    }
                    $scope.$root.$safeApply($scope);
                },
                updateVariable = function (variable) {
                    /*If grid is bound to filter, update the variable dataset*/
                    if ($scope.isBoundToFilter) {
                        variable.update({
                            'type': 'wm.LiveVariable'
                        }, WM.noop);
                    }
                },
                deleteRecord = function (row, cancelRowDeleteCallback) {
                    if ($scope.gridVariable.propertiesMap && $scope.gridVariable.propertiesMap.tableType === "VIEW") {
                        wmToaster.show('info', 'Not Editable', 'Table of type view, not editable');
                        $scope.$root.$safeApply($scope);
                        return;
                    }
                    /* delete if user confirm to delete*/
                    if (confirm($scope.confirmdelete)) {
                        var variable = $scope.gridElement.scope().Variables[$scope.variableName];
                        if (!variable) {
                            return;
                        }
                        variable.deleteRecord({
                            "row": row,
                            "transform": true,
                            "scope": $scope.gridElement.scope()
                        }, function (success) {
                            /* check the response whether the data successfully deleted or not , if any error occurred show the
                             * corresponding error , other wise remove the row from grid */
                            if (success && success.error) {
                                wmToaster.show("error", "ERROR", success.error);
                                return;
                            }
                            /*Emit on row delete to handle any events listening to the delete action*/
                            $scope.$emit('on-row-delete', row);

                            $scope.onRecordDelete();
                            updateVariable(variable);
                            if ($scope.deletemessage) {
                                wmToaster.show("success", "SUCCESS", $scope.deletemessage);
                            }
                            /*custom EventHandler for row deleted event*/
                            $scope.onRowdeleted({$data: row});

                        }, function (error) {
                            wmToaster.show("error", "ERROR", error);
                        });
                    } else {
                        if (cancelRowDeleteCallback) {
                            cancelRowDeleteCallback();
                        }
                    }
                },
                insertRecord = function (options) {
                    /*TODO To be uncommented after onRowinsert gets the right value i.e., onRowinsert should have the value defined from the widget events.*/
                    /*if (WM.isDefined($scope.onRowinsert)) {
                        $scope.onRowinsert(rowData);
                        return;
                    }*/

                    var variable = $scope.gridElement.scope().Variables[$scope.variableName],
                        dataObject = {
                            "row": options.row,
                            "transform": true,
                            "scope": $scope.gridElement.scope(),
                            "multipartData": options.multipartData
                        };

                    if (!variable) {
                        return;
                    }
                    variable.insertRecord(dataObject, function (response) {
                        /*Display appropriate error message in case of error.*/
                        if (response.error) {
                            wmToaster.show('error', 'ERROR', response.error);
                            Utils.triggerFn(options.error, response);
                        } else {
                            if ($scope.allowinlineedit && $scope.allowinlineedit !== "false" && options.event) {
                                var row = WM.element(options.event.target).closest('tr');
                                $scope.datagridElement.datagrid('hideRowEditMode', row);
                            }
                            wmToaster.show('success', 'SUCCESS', 'Record added successfully');
                            $scope.initiateSelectItem('last', response, $scope.primaryKey);
                            updateVariable(variable);
                            Utils.triggerFn(options.success, response);
                        }
                    }, function (error) {
                        wmToaster.show('error', 'ERROR', error);
                        Utils.triggerFn(options.error, error);
                    });
                },
                updateRecord = function (options) {
                    /*TODO To be uncommented after onRowupdated gets the right value i.e., onRowupdated should have the value defined from the widget events.*/
                    /*if (WM.isDefined($scope.onRowupdated)) {
                        $scope.onRowupdated(rowData);
                        return;
                    }*/
                    var variable = $scope.gridElement.scope().Variables[$scope.variableName],
                        dataObject = {
                            "row": options.row,
                            "prevData": options.prevData,
                            "multipartData": options.multipartData,
                            "transform": true,
                            "scope": $scope.gridElement.scope()
                        };

                    if (!variable) {
                        return;
                    }
                    variable.updateRecord(dataObject, function (response) {
                        /*Display appropriate error message in case of error.*/
                        if (response.error) {
                            /*disable readonly and show the appropriate error*/
                            wmToaster.show('error', 'ERROR', response.error);
                            Utils.triggerFn(options.error, response);
                        } else {
                            if (options.event) {
                                var row = WM.element(options.event.target).closest('tr');
                                $scope.datagridElement.datagrid('hideRowEditMode', row);
                            }
                            $scope.operationType = "";
                            wmToaster.show('success', 'SUCCESS', 'Record updated successfully');
                            $scope.initiateSelectItem('current', response, $scope.primaryKey);
                            updateVariable(variable);
                            Utils.triggerFn(options.success, response);
                        }
                    }, function (error) {
                        wmToaster.show('error', 'ERROR', error);
                        Utils.triggerFn(options.error, error);
                    });
                },
            /*Function to remove the column containing row operations.*/
                removeOperationColumns = function () {
                    var lastColumn = $scope.fieldDefs[$scope.fieldDefs.length - 1];
                    if (lastColumn.type === 'custom' && lastColumn.field === 'rowOperations') {
                        $scope.fieldDefs.pop();
                    }
                },
            /*Function to fetch the reference variable details when a grid2 is bound to another grid1 and grid1 is bound to a variable.*/
                fetchReferenceDetails = function () {
                    var bindDataSetSplit,
                        referenceWidgetName,
                        referenceWidget,
                        referenceBindDataSet,
                        referenceVariableName,
                        relatedFieldName,
                        relatedFieldType,
                        fields,
                        details,
                        referenceVariable,
                        isBoundToSelectedItemSubset = $scope.binddataset.indexOf('selecteditem.') !== -1;

                    bindDataSetSplit = $scope.binddataset.split('.');
                    referenceWidgetName = bindDataSetSplit[1];
                    referenceWidget = $scope.Widgets[referenceWidgetName];
                    referenceBindDataSet = referenceWidget.binddataset;

                    /*the binddataset comes as bind:Variables.VariableName.dataset.someOther*/
                    referenceVariableName = referenceBindDataSet.replace('bind:Variables.', '');
                    referenceVariableName = referenceVariableName.substr(0, referenceVariableName.indexOf('.'));

                    referenceVariable = Variables.getVariableByName(referenceVariableName);
                    relatedFieldName = isBoundToSelectedItemSubset && bindDataSetSplit[3];
                    fields = (referenceVariable !== null) && $rootScope.dataTypes &&
                        $rootScope.dataTypes[referenceVariable.package || referenceVariable.type].fields;
                    details = {
                        'referenceVariableName': referenceVariableName,
                        'referenceWidget': referenceWidget,
                        'referenceVariable': referenceVariable,
                        'relatedFieldName': relatedFieldName
                    };
                    /* If binddataset is of the format: bind:Widgets.widgetName.selecteditem.something,
                     * i.e. widget is bound to a subset of selected item, get type of that subset.*/
                    if (relatedFieldName && fields) {
                        relatedFieldType = fields[relatedFieldName].type;
                        details['relatedFieldType'] = relatedFieldType;
                    } else {
                        /* When binddataset is of the format: bind:Widgets.widgetName.selecteditem */
                        details['fields'] = fields;
                    }
                    return details;
                },
                isBoundToView = function () {
                    return $scope.dataset.propertiesMap && $scope.dataset.propertiesMap.tableType === 'VIEW';
                };
            /* Function to reset the column definitions dynamically. */
            $scope.resetColumnDefinitions = function () {
                $scope.fieldDefs = [];
                $scope.setDataGridOption('colDefs', Utils.getClonedObject($scope.fieldDefs));
            };

            /*Function to render the column containing row operations.*/
            $scope.renderOperationColumns = function () {

                /*Return if no fieldDefs are present.*/
                if (!$scope.fieldDefs.length) {
                    return;
                }
                /*Invoke the function to remove the column containing row operations.*/
                removeOperationColumns();

                var opConfig = {},
                    operations = [];
                /*Loop through the "rowOperations"*/
                WM.forEach(rowOperations, function (field, fieldName) {
                    /* Add it to operations only if the corresponding property is enabled.*/
                    if ($scope[field.property]) {
                        opConfig[fieldName] = rowOperations[fieldName].config;
                        operations.push(fieldName);
                    }
                });

                /*Add the column for row operations only if at-least one operation has been enabled.*/
                if (operations.length) {
                    columnObj.rowOperationsColumn.operations = operations;
                    columnObj.rowOperationsColumn.opConfig = opConfig;
                    $scope.fieldDefs.push(columnObj.rowOperationsColumn);
                }
            };

            $scope.fieldDefs = [];
            $scope.fullFieldDefs = [];
            /* This is the array which contains all the selected items */
            $scope.selectedItems = [];
            $scope.toggleVariableHandlerAttached = false;

            $scope.$watch('gridData', function (newValue) {
                var startRowIndex,
                    gridOptions;

                if (WM.isDefined(newValue)) {
                    /*Setting the serial no's only when show navigation is enabled and data navigator is compiled
                     and its current page is set properly*/
                    if ($scope.shownavigation && $scope.dataNavigator && $scope.dataNavigator.currentPage) {
                        startRowIndex = (($scope.dataNavigator.currentPage - 1) * $scope.dataNavigator.maxResults) + 1;
                        $scope.setDataGridOption('startRowIndex', startRowIndex);
                    }
                    /* If colDefs are available, but not already set on the datagrid, then set them.
                     * This will happen while switching from markup to design tab. */
                    gridOptions = $scope.datagridElement.datagrid('getOptions');
                    if (!gridOptions.colDefs.length && $scope.fieldDefs.length) {
                        $scope.setDataGridOption('colDefs', Utils.getClonedObject($scope.fieldDefs));
                    }
                    $scope.setDataGridOption('data', Utils.getClonedObject(newValue));
                }
            });

            $scope.addNewRow = function () {
                var shouldInsert = $scope.onBeforerowinsert();
                if (WM.isUndefined(shouldInsert) || shouldInsert) {
                    $scope.datagridElement.datagrid('addNewRow');
                    $scope.$emit('add-new-row');
                    $rootScope.$emit("wm-event", $scope.widgetid, "create");
                }
            };

            $scope.isGridEditMode = false;
            $scope.gridData = [];
            $scope.gridOptions = {
                data: Utils.getClonedObject($scope.gridData),
                colDefs: $scope.fieldDefs,
                startRowIndex: 1,
                onRowSelect: function (rowData, e) {
                    $scope.selectedItems = $scope.datagridElement.datagrid('getSelectedRows');
                    $scope.onSelect({$data: rowData, $event: e});
                    $scope.onRowclick({$data: rowData, $event: e});
                    // For backward compatibility.
                    if (WM.isDefined($scope.onClick)) {
                        $scope.onClick({$data: rowData, $event: e});
                    }
                    $rootScope.$safeApply($scope);
                },
                onRowDeselect: function (rowData, e) {
                    $scope.selectedItems = $scope.datagridElement.datagrid('getSelectedRows');
                    $scope.onDeselect({$data: rowData, $event: e});
                    $rootScope.$safeApply($scope);
                },
                onColumnSelect: function (col, e) {
                    $scope.selectedColumns = $scope.datagridElement.datagrid('getSelectedColumns');
                    $scope.onColumnselect({$data: col, $event: e});
                    $rootScope.$safeApply($scope);
                },
                onColumnDeselect: function (col, e) {
                    $scope.selectedColumns = $scope.datagridElement.datagrid('getSelectedColumns');
                    $scope.onColumndeselect({$data: col, $event: e});
                    $rootScope.$safeApply($scope);
                },
                onHeaderClick: function (e) {
//                    /* if onSort function is registered invoke it when the column header is clicked */
//                    $scope.onSort({$event: e, $data: e.data.col});
                    $scope.onHeaderclick({$event: e, $data: e.data.col});
                },
                onRowDelete: function (rowData, cancelRowDeleteCallback, e) {
                    deleteRecord(rowData, cancelRowDeleteCallback);
                },
                onRowInsert: function (rowData, e, multipartData) {
                    insertRecord({'row': rowData, 'multipartData': multipartData, event: e});
                },
                beforeRowUpdate: function (rowData, e, eventName) {
                    /*TODO: Check why widgetid is undefined here.*/
                    $scope.$emit('update-row', $scope.widgetid, rowData, eventName);
                    $scope.prevData = Utils.getClonedObject(rowData);
                    $rootScope.$safeApply($scope);
                    $rootScope.$emit('wm-event', $scope.widgetid, 'update');
                    /*TODO: Bind this event.*/
//                    $scope.beforeRowupdate({$data: rowData, $event: e});
                },
                afterRowUpdate: function (rowData, e, multipartData) {
                    updateRecord({'row': rowData, 'prevData': $scope.prevData, 'event': e, 'multipartData': multipartData});
                },
                onSetRecord: function (rowData, e) {
                    $scope.onSetrecord({$data: rowData, $event: e});
                },
                allowDeleteRow: true,
                allowInlineEditing: true,
                sortInfo: {
                    'field': '',
                    'direction': ''
                },
                getCompiledTemplate: function (htm, row, colDef, refreshImg) {
                    return getCompiledTemplate(htm, row, colDef, refreshImg);
                },
                compileTemplateInGridScope: function (htm) {
                    return compileTemplateInGridScope(htm);
                },
                setGridEditMode: function (val) {
                    $scope.isGridEditMode = val;
                },
                noChangesDetected: function () {
                    wmToaster.show('info', '', 'No changes detected');
                    $scope.$root.$safeApply($scope);
                },
                afterSort: function () {
                    $rootScope.$safeApply($scope);
                }
            };

            $scope.resetPageNavigation = function () {
                /*Check for sanity*/
                if ($scope.dataNavigator) {
                    $scope.dataNavigator.resetPageNavigation();
                }
            };

            /*Function to enable page navigation for the grid.*/
            $scope.enablePageNavigation = function () {
                if ($scope.dataset) {
                    /*Check for sanity*/
                    if ($scope.dataNavigator) {

                        $scope.dataNavigator.pagingOptions = {
                            maxResults: $scope.pagesize || 5
                        };
                        /*De-register the watch if it is exists */
                        Utils.triggerFn(navigatorResultWatch);
                        $scope.dataNavigator.dataset = $scope.binddataset;
                        if (CONSTANTS.isStudioMode && $scope.variableType === 'wm.ServiceVariable') {
                            return;
                        }
                        /*Register a watch on the "result" property of the "dataNavigator" so that the paginated data is displayed in the live-list.*/
                        navigatorResultWatch = $scope.dataNavigator.$watch('result', function (newVal) {
                            /* Check for sanity. */
                            if (WM.isDefined(newVal)) {
                                $scope.watchVariableDataSet(newVal, $scope.gridElement);
                            }
                        });
                        /*De-register the watch if it is exists */
                        Utils.triggerFn(navigatorMaxResultWatch);
                        /*Register a watch on the "maxResults" property of the "dataNavigator" so that the "pageSize" is displayed in the live-list.*/
                        navigatorMaxResultWatch = $scope.dataNavigator.$watch('maxResults', function (newVal) {
                            $scope.pagesize = newVal;
                        });

                        $scope.dataNavigatorWatched = true;
                    }
                }
            };

            /*Function to dynamically fetch column definitions.*/
            $scope.fetchDynamicColumnDefs = function () {
                var fields,
                    result,
                    f,
                    dataKeys;

                /*Invoke the function to fetch the reference variable details when a grid2 is bound to another grid1 and grid1 is bound to a variable.*/
                result = fetchReferenceDetails();
                if (result.fields) {
                    f = result.fields;
                    dataKeys = Object.keys(f);
                    fields = {};
                    dataKeys.forEach(function (key) {
                        fields[key] = '';
                    });
                } else if (result.relatedFieldType) {
                    /*Invoke the function to fetch sample data-structure for the field.*/
                    fields = $servicevariable.getServiceModel({
                        typeRef: result.relatedFieldType,
                        variable: result.referenceVariable
                    });
                }
                if (fields) {
                    $scope.watchVariableDataSet(fields, $scope.gridElement);
                }
            };

            /*Function to dynamically fetch data.*/
            $scope.fetchDynamicData = function () {
                var reference,
                    referenceVariableKey,
                    watchSelectedItem,
                    referenceVariable;

                /*Invoke the function to fetch the reference variable details when a grid2 is bound to another grid1 and grid1 is bound to a variable.*/
                reference = fetchReferenceDetails();

                /*Check if a watch is not registered on selectedItem.*/
                if (!$scope.selectedItemWatched) {
                    watchSelectedItem = reference.referenceWidget.$watch('selecteditem', function (newVal, oldVal) {

                        $scope.selectedItemWatched = true;

                        /*Check for sanity of newVal.*/
                        /*Check for sanity of newVal.*/
                        if (newVal && !WM.equals(newVal, oldVal)) {

                            referenceVariable = Variables.getVariableByName(reference.referenceVariableName);
                            /*Check if "referenceVariableKey" has already been computed.*/
                            if (!referenceVariableKey && referenceVariable && referenceVariable.category === 'wm.LiveVariable') {
                                /*Invoke the function to get the primary key.*/
                                referenceVariableKey = referenceVariable.getPrimaryKey();

                                /*If the there is a single primary key, fetch the first element of the array.*/
                                if (referenceVariableKey.length === 1) {
                                    referenceVariableKey = referenceVariableKey[0];
                                }

                                /*De-register the watch on selected item.*/
                                watchSelectedItem();

                                /*Register a watch on the primary key field of the selected item.*/
                                reference.referenceWidget.$watch('selecteditem.' + referenceVariableKey, function (newVal) {
                                    /*Check for sanity.*/
                                    if (newVal) {
                                        /*Invoke the function to update the related data of the variable for the specified relatedFieldName.*/
                                        referenceVariable.updateRelatedData({
                                            'id': reference.referenceWidget.selecteditem[referenceVariableKey],
                                            'relatedFieldName': reference.relatedFieldName,
                                            'scope': $scope.gridElement.scope()
                                        }, function (data, propertiesMap, pagingOptions) {
                                            /*Check for sanity of data.*/
                                            if (WM.isDefined(data)) {
                                                if (!$scope.dataNavigatorWatched) {
                                                    $scope.dataNavigator.dataset = $scope.binddataset;
                                                }
                                                $scope.watchVariableDataSet(data, $scope.gridElement);
                                            }
                                            /*Check for sanity*/
                                            if ($scope.dataNavigator) {
                                                $scope.dataNavigator.dataset = {
                                                    "data": data,
                                                    "propertiesMap": propertiesMap,
                                                    "pagingOptions": pagingOptions,
                                                    "variableName": reference.referenceVariableName
                                                };

                                                /*If the current page does not contain any records due to deletion, then navigate to the previous page.*/
                                                if ($scope.dataNavigator.pageCount < $scope.dataNavigator.currentPage) {
                                                    $scope.dataNavigator.navigatePage("prev");
                                                }
                                            }
                                        }, function (error) {
                                            wmToaster.show("error", "ERROR", error);
                                        });
                                    }
                                });
                            }
                        }
                    }, true);
                }
            };
            $scope.isDataValid = function () {
                var error;

                /*In case "data" contains "error" & "errorMessage", then display the error message in the grid.*/
                if ($scope.dataset.error) {
                    error = $scope.dataset.error;
                }
                if ($scope.dataset.data && $scope.dataset.data.error) {
                    if ($scope.dataset.data.errorMessage) {
                        error = $scope.dataset.data.errorMessage;
                    }
                }
                if (error) {
                    setGridData([]);
                    $scope.datagridElement.datagrid('setStatus', 'error', error);
                    return false;
                }
                return true;
            };

            $scope.watchVariableDataSet = function (newVal, element) {
                /* TODO: In studio mode, service variable data should initially
                    be empty array, and metadata should be passed separately. */
                var variableName,
                    widgetName,
                    variableObj,
                    elScope,
                    result,
                    selectedItemIndex,
                    isBoundToSelectedItem,
                    isBoundToSelectedItemSubset,
                    isBoundToServiceVariableSelectedItem,
                    isBoundToQueryServiceVariable,
                    isBoundToFilter,
                    columns;
                $scope.datagridElement.datagrid('setStatus', 'loading', $scope.loadingdatamsg);

                result = Utils.getValidJSON(newVal);

                /*Reset the values to undefined so that they are calculated each time.*/
                isBoundToLiveVariable = undefined;
                isBoundToLiveVariableRoot = undefined;
                isBoundToServiceVariable = undefined;
                isBoundToStaticVariable = undefined;
                isBoundToQueryServiceVariable = undefined;
                isBoundToFilter = undefined;
                isBoundToServiceVariableSelectedItem = undefined;
                $scope.gridVariable = '';
                /* Always set newcolumns equal to value of redrawColumns coming from datamodel design controller. */
                if (CONSTANTS.isStudioMode && WM.isDefined($scope.$parent) && $scope.$parent.redrawColumns) {
                    $scope.newcolumns = $scope.$parent.redrawColumns;
                }

                //Converting newval to object if it is an Object that comes as a string "{"data" : 1}"
                if (result) {
                    newVal = result;
                }

                /*Return if data is invalid.*/
                if (!$scope.isDataValid()) {
                    return;
                }

                /*If the data is a pageable object, then display the content.*/
                if (WM.isObject(newVal) && Utils.isPageable(newVal)) {
                    newVal = newVal.content;
                }

                if (newVal) {
                    if (!$scope.dataNavigatorWatched) {
                        $scope.enablePageNavigation();
                    }
                } else {
                    $scope.resetPageNavigation();
                    /*for run mode, disabling the loader and showing no data found message if dataset is not valid*/
                    if (CONSTANTS.isRunMode) {
                        $scope.datagridElement.datagrid('setStatus', 'nodata', $scope.nodatamessage);
                        $scope.setDataGridOption('selectFirstRow', $scope.gridfirstrowselect);
                    }
                }
                if ($scope.binddataset) {
                    isBoundToVariable = $scope.binddataset.indexOf('bind:Variables.') !== -1;
                    isBoundToWidget = $scope.binddataset.indexOf('bind:Widgets.') !== -1;
                    if (isBoundToVariable) {
                        /*the binddataset comes as bind:Variables.VariableName.dataset.someOther*/
                        variableName = $scope.binddataset.replace('bind:Variables.', '');
                        variableName = variableName.substr(0, variableName.indexOf('.'));
                    } else if (isBoundToWidget) {
                        widgetName = $scope.binddataset.replace('bind:Widgets.', '').split(".")[0];
                        isBoundToFilter = $scope.Widgets[widgetName]._widgettype === 'wm-livefilter';

                        $scope.isBoundToFilter = isBoundToFilter;
                        $scope.widgetName = widgetName;

                        variableName = Utils.getVariableName($scope);
                        variableObj = element.scope().Variables && element.scope().Variables[variableName];
                        isBoundToSelectedItem = $scope.binddataset.indexOf('selecteditem') !== -1;
                        isBoundToSelectedItemSubset = $scope.binddataset.indexOf('selecteditem.') !== -1;
                        isBoundToServiceVariableSelectedItem = variableObj && variableObj.category === 'wm.ServiceVariable';
                        if (isBoundToSelectedItemSubset || isBoundToSelectedItem) {
                            if (variableName === null) {
                                var widgetBindingDetails = fetchReferenceDetails();
                                if (!widgetBindingDetails.fields) {
                                    var relatedTables = (widgetBindingDetails.referenceVariable && widgetBindingDetails.referenceVariable.relatedTables) || [];
                                    variableName = widgetBindingDetails.referenceVariableName;
                                    relatedTables.forEach(function (val) {
                                        if (val.columnName === widgetBindingDetails.relatedFieldName) {
                                            variableName = val.watchOn;
                                        }
                                    });
                                }
                            }
                            /*Check for studio mode.*/
                            if (CONSTANTS.isStudioMode && newVal !== '') {
                                /*If "newVal" is not available(in studio mode, newVal will be same as bindDataSet with 'bind:' removed; for the first time)
                                 , fetch column definitions dynamically.*/
                                if (($scope.binddataset === ('bind:' + newVal)) || (WM.isArray(newVal) && !newVal.length)) {
                                    $scope.fetchDynamicColumnDefs();
                                    return;
                                }
                            } else if (!newVal) { /*In run-mode, if "newVal" is not available, fetch data dynamically.*/
                                $scope.fetchDynamicData();
                            }
                        }
                    }
                    if (variableName && !$scope.toggleVariableHandlerAttached) {
                        $scope.toggleVariableStateHandler = $rootScope.$on('toggle-variable-state', function (event, boundVariableName, active) {
                            /*based on the active state and response toggling the 'loading data...' and 'no data found' messages. */
                            if (boundVariableName === variableName) {
                                $scope.variableInflight = active;
                            }
                        });
                        $scope.toggleVariableHandlerAttached = true;
                    }
                    elScope = element.scope();

                    /*TODO to remove is studiomode check*/
                    if ($scope.variableName && (variableName !== $scope.variableName) && CONSTANTS.isStudioMode) {
                        $scope.fullFieldDefs = [];
                    }
                    $scope.variableName = variableName;
                    variableObj = elScope.Variables && elScope.Variables[$scope.variableName];

                    if (variableObj && isBoundToVariable) {
                        /* set the variable type info to the grid selecteditem type (for reflection while binding to grid.selecteditem)*/
                        $scope.widgetProps.selecteditem.type = 'object, ' + variableObj.type;
                        $scope.variableType = variableObj.category;

                        /*Check if the variable is a liveVariable*/
                        isBoundToLiveVariable = $scope.variableType === 'wm.LiveVariable';
                        isBoundToLiveVariableRoot = isBoundToLiveVariable &&
                            $scope.binddataset.indexOf('dataSet.') === -1 &&
                            $scope.binddataset.indexOf('selecteditem') === -1;
                        isBoundToServiceVariable = $scope.variableType === 'wm.ServiceVariable';
                        isBoundToStaticVariable = $scope.variableType === 'wm.Variable';
                        isBoundToQueryServiceVariable = isBoundToServiceVariable && (variableObj.serviceType === 'DataService');

                        if (isBoundToLiveVariable) {
                            $scope.setDataGridOption('searchHandler', searchGrid);
                            $scope.setDataGridOption('sortHandler', sortHandler);

                            if ($scope.dataset.propertiesMap && $scope.dataset.propertiesMap.columns) {
                                $scope.primaryKey = variableObj.getPrimaryKey();
                            }
                            $scope.contentBaseUrl = ((variableObj.prefabName !== "" && variableObj.prefabName !== undefined) ? "prefabs/" + variableObj.prefabName : "services") + '/' + variableObj.liveSource + '/' + variableObj.type + '/';
                        } else if (variableObj.serviceType === 'DataService' && variableObj.controller !== 'ProcedureExecution') {
                            /*Calling the specific search and sort handlers*/
                            $scope.setDataGridOption('sortHandler', sortHandler);
                        } else if (variableObj.serviceType !== 'DataService') {
                            /*Calling the specific search and sort handlers*/
                            $scope.setDataGridOption('searchHandler', handleOperation);
                            $scope.setDataGridOption('sortHandler', handleOperation);
                        }
                    } else if (isBoundToFilter) {
                        /*If the variable is deleted hiding the spinner and showing the no data found message*/
                        $scope.setDataGridOption('sortHandler', sortHandler);
                    } else if ($scope.binddataset.indexOf('bind:Widgets') === -1) {
                        /*if the grid is not bound to widgets*/
                        /*If the variable is deleted hiding the spinner and showing the no data found message*/
                        $scope.datagridElement.datagrid('setStatus', 'error', $scope.nodatamessage);
                    }
                }
                /* Disable/Update the properties in properties panel which are dependent on binddataset value. */
                if (CONSTANTS.isStudioMode) {
                    /*Make the "pageSize" property hidden so that no editing is possible for live and query service variables*/
                    $scope.widgetProps.pagesize.show = !(isBoundToLiveVariable || isBoundToQueryServiceVariable);
                    $scope.widgetProps.multiselect.show = $scope.isPartOfLiveGrid ? false : $scope.widgetProps.multiselect.show;
                    $scope.widgetProps.multiselect.showindesigner = $scope.isPartOfLiveGrid ? false : $scope.widgetProps.multiselect.showindesigner;
                    /* In Studio, disabling readonlygrid property if bound to a service variable or view */
                    if (!($scope.binddataset && (isBoundToServiceVariable || isBoundToStaticVariable || isBoundToServiceVariableSelectedItem)) && !isBoundToView()) {
                        $scope.widgetProps.readonlygrid.disabled = false;
                    } else {
                        if ($scope.isPartOfLiveGrid) {
                            $scope.readonlygrid = true;
                            $scope.insertrow = false;
                            $scope.updaterow = false;
                            $scope.deleterow = false;
                            $rootScope.$emit('set-markup-attr', $scope.widgetid, {
                                'readonlygrid': $scope.readonlygrid,
                                'insertrow': $scope.insertrow,
                                'updaterow': $scope.updaterow,
                                'deleterow': $scope.deleterow
                            });
                        } else {
                            //For service and static variable update readonly only if its not set on to the grid
                            if (!$scope.readonlygrid) {
                                $rootScope.$emit('update-widget-property', 'readonlygrid', true);
                            }
                        }
                        $scope.widgetProps.readonlygrid.disabled = true;
                    }
                    /* If bound to live filter result, disable grid search. */
                    if (isBoundToWidget && $scope.binddataset.indexOf('livefilter') !== -1) {
                        $rootScope.$emit('update-widget-property', 'gridsearch', false);
                        $scope.widgetProps.gridsearch.disabled = true;
                    } else {
                        $scope.widgetProps.gridsearch.disabled = false;
                    }
                }
                if (!WM.isObject(newVal) || (newVal && newVal.dataValue === '')) {
                    if (newVal === '' || (newVal && newVal.dataValue === '')) {
                        /* clear the grid columnDefs and data in studio */
                        if (CONSTANTS.isStudioMode && $scope.newcolumns) {
                            /* if new columns to be rendered, create new column defs*/
                            $scope.prepareFieldDefs();
                            $scope.newcolumns = false;
                        }
                        if (!$scope.variableInflight) {
                            /* If variable has finished loading and resultSet is empty,
                             * render empty data in both studio and run modes */
                            setGridData([]);
                        }
                    }
                    return;
                }

                if (newVal) {
                    if (CONSTANTS.isStudioMode) {
                        $scope.createGridColumns(isBoundToLiveVariableRoot ? newVal.data : newVal, newVal.propertiesMap || undefined);
                        $scope.newcolumns = false;
                    }
                    /*Set the type of the column to the default variable type*/
                    if ($scope.fieldDefs && $scope.columnDefsExists() && newVal.propertiesMap) {
                        columns = Utils.fetchPropertiesMapColumns(newVal.propertiesMap);
                        $scope.fieldDefs.forEach(function (fieldDef) {
                            Object.keys(columns).forEach(function (key) {
                                if (key === fieldDef.field) {
                                    fieldDef.type = columns[key].type;
                                }
                            });
                        });
                    }
                    populateGridData(newVal);
                    if (isBoundToServiceVariable && CONSTANTS.isStudioMode) {
                        /*Checking if grid is bound to service variable, for which data cannot be loaded in studio mode,
                        in studio mode and if the fieldDefs are generated. */
                        $scope.gridData = [];
                        $scope.datagridElement.datagrid('setStatus', 'error', $rootScope.locale['MESSAGE_GRID_CANNOT_LOAD_DATA_IN_STUDIO']);
                    }
                } else if (CONSTANTS.isStudioMode) {
                    /* Put In case of error while fetching data from provided variable, prepare default fieldDefs
                     * Error cases:
                     * 1. empty variable provided
                     * 2. data not found for provided variable
                     */
                    $scope.datagridElement.datagrid('setStatus', 'nodata', $scope.nodatamessage);
                    $scope.setDataGridOption('selectFirstRow', $scope.gridfirstrowselect);
                    /* if new columns to be rendered, create new column defs*/
                    if ($scope.newcolumns) {
                        $scope.prepareFieldDefs();
                        $scope.newcolumns = false;
                    }
                }
            };
            $scope.createGridColumns = function (data, propertiesMap) {
                /* this call back function receives the data from the variable */
                /* check whether data is valid or not */
                var dataValid = data && !data.error;
                /*if the data is type json object, make it an array of the object*/
                if (dataValid && !WM.isArray(data)) {
                    data = [data];
                }
                /* if new columns to be rendered, prepare default fieldDefs for the data provided*/
                if ($scope.newcolumns) {
                    if (propertiesMap) {
                        /*get current entity name from properties map*/
                        $scope.prepareFieldDefs(data, propertiesMap);
                    } else {
                        $scope.prepareFieldDefs(data);
                    }
                }
                /* Arranging Data for Pagination */
                /* if data exists and data is not error type the render the data on grid using setGridData function */
                if (dataValid) {
                    /*check for nested data if existed*/
                    $scope.serverData = data;
                    setGridData($scope.serverData);
                }
            };
            /* function to prepare fieldDefs for the grid according to data provided */
            $scope.prepareFieldDefs = function (data, propertiesMap) {
                var defaultFieldDefs,
                    properties,
                    columns,
                    gridObj;

                $scope.fieldDefs = [];
                /* if properties map is existed then fetch the column configuration for all nested levels using util function */
                if (propertiesMap) {
                    columns = Utils.fetchPropertiesMapColumns(propertiesMap);
                    properties = [Utils.resetObjectWithEmptyValues(columns)];
                } else {
                    properties = data;
                }
                /*call utility function to prepare fieldDefs for grid against given data (A MAX OF 10 COLUMNS ONLY)*/
                defaultFieldDefs = Utils.prepareFieldDefs(properties, $scope.displayAllFields ? -1 : 10);
                /*append additional properties*/
                WM.forEach(defaultFieldDefs, function (columnDef) {
                    columnDef.pcDisplay = true;
                    columnDef.mobileDisplay = true;
                    WM.forEach($scope.fullFieldDefs, function (column) {
                        if (column.field && column.field === columnDef.field) {
                            columnDef.pcDisplay = column.pcDisplay;
                            columnDef.mobileDisplay = column.mobileDisplay;
                            columnDef.customExpression = column.customExpression;
                            columnDef.width = column.width;
                            columnDef.textAlignment = column.textAlignment;
                            columnDef.backgroundColor = column.backgroundColor;
                            columnDef.textColor = column.textColor;
                            columnDef.widgetType = column.widgetType;
                            columnDef.displayName = column.displayName;
                            columnDef.class = column.class;
                            columnDef.ngclass = column.ngclass;
                            columnDef.searchPlaceholder = column.searchPlaceholder || (
                                columnDef.type !== 'date' ? 'Search' : 'Enter date in yyyy-mm-dd'
                            );
                            columnDef.formatpattern = column.formatpattern;
                            columnDef.datepattern = column.datepattern;
                            columnDef.currencypattern = column.currencypattern;
                            columnDef.fractionsize = column.fractionsize;
                            columnDef.suffix = column.suffix;
                            columnDef.prefix = column.prefix;
                            columnDef.accessroles = column.accessroles;
                        }
                    });
                    /* if properties map is provided, append the same to column defs*/
                    if (propertiesMap) {
                        columnDef.type = columns[columnDef.field].type;
                        columnDef.primaryKey = columns[columnDef.field].isPrimaryKey;
                        columnDef.generator = columns[columnDef.field].generator;
                        columnDef.readonly = WM.isDefined(columns[columnDef.field].readonly) ?
                                    columns[columnDef.field].readonly === "true" : (columnDef.generator === 'identity' && columns[columnDef.field].isRelatedPk !== 'true');

                        /*Prevent searching and sorting on non-primary key columns in related tables.*/
                        columnDef.searchable = columnDef.sortable = !(columnDef.field && columnDef.field.indexOf('.') !== -1 && !columnDef.primaryKey);
                        if (columnDef.type === 'timestamp' || columnDef.type === 'datetime' || columnDef.type === 'date') {
                            if (!columnDef.formatpattern) {
                                columnDef.formatpattern = 'toDate';
                            }
                            if (!columnDef.datepattern) {
                                columnDef.datepattern = columnDef.type === 'date' ? 'yyyy-MM-dd' : 'dd-MMM-yyyy HH:mm:ss';
                            }
                        }
                        if (columnDef.type === 'blob' && !columnDef.customExpression) {
                            if (columnDef.widgetType === 'image') {
                                columnDef.customExpression = '<img width="48px" class="wm-icon wm-icon24 glyphicon glyphicon-file" data-ng-src="{{contentBaseUrl + row[primaryKey] + \'/content/\'+ colDef.field}}"/>';
                            } else {
                                columnDef.customExpression = '<a ng-if="columnValue != null" class="col-md-9" target="_blank" data-ng-href="{{contentBaseUrl + row[primaryKey] + \'/content/\'+ colDef.field}}"><i class="wm-icon wm-icon24 glyphicon glyphicon-file"></i></a>';
                            }
                        }
                        columnDef.disableInlineEditing = columns[columnDef.field].disableInlineEditing;
                    }
                    //For readonly grid each field should be checked on readonly
                    if ($scope.readonlygrid) {
                        columnDef.readonly = true;
                    }
                });

                /*prepare a copy of fieldDefs prepared
                 (defaultFieldDefs will be passed to markup and fieldDefs are used for grid)
                 (a copy is kept to prevent changes made by ng-grid in the fieldDefs)
                 */
                $scope.fieldDefs = Utils.getClonedObject(defaultFieldDefs);

                /*push the fieldDefs in respective grid markup*/
                gridObj = {
                    widgetName : $scope.name,
                    fieldDefs: defaultFieldDefs,
                    scopeId: $scope.$id
                };
                $rootScope.$emit('grid-defs-modified', gridObj);
                $scope.setDataGridOption('colDefs', Utils.getClonedObject($scope.fieldDefs));
            };

            $scope.setDataGridOption = function (optionName, newVal) {
                var option = {};
                if (WM.isDefined(newVal) && !WM.equals(newVal, $scope.gridOptions[optionName])) {
                    option[optionName] = newVal;
                    $scope.datagridElement.datagrid('option', option);
                    $scope.gridOptions[optionName] = newVal;
                }
            };

            $scope.initiateSelectItem = function (index, row, primaryKey, skipSelectItem) {
                /*index === "last" indicates that an insert operation has been successfully performed and navigation to the last page is required.
                * Hence increment the "dataSize" by 1.*/
                if (index === 'last') {
                    $scope.dataNavigator.dataSize += 1;
                    /*Update the data in the current page in the grid after insert/update operations.*/
                    if (!$scope.shownavigation) {
                        index = 'current';
                    }
                }
                /*Re-calculate the paging values like pageCount etc that could change due to change in the dataSize.*/
                $scope.dataNavigator.calculatePagingValues();
                $scope.dataNavigator.navigatePage(index, null, true, function () {
                    /*$timeout is used so that by then $scope.dataset has the updated value.
                    * Selection of the item is done in the callback of page navigation so that the item that needs to be selected actually exists in the grid.*/
                    /*Do not select the item if skip selection item is specified*/
                    if (!skipSelectItem) {
                        $timeout(function () {
                            $scope.selectItem(row, $scope.dataset.data);
                        }, null, false);
                    }
                });
            };

            $scope.selectItem = function (item, data) {
                /* server is not updating immediately, so set the server data to success callback data */
                if (data) {
                    $scope.serverData = data;
                }
                $scope.datagridElement.datagrid('selectRow', item, true);
            };

            /** TODO deprecate this highlight the given row and use selectItem **/
            $scope.highlightRow = $scope.selectItem;

            /* deselect the given item*/
            $scope.deselectItem = function (item) {
                $scope.datagridElement.datagrid('deselectRow', item);
            };

            /* determines if the 'user-defined'(not default) columnDefs exists already for the grid */
            $scope.columnDefsExists = function () {
                var i, n;
                /* override the fieldDefs if user has untouched the columnDefs*/
                for (i = 0, n = $scope.fieldDefs.length; i < n; i = i + 1) {
                    /* if a binding field is found in the fieldDef, user has edited the columnDefs, don't override the columnDefs */
                    if ($scope.fieldDefs[i].field) {
                        return true;
                    }
                }
                /* modified column defs do not exist, return false*/
                return false;
            };

            $scope.deleteRow = function (row) {

                row = row || $scope.selectedItems[0];
                deleteRecord(row);
            };

            $scope.editRow = function (row) {
                row = row || $scope.selectedItems[0];
                $scope.gridOptions.beforeRowUpdate(row);
            };

            $scope.addRow = function () {
                $scope.addNewRow();
            };


            $scope.onRecordDelete = function () {
                /*Check for sanity*/
                if ($scope.dataNavigator) {
                    $scope.dataNavigator.dataSize -= 1;
                    $scope.dataNavigator.calculatePagingValues();
                    /*If the current page does not contain any records due to deletion, then navigate to the previous page.*/
                    if ($scope.dataNavigator.pageCount < $scope.dataNavigator.currentPage) {
                        $scope.dataNavigator.navigatePage('prev');
                    } else {
                        $scope.dataNavigator.navigatePage();
                    }
                } else {
                    var variable = $scope.gridElement.scope().Variables[$scope.variableName];
                    if (!variable) {
                        return;
                    }

                    variable.update({
                        'type': 'wm.LiveVariable',
                        'page': $scope.dataNavigator ? $scope.dataNavigator.currentPage : 1,
                        'scope': $scope.gridElement.scope()
                    }, function (data) {
                        $scope.serverData = data;
                        setGridData($scope.serverData);
                    }, function (error) {
                        wmToaster.show('error', 'ERROR', error);
                    });
                }
            };

            $scope.call = function (operation, data, success, error) {
                data.success = success;
                data.error = error;
                switch (operation) {
                case "create":
                    insertRecord(data);
                    break;
                case "update":
                    updateRecord(data);
                    break;
                case "delete":
                    deleteRecord(data);
                    break;
                }
            };

        }])

/**
 * @ngdoc directive
 * @name wm.widgets.grid.directive:wmGridColumn
 * @restrict E
 *
 * @description
 * The `wmGridColumn` serves the purpose of providing column definitions to the parent `wmGrid` directive.
 * `wmGridColumn` is internally used by `wmGrid`.
 *
 * @requires $parse
 * @requires Utils
 *
 * @param {string=} caption
 *                  Sets the title of the column.
 * @param {string=} width
 *                  Sets the width of the column
 * @param {boolean=} pcdisplay
 *                  Sets the display property of the column on a pc.
 * @param {boolean=} mobiledisplay
 *                  Sets the display property of the column on a mobile.
 * @param {string=} textcolor
 *                  Sets the color of the text in all the rows of the column.
 * @param {string=} backgroundcolor
 *                  Sets the background color of the column.
 * @param {string=} textalignment
 *                  Sets the alignment of the text in all the rows of the column.
 * @param {string=} binding
 *                  Sets the binding for the column.<br>
 *                  The value provided will be evaluated in the 'dataset' or 'scopedataset' of the parent 'wmGrid' and the data will be displayed in the column.
 *
 * @example
  <example module="wmCore">
      <file name="index.html">
          <div data-ng-controller="Ctrl" class="wm-app">
              <wm-grid readonlygrid="true" dataset="bind:Variables.gridVariable.dataSet">
                  <wm-grid-column binding="deptid" caption="deptid" pcdisplay="true" mobiledisplay="true"></wm-grid-column>
                  <wm-grid-column binding="budget" caption="budget" pcdisplay="true" mobiledisplay="true"></wm-grid-column>
                  <wm-grid-column binding="location" caption="location" pcdisplay="true" mobiledisplay="true"></wm-grid-column>
                  <wm-grid-column binding="q1" caption="q1" pcdisplay="true" mobiledisplay="true"></wm-grid-column>
                  <wm-grid-column binding="q2" caption="q2" pcdisplay="true" mobiledisplay="true"></wm-grid-column>
                  <wm-grid-column binding="q3" caption="q3" pcdisplay="true" mobiledisplay="true"></wm-grid-column>
                  <wm-grid-column binding="name" caption="name" pcdisplay="true" mobiledisplay="true"></wm-grid-column>
                  <wm-grid-column binding="deptcode" caption="deptcode" pcdisplay="true" mobiledisplay="true"></wm-grid-column>
              </wm-grid>
          </div>
      </file>
      <file name="script.js">
          function Ctrl($scope) {
              var deptData = '{"name":"HrdbDepartmentData","type":"Department","isList":true,"owner":"App","editJson":"","isBound":"","dataSet":{"data":[{"deptid":1,"name":"Engineering","budget":1936760,"q1":445455,"q2":522925,"q3":426087,"q4":542293,"deptcode":"Eng","location":"San Francisco","tenantid":1},{"deptid":2,"name":"Marketing","budget":1129777,"q1":225955,"q2":271146,"q3":327635,"q4":305040,"deptcode":"Mktg","location":"New York","tenantid":1},{"deptid":3,"name":"General and Admin","budget":1452570,"q1":435771,"q2":290514,"q3":348617,"q4":377668,"deptcode":"G&A","location":"San Francisco","tenantid":1},{"deptid":4,"name":"Sales","budget":2743744,"q1":493874,"q2":658499,"q3":713373,"q4":877998,"deptcode":"Sales","location":"Austin","tenantid":1},{"deptid":5,"name":"Professional Services","budget":806984,"q1":201746,"q2":201746,"q3":177536,"q4":225955,"deptcode":"PS","location":"San Francisco","tenantid":2}],"propertiesMap":{"columns":[{"fieldName":"deptid","type":"integer","hibernateType":"integer","fullyQualifiedType":"integer","columnName":"DEPTID","isPrimaryKey":true,"notNull":true,"length":255,"precision":19,"generator":"identity","isRelated":false,"defaultValue":null},{"fieldName":"name","type":"string","hibernateType":"string","fullyQualifiedType":"string","columnName":"NAME","isPrimaryKey":false,"notNull":false,"length":255,"precision":19,"generator":null,"isRelated":false,"defaultValue":null},{"fieldName":"budget","type":"integer","hibernateType":"integer","fullyQualifiedType":"integer","columnName":"BUDGET","isPrimaryKey":false,"notNull":false,"length":255,"precision":19,"generator":null,"isRelated":false,"defaultValue":null},{"fieldName":"q1","type":"integer","hibernateType":"integer","fullyQualifiedType":"integer","columnName":"Q1","isPrimaryKey":false,"notNull":false,"length":255,"precision":19,"generator":null,"isRelated":false,"defaultValue":null},{"fieldName":"q2","type":"integer","hibernateType":"integer","fullyQualifiedType":"integer","columnName":"Q2","isPrimaryKey":false,"notNull":false,"length":255,"precision":19,"generator":null,"isRelated":false,"defaultValue":null},{"fieldName":"q3","type":"integer","hibernateType":"integer","fullyQualifiedType":"integer","columnName":"Q3","isPrimaryKey":false,"notNull":false,"length":255,"precision":19,"generator":null,"isRelated":false,"defaultValue":null},{"fieldName":"q4","type":"integer","hibernateType":"integer","fullyQualifiedType":"integer","columnName":"Q4","isPrimaryKey":false,"notNull":false,"length":255,"precision":19,"generator":null,"isRelated":false,"defaultValue":null},{"fieldName":"deptcode","type":"string","hibernateType":"string","fullyQualifiedType":"string","columnName":"DEPTCODE","isPrimaryKey":false,"notNull":false,"length":20,"precision":19,"generator":null,"isRelated":false,"defaultValue":null},{"fieldName":"location","type":"string","hibernateType":"string","fullyQualifiedType":"string","columnName":"LOCATION","isPrimaryKey":false,"notNull":false,"length":255,"precision":19,"generator":null,"isRelated":false,"defaultValue":null},{"fieldName":"tenantid","type":"integer","hibernateType":"integer","fullyQualifiedType":"integer","columnName":"TENANTID","isPrimaryKey":false,"notNull":false,"length":255,"precision":19,"generator":null,"isRelated":false,"defaultValue":null}],"primaryKeys":["deptid"],"entityName":"Department","fullyQualifiedName":"com.hrdb.Department","tableType":"TABLE"},"relatedData":{},"pagingOptions":{"dataSize":5,"maxResults":20}},"dataBinding":{},"saveInPhonegap":false,"firstRow":0,"maxResults":20,"designMaxResults":10,"service":"","operation":"read","operationType":"","startUpdate":true,"autoUpdate":false,"inFlightBehavior":"executeLast","transformationRequired":false,"columnField":"","dataField":"","onCanUpdate":"","onBeforeUpdate":"","onResult":"","onSuccess":"","onError":"","onPrepareSetData":"","liveSource":"hrdb","ignoreCase":false,"matchMode":"start","orderBy":"","category":"wm.LiveVariable","isDefault":true,"_id":"wm-wm.LiveVariable1428412293661","package":"com.hrdb.Department","tableName":"DEPARTMENT","tableType":"TABLE","propertiesMap":{"columns":[{"fieldName":"deptid","type":"integer","hibernateType":"integer","fullyQualifiedType":"integer","columnName":"DEPTID","isPrimaryKey":true,"notNull":true,"length":255,"precision":19,"generator":"identity","isRelated":false,"defaultValue":null},{"fieldName":"name","type":"string","hibernateType":"string","fullyQualifiedType":"string","columnName":"NAME","isPrimaryKey":false,"notNull":false,"length":255,"precision":19,"generator":null,"isRelated":false,"defaultValue":null},{"fieldName":"budget","type":"integer","hibernateType":"integer","fullyQualifiedType":"integer","columnName":"BUDGET","isPrimaryKey":false,"notNull":false,"length":255,"precision":19,"generator":null,"isRelated":false,"defaultValue":null},{"fieldName":"q1","type":"integer","hibernateType":"integer","fullyQualifiedType":"integer","columnName":"Q1","isPrimaryKey":false,"notNull":false,"length":255,"precision":19,"generator":null,"isRelated":false,"defaultValue":null},{"fieldName":"q2","type":"integer","hibernateType":"integer","fullyQualifiedType":"integer","columnName":"Q2","isPrimaryKey":false,"notNull":false,"length":255,"precision":19,"generator":null,"isRelated":false,"defaultValue":null},{"fieldName":"q3","type":"integer","hibernateType":"integer","fullyQualifiedType":"integer","columnName":"Q3","isPrimaryKey":false,"notNull":false,"length":255,"precision":19,"generator":null,"isRelated":false,"defaultValue":null},{"fieldName":"q4","type":"integer","hibernateType":"integer","fullyQualifiedType":"integer","columnName":"Q4","isPrimaryKey":false,"notNull":false,"length":255,"precision":19,"generator":null,"isRelated":false,"defaultValue":null},{"fieldName":"deptcode","type":"string","hibernateType":"string","fullyQualifiedType":"string","columnName":"DEPTCODE","isPrimaryKey":false,"notNull":false,"length":20,"precision":19,"generator":null,"isRelated":false,"defaultValue":null},{"fieldName":"location","type":"string","hibernateType":"string","fullyQualifiedType":"string","columnName":"LOCATION","isPrimaryKey":false,"notNull":false,"length":255,"precision":19,"generator":null,"isRelated":false,"defaultValue":null},{"fieldName":"tenantid","type":"integer","hibernateType":"integer","fullyQualifiedType":"integer","columnName":"TENANTID","isPrimaryKey":false,"notNull":false,"length":255,"precision":19,"generator":null,"isRelated":false,"defaultValue":null}],"primaryKeys":["deptid"],"entityName":"Department","fullyQualifiedName":"com.hrdb.Department","tableType":"TABLE"},"bindCount":1}',
                 deptVar = JSON.parse(deptData);
              deptVar.getPrimaryKey = function () {return ["deptid"]};
              $scope.Variables = {"gridVariable": deptVar};
          }
      </file>
  </example>
 */
    .directive('wmGridColumn', ['$parse', 'Utils', 'CONSTANTS', 'BindingManager', 'LiveWidgetUtils', function ($parse, Utils, CONSTANTS, BindingManager, LiveWidgetUtils) {
        'use strict';

        return {
            'restrict': 'E',
            'scope': true,
            'template': '<div></div>',
            'replace': true,
            'compile': function (tElement) {
                return {
                    'pre': function (scope, element, attrs) {

                        /*
                         * Class : ColumnDef
                         * Discription : ColumnDef is intermediate class which extends FieldDef base class
                         * */
                        scope.ColumnDef = function () {};

                        scope.ColumnDef.prototype = new wm.baseClasses.FieldDef();

                        scope.ColumnDef.prototype.setProperty = function (property, newval) {
                            this.$is.setProperty.call(this, property, newval);
                            if (property === 'displayName') {
                                scope.datagridElement.datagrid('setColumnProp', this.field, property, newval);
                            } else {
                                this.$is.reRender && this.$is.reRender();
                            }
                        };

                        var index,
                            exprWatchHandlers = [],
                            expr,
                            textAlignment = attrs.textalignment || 'left',
                            backgroundColor = attrs.backgroundcolor || '',
                            textColor = attrs.textcolor || '',
                            width = attrs.width || '',
                            styleDef = 'width: ' + width +
                                '; background-color: ' + backgroundColor +
                                '; color: ' + textColor + ';',
                            //Obj of its base with setter and getter defined
                            columnDef = new scope.ColumnDef(),
                            columnDefProps = {
                                'field': attrs.binding,
                                'displayName': attrs.caption,
                                'pcDisplay': (attrs.pcdisplay === "1" || attrs.pcdisplay === "true"),
                                'mobileDisplay': (attrs.mobiledisplay === "1" || attrs.mobiledisplay === "true"),
                                'width': attrs.width || '*',
                                'textAlignment': textAlignment,
                                'backgroundColor': backgroundColor,
                                'textColor': textColor,
                                'type': attrs.type || 'string',
                                'primaryKey': attrs.primaryKey ? $parse(attrs.primaryKey)() : '',
                                'generator': attrs.generator,
                                'isRelatedPk': attrs.isRelatedPk === 'true',
                                'widgetType': attrs.widgetType,
                                'style': styleDef,
                                'class': attrs.colClass || '',
                                'ngclass': attrs.colNgClass || '',
                                'searchPlaceholder': attrs.searchPlaceholder || (attrs.type !== 'date' ? 'Search' : 'Enter date in yyyy-mm-dd'),
                                'datepattern': attrs.datepattern,
                                'formatpattern': attrs.formatpattern,
                                'currencypattern': attrs.currencypattern,
                                'fractionsize': attrs.fractionsize,
                                'suffix': attrs.suffix,
                                'prefix': attrs.prefix,
                                'accessroles': attrs.accessroles || '',
                                'editWidgetType': attrs.editWidgetType,
                                'dataset': attrs.dataset,
                                'datafield': attrs.datafield,
                                'displayfield': attrs.displayfield,
                                'defaultvalue': attrs.defaultvalue
                            },
                            updateCustomExpression = function (column) {
                                LiveWidgetUtils.setColumnConfig(column);
                            };
                        function watchProperty(property, expression) {
                            exprWatchHandlers[property] = BindingManager.register(scope.$parent, expression, function (newVal) {
                                if (newVal) {
                                    scope.$parent.fieldDefs[index].setProperty(property, newVal);
                                }
                            }, {"deepWatch": true, "allowPageable": true, "acceptsArray": false});
                        }

                        //Will be used in ColumnDef prototype methods to re-render grid.
                        scope.ColumnDef.prototype.$is = scope.$parent;

                        //Extends the columnDef class with column meta data
                        WM.extend(columnDef, columnDefProps);

                        if (tElement.context.innerHTML) {
                            columnDef.customExpression = tElement.context.innerHTML;
                        }
                        /*Prevent searching and sorting on non-primary key columns in related tables.*/
                        columnDef.searchable = columnDef.sortable = !(columnDef.field && columnDef.field.indexOf('.') !== -1 && !columnDef.primaryKey);
                        columnDef.readonly = WM.isDefined(attrs.readonly) ? attrs.readonly === "true" : (columnDef.generator === 'identity' && !columnDef.isRelatedPk);

                        if (columnDef.type === 'blob' && !columnDef.customExpression) {
                            if (columnDef.widgetType !== 'image') {
                                columnDef.customExpression = '<a ng-if="columnValue != null" class="col-md-9" target="_blank" data-ng-href="{{contentBaseUrl + row[primaryKey] + \'/content/\'+ colDef.field}}"><i class="wm-icon wm-icon24 glyphicon glyphicon-file"></i></a>';
                            }
                        }
                        columnDef.disableInlineEditing = attrs.disableInlineEditing === 'true';
                        /* push the fieldDef in the object meant to have all fields */
                        index = scope.$parent.fullFieldDefs.push(columnDef) - 1;
                        /* Backward compatibility for widgetType */
                        if (columnDef.widgetType && !columnDef.customExpression) {
                            updateCustomExpression(columnDef);
                            if (CONSTANTS.isStudioMode && scope.$parent.fullFieldDefs.length === scope.$parent.gridColumnCount) {
                                /* Update markup for grid. */
                                var config = {
                                    widgetName: scope.name,
                                    scopeId: scope.$parent.$id,
                                    fieldDefs: scope.$parent.fullFieldDefs
                                };
                                scope.$root.$emit('grid-defs-modified', config);
                                scope.$root.$emit('save-workspace', true);
                            }
                        }
                        /*check if any attribute has binding. put a watch for the attributes*/
                        if (CONSTANTS.isRunMode) {
                            _.each(columnDef, function (value, property) {
                                if (Utils.stringStartsWith(value, 'bind:') && property !== 'dataset' && property !== 'defaultvalue') {
                                    watchProperty(property, value.replace('bind:', ''));
                                }
                            });
                        }
                        /* this condition will run for:
                         *  1. PC view in STUDIO mode
                         *  2. Mobile/tablet view in RUN mode
                         */
                        if (Utils.isMobile()) {
                            if (!columnDef.mobileDisplay) {
                                return;
                            }
                        } else {
                            if (!columnDef.pcDisplay) {
                                return;
                            }
                        }
                        /* push the fieldDef in the object meant for actual display in the grid (this will be passed to ng-grid) */
                        scope.$parent.fieldDefs.push(columnDef);
                        element.remove();
                        /*destroy watch handler on scope destroy*/
                        scope.$on('$destroy', function () {
                            _.each(exprWatchHandlers, Utils.triggerFn);
                        });
                    }
                };
            }
        };
    }])
    .directive('wmGridAction', ['$compile', 'CONSTANTS', 'LiveWidgetUtils', function ($compile, CONSTANTS, LiveWidgetUtils) {
        'use strict';
        return {
            "restrict": 'E',
            "scope": true,
            "replace": true,
            "compile": function () {
                return {
                    "post": function (scope, element, attrs) {
                        /*scope.$parent is defined when compiled with grid scope*/
                        /*element.parent().isolateScope() is defined when compiled with dom scope*/
                        var parentIsolateScope,
                            buttonDef =  WM.extend(LiveWidgetUtils.getButtonDef(attrs), {
                                /*iconame support for old projects*/
                                'icon': attrs.icon
                            });

                        if (CONSTANTS.isRunMode) {
                            parentIsolateScope = scope;
                        } else {
                            parentIsolateScope = scope.parentIsolateScope = (element.parent() && element.parent().length > 0) ? element.parent().closest('[data-identifier="grid"]').isolateScope() || scope.$parent : scope.$parent;
                        }
                        parentIsolateScope.actions = parentIsolateScope.actions || [];
                        parentIsolateScope.actions.push(buttonDef);
                    }
                };
            }
        };
    }]);

/*global WM, window, document, FormData, Blob, _*/
/*Directive for liveform */

WM.module('wm.widgets.live')
    /*Define controller for the liveform in dialog mode - required*/
    .controller('liveFormDialogController', WM.noop)
    .directive('wmLiveform', ['PropertiesFactory', 'WidgetUtilService', '$compile', '$rootScope', 'CONSTANTS', '$controller', 'Utils', 'wmToaster', '$filter', 'LiveWidgetUtils', 'DialogService', function (PropertiesFactory, WidgetUtilService, $compile, $rootScope, CONSTANTS, $controller, Utils, wmToaster, $filter, LiveWidgetUtils, DialogService) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.layouts.liveform', ['wm.layouts', 'wm.base.events.successerror']),
            notifyFor = {
                'dataset': true,
                'captionsize': true,
                'novalidate': true,
                'autocomplete': true,
                'rowdata': true,
                'formdata': true,
                'updatemode': true,
                'formlayout': true,
                'formtype': true,
                'defaultmode': true
            },
            /*check if the field is of column type time or widget type time*/
            isTimeType = function (field) {
                return field.widget === 'time' || (field.type === 'time' && !field.widget);
            },
            /*Convert time value to a valid date time value*/
            getValidTime = function (val) {
                if (val) {
                    var date = (new Date()).toDateString();
                    return (new Date(date + ' ' + val)).getTime();
                }
                return undefined;
            },
            dateTimeFormats = Utils.getDateTimeDefaultFormats(),
            pageTemplate,
            defaultTemplate;

        return {
            restrict: 'E',
            replace: true,
            scope: {
                //"onSuccess": "&",
                //"onError": "&",
                "onBeforeservicecall": "&",
                "onResult": "&"
            },
            require: '?^wmLivegrid',
            template: function (template, attrs) {
                /*render the template with mobile-navbar if formlayout is page*/
                pageTemplate = '<form data-identifier="liveform" init-widget data-ng-show="show" role="form" class="app-device-liveform panel panel-default liveform-inline align-{{captionalign}} position-{{captionposition}}" data-ng-submit="formSave($event);" autocomplete="autocomplete" apply-styles="shell">' +
                                '<wm-mobile-navbar title="{{title}}" on-backbtnclick="onBackbtnclick({$event: $event, $scope: this})">' +
                                    '<wm-button type="{{btn.type}}" class="btn-transparent btn-default" data-ng-repeat="btn in buttonArray" caption="" title="{{btn.displayName}}" iconclass="{{btn.iconclass}}" show="{{isUpdateMode && btn.show}}" on-click="{{btn.action}}"></wm-button>' +
                                '</wm-mobile-navbar>' +
                                '<div data-ng-show="isLayoutDialog"><i class="wm-icon24 glyphicon glyphicon-cog"></i>Live form in dialog mode</div>' +
                                '<div class="form-elements panel-body" data-ng-class="{\'update-mode\': isUpdateMode }" data-ng-show="!isLayoutDialog" apply-styles="inner-shell">' +
                                    template.context.innerHTML +
                                '</div>' +
                                '<div class="hidden-form-elements"></div>' +
                        '</form>';

                defaultTemplate = '<form data-identifier="liveform" init-widget data-ng-show="show" role="form" class="app-liveform panel panel-default liveform-inline align-{{captionalign}} position-{{captionposition}}" data-ng-submit="formSave($event);" autocomplete="autocomplete" apply-styles="shell">' +
                                    '<div data-ng-show="isLayoutDialog"><i class="wm-icon24 glyphicon glyphicon-cog"></i>Live form in dialog mode</div>' +
                                    '<div class="form-header panel-heading" data-ng-show="!isLayoutDialog" data-ng-if="title">' +
                                        '<h3 class="panel-title">' +
                                            '<i data-ng-if="iconclass" class="{{iconclass}}" data-ng-style="{width:iconwidth, height:iconheight, margin:iconmargin}"></i>' +
                                            '<span class="form-header-text">{{title}}</span>' +
                                        '</h3>' +
                                    '</div>' +
                                    '<div class="form-elements panel-body" data-ng-class="{\'update-mode\': isUpdateMode }" data-ng-show="!isLayoutDialog" apply-styles="inner-shell">' +
                                        '<wm-message data-ng-if=(messagelayout==="Inline") scopedataset="statusMessage" hideclose="false"></wm-message>' +
                                        template.context.innerHTML +
                                    '</div>' +
                                    '<div class="hidden-form-elements"></div>' +
                                    '<div class="basic-btn-grp form-action panel-footer clearfix" data-ng-hide="isLayoutDialog"></div>' +
                                '</form>';

                if (CONSTANTS.isRunMode && (attrs.formtype === 'dialog' || attrs.layout === 'dialog' || attrs.formlayout === 'dialog')) {
                    /*Generate a unique id for the dialog to avoid conflict with multiple dialogs.*/
                    attrs.dialogid = 'liveformdialog-' + attrs.name + '-' + Utils.generateGUId();
                    return '<div data-identifier="liveform" init-widget data-ng-show="show" class="app-liveform liveform-dialog" autocomplete="autocomplete" >' +
                                '<wm-dialog class="app-liveform-dialog" width="{{dialogWidth}}" name="' + attrs.dialogid + '" title="{{title}}" modal="true" controller="liveFormDialogController">' +
                                    '<wm-dialogheader iconclass="{{iconclass}}"></wm-dialogheader>' +
                                    '<wm-dialogcontent class="noscroll">' +
                                        '<form data-identifier="liveform" role="form" name="' + attrs.name + '" class="app-liveform align-{{captionalign}} position-{{captionposition}}" data-ng-submit="formSave($event);" apply-styles="shell">' +
                                            '<div class="form-elements panel-body" data-ng-class="{\'update-mode\': isUpdateMode }" data-ng-style="{height: height, overflow: height ? \'auto\': overflow, paddingTop: paddingtop + paddingunit,paddingRight: paddingright + paddingunit,paddingLeft: paddingleft + paddingunit,paddingBottom: paddingbottom + paddingunit}">' +
                                                '<div class="form-content">' + template.context.innerHTML + '</div>' +
                                            '</div>' +
                                            '<div class="hidden-form-elements"></div>' +
                                            '<div class="basic-btn-grp form-action modal-footer clearfix">' +
                                                '<div class="action-content"></div>' +
                                            '</div>' +
                                        '</form>' +
                                    '</wm-dialogcontent>' +
                                '</wm-dialog>' +
                            '</div>';
                }
                if (attrs.formlayout === 'page') {
                    return pageTemplate;
                }
                return defaultTemplate;
            },
            controller: function ($scope, DialogService) {
                $scope.__compileWithIScope = true;
                /* when the service call ended this function will be called */
                /* prevformFields is used for showing the previous data when cancel is clicked and also for update calls*/
                var prevformFields,
                    prevDataObject = {},
                    onResult = function (data, status, event) {
                        /* whether service call success or failure call this method*/
                        $scope.onResult({$event: event, $operation: $scope.operationType, $data: data});
                        if (status) {
                            /*if service call is success call this method */
                            Utils.triggerFn($scope.onSuccess, {$event: event, $operation: $scope.operationType, $data: data});
                        } else {
                            /* if service call fails call this method */
                            Utils.triggerFn($scope.onError, {$event: event, $operation: $scope.operationType, $data: data});
                        }

                    },
                    onVariableUpdate = function (response, newForm, updateMode) {
                        if (newForm) {
                            $scope.new();
                        } else {
                            $scope.changeDataObject(response);
                        }
                        $scope.isUpdateMode = WM.isDefined(updateMode) ? updateMode : true;
                    };
                $scope.prevDataValues = {};
                $scope.findOperationType = function () {
                    var operation;
                    /*If OperationType is not set then based on the formdata object return the operation type,
                        this case occurs only if the form is outside a livegrid*/
                    /*If the formdata object has primary key value then return update else insert*/
                    if ($scope.primaryKey && $scope.formdata) {
                        /*If only one column is primary key*/
                        if ($scope.primaryKey.length === 1) {
                            if ($scope.formdata[$scope.primaryKey[0]]) {
                                operation = 'update';
                            }
                        /*If only no column is primary key*/
                        } else if ($scope.primaryKey.length === 0) {
                            operation = WM.forEach($scope.formdata, function (value) {
                                if (value) {
                                    return 'update';
                                }
                            });
                        /*If multiple columns are primary key*/
                        } else {
                            operation = $scope.primaryKey.some(function (primarykey) {
                                if ($scope.formdata[primarykey]) {
                                    return 'update';
                                }
                            });
                        }
                    }
                    return operation || 'insert';
                };
                /*Call respective functions for save and cancel*/
                $scope.save = function () {
                    $scope.formSave(undefined, true);
                };

                /*Function use to save the form and open new form after save*/
                $scope.saveAndNew = function () {
                    $scope.formSave(undefined, true, true);
                };
                /*Function use to save the form and open new form after save*/
                $scope.saveAndView = function () {
                    $scope.formSave(undefined, false);
                };
                /*Function to show the message on top of the dialog or to display the toaster
                 * type can be error or success*/
                $scope.toggleMessage = function (show, msg, type) {
                    var template;
                    if (show && msg) {
                        if ($scope.messagelayout === 'Inline') {
                            template = (type === 'error' && $scope.errormessage) ? ($scope.errormessage + '<span class="toast-title"> CAUSE: </span><span>' + msg + '</span>') : msg;
                            $scope.statusMessage = {'caption': template || '', type: type};
                        } else {
                            template = (type === 'error' && $scope.errormessage) ? ($scope.errormessage + '<div class="toast-title">CAUSE</div><p>' + msg + '</p>') : msg;
                            wmToaster.show(type, type.toUpperCase(), template, undefined, 'trustedHtml');
                        }
                    } else {
                        $scope.statusMessage = null;
                    }
                };
                /*Method to handle the insert, update, delete actions*/
                /*The operationType decides the type of action*/
                $scope.formSave = function (event, updateMode, newForm) {
                    var data,
                        prevData,
                        requestData = {},
                        elScope = $scope.element.scope(),
                        variableName = $scope.variableName || Utils.getVariableNameFromExpr($scope.binddataset),
                        variable = elScope.Variables[variableName],
                        isValid;
                    if ($scope.propertiesMap && $scope.propertiesMap.tableType === "VIEW") {
                        wmToaster.show('info', 'Not Editable', 'Table of type view, not editable');
                        return;
                    }
                    /*If live-form is in a dialog, then always fetch the formElement by name
                    because the earlier reference "$scope.formElement" would be destroyed on close of the dialog.*/
                    $scope.formElement = $scope.isLayoutDialog ? (document.forms[$scope.name]) : ($scope.formElement || document.forms[$scope.name]);

                    $scope.operationType = $scope.operationType || $scope.findOperationType();
                    /*Construct the data object with required values from the formFields*/
                    /*If it is an update call send isUpdate true for constructDataObject so the dataObject is
                    constructed out of the previous object*/
                    data = $scope.constructDataObject($scope.formFields);
                    $scope.dataoutput = data;
                    prevData = prevformFields ? $scope.constructDataObject(prevformFields) : data;
                    try {
                        isValid = $scope.onBeforeservicecall({$event: event, $operation: $scope.operationType, $data: data});
                        if (isValid === false) {
                            return;
                        }
                        if (isValid && isValid.error) {
                            wmToaster.show('error', 'ERROR', isValid.error);
                            return;
                        }
                    } catch (err) {
                        if (err.message === "Abort") {
                            return;
                        }
                    }
                    requestData = {
                        "row": data,
                        "transform": true,
                        "multipartData": $scope.multipartData
                    };
                    /*Pass in the prefab scope if the liveForm is present in a prefab, as the bound variable is available in the prefab scope only*/
                    if (elScope.prefabname) {
                        requestData.scope = elScope;
                    }
                    /*Based on the operationType decide the action*/
                    switch ($scope.operationType) {
                    case "update":
                        requestData.rowData = $scope.rowdata || $scope.formdata;
                        requestData.prevData = prevData;
                        if ($scope.subscribedWidget) {
                            $scope.subscribedWidget.call("update", requestData, function () {
                                if ($scope.isLayoutDialog) {
                                    DialogService.hideDialog($scope._dialogid);
                                }
                                $scope.isUpdateMode = false;
                            });
                        } else {
                            variable.updateRecord(requestData, function (response) {
                                /*Display appropriate error message in case of error.*/
                                if (response.error) {
                                    /*disable readonly and show the appropriate error*/
                                    $scope.toggleMessage(true, response.error, 'error');
                                    onResult(response, false, event);
                                } else {
                                    $scope.toggleMessage(true, $scope.updatemessage, 'success');
                                    onResult(response, true, event);
                                    if ($scope.ctrl) {
                                        /* highlight the current updated row */
                                        $scope.$emit("on-result", "update", response, newForm, updateMode);
                                    } else {
                                        /*get updated data without refreshing page*/
                                        variable.update({
                                            "type": "wm.LiveVariable",
                                            "isNotTriggerForRelated": true
                                        }, WM.noop);
                                        onVariableUpdate(response, newForm, updateMode);
                                    }
                                }
                            }, function (error) {
                                $scope.toggleMessage(true, error, 'error');
                                onResult(error, false, event);
                            });
                        }
                        break;
                    case "insert":
                        if ($scope.subscribedWidget) {
                            $scope.subscribedWidget.call("create", requestData, function () {
                                if ($scope.isLayoutDialog) {
                                    DialogService.hideDialog($scope._dialogid);
                                }
                                $scope.isUpdateMode = false;
                            });
                        } else {
                            variable.insertRecord(requestData, function (response) {
                                /*Display appropriate error message in case of error.*/
                                if (response.error) {
                                    $scope.toggleMessage(true, response.error, 'error');
                                    onResult(response, false, event);
                                } else {
                                    $scope.toggleMessage(true, $scope.insertmessage, 'success');
                                    onResult(response, true, event);
                                    /* if successfully inserted  change editable mode to false */
                                    if ($scope.ctrl) {
                                        /* highlight the current updated row */
                                        $scope.$emit("on-result", "insert", response, newForm, updateMode);
                                    } else {
                                        /*get updated data without refreshing page*/
                                        variable.update({
                                            "type": "wm.LiveVariable",
                                            "isNotTriggerForRelated": true
                                        }, WM.noop);
                                        onVariableUpdate(response, newForm, updateMode);
                                    }
                                }
                            }, function (error) {
                                $scope.toggleMessage(true, error, 'error');
                                onResult(error, false, event);
                            });
                        }
                        break;
                    case "delete":
                        $scope.toggleMessage(false);
                        if ($scope.ctrl) {
                            if (!$scope.ctrl.confirmMessage()) {
                                return;
                            }
                        }
                        variable.deleteRecord(requestData, function (success) {
                            /* check the response whether the data successfully deleted or not , if any error occurred show the
                             * corresponding error , other wise remove the row from grid */
                            if (success && success.error) {
                                $scope.toggleMessage(true, success.error, 'error');
                                onResult(success, false);
                                return;
                            }
                            onResult(success, true);
                            $scope.clearData();
                            $scope.toggleMessage(true, $scope.deletemessage, 'success');
                            $scope.isSelected = false;
                            /*get updated data without refreshing page*/
                            if ($scope.ctrl) {
                                $scope.$emit("on-result", "delete", success);
                            } else {
                                variable.update({
                                    "type": "wm.LiveVariable"
                                }, WM.noop);
                            }

                        }, function (error) {
                            $scope.toggleMessage(true, error, 'error');
                            onResult(error, false);
                        });
                        break;
                    }
                };
                /*Function to set the previous data array to be used while updating records in a live-form.*/
                $scope.setPrevformFields = function (formFields) {
                    prevformFields = Utils.getClonedObject(formFields);
                    prevDataObject = Utils.getClonedObject($scope.rowdata);
                };
                /*Method to clear the fields and set the form to readonly*/
                $scope.formCancel = function () {
                    $scope.clearData();
                    $scope.toggleMessage(false);
                    /*Show the previous selected data*/
                    if ($scope.isSelected) {
                        $scope.formFields = Utils.getClonedObject(prevformFields) || $scope.formFields;
                    }
                    $scope.$emit("on-cancel");
                    $scope.isUpdateMode = false;
                    if ($scope.isLayoutDialog) {
                        DialogService.hideDialog($scope._dialogid);
                    }
                };
                /*clear the formFields*/
                /*Method to save the previous data values. This will be used on form reset*/
                $scope.setPrevDataValues = function () {
                    if ($scope.formFields) {
                        $scope.prevDataValues = $scope.formFields.map(function (obj) {
                            return {'key': obj.key, 'value': obj.value};
                        });
                    }
                };
                /*clear the file uploader widget for reset*/
                function resetFileUploadWidget(dataValue) {
                    WM.element($scope.formElement).find('[name=' + dataValue.key + ']').val('');
                    dataValue.href = '';
                    dataValue.value = null;
                }
                /*Method to reset the form to original state*/
                $scope.reset = function () {
                    $scope.toggleMessage(false);
                    if (WM.isArray($scope.formFields)) {
                        $scope.formFields.forEach(function (dataValue) {
                            if (dataValue.type === 'blob') {
                                resetFileUploadWidget(dataValue);
                            } else {
                                var prevObj = _.find($scope.prevDataValues, function (obj) {
                                    return obj.key === dataValue.key;
                                });
                                dataValue.value = prevObj ? prevObj.value : undefined;
                            }
                        });
                    }
                };
                /*clear the formFields*/
                function emptyDataModel() {
                    $scope.formFields.forEach(function (dataValue) {
                        if (dataValue.type === 'blob') {
                            resetFileUploadWidget(dataValue);
                        } else {
                            dataValue.value = '';
                        }
                    });
                }
                /*Method to update, sets the operationType to "update" disables the readonly*/
                $scope.edit = function () {
                    $scope.toggleMessage(false);
                    /*set the formFields into the prevformFields only in case of inline form
                    * in case of dialog layout the set prevformFields is called before manually clearing off the formFields*/

                    if (!$scope.isLayoutDialog) {
                        if ($scope.isSelected) {
                            prevformFields = Utils.getClonedObject($scope.formFields);
                        }
                        /*Set the rowdata to prevDataObject irrespective whether the row is selected
                         or not*/
                        prevDataObject = Utils.getClonedObject($scope.rowdata);
                    }
                    $scope.setReadonlyFields();
                    $scope.isUpdateMode = true;
                    $scope.operationType = "update";
                };
                /*Method clears the fields, sets any defaults if available,
                 disables the readonly, and sets the operationType to "insert"*/
                $scope.new = function () {
                    $scope.toggleMessage(false);
                    if ($scope.isSelected && !$scope.isLayoutDialog) {
                        prevformFields = Utils.getClonedObject($scope.formFields);
                    }
                    if ($scope.formFields && $scope.formFields.length > 0) {
                        emptyDataModel();
                    }
                    $scope.setDefaults();
                    $scope.setPrevDataValues();
                    $scope.isUpdateMode = true;
                    $scope.operationType = "insert";
                };
                $scope.filetypes = {
                    "image": "image/*",
                    "video": "video/*",
                    "audio": "audio/*"
                };
                $scope.isDateTimeWidgets = Utils.getDateTimeTypes();
               /*Set if any default values, if given*/
                $scope.setDefaults = function () {
                    $scope.formFields.forEach(function (fieldObj) {
                        $scope.setDefaultValueToValue(fieldObj);
                    });
                };
                $scope.setDefaultValueToValue = function (fieldObj) {
                    var defaultValue = fieldObj.defaultvalue;
                    /*Set the default value only if it exists.*/
                    if (defaultValue && defaultValue !== "null") {
                        fieldObj.value = LiveWidgetUtils.getDefaultValue(defaultValue, fieldObj.type);
                    } else {
                        fieldObj.value = undefined;
                    }
                    if (fieldObj.type === "blob") {
                        /*Handle default*/
                        fieldObj.permitted = $scope.filetypes[fieldObj.filetype] + (fieldObj.extensions ? ',' + fieldObj.extensions : '');
                    }
                    /*If the field is primary but is assigned set readonly false.
                     Assigned is where the user inputs the value while a new entry.
                     This is not editable(in update mode) once entry is successful*/
                    if (fieldObj.primaryKey && fieldObj.generator === "assigned") {
                        fieldObj.readonly = false;
                    }
                    $scope.setPrevDataValues();
                };
                $scope.setReadonlyFields = function () {
                    $scope.formFields.forEach(function (column) {
                        if (column.primaryKey) {
                            column.readonly = true;
                        }
                    });
                };
                /*Sets the operationType to "delete" and calls the formSave function to handle the action*/
                $scope.delete = function () {
                    $scope.operationType = "delete";
                    prevDataObject = Utils.getClonedObject($scope.rowdata);
                    $scope.formSave();
                };
                /*Check if the data is in required format, i.e, if the field has a key and type*/
                $scope.isInReqdFormat = function (data) {
                    return (WM.isArray(data) && data[0].key && data[0].type);
                };
                /*Function to get the default data object based on the operation type*/
                function getDataObject() {
                    if ($scope.operationType === 'insert') {
                        return {};
                    }
                    if (WM.isDefined(prevDataObject) && !Utils.isEmptyObject(prevDataObject)) {
                        return Utils.getClonedObject(prevDataObject);
                    }
                    return Utils.getClonedObject($scope.formdata || {});
                }
                /*construct the data object from the formFields*/
                $scope.constructDataObject = function (formFields) {
                    var dataObject = getDataObject(),
                        formName = $scope.name,
                        isFormDataSupported = (window.File && window.FileReader && window.FileList && window.Blob),
                        formData;

                    if (isFormDataSupported) {
                        /* Angular does not bind file values so using native object to send files */
                        formData = new FormData();
                    }
                    formFields.forEach(function (field) {
                        /*collect the values from the fields and construct the object*/
                        /*Format the output of date time widgets to the given output format*/
                        if (((field.widget && $scope.isDateTimeWidgets[field.widget]) || $scope.isDateTimeWidgets[field.type])) {
                            var dateTime = Utils.getValidDateObject(field.value);
                            if (field.outputformat === 'timestamp' || field.type === 'timestamp') {
                                dataObject[field.key] = field.value ? dateTime.getTime() : null;
                            } else if (field.outputformat) {
                                dataObject[field.key] = $filter('date')(dateTime, field.outputformat);
                            } else {
                                dataObject[field.key] = field.value;
                            }
                        } else if (field.type === "blob") {
                            if (isFormDataSupported) {
                                $scope.multipartData = true;
                                /*Display an error message if no file is selected and simply return.*/
                                //if (document.forms[formName].file.files.length === 0) {
                                /*Handle if file not selected*/
                                //}
                                /*1. Append the uploaded script file.
                                 * 2. Append the connection properties.*/
                                if ($scope.operationType !== 'delete') {
                                    formData.append(field.key, document.forms[formName][field.key].files[0]);
                                }
                            }
                        } else if (field.type === "list") {
                            if (field.value) {
                                dataObject[field.key] = field.value;
                            }
                        } else {
                            dataObject[field.key] = field.value;
                        }
                    });
                    if ($scope.operationType !== 'delete' && $scope.multipartData) {
                        formData.append('wm_data_json', new Blob([JSON.stringify(dataObject)], {
                            type: "application/json"
                        }));
                        return formData;
                    }
                    return dataObject;
                };


                /*Clear the fields in the array*/
                $scope.clearData = function () {
                    $scope.toggleMessage(false);
                    if ($scope.formFields && $scope.formFields.length > 0) {
                        emptyDataModel();
                    }
                };
                /*Set the form fields to readonly*/
                $scope.setReadonly = function (element) {
                    WM.element(element)
                        .find('input, textarea')
                        .attr('disabled', true);
                };
                /*Disable readonly*/
                $scope.removeReadonly = function (element) {
                    WM.element(element)
                        .find('input, textarea')
                        .attr('disabled', false);
                };
                $scope.isUpdateMode = false;
                /*Function to set the specified column as a primary key by adding it to the primary key array.*/
                $scope.setPrimaryKey = function (columnName) {
                    /*Store the primary key of data*/
                    if (WM.element.inArray(columnName, $scope.primaryKey) === -1) {
                        $scope.primaryKey.push(columnName);
                    }
                };

                /*Translate the variable rawObject into the formFields for form construction*/
                $scope.translateVariableObject = function (rawObject) {
                    return LiveWidgetUtils.translateVariableObject(rawObject, $scope);
                };
                $scope.changeDataObject = function (dataObj) {
                    var primaryKey,
                        href;
                    if ($scope.formFields) {
                        $scope.formFields.forEach(function (formField) {
                            if (isTimeType(formField)) {
                                formField.value = getValidTime(dataObj[formField.key]);
                            } else if (formField.type === "blob") {
                                if ($scope.dataset.propertiesMap) {
                                    var primaryKeys = $scope.dataset.propertiesMap.primaryFields || $scope.dataset.propertiesMap.primaryKeys;
                                    primaryKey = primaryKeys.join();
                                    href = (($scope.variableObj.prefabName !== "" && $scope.variableObj.prefabName !== undefined) ? "prefabs/" + $scope.variableObj.prefabName : "services") + '/';
                                    href = href + $scope.variableObj.liveSource + '/' + $scope.variableObj.type + '/' + dataObj[primaryKey] + '/content/' + formField.key + '?' + Math.random();
                                    formField.href = href;
                                }
                                formField.value = dataObj[formField.key];
                            } else {
                                formField.value = dataObj[formField.key];
                            }
                        });
                        $scope.setPrevDataValues();
                    }
                };

                $scope.setFieldVal = function (fieldDef) {
                    var dataObj = $scope.rowdata, primaryKey, href, primaryKeys;
                    if (!dataObj) {
                        return;
                    }
                    if (isTimeType(fieldDef)) {
                        fieldDef.value = getValidTime(dataObj[fieldDef.key]);
                    } else if (fieldDef.type === "blob") {
                        primaryKeys = $scope.dataset.propertiesMap.primaryFields || $scope.dataset.propertiesMap.primaryKeys;
                        primaryKey = primaryKeys.join();
                        href = 'services/' + $scope.variableObj.liveSource + '/' + $scope.variableObj.type + '/' + dataObj[primaryKey] + '/content/' + fieldDef.key + '?' + Math.random();
                        fieldDef.href = href;
                    } else {
                        fieldDef.value = dataObj[fieldDef.key];
                    }
                };

                /*For related fields, get the display value from the object*/
                $scope.getDisplayExpr = function (object, displayExpr) {
                    if (WM.isObject(object)) {
                        if (!displayExpr) {
                            displayExpr = Object.keys(object)[0];
                        }
                        return Utils.getEvaluatedExprValue(object, displayExpr, $scope);
                    }
                    return object;
                };
                /*returns the default output formats for date time types*/
                $scope.getOutputPatterns = function (type, outputFormat) {
                    if (type === 'date' || type === 'time' || type === 'datetime') {
                        return dateTimeFormats[type];
                    }
                    return outputFormat;
                };

                $scope.cancel = function () {
                    $scope.formCancel();
                };
                /*For backward compatibility of update action*/
                $scope.update = function () {
                    $scope.edit();
                };
            },
            compile: function () {
                return {
                    pre: function (scope, element, attrs) {
                        var elScope = element.scope();
                        /*Applying widget properties to directive scope*/
                        scope.widgetProps = widgetProps;

                        /*check for formtype or layout values for backward compatability*/
                        if (attrs.formtype || attrs.layout) {
                            attrs.formlayout = attrs.formtype || attrs.layout;
                        }

                        /*enable the fromlayout for device*/
                        if ($rootScope.isMobileApplicationType && CONSTANTS.isStudioMode) {
                            scope.widgetProps.formlayout.show = true;
                            scope.widgetProps.formlayout.showindesigner = true;
                        }

                        if (attrs.formlayout === 'dialog') {
                            scope.isLayoutDialog = true;
                            scope._dialogid = attrs.dialogid;
                        }

                        scope.Variables = elScope.Variables;
                        scope.Widgets = elScope.Widgets;
                        scope.appLocale = $rootScope.appLocale;
                    },
                    post: function (scope, element, attrs, controller) {
                        scope.ctrl = controller;
                        if (attrs.formlayout !== 'dialog') {
                            scope.formElement = element;
                        } else {
                            /* for dialog layout dialog will take the width assigned to the form */
                            if (CONSTANTS.isRunMode) {
                                scope.dialogWidth = scope.width;
                                scope.width = "100%";
                            }
                        }
                        scope.element = element;
                        var formController,
                            handlers = [];

                        scope.getActiveLayout = function () {
                            return LiveWidgetUtils.getColumnCountByLayoutType(scope.layout);
                        };
                        /*
                         * Extend the properties from the form controller exposed to end user in page script
                         * Kept in try/catch as the controller may not be available sometimes
                         */
                        if (CONSTANTS.isRunMode) {
                            try {
                                formController = scope.name + "Controller";
                                $controller(formController, {$scope: scope});
                            } catch (ignore) {
                            }
                        }

                        // returns the grid object when dataset is empty
                        function getEmptyDataSetGridObj() {
                            return {
                                widgetName: scope.name,
                                fieldDefs: [],
                                buttonDefs: [],
                                scopeId: scope.$id,
                                numColumns: scope.getActiveLayout()
                            };
                        }

                        // returns the grid object when dataset is not empty
                        function getNonEmptyDatSetGridObj() {
                            return {
                                widgetName: scope.name,
                                fieldDefs: scope.formFields,
                                buttonDefs: scope.buttonArray,
                                scopeId: scope.$id,
                                numColumns: scope.getActiveLayout()
                            };
                        }

                        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
                        function propertyChangeHandler(key, newVal, oldVal) {
                            var value,
                                labelElements,
                                elementScope,
                                translatedObj,
                                tempVarName,
                                gridObj,
                                variableObj,
                                elScope = element.scope();

                            switch (key) {
                            case "dataset":
                                /*Process the dataset if only the data is an array*/
                                if (newVal.propertiesMap && WM.isArray(newVal.propertiesMap.columns)) {
                                    if (!oldVal || !oldVal.propertiesMap || !WM.equals(newVal.propertiesMap.columns, oldVal.propertiesMap.columns)) {
                                        tempVarName = Utils.getVariableNameFromExpr(scope.binddataset);
                                        if (scope.variableName && (tempVarName !== scope.variableName)) {
                                            scope.formCreated = false;
                                            scope.formConstructed = false;
                                        }
                                        scope.variableName = tempVarName;
                                        /*Check if form has been created, if true translate the variable object.*/
                                        if ((scope.formCreated || scope.formConstructed) && scope.formFields) {
                                            translatedObj = scope.translateVariableObject(newVal);
                                            scope.translatedObj = translatedObj;
                                            /*Check if the formFields is defined, then in the formFields array override only certain fields.*/
                                            scope.formFields.forEach(function (fieldObject) {
                                                translatedObj.forEach(function (transObj) {
                                                    if (transObj.key === fieldObject.key) {
                                                        fieldObject.isRelated = transObj.isRelated;
                                                        fieldObject.type = transObj.type; /*Set the type of the column to the default variable type*/
                                                        fieldObject.outputformat = scope.getOutputPatterns(fieldObject.type, fieldObject.outputformat);
                                                    }
                                                });
                                            });

                                            variableObj =  elScope.Variables && elScope.Variables[scope.variableName];
                                            scope.variableObj = variableObj;
                                            if (variableObj) {
                                                /* set the variable type info to the live-form selected-entry type, so that type matches to the variable for which variable is created*/
                                                scope.widgetProps.formdata.type = variableObj.type;
                                                scope.widgetProps.dataoutput.type = 'object, ' + variableObj.type;
                                            }
                                        } else {
                                            /*Defining two buttons for default actions*/
                                            scope.buttonArray = LiveWidgetUtils.getLiveWidgetButtons('LIVEFORM').filter(function (button) {
                                                /* show only save button for liveform with page layout */
                                                return scope.formlayout === 'page' ? button.key === 'save' : button.key === 'cancel' || button.key === 'save';
                                            });
                                            variableObj = elScope.Variables && elScope.Variables[scope.variableName];
                                            scope.variableObj = variableObj;
                                            if (variableObj) {
                                                /* set the variable type info to the live-form selected-entry type, so that type matches to the variable for which variable is created*/
                                                scope.widgetProps.formdata.type = variableObj.type;
                                            }
                                            /*Check if the newVal is in the required format, checking for key and type for each field,
                                             * else call the translateVariableObject method*/
                                            if (scope.isInReqdFormat(newVal)) {
                                                translatedObj = newVal;
                                            } else {
                                                translatedObj = scope.translateVariableObject(newVal);
                                            }
                                            scope.translatedObj = translatedObj;
                                            scope.formFields = translatedObj;
                                        }
                                        gridObj = getNonEmptyDatSetGridObj();
                                    }
                                } else if (!newVal) {
                                    /*If variable binding has been removed empty the form and the variableName*/
                                    if (CONSTANTS.isStudioMode) {
                                        element.find('.form-elements').empty();
                                        element.find('.hidden-form-elements').empty();
                                    }
                                    scope.variableName = '';
                                    /*When initially a variable is bound to the live-form the form is constructed and the
                                     markup is updated with the form field action and button directives*/
                                    gridObj = getEmptyDataSetGridObj();
                                }
                                if (CONSTANTS.isStudioMode && gridObj && (!scope.formFieldCompiled || scope.newcolumns)) {
                                    scope.newcolumns = false;
                                    gridObj.bindDataSetChanged = true;
                                    gridObj.widgettype = scope.widgettype;
                                    $rootScope.$emit('formFieldsDefs-modified', gridObj);
                                }
                                break;
                            case 'captionsize':
                                labelElements = WM.element(element).find('.app-label');
                                /*Set the width of all labels in the form to the caption size*/
                                WM.forEach(labelElements, function (childelement) {
                                    elementScope = WM.element(childelement).isolateScope();
                                    elementScope.width = newVal;
                                });
                                break;
                            case 'novalidate':
                                /*Add or remove the novalidate attribute based on the input*/
                                if (newVal === true || newVal === "true") {
                                    element.attr('novalidate', '');
                                } else {
                                    element.removeAttr('novalidate');
                                }
                                break;
                            case 'autocomplete':
                                /*Set the auto complete on/off based on the input*/
                                value = (newVal === true || newVal === "true") ? 'on' : 'off';
                                element.attr(key, value);
                                break;
                            case "rowdata":
                                if (newVal && WM.isObject(newVal)) {
                                    scope.changeDataObject(newVal);
                                }
                                break;
                            case "formdata":
                                if (newVal && WM.isObject(newVal)) {
                                    scope.changeDataObject(newVal);
                                }
                                break;
                            case "updatemode":
                                scope.isUpdateMode = (newVal === true || newVal === "true");
                                break;
                            case "defaultmode":
                                if (newVal && newVal === 'Edit') {
                                    scope.updateMode = true;
                                } else {
                                    scope.updateMode = false;
                                }
                                scope.isUpdateMode = scope.updateMode;
                                break;
                            case "formlayout":
                                scope.isLayoutDialog = newVal === 'dialog';
                                element.toggleClass('liveform-dialog', scope.isLayoutDialog);
                                // show backbtn event for page formlayout
                                if (CONSTANTS.isStudioMode) {
                                    scope.widgetProps.onBackbtnclick.show = (newVal === 'page');
                                }
                                break;
                            }
                        }

                        /* register the property change handler */
                        WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler, scope, notifyFor);

                        if (scope.widgetid) {
                            /* event emitted on building new markup from canvasDom */
                            handlers.push($rootScope.$on('compile-form-fields', function (event, scopeId, markup, newVal, fromDesigner) {

                                if ($rootScope.isMobileApplicationType && CONSTANTS.isStudioMode) {
                                    if (scope.formlayout === 'page') {
                                        // recompile the pageTemplate.
                                        element.html(pageTemplate);
                                        scope.buttonArray = undefined;
                                        $compile(element.contents())(scope);
                                        element.addClass('app-device-liveform');
                                    } else {
                                        // recompile the default template
                                        element.html(defaultTemplate);
                                        element.find('.basic-btn-grp').empty();
                                        $compile(element.contents())(scope);
                                        element.removeClass('app-device-liveform');
                                    }
                                }

                                /* as multiple form directives will be listening to the event, apply field-definitions only for current form */
                                if (scope.$id === scopeId) {
                                    scope.formFields = undefined;
                                    scope.buttonArray = undefined;
                                    element.find('.form-elements').empty();
                                    element.find('.hidden-form-elements').empty();
                                    element.find('.basic-btn-grp').empty();
                                    scope.formConstructed = fromDesigner;
                                    /*If the event has been emitted after changes in the liveFormDesigner then empty the form and reconstruct*/
                                    if (markup) {
                                        scope.formConstructed = true;
                                        var markupObj = WM.element('<div>' + markup + '</div>'),
                                            fieldsObj = markupObj.find('> :not(wm-form-action)'), // select nodes other than form-actions
                                            actionsObj = markupObj.find('wm-form-action'); // select form-action nodes

                                        /* if layout grid template found, simulate canvas dom addition of the elements */
                                        if (fieldsObj) {
                                            $rootScope.$emit('prepare-element', fieldsObj, function () {
                                                element.find('.form-elements').append(fieldsObj);
                                                element.find('.basic-btn-grp').append(actionsObj);
                                                $compile(fieldsObj)(scope);
                                                $compile(actionsObj)(scope);
                                            });
                                        } else {
                                            /* else compile and add the form fields */
                                            fieldsObj = markupObj.find('wm-form-field');
                                            element.find('.form-elements').append(fieldsObj);
                                            element.find('.basic-btn-grp').append(actionsObj);
                                            $compile(fieldsObj)(scope);
                                            $compile(actionsObj)(scope);
                                        }
                                    }
                                }
                            }));
                        }
                        scope.$on("$destroy", function () {
                            handlers.forEach(Utils.triggerFn);
                        });

                        WidgetUtilService.postWidgetCreate(scope, element, attrs);

                        function initDependency(widgetname) {
                            var dependsonWidget = scope.$root.Widgets[widgetname],
                                eventChangeHandler;
                            if (dependsonWidget) {
                                scope.subscribedWidget = dependsonWidget;
                                eventChangeHandler = function (event, widgetid, eventName) {
                                    if (widgetid === scope.subscribedWidget.name) {
                                        /* handle operation change */
                                        switch (eventName) {
                                        case 'create':
                                            scope.isSelected = true;
                                            scope.rowdata = '';
                                            /*In case of dialog layout set the previous data Array before clearing off*/
                                            if (scope.isLayoutDialog) {
                                                scope.setPrevformFields(scope.formFields);
                                                scope.formFields = [];
                                            }
                                            scope.new();
                                            if (scope.isLayoutDialog) {
                                                DialogService.showDialog(scope._dialogid, { 'resolve': {}, 'scope' : scope });
                                            }
                                            break;
                                        case 'update':
                                            scope.isSelected = true;
                                            /*In case of dialog layout set the previous data Array before clearing off*/
                                            if (scope.isLayoutDialog) {
                                                scope.setPrevformFields(scope.formFields);
                                                scope.formFields = [];
                                            }
                                            scope.edit();
                                            scope.$root.$safeApply(scope);
                                            if (scope.isLayoutDialog) {
                                                /*Open the dialog in view or edit mode based on the defaultmode property*/
                                                scope.isUpdateMode = true;
                                                DialogService.showDialog(scope._dialogid, {'resolve': {}, 'scope': scope});
                                            }
                                            break;
                                        case 'read':
                                            scope.isUpdateMode = false;
                                            break;
                                        case 'delete':
                                            scope.subscribedWidget.call('delete', {"row": scope.constructDataObject(scope.subscribedWidget.selecteditem)});
                                            break;
                                        }
                                    }
                                };
                                handlers.push(dependsonWidget.$watch('selectedItems', function (newVal) {
                                    if (newVal && newVal.length) {
                                        scope.rowdata = newVal[newVal.length - 1];
                                        if (scope.isUpdateMode) {
                                            eventChangeHandler(null, dependsonWidget.widgetid, "update");
                                        }
                                    }
                                }));
                                handlers.push($rootScope.$on('wm-event', eventChangeHandler));
                            }
                        }
                        if (attrs.dependson && CONSTANTS.isRunMode) {
                            initDependency(attrs.dependson);
                        }
                    }
                };
            }
        };
    }])
    .directive("wmFormField", ["Utils", "$compile", "CONSTANTS", "BindingManager", "LiveWidgetUtils", "WidgetUtilService", function (Utils, $compile, CONSTANTS, BindingManager, LiveWidgetUtils, WidgetUtilService) {
        'use strict';
        return {
            "restrict": 'E',
            "template": "<div init-widget data-role='form-field'></div>",
            "scope": {},
            "replace": true,
            "compile": function (tElement) {
                return {
                    "pre": function (scope, element, attrs) {
                        LiveWidgetUtils.preProcessFields('wm-form-field', scope, attrs, tElement);
                    },
                    "post": function (scope, element, attrs) {
                        /*scope.$parent is defined when compiled with live filter scope*/
                        /*element.parent().isolateScope() is defined when compiled with dom scope*/
                        var parentIsolateScope,
                            template,
                            index,
                            columnDef,
                            expr,
                            exprWatchHandler,
                            relatedDataWatchHandler,
                            elScope = element.scope(),
                            defaultObj,
                            dataSetWatchHandler,
                            variable,
                            isLayoutDialog;
                        parentIsolateScope = scope.parentIsolateScope = (element.parent() && element.parent().length > 0) ? element.parent().closest('[data-identifier="liveform"]').isolateScope() || scope.$parent : scope.$parent;
                        isLayoutDialog = parentIsolateScope.isLayoutDialog;
                        columnDef = WM.extend(LiveWidgetUtils.getColumnDef(attrs), {
                            'key'    : attrs.key || attrs.binding,
                            'regexp' : attrs.regexp || ".*"
                        });
                        attrs.isRelated =  attrs.isRelated === "true" || attrs.primaryKey === true;
                        columnDef.isRelated = attrs.isRelated;
                        /*if the show property is set to false, set the required property to false (except for identity columns)
                         * This will prevent 'required field can not be focused' error*/
                        if (CONSTANTS.isRunMode && columnDef.show === false) {
                            columnDef.required = false;
                        }
                        /*Set below properties on the scope, as post widget create is not called for this directive */
                        scope.required = columnDef.required;
                        scope.readonly = columnDef.readonly;
                        scope.disabled = columnDef.disabled;
                        //For normal form is update mode won't be set on parent scope, set it explicitly based on isupdatemode attribute
                        if (scope.isupdatemode === 'true') {
                            parentIsolateScope.isUpdateMode = true;
                        }

                        /*If defaultValue is set then assign it to the attribute*/
                        if (attrs.defaultvalue) {
                            if (Utils.stringStartsWith(attrs.defaultvalue, 'bind:') && CONSTANTS.isRunMode) {
                                expr = attrs.defaultvalue.replace('bind:', '');
                                exprWatchHandler = BindingManager.register(parentIsolateScope, expr, function (newVal) {
                                    parentIsolateScope.formFields[index].defaultvalue = newVal;
                                    if (parentIsolateScope.operationType !== 'update') {
                                        parentIsolateScope.setDefaultValueToValue(columnDef);
                                    }
                                }, {"deepWatch": true, "allowPageable": true, "acceptsArray": false});
                            } else {
                                columnDef.defaultvalue = attrs.defaultvalue;
                                if (CONSTANTS.isRunMode) {
                                    parentIsolateScope.setDefaultValueToValue(columnDef);
                                }
                            }
                        }
                        if (attrs.dataset) {
                            if (Utils.stringStartsWith(attrs.dataset, 'bind:') && CONSTANTS.isRunMode) {
                                expr = attrs.dataset.replace('bind:', '');
                                /*Watch on the bound variable. dataset will be set after variable is populated.*/
                                dataSetWatchHandler = parentIsolateScope.$watch(expr, function (newVal) {
                                    variable = elScope.Variables[expr.split('.')[1]];
                                    if (WM.isObject(variable)) {
                                        if (WM.isObject(newVal) && Utils.isPageable(newVal)) {
                                            parentIsolateScope.formFields[index].dataset = newVal.content;
                                        } else if (variable.category === "wm.LiveVariable") {
                                            parentIsolateScope.formFields[index].dataset = newVal.data;
                                        } else {
                                            parentIsolateScope.formFields[index].dataset = newVal;
                                        }
                                        /* fallback to set datafield to 'All Fields' for backward compatibility */
                                        if (!attrs.datafield) {
                                            parentIsolateScope.formFields[index].datafield = "All Fields";
                                        }
                                    }
                                });
                            } else {
                                columnDef.dataset = attrs.dataset;
                            }
                        } else if (attrs.isRelated && CONSTANTS.isRunMode) {
                            relatedDataWatchHandler = parentIsolateScope.$watch(parentIsolateScope.binddataset.replace('bind:', ''), function (newVal) {
                                if (!newVal) {
                                    return;
                                }
                                relatedDataWatchHandler();
                                var boundVariable = elScope.Variables[parentIsolateScope.variableName || Utils.getVariableNameFromExpr(parentIsolateScope.binddataset)];
                                boundVariable.getRelatedTableData(columnDef.key, {}, function (response) {
                                    var primaryKeys = boundVariable.getRelatedTablePrimaryKeys(columnDef.key, {scope: elScope}),
                                        relatedFormField = parentIsolateScope.formFields[index];
                                    relatedFormField.datafield = 'All Fields';
                                    relatedFormField.dataset = response;
                                    if (primaryKeys.length > 0) {
                                        relatedFormField.displayfield = primaryKeys[0];
                                        return;
                                    }
                                    relatedFormField.displayfield = response && _.keys(response[0]) && _.keys(response[0])[0];
                                });
                            });
                        }
                        if (attrs.extensions) {
                            columnDef.extensions = attrs.extensions;
                        }
                        if (attrs.filetype) {
                            columnDef.filetype = attrs.filetype;
                        }

                        if (isLayoutDialog) {
                            defaultObj = _.find(parentIsolateScope.translatedObj, function (obj) {
                                return obj.key === columnDef.key;
                            });
                            if (defaultObj) {
                                columnDef.isRelated = defaultObj.isRelated;
                                columnDef.type = defaultObj.type;
                                columnDef.outputformat = parentIsolateScope.getOutputPatterns(columnDef.type, columnDef.outputformat);
                            }
                            parentIsolateScope.setDefaultValueToValue(columnDef);
                            parentIsolateScope.setFieldVal(columnDef);
                            if (scope.operationType === 'update') {
                                scope.setReadonlyFields();
                            }
                        }

                        scope.fieldDefConfig = columnDef;
                        parentIsolateScope.formFields = parentIsolateScope.formFields || [];
                        index = parentIsolateScope.formFields.push(columnDef) - 1;
                        if (isLayoutDialog) {
                            parentIsolateScope.setPrevDataValues();
                        }
                        parentIsolateScope.formCreated = true;
                        parentIsolateScope.formFieldCompiled = true;
                        /* this condition will run for:
                         *  1. PC view in STUDIO mode
                         *  2. Mobile/tablet view in RUN mode
                         */
                        if (CONSTANTS.isRunMode) {
                            if (Utils.isMobile()) {
                                if (!columnDef.mobileDisplay) {
                                    return;
                                }
                            } else {
                                if (!columnDef.pcDisplay) {
                                    return;
                                }
                            }
                        }
                        if (!CONSTANTS.isRunMode || columnDef.show) {
                            template = LiveWidgetUtils.getTemplate(columnDef, index);
                            element.html(template);
                            $compile(element.contents())(parentIsolateScope);
                        } else {
                            template = LiveWidgetUtils.getHiddenTemplate(columnDef, index);
                            element.closest('[data-identifier="liveform"]').find('> .hidden-form-elements').append($compile(template)(parentIsolateScope));
                        }
                        parentIsolateScope.$on('$destroy', function () {
                            if (exprWatchHandler) {
                                exprWatchHandler();
                            }
                            if (relatedDataWatchHandler) {
                                relatedDataWatchHandler();
                            }
                            if (dataSetWatchHandler) {
                                dataSetWatchHandler();
                            }
                        });
                        // when the form-field element is removed, remove the corresponding entry from parentIScope.formFields
                        element.on('$destroy', function () {
                            _.pullAt(parentIsolateScope.formFields, _.indexOf(parentIsolateScope.formFields, columnDef));
                        });
                        WidgetUtilService.registerPropertyChangeListener(LiveWidgetUtils.fieldPropertyChangeHandler.bind(undefined, scope, element, attrs, parentIsolateScope, index), scope, undefined);
                    }
                };
            }
        };
    }])
    .directive('wmFormAction', ['$compile', 'CONSTANTS', 'LiveWidgetUtils', function ($compile, CONSTANTS, LiveWidgetUtils) {
        'use strict';

        var getTemplate = function (btnField, index) {
            var template = '';
            if (btnField.updateMode) {
                template  = '<wm-button name="{{buttonArray[' + index + '].key}}" caption="{{buttonArray[' + index + '].displayName}}" show="{{isUpdateMode && buttonArray[' + index + '].show}}" class="{{buttonArray[' + index + '].class}}" iconname="{{buttonArray[' + index + '].iconname}}"  iconclass="{{buttonArray[' + index + '].iconclass}}" on-click="' + btnField.action + '" type="{{buttonArray[' + index + '].type}}" ></wm-button>';
            } else {
                template  = '<wm-button name="{{buttonArray[' + index + '].key}}" caption="{{buttonArray[' + index + '].displayName}}" show="{{!isUpdateMode && buttonArray[' + index + '].show}}" class="{{buttonArray[' + index + '].class}}" iconname="{{buttonArray[' + index + '].iconname}}" iconclass="{{buttonArray[' + index + '].iconclass}}" on-click="' + btnField.action + '" type="{{buttonArray[' + index + '].type}}" ></wm-button>';
            }

            return template;
        };

        return {
            "restrict": 'E',
            "scope": true,
            "replace": true,
            "template": "<div></div>",
            "compile": function () {
                return {
                    "post": function (scope, element, attrs) {
                        /*scope.$parent is defined when compiled with live filter scope*/
                        /*element.parent().isolateScope() is defined when compiled with dom scope*/
                        var parentIsolateScope,
                            template,
                            index,
                            buttonDef = WM.extend(LiveWidgetUtils.getButtonDef(attrs), {
                                /*iconame support for old projects*/
                                'iconname': attrs.iconname,
                                'type': attrs.type || 'button',
                                'updateMode': attrs.updateMode === true || attrs.updateMode === 'true'
                            });

                        if (CONSTANTS.isRunMode && scope.isLayoutDialog) {
                            parentIsolateScope = scope;
                        } else {
                            parentIsolateScope = scope.parentIsolateScope = (element.parent() && element.parent().length > 0) ? element.parent().closest('[data-identifier="liveform"]').isolateScope() || scope.$parent : scope.$parent;
                        }

                        parentIsolateScope.buttonArray = parentIsolateScope.buttonArray || [];
                        index = parentIsolateScope.buttonArray.push(buttonDef) - 1;
                        parentIsolateScope.formCreated = true;
                        parentIsolateScope.formFieldCompiled = true;
                        template = getTemplate(buttonDef, index);

                        if (scope.formlayout === 'page') {
                            /* add actions to the buttonArray*/
                            scope.buttonArray[index].action = buttonDef.action;
                        } else {
                            /*append the buttons template to element with class basic-btn-grp*/
                            element.closest('[data-identifier="liveform"]').find('> .basic-btn-grp').append($compile(template)(parentIsolateScope));
                        }
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.widgets.live.directive:wmLiveform
 * @restrict E
 *
 * @description
 * The 'wmLiveform' directive defines a live-form in the layout.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 * @requires $compile
 * @requires $rootScope
 * @requires CONSTANTS
 * @requires $controller
 * @requires Utils
 *
 * @param {string=} name
 *                  Name of the form widget.
 * @param {string=} title
 *                  Title of the form widget.
 * @param {string=} width
 *                  Width of the form widget.
 * @param {string=} height
 *                  Height of the form widget.
 * @param {string=} formdata
 *                  This property sets the data to show in the form. <br>
 *                  This is a bindable property.
 * @param {string=} dataset
 *                  This property sets a variable to populate the data required to display the list of values. <br>
 *                  This is a bindable property.
 * @param {boolean=} novalidate
 *                  This property sets novalidate option for the form. <br>
 *                  default value: `true`.
 * @param {string=} insertmessage
 *                  This property sets the message to be displayed in toaster, when data is inserted in liveform. <br>
 *                  default value: `Record added successfully`. <br>
 *                  This is a bindable property.
 * @param {string=} updatemessage
 *                  This property sets the message to be displayed in toaster, when data is updated in liveform. <br>
 *                  default value: `Record updated successfully`. <br>
 *                  This is a bindable property.
 * @param {boolean=} show
 *                  This is a bindable property. <br>
 *                  This property will be used to show/hide the form on the web page. <br>
 *                  default value: `true`.
 * @param {boolean=} autocomplete
 *                  Sets autocomplete for the form.  <br>
 *                  Default value is `true`.
 * @param {boolean=} updatemode
 *                  This property controls whether live form is on updatemode or not.  <br>
 *                  Default value is `false`.
 * @param {string=} captionalign
 *                  Defines the alignment of the caption elements of widgets inside the form. <br>
 *                  Possible values are `left`, `center`, and `right`. <br>
 *                  Default value for captionalign is `left`.
 * @param {string=} captionposition
 *                  Defines the position of the caption elements of widgets inside the form.<br>
 *                  Possible values are `left`, `center`, and `right`. <br>
 *                  Default value for captionposition is `left`.
 * @param {string=} captionsize
 *                  This property sets the width of the caption.
 * @param {string=} iconclass
 *                  This property defines the class of the icon that is applied to the button. <br>
 *                  This is a bindable property.
 * @param {string=} horizontalalign
 *                  This property used to set text alignment horizontally. <br>
 *                  Possible values are `left`, `center` and `right`.
 * @param {string=} on-success
 *                  Callback function which will be triggered when the form submit is success.
 * @param {string=} on-error
 *                  Callback function which will be triggered when the form submit results in an error.
 * @param {string=} on-result
 *                  Callback function which will be triggered when the form submitted.
 * @param {string=} on-beforeservicecall
 *                  Callback function which will be triggered before the service call.
 *
 * @example
     <example module="wmCore">
         <file name="index.html">
             <wm-liveform>
                 <wm-composite widget="text">
                 <wm-label></wm-label>
                 <wm-text></wm-text>
                 </wm-composite>
                 <wm-composite widget="textarea">
                 <wm-label></wm-label>
                 <wm-textarea></wm-textarea>
                 </wm-composite>
             </wm-liveform>
         </file>
     </example>
 */

/*global WM, window, _, wm */

WM.module('wm.widgets.live')
    .run(["$templateCache", function ($templateCache) {
        "use strict";

        $templateCache.put("template/widget/livefilter/livefilter.html",
                '<form data-identifier="livefilter" class="app-livefilter panel panel-default clearfix liveform-inline align-{{captionalign}} position-{{captionposition}}" init-widget title="{{hint}}" data-ng-show="show" apply-styles>' +
                    '<div class="form-header panel-heading" data-ng-if="title"><h3 class="panel-title">' +
                        '<i class="{{iconclass}}" data-ng-style="{width:iconwidth, height:iconheight, margin:iconmargin}"></i>' +
                        '<span class="form-header-text">{{title}}</span>' +
                        '<div class="panel-actions">' +
                            '<button type="button" class="app-icon glyphicon panel-action" data-ng-if="collapsible" title="{{::$root.appLocale.LABEL_COLLAPSE}}/{{::$root.appLocale.LABEL_EXPAND}}" data-ng-class="expanded ? \'glyphicon-minus\': \'glyphicon-plus\'" data-ng-click="expandCollapsePanel($event);"></button>' +
                        '</div>' +
                    '</h3></div>' +
                    '<div data-ng-show="expanded" class="panel-body">' +
                        '<div data-identifier="filter-elements" ng-transclude></div>' +
                        '<div class="hidden-filter-elements"></div>' +
                        '<div class="basic-btn-grp form-action panel-footer clearfix"></div>' +
                    '</div>' +
                '</form>'
            );
    }]).directive('wmLivefilter', ['PropertiesFactory',
        '$rootScope',
        '$templateCache',
        'WidgetUtilService',
        '$compile',
        'CONSTANTS',
        'QueryBuilder',
        'Utils',
        'wmToaster',
        '$controller',
        'LiveWidgetUtils',
        function (PropertiesFactory, $rootScope, $templateCache, WidgetUtilService, $compile, CONSTANTS, QueryBuilder, Utils, wmToaster, $controller, LiveWidgetUtils) {
            "use strict";
            var widgetProps = PropertiesFactory.getPropertiesOf('wm.livefilter', ['wm.layouts', 'wm.containers']),
                filterMarkup = '',
                notifyFor,
                FILTER_CONSTANTS = {
                    'EMPTY_KEY'   : 'EMPTY_NULL_FILTER',
                    'EMPTY_VALUE' : 'No Value',
                    'NULLEMPTY'   : ['null', 'empty'],
                    'NULL'        : 'null',
                    'EMPTY'       : 'empty',
                    'LABEL_KEY'   : 'key',
                    'LABEL_VALUE' : 'value'
                },
                getEnableEmptyFilter = function (enableemptyfilter) {
                    return enableemptyfilter && _.intersection(enableemptyfilter.split(','), FILTER_CONSTANTS.NULLEMPTY).length > 0;
                };
            if (CONSTANTS.isStudioMode) {
                notifyFor = {
                    'dataset': true,
                    'pagesize': true
                };
            } else {
                notifyFor = {
                    'dataset': true
                };
            }

            return {
                restrict: 'E',
                replace: true,
                transclude: true,
                scope: {
                    "onBeforeservicecall": "&",
                    "onSuccess": "&",
                    "onError": "&"
                },
                controller: function ($scope) {
                    /* when the service call ended this function will be called */
                    var onResult = function (data, status) {
                        /* whether service call success or failure call this method*/
                        if (status) {
                            /*if service call is success call this method */
                            Utils.triggerFn($scope.onSuccess, {$data: data});
                        } else {
                            /* if service call fails call this method */
                            Utils.triggerFn($scope.onError, {$data: data});
                        }

                    };
                    $scope.dateTimeFormats = Utils.getDateTimeDefaultFormats();
                    $scope.isDateTime = Utils.getDateTimeTypes();
                    $scope.isUpdateMode = true;
                    $scope.__compileWithIScope = true;
                    $scope.clearFilter = function () {
                        WM.forEach($scope.formFields, function (filterField) {
                            //Added check for range field
                            if (!filterField.readonly && filterField.show) {
                                if (filterField.isRange) {
                                    filterField.minValue = undefined;
                                    filterField.maxValue = undefined;
                                } else {
                                    filterField.value = undefined;
                                }
                            }
                        });
                        /*Setting result to the default data*/
                        $scope.orderBy = '';
                        $scope.filter();
                    };
                    $scope.applyFilter = function (options) {
                        options = options || {};
                        options.page = options.page || 1;
                        options.orderBy = options.orderBy || $scope.orderBy || '';
                        $scope.filter(options);
                    };

                    $scope.filter = function (options) {
                        var formFields = {},
                            variable = $scope.Variables[$scope.variableName],
                            page = 1,
                            orderBy,
                            isValid,
                            dataModel = {},
                            MATCH_MODES = {
                                'BETWEEN'     : 'between',
                                'GREATER'     : 'greaterthanequal',
                                'LESSER'      : 'lessthanequal',
                                'NULL'        : 'null',
                                'EMPTY'       : 'empty',
                                'NULLOREMPTY' : 'nullorempty'
                            },
                            emptyFilterOptions = $scope.enableemptyfilter.split(',');
                        options = options || {};
                        page = options.page || page;
                        orderBy = options.orderBy || "";
                        $scope.orderBy = options.orderBy;
                        /* Copy the values to be sent to the user as '$data' before servicecall */
                        _.each($scope.formFields, function (field) {
                            if (!field.isRange) {
                                dataModel[field.field] = {
                                    'value': field.value
                                };
                            } else {
                                dataModel[field.field] = {
                                    'minValue': field.minValue,
                                    'maxValue': field.maxValue
                                };
                            }
                        });
                        /*Perform this function for the event onBeforeservicecall*/
                        try {
                            isValid = $scope.onBeforeservicecall({$data: dataModel});
                            if (isValid === false) {
                                return;
                            }
                            if (isValid && isValid.error) {
                                wmToaster.show('error', 'ERROR', isValid.error);
                                return;
                            }
                            /*Update these values in the formFields with new reference, inorder to maintain the UI values*/
                            _.each($scope.formFields, function (filterField) {
                                if (!filterField.isRange) {
                                    filterField._value = dataModel[filterField.field].value;
                                } else {
                                    filterField._minValue = dataModel[filterField.field].minValue;
                                    filterField._maxValue = dataModel[filterField.field].maxValue;
                                }
                            });
                        } catch (err) {
                            if (err.message === 'Abort') {
                                return;
                            }
                        }
                        /* Construct the formFields Variable to send it to the queryBuilder */
                        WM.forEach($scope.formFields, function (filterField) {
                            var fieldValue,
                                matchMode,
                                minValue = filterField._minValue,
                                maxvalue = filterField._maxValue,
                                colName = variable.getModifiedFieldName(filterField.field);
                            /* if field is part of a related entity, column name will be 'entity.fieldName' */
                            if (filterField.isRelated) {
                                colName += '.' + filterField.lookupField;
                            }
                            if (filterField.isRange) {
                                /*Based on the min and max values, decide the matchmode condition*/
                                if (minValue && maxvalue) {
                                    fieldValue = [minValue, maxvalue];
                                    matchMode = MATCH_MODES.BETWEEN;
                                } else if (minValue) {
                                    fieldValue = minValue;
                                    matchMode = MATCH_MODES.GREATER;
                                } else if (maxvalue) {
                                    fieldValue = maxvalue;
                                    matchMode = MATCH_MODES.LESSER;
                                }
                                if (WM.isDefined(fieldValue)) {
                                    formFields[colName] = {
                                        'value': fieldValue,
                                        'matchMode': matchMode
                                    };
                                }
                            } else {
                                switch (filterField.widget) {
                                case 'select':
                                case 'radioset':
                                    if (getEnableEmptyFilter($scope.enableemptyfilter) && filterField._value === FILTER_CONSTANTS.EMPTY_KEY) {
                                        if (_.intersection(emptyFilterOptions, FILTER_CONSTANTS.NULLEMPTY).length === 2) {
                                            matchMode = MATCH_MODES.NULLOREMPTY;
                                        } else if (_.includes(emptyFilterOptions, FILTER_CONSTANTS.NULL)) {
                                            matchMode = MATCH_MODES.NULL;
                                        } else if (_.includes(emptyFilterOptions, FILTER_CONSTANTS.EMPTY)) {
                                            matchMode = MATCH_MODES.EMPTY;
                                        }
                                        fieldValue = filterField._value;
                                    } else {
                                        if (filterField.type === 'boolean') {
                                            if (WM.isDefined(filterField._value) && filterField._value !== '') {
                                                fieldValue = JSON.parse(filterField._value);
                                            }
                                        } else {
                                            fieldValue = filterField._value;
                                        }
                                    }
                                    break;
                                case 'checkboxset':
                                    if (filterField._value && filterField._value.length) {
                                        fieldValue = filterField._value;
                                    }
                                    break;
                                case 'checkbox':
                                case 'toggle':
                                    if (WM.isDefined(filterField._value) && filterField._value !== '') {
                                        fieldValue = JSON.parse(filterField._value);
                                    }
                                    break;
                                default:
                                    fieldValue = filterField._value;
                                    break;
                                }
                                if (WM.isDefined(fieldValue) && fieldValue !== '' && fieldValue !== null) {
                                    formFields[colName] = {};
                                    if (matchMode) {
                                        formFields[colName].matchMode = matchMode;
                                        fieldValue = undefined;
                                    } else if (filterField.type === 'string') { //Only for string types, custom match modes are enabled
                                        formFields[colName].matchMode = matchMode || filterField.matchmode || variable.matchMode;
                                    }
                                    formFields[colName].value = fieldValue;
                                }
                            }
                        });

                        variable.update({
                            'filterFields'       : formFields,
                            'orderBy'            : orderBy,
                            'page'               : page,
                            'pagesize'           : $scope.pagesize || 20,
                            'skipDataSetUpdate' : true //dont update the actual variable dataset
                        }, function (data, propertiesMap, pageOptions) {
                            if (data.error) {
                                /*disable readonly and show the appropriate error*/
                                wmToaster.show('error', 'ERROR', (data.error));
                                onResult(data, false);
                            } else {
                                /*Set the response in "result" so that all widgets bound to "result" of the live-filter are updated.*/
                                $scope.result.data = data;
                                /*Create an object as required by the formFields for live-variable so that all further calls to getData take place properly.
                                 * This is used by widgets such as dataNavigator.*/
                                $scope.result.formFields = Utils.getClonedObject(formFields);
                                /*Set the paging options also in the result so that it could be used by the dataNavigator.
                                 * "currentPage" is set to "1" because each time the filter is applied, the dataNavigator should display results from the 1st page.*/
                                $scope.result.pagingOptions = {
                                    "dataSize": pageOptions.dataSize,
                                    "maxResults": $scope.pagesize || 20,
                                    "currentPage": page
                                };
                                /*Save the page options. When the filter dataSet changes, filter is applied with these options*/
                                $scope.result.options = {
                                    "page": page,
                                    "orderBy": orderBy
                                };
                                onResult(data, true);
                            }
                        }, function (error) {
                            wmToaster.show('error', 'ERROR', error);
                            onResult(error, false);
                        });
                    };
                    $scope.constructDefaultData = function (dataset) {
                        var columnObj = dataset.propertiesMap.columns,
                            colDefArray = [],
                            numColumns = Math.min(columnObj.length, 5),
                            fieldTypeWidgetTypeMap = LiveWidgetUtils.getFieldTypeWidgetTypesMap();
                        _.each(columnObj, function (column, index) {
                            var colDef = {
                                'field'             :   column.fieldName,
                                'displayname'       :   Utils.prettifyLabel(column.fieldName),
                                'widget'            :   fieldTypeWidgetTypeMap[column.type][0],
                                'isRange'           :   false,
                                'filterOn'          :   column.fieldName,
                                'lookupType'        :   '',
                                'lookupField'       :   '',
                                'minPlaceholder'    :   '',
                                'maxPlaceholder'    :   '',
                                'placeholder'       :   '',
                                'datepattern'       :   '',
                                'class'             :   '',
                                'width'             :   '',
                                'height'            :   '',
                                'textAlignment'     :   '',
                                'backgroundColor'   :   '',
                                'required'          :   '',
                                'minValue'          :   '',
                                'maxValue'          :   '',
                                'multiple'          :   '',
                                'value'             :   '',
                                'type'              :   column.type,
                                'step'              :   LiveWidgetUtils.getStepValue(column.type),
                                'ismeridian'        :   '',
                                'isPrimaryKey'      :   column.isPrimaryKey,
                                'generator'         :   column.generator,
                                'show'              :   true,
                                'pcDisplay'         :   true,
                                'mobileDisplay'     :   true
                            };
                            if (column.isRelated) {
                                /* otherwise build object with required configuration */
                                colDef.field = column.fieldName.charAt(0).toLowerCase() + column.fieldName.slice(1);
                                colDef.displayname = Utils.prettifyLabel(colDef.field);
                                colDef.isRelated = true;
                                colDef.lookupType = column.relatedEntityName;
                                colDef.lookupField = '';
                                _.each(column.columns, function (subcolumn) {
                                    if (subcolumn.isPrimaryKey) {
                                        colDef.lookupField = subcolumn.fieldName;
                                    }
                                });
                                colDef.relatedEntityName = column.relatedEntityName;
                            } else {
                                colDef.isRelated = false;
                            }
                            colDefArray.push(colDef);
                            /*Return false will break the loop after processing numColumns*/
                            return (index + 1) < numColumns;
                        });
                        return colDefArray;
                    };
                    /*Calls the filter function if default values are present*/
                    $scope.filterOnDefault = function () {
                        /*Check if default value is present for any filter field*/
                        var defaultObj = _.find($scope.formFields, function (obj) {
                            return obj.value;
                        });
                        /*If default value exists and data is loaded, apply the filter*/
                        if (defaultObj && $scope.result) {
                            $scope.filter();
                        }
                    };
                    $scope.expandCollapsePanel = function ($event) {
                        if ($scope.collapsible && CONSTANTS.isRunMode) {
                            if ($scope.expanded) {
                                if ($scope.onCollapse) {
                                    $scope.onCollapse({$event: $event, $scope: this});
                                }
                            } else {
                                if ($scope.onExpand) {
                                    $scope.onExpand({$event: $event, $scope: this});
                                }
                            }
                            /* flip the active flag */
                            $scope.expanded = !$scope.expanded;
                        }
                    };
                },
                template: function (element) {
                    filterMarkup = element.html();
                    return $templateCache.get("template/widget/livefilter/livefilter.html");
                },
                compile: function (tElement, tAttr) {
                    tAttr.gridColumnMarkup = filterMarkup;

                    return {
                        pre: function (iScope, element) {
                            var elScope = element.scope();
                            if (CONSTANTS.isStudioMode) {
                                iScope.widgetProps = Utils.getClonedObject(widgetProps);
                            } else {
                                iScope.widgetProps = widgetProps;
                            }
                            iScope.filterElement = element;
                            iScope.Variables = elScope.Variables;
                            iScope.Widgets = elScope.Widgets;
                            //Map for filterFields with filter key as key
                            iScope.filterFields = {};
                        },
                        post: function (scope, element, attrs) {
                            if (scope.expanded === undefined) {
                                scope.expanded = true;
                            }
                            /*
                             * Extend the properties from the form controller exposed to end user in page script
                             * Kept in try/catch as the controller may not be available sometimes
                             */
                            if (CONSTANTS.isRunMode) {
                                try {
                                    var filterController = scope.name + "Controller";
                                    $controller(filterController, {$scope: scope});
                                } catch (ignore) {
                                }
                            }

                            var variableRegex = /^bind:Variables\.(.*)\.dataSet$/,
                                handlers = [],
                                defaultButtonsArray = LiveWidgetUtils.getLiveWidgetButtons('LIVEFILTER');
                            scope.filterContainer = element;
                            scope.primaryKey = null;

                            scope.getActiveLayout = function () {
                                return LiveWidgetUtils.getColumnCountByLayoutType(scope.layout);
                            };

                            function updateAllowedValues() {
                                var variable = scope.Variables[scope.variableName];
                                WM.forEach(scope.formFields, function (filterField) {
                                    var query,
                                        tableName,
                                        columns,
                                        aliasColumn,
                                        fieldColumn,
                                        widgetTypes = ['select', 'radioset', 'checkboxset'],
                                        isEnableEmptyFilter = getEnableEmptyFilter(scope.enableemptyfilter),
                                        emptyOption = {};

                                    fieldColumn = variable.getModifiedFieldName(filterField.field);
                                    if (_.includes(widgetTypes, filterField.widget) && !filterField.tempDataset) {
                                        if (filterField.isRelated) {
                                            tableName = filterField.lookupType;
                                            columns = filterField.lookupField;
                                            aliasColumn = columns.replace('.', '_');
                                            query = QueryBuilder.getQuery({
                                                "tableName": tableName,
                                                "columns": [" DISTINCT " + columns + " AS " + aliasColumn]
                                            });
                                        } else {
                                            aliasColumn = fieldColumn;
                                            query = QueryBuilder.getQuery({
                                                "tableName": scope.result.propertiesMap.entityName,
                                                "columns": [" DISTINCT " + fieldColumn + " AS " + filterField.field]
                                            });
                                        }
                                        /* Sending size = 500 because we want to populate all data values in widgets
                                         * like select box, checkbox set etc.
                                         * NOTE: Currently backend is returning max. 100 records for any page size
                                         * more than 100. So this size will need to change once backend is fixed to
                                         * return all records instead of max 100 records in this case. */
                                        QueryBuilder.executeQuery({
                                            "databaseName": variable.liveSource,
                                            "query": query,
                                            "page": 1,
                                            "size": 500,
                                            "nativeSql": false,
                                            "prefabName": variable.prefabName
                                        }, function (data) {
                                            filterField.dataset = [];
                                            if (isEnableEmptyFilter && filterField.widget !== 'checkboxset' && !filterField.isRange) {
                                                emptyOption[FILTER_CONSTANTS.LABEL_KEY]   = FILTER_CONSTANTS.EMPTY_KEY;
                                                emptyOption[FILTER_CONSTANTS.LABEL_VALUE] = FILTER_CONSTANTS.EMPTY_VALUE;
                                                filterField.dataset.push(emptyOption);
                                            }
                                            _.each(data.content, function (key) {
                                                var value = key[aliasColumn],
                                                    option = {};
                                                if (value !== null && value !== '') {
                                                    option[FILTER_CONSTANTS.LABEL_KEY]   = value;
                                                    option[FILTER_CONSTANTS.LABEL_VALUE] = value;
                                                    filterField.dataset.push(option);
                                                }
                                            });
                                            filterField.displayfield = FILTER_CONSTANTS.LABEL_VALUE;
                                            filterField.datafield    = FILTER_CONSTANTS.LABEL_KEY;
                                        });
                                    }
                                });
                            }

                            /* Define the property change handler. This function will be triggered when there is a change in the widget property */
                            function propertyChangeHandler(key, newVal, oldVal) {
                                switch (key) {
                                case "dataset":
                                    var fieldsObj,
                                        buttonsObj,
                                        designerObj,
                                        fieldTypeWidgetTypeMap = LiveWidgetUtils.getFieldTypeWidgetTypesMap(),
                                        elScope = element.scope();
                                    /*If properties map is populated and if columns are presented for filter construction*/
                                    if (newVal.propertiesMap && WM.isArray(newVal.propertiesMap.columns)) {
                                        if (!oldVal || !oldVal.propertiesMap || !WM.equals(newVal.propertiesMap.columns, oldVal.propertiesMap.columns) || !WM.equals(newVal.data, oldVal.data)) {
                                            /* old data cached to avoid live variable data's effect on filter.
                                             * The filter is not depending on variable's data, as filter is making explicit call through QUERY
                                             * Hence, to avoid flicker when data from explicit call is rendered, the live variable's data is ignored
                                             */
                                            scope.result = scope.result || {
                                                data: [],
                                                pagingOptions: newVal.pagingOptions,
                                                options: { /*Set default options with page 1*/
                                                    page: 1
                                                }
                                            };
                                            scope.variableName = scope.binddataset.match(variableRegex)[1];
                                            scope.variableObj = elScope.Variables && elScope.Variables[scope.variableName];
                                            scope.variableType = scope.variableObj.category;
                                            /*Set the "variableName" along with the result so that the variable could be used by the data navigator during navigation.*/
                                            scope.result.variableName = scope.variableName;
                                            scope.result.propertiesMap = newVal.propertiesMap;
                                            scope.result.widgetName = scope.name;
                                            scope.result.isBoundToFilter = true;
                                            /*transform the data to filter consumable data*/
                                            fieldsObj = scope.constructDefaultData(newVal);
                                            /*Set the type of the column to the default variable type*/
                                            if (scope.formFields && newVal && newVal.propertiesMap) {
                                                scope.formFields.forEach(function (filterField) {
                                                    var filterObj = _.find(newVal.propertiesMap.columns, function (obj) {
                                                        return obj.fieldName === filterField.field;
                                                    });
                                                    if (filterObj) {
                                                        filterField.type = filterObj.type;
                                                        /*For backward compatibility of datetime column types, set widget to datetime*/
                                                        if (CONSTANTS.isStudioMode && filterField.type === 'datetime' && (!filterField.widget || filterField.widget === 'text')) {
                                                            filterField.widget = fieldTypeWidgetTypeMap[filterField.type][0];
                                                            scope.$root.$emit("set-markup-attr", scope.widgetid, {
                                                                'type': filterField.type,
                                                                'widget': filterField.widget
                                                            }, 'wm-filter-field[field=' + filterField.field + ']');
                                                        }
                                                    }
                                                });

                                                //This creates filterFields as map with name of the field as key
                                                scope.formFields.map(function (field) {
                                                    scope.filterFields[field.key] = field;
                                                });
                                            }
                                            buttonsObj = defaultButtonsArray;

                                            /*On load check if default value exists and apply filter.
                                            * Call the filter with the result options*/
                                            scope.filter(scope.result.options);
                                        }
                                        /* call method to update allowed values for select type filter fields */
                                        updateAllowedValues();
                                    } else if (!newVal && CONSTANTS.isStudioMode) { /*Clear the variables when the live-filter has not been bound.*/
                                        //element.empty();
                                        scope.variableName = '';
                                        scope.result = '';
                                        scope.formFields = '';
                                        scope.filterConstructed = false;
                                        scope.fieldObjectCreated = false;
                                        fieldsObj = [];
                                        buttonsObj = [];
                                    }
                                    if (CONSTANTS.isStudioMode && scope.newcolumns && fieldsObj) {
                                        scope.newcolumns = false;
                                        designerObj = {
                                            widgetName: scope.name,
                                            fieldDefs: fieldsObj,
                                            buttonDefs: buttonsObj,
                                            variableName: scope.variableName,
                                            scopeId: scope.$id,
                                            numColumns: scope.getActiveLayout(),
                                            bindDataSetChanged: true,
                                            widgettype: scope.widgettype
                                        };
                                        scope.$root.$emit('filterDefs-modified', designerObj);
                                    }
                                    break;
                                case "pagesize":
                                    if (WM.isDefined(scope.variableName) && WM.isDefined(newVal) && !WM.equals(newVal, oldVal)) {
                                        scope.filter();
                                    }
                                    break;
                                }
                            }

                            /* register the property change handler */
                            WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler, scope, notifyFor);

                            /* event emitted on building new markup from canvasDom */
                            handlers.push($rootScope.$on('compile-filters', function (event, scopeId, markup, filterObj, variableName, fromDesigner) {

                                if (scope.$id === scopeId) {
                                    var markupObj = WM.element('<div>' + markup + '</div>'),
                                        fieldsObj = markupObj.find('wm-layoutgrid'),
                                        actionsObj = markupObj.find('wm-filter-action');

                                    scope.filterConstructed = fromDesigner;
                                    scope.variableName = variableName;
                                    scope.formFields = undefined;
                                    scope.buttonArray = undefined;

                                    element.find('[data-identifier="filter-elements"]').empty();
                                    element.find('.hidden-filter-elements').empty();
                                    element.find('.basic-btn-grp').empty();

                                    /* if layout grid template found, simulate canvas dom addition of the elements */
                                    if (fieldsObj && fieldsObj.length) {
                                        $rootScope.$emit('prepare-element', fieldsObj, function () {
                                            element.find('[data-identifier="filter-elements"]').append(fieldsObj);
                                            element.find('.basic-btn-grp').append(actionsObj);
                                            $compile(fieldsObj)(scope);
                                            $compile(actionsObj)(scope);
                                        });
                                    } else {
                                        /* else compile and add the form fields */
                                        fieldsObj = markupObj.find('wm-filter-field');
                                        element.find('[data-identifier="filter-elements"]').append(fieldsObj);
                                        element.find('.basic-btn-grp').append(actionsObj);
                                        $compile(fieldsObj)(scope);
                                        $compile(actionsObj)(scope);
                                    }
                                    /*To get dataset up on saving designer dialog for fields with widget type as checkboxsex, radioset */
                                    updateAllowedValues();
                                    scope.filterConstructed = true;
                                }
                            }));
                            scope.$on("$destroy", function () {
                                handlers.forEach(Utils.triggerFn);
                            });

                            //Will be called after setting filter property.
                            scope.reRender = function () {
                                scope.filter(scope.result.options);
                            };

                            WidgetUtilService.postWidgetCreate(scope, element, attrs);
                        }
                    };
                }
            };
        }])
    .directive("wmFilterField", ["$compile", "Utils", "CONSTANTS", "BindingManager", "LiveWidgetUtils", "WidgetUtilService", function ($compile, Utils, CONSTANTS, BindingManager, LiveWidgetUtils, WidgetUtilService) {
        'use strict';
        return {
            "restrict": 'E',
            "scope": {},
            "template": "<div init-widget data-role='filter-field'></div>",
            "replace": true,
            "compile": function (tElement) {
                return {
                    "pre": function (scope, element, attrs) {
                        LiveWidgetUtils.preProcessFields('wm-filter-field', scope, attrs, tElement);
                    },
                    "post": function (scope, element, attrs) {
                        /*scope.$parent is defined when compiled with live filter scope*/
                        /*element.parent().isolateScope() is defined when compiled with dom scope*/
                        scope.parentIsolateScope = (element.parent() && element.parent().length > 0) ? element.parent().closest('[data-identifier="livefilter"]').isolateScope() : scope.$parent;

                        /*
                         * Class : FilterField
                         * Discription : FilterField is intermediate class which extends FieldDef base class
                         * */
                        scope.FilterField = function () {
                        };

                        scope.FilterField.prototype = new wm.baseClasses.FieldDef();
                        var expr,
                            exprWatchHandler,
                            dataSetWatchHandler,
                            variable,
                            template,
                            index,
                            defaultVal,
                            parentIsolateScope = scope.parentIsolateScope,
                            columnsDef = new scope.FilterField(),
                            columnsDefProps = WM.extend(LiveWidgetUtils.getColumnDef(attrs), {
                                'field'             : attrs.field || attrs.binding,
                                'filterOn'          : attrs.filterOn || attrs.field || attrs.binding,
                                'isRange'           : attrs.isRange === "true" || attrs.isRange === true,
                                'isRelated'         : attrs.isRelated === "true" || attrs.isRelated === true,
                                'lookupType'        : attrs.lookupType,
                                'lookupField'       : attrs.lookupField,
                                'relatedEntityName' : attrs.relatedEntityName
                            });

                        WM.extend(columnsDef, columnsDefProps);
                        columnsDef.key = columnsDef.field;
                        /*Set below properties on the scope, as post widget create is not called for this directive */
                        scope.required = columnsDef.required;
                        scope.readonly = columnsDef.readonly;
                        scope.disabled = columnsDef.disabled;
                        //This is used to call base set and get methods on widgets
                        scope.FilterField.prototype.$is = parentIsolateScope;
                        /*Support for old projects which were using value for default value*/
                        columnsDefProps.defaultvalue = attrs.defaultvalue || attrs.value;
                        /*Set the default value*/
                        if (columnsDef.defaultvalue) {
                            /*If the default value is bound variable, keep watch on the expression*/
                            if (Utils.stringStartsWith(columnsDef.defaultvalue, 'bind:') && CONSTANTS.isRunMode) {
                                expr = columnsDef.defaultvalue.replace('bind:', '');
                                if (parentIsolateScope.Variables && !Utils.isEmptyObject(parentIsolateScope.Variables) && parentIsolateScope.$eval(expr)) {
                                    defaultVal = scope.$eval(expr);
                                    columnsDef.value = defaultVal;
                                    if (columnsDef.isRange) {
                                        columnsDef.minValue = defaultVal;
                                        columnsDef.maxValue = defaultVal;
                                    }
                                } else {
                                    exprWatchHandler = BindingManager.register(parentIsolateScope, expr, function (newVal) {
                                        parentIsolateScope.formFields[index].value = newVal;
                                        if (columnsDef.isRange) {
                                            parentIsolateScope.formFields[index].minValue = newVal;
                                            parentIsolateScope.formFields[index].maxValue = newVal;
                                        }
                                        /*Apply the filter after the default value change*/
                                        parentIsolateScope.filterOnDefault();
                                    }, {"deepWatch": true, "allowPageable": true, "acceptsArray": false});
                                }
                            } else {
                                defaultVal = columnsDef.defaultvalue;
                                /*Assigning 'defaultVal' only in run mode as it can be evaluated only in run mode*/
                                if (CONSTANTS.isRunMode) {
                                    defaultVal = LiveWidgetUtils.getDefaultValue(defaultVal, columnsDef.type);
                                }
                                columnsDef.value = defaultVal;
                                if (columnsDef.isRange) {
                                    columnsDef.minValue = defaultVal;
                                    columnsDef.maxValue = defaultVal;
                                }
                            }
                        }
                        if (attrs.dataset) {
                            /*Store the dataset in tempdataset. If tempdataset is undefined, fetch the default values for field*/
                            columnsDef.tempDataset = attrs.dataset;
                            if (Utils.stringStartsWith(attrs.dataset, 'bind:') && CONSTANTS.isRunMode) {
                                expr = attrs.dataset.replace('bind:', '');
                                /*Watch on the bound variable. dataset will be set after variable is populated.*/
                                dataSetWatchHandler = parentIsolateScope.$watch(expr, function (newVal) {
                                    variable = parentIsolateScope.Variables[expr.split('.')[1]];
                                    if (WM.isObject(variable)) {
                                        if (WM.isObject(newVal) && Utils.isPageable(newVal)) {
                                            parentIsolateScope.formFields[index].dataset = newVal.content;
                                        } else if (variable.category === "wm.LiveVariable") {
                                            parentIsolateScope.formFields[index].dataset = newVal.data;
                                        } else {
                                            parentIsolateScope.formFields[index].dataset = newVal;
                                        }
                                        /* fallback to set datafield to 'All Fields' for backward compatibility */
                                        if (!attrs.datafield) {
                                            parentIsolateScope.formFields[index].datafield = "All Fields";
                                        }
                                    }
                                });
                            } else {
                                columnsDef.dataset = attrs.dataset;
                            }
                        }
                        scope.fieldDefConfig = columnsDef;
                        parentIsolateScope.formFields = parentIsolateScope.formFields || [];
                        parentIsolateScope.columnsDefCreated = true;
                        index = parentIsolateScope.formFields.push(columnsDef) - 1;

                        /* this condition will run for:
                         *  1. PC view in STUDIO mode
                         *  2. Mobile/tablet view in RUN mode
                         */
                        if (CONSTANTS.isRunMode) {
                            if (Utils.isMobile()) {
                                if (!columnsDef.mobileDisplay) {
                                    return;
                                }
                            } else {
                                if (!columnsDef.pcDisplay) {
                                    return;
                                }
                            }
                        }
                        if (!CONSTANTS.isRunMode || columnsDef.show) {
                            template = LiveWidgetUtils.getTemplate(columnsDef, index);
                            element.html(template);
                            $compile(element.contents())(parentIsolateScope);
                        } else {
                            template = LiveWidgetUtils.getHiddenTemplate(columnsDef, index);
                            element.closest('[data-identifier="livefilter"]').find('> .hidden-filter-elements').append($compile(template)(parentIsolateScope));
                        }

                        parentIsolateScope.$on('$destroy', function () {
                            if (exprWatchHandler) {
                                exprWatchHandler();
                            }
                            if (dataSetWatchHandler) {
                                dataSetWatchHandler();
                            }
                        });

                        // when the filter-field element is removed, remove the corresponding entry from parentIScope.formFields
                        element.on('$destroy', function () {
                            _.pullAt(parentIsolateScope.formFields, _.indexOf(parentIsolateScope.formFields, columnsDef));
                        });
                        WidgetUtilService.registerPropertyChangeListener(LiveWidgetUtils.fieldPropertyChangeHandler.bind(undefined, scope, element, attrs, parentIsolateScope, index), scope, undefined);
                    }
                };
            }
        };
    }])
    .directive('wmFilterAction', ['$compile', 'LiveWidgetUtils', function ($compile, LiveWidgetUtils) {
        'use strict';

        return {
            "restrict": 'E',
            "scope": true,
            "template": '',
            "replace": true,
            "compile": function () {
                return {
                    "post": function (scope, element, attrs) {
                        /*scope.$parent is defined when compiled with live filter scope*/
                        /*element.parent().isolateScope() is defined when compiled with dom scope*/
                        scope.parentIsolateScope = (element.parent() && element.parent().length > 0) ? element.parent().closest('[data-identifier="livefilter"]').isolateScope() : scope.$parent;

                        var buttonTemplate, index, buttonDef = WM.extend(LiveWidgetUtils.getButtonDef(attrs), {
                            /*iconame support for old projects*/
                            'iconname': attrs.iconname,
                            'type': 'button'
                        });
                        scope.parentIsolateScope.buttonArray = scope.parentIsolateScope.buttonArray || [];
                        index = scope.parentIsolateScope.buttonArray.push(buttonDef) - 1;
                        scope.parentIsolateScope.columnsDefCreated = true;

                        buttonTemplate = '<wm-button caption="{{buttonArray[' + index + '].displayName}}" show="{{buttonArray[' + index + '].show}}" ' +
                            'class="{{buttonArray[' + index + '].class}}" iconname="{{buttonArray[' + index + '].iconname}}" iconclass="{{buttonArray[' + index + '].iconclass}}"' +
                            'on-click="' + buttonDef.action + '" type="{{buttonArray[' + index + '].type}}" ></wm-button>';
                        element.closest('[data-identifier="livefilter"]').find('.basic-btn-grp').append($compile(buttonTemplate)(scope.parentIsolateScope));
                        $compile(element.contents())(scope.parentIsolateScope);
                    }
                };
            }
        };
    }]);
/**
 * @ngdoc directive
 * @name wm.widgets.live.directive:wmLivefilter
 * @restrict E
 *
 * @description
 * The 'wmLivefilter' directive defines a live filter in the layout.
 *
 * @scope
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 * @requires $templateCache
 * @requires Variables
 * @requires QueryBuilder
 * @requires $compile
 * @requires $rootScope
 * @requires Utils
 * @requires CONSTANTS
 *
 * @param {string=} name
 *                  Name of the filter widget.
 * @param {string=} width
 *                  Width of the filter widget.
 * @param {string=} height
 *                  Height of the filter widget.
 * @param {string=} scopedataset
 *                  This property sets a variable to populate the data required to display the list of values.
 * @param {string=} dataset
 *                  This property sets the data to show in the filter. <br>
 *                  This is a bindable property.
 * @param {boolean=} show
 *                  This is a bindable property. <br>
 *                  This property will be used to show/hide the filter on the web page. <br>
 *                  default value: `true`.
 * @param {string=} horizontalalign
 *                  This property used to set text alignment horizontally. <br>
 *                  Possible values are `left`, `center` and `right`.
 *
 * @example
 <example module="wmCore">
 <file name="index.html">
 <wm-livefilter>
 </wm-livefilter>
 </file>
 </example>
 */


/*global WM, window,confirm */

WM.module('wm.widgets.live')
    .run(["$templateCache", function ($templateCache) {
        "use strict";

        $templateCache.put("template/widget/livegrid/livegrid.html",
                '<div class="app-livegrid" init-widget title="{{hint}}" apply-styles="container" data-ng-show="show">' +
                    '<div wmtransclude></div>' +
                '</div>'
            );
    }]).directive('wmLivegrid', ['PropertiesFactory',
        '$templateCache',
        'WidgetUtilService',
        'DialogService',
        '$compile',
        '$timeout',
        'Utils',
        'CONSTANTS',
        function (PropertiesFactory, $templateCache, WidgetUtilService, DialogService, $compile, $timeout, Utils, CONSTANTS) {
            "use strict";
            var widgetProps = PropertiesFactory.getPropertiesOf('wm.livegrid', ['wm.base']),
                gridMarkup = '',
                notifyFor = {
                    'formlayout': true
                };

            return {
                restrict: 'E',
                replace: true,
                transclude: true,
                scope: {},
                controller: function ($scope) {
                    this.confirmMessage = function () {
                        if (!($scope.grid && $scope.grid.confirmdelete)) {
                            return true;
                        }
                        return confirm($scope.grid.confirmdelete);
                    };
                },
                template: function (element) {
                    gridMarkup = element.html();
                    return $templateCache.get('template/widget/livegrid/livegrid.html');
                },
                compile: function (tElement, tAttr) {
                    tAttr.gridColumnMarkup = gridMarkup;

                    return {
                        pre: function (iScope) {
                            if (CONSTANTS.isStudioMode) {
                                iScope.widgetProps = Utils.getClonedObject(widgetProps);
                            } else {
                                iScope.widgetProps = widgetProps;
                            }
                        },
                        post: function (scope, element, attrs) {
                            var handlers = [],
                                liveGridOptions = {
                                    'allowInlineEditing': false,
                                    'multiselect': false,
                                    'allowAddNewRow': false
                                };
                            /* For row delete , set the row fields to the gridform */
                            liveGridOptions.onRowDelete = function (row) {
                                scope.gridform.rowdata = row;
                                scope.gridform.delete();
                            };
                            /* call the registered methods in gridform's scope */
                            /*Function to obtain parsed regular expression as provided in properties.*/
                            scope.getRegExp = function () {
                                return new RegExp(scope.regexp);
                            };
                            scope.primaryKey = null;
                            scope.fullFieldDefs = [];
                            scope.fieldDefs = [];
                            scope.grid = element.find('[data-identifier=grid]').isolateScope();
                            scope.gridform = element.find('[data-identifier=liveform]').isolateScope();
                            scope.isLayoutDialog = false;
                            /*Add watchers or listeners only if the grid or form are present in the element*/
                            if (scope.grid && scope.gridform) {
                                scope.grid.datagridElement.datagrid('option', liveGridOptions);
                                scope.grid.parentgrid = true;
                                scope.grid.isGridPartOfLiveGrid = true;
                                scope.grid.newcolumns = scope.newcolumns;
                                /* check whether any row selected or not and set the flag in grid form widget */
                                scope.grid.$watch('selectedItems', function (newValue) {
                                    if (!(scope.grid && scope.gridform && (scope.grid.variableName === scope.gridform.variableName))) {
                                        return;
                                    }
                                    if (newValue && newValue.length > 0 && !scope.gridform.isSelected) {
                                        scope.gridform.isSelected = true;
                                    }

                                    /*Update the rowdata of only that grid form that is associated with the specific grid on which row selection is being performed...
                                     * Since both the grid & gridform are associated with the same "parentgrid", match the same*/
                                    if (newValue && newValue.length > 0) {
                                        if (scope.grid.multiselect) {
                                            scope.gridform.rowdata = newValue[0];
                                        } else {
                                            scope.gridform.rowdata = newValue[newValue.length - 1];
                                        }
                                        /*If the form is already in update mode, call the form update function*/
                                        if (scope.gridform.isUpdateMode) {
                                            scope.gridform.edit();
                                        }
                                    } else {
                                        scope.gridform.isSelected = false;
                                        scope.gridform.rowdata = '';
                                        scope.gridform.clearData();
                                    }
                                }, true);

                                scope.grid.$watch('fullFieldDefs', function (newVal) {
                                    scope.fullFieldDefs = newVal;
                                }, true);
                                scope.grid.$watch('fieldDefs', function (newVal) {
                                    scope.fieldDefs = newVal;
                                }, true);
                                scope.grid.$watch('serverData', function (newVal) {
                                    scope.serverData = newVal;
                                }, true);
                                /*On add new row call the form new function*/
                                handlers.push(scope.grid.$on('add-new-row', function () {
                                    scope.gridform.isSelected = true;
                                    scope.gridform.rowdata = '';
                                    /*In case of dialog layout set the previous data Array before clearing off*/
                                    if (scope.gridform.isLayoutDialog) {
                                        scope.gridform.setPrevformFields(scope.gridform.formFields);
                                        scope.gridform.formFields = [];
                                    }
                                    scope.gridform.new();
                                    if (scope.isLayoutDialog) {
                                        DialogService.showDialog(scope.gridform._dialogid, { 'resolve': {}, 'scope' : scope.gridform });
                                    }
                                }));
                                /*On update row call the form update function*/
                                handlers.push(scope.grid.$on('update-row', function (event, widgetid, row, eventName) {
                                    scope.gridform.rowdata = row;
                                    /*In case of dialog layout set the previous data Array before clearing off*/
                                    if (scope.gridform.isLayoutDialog) {
                                        scope.gridform.setPrevformFields(scope.gridform.formFields);
                                        scope.gridform.formFields = [];
                                    }
                                    scope.gridform.edit();
                                    scope.$root.$safeApply(scope);
                                    if (scope.isLayoutDialog) {
                                        /*Open the dialog in view or edit mode based on the defaultmode property*/
                                        scope.gridform.isUpdateMode = (eventName === 'dblclick') ? scope.gridform.updateMode : true;
                                        DialogService.showDialog(scope.gridform._dialogid, {
                                            'resolve': {},
                                            'scope': scope.gridform
                                        });
                                    }
                                }));
                                /* watch the primaryKey field in grid form , as soon as it updated change the live grid primary key */
                                scope.gridform.$watch('primaryKey', function (newVal) {
                                    scope.primaryKey = newVal;
                                });
                                /*On row delete clear the form*/
                                handlers.push(scope.gridform.$on('on-cancel', function () {
                                    scope.gridform.isUpdateMode = false;
                                    if (scope.isLayoutDialog) {
                                        DialogService.hideDialog(scope.gridform._dialogid);
                                    }
                                }));
                                /* this function will be called from liveform , when the service call ended */
                                handlers.push(scope.gridform.$on('on-result', function (event, operation, response, newForm, updateMode) {
                                    scope.gridform.isUpdateMode = WM.isDefined(updateMode) ? updateMode : newForm ? true : false;
                                    switch (operation) {
                                    case 'insert':
                                        if (newForm) {
                                            /*if new form is to be shown after insert, skip the highlight of the row*/
                                            scope.grid.gridfirstrowselect = false;
                                            scope.grid.initiateSelectItem('last', response, scope.primaryKey, true);
                                        } else {
                                            /*The new row would always be inserted at the end of all existing records. Hence navigate to the last page and highlight the inserted row.*/
                                            scope.grid.initiateSelectItem('last', response, scope.primaryKey);
                                        }
                                        if (WM.isDefined(scope.grid.onRowinsert)) {
                                            scope.grid.onRowinsert(response);
                                        }
                                        break;
                                    case 'update':
                                        /*The updated row would be found in the current page itself. Hence simply highlight the row in the current page.*/
                                        if (newForm) {
                                            scope.grid.gridfirstrowselect = false;
                                            scope.grid.initiateSelectItem('current', response, scope.primaryKey, true);
                                        } else {
                                            scope.grid.initiateSelectItem('current', response, scope.primaryKey);
                                        }
                                        break;
                                    case 'delete':
                                        scope.grid.onRecordDelete();
                                        break;
                                    }
                                    if (scope.isLayoutDialog) {
                                        /*if new form is to be shown after update or insert, don't close the dialog*/
                                        if (newForm) {
                                            if (operation === 'insert') {
                                                scope.gridform.new();
                                            } else if (operation === 'update') {
                                                scope.gridform.edit();
                                            }
                                        } else {
                                            DialogService.hideDialog(scope.gridform._dialogid);
                                        }
                                    }
                                }));
                            }
                            $compile(attrs.gridColumnMarkup)(scope);
                            function propertyChangeHandler(key, newVal) {
                                switch (key) {
                                case 'formlayout':
                                    if (scope.gridform) {
                                        scope.isLayoutDialog = newVal === 'dialog';
                                        scope.gridform.formlayout = newVal;
                                        scope.$root.$emit('set-markup-attr', scope.gridform.widgetid, {'formlayout': newVal});
                                    }
                                    break;
                                }
                            }
                            scope.$on('$destroy', function () {
                                handlers.forEach(Utils.triggerFn);
                            });
                            /* register the property change handler */
                            WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler, scope, notifyFor);
                            $timeout(function () {
                                WidgetUtilService.postWidgetCreate(scope, element, attrs);
                            }, 0, false);
                        }
                    };
                }
            };
        }]);

/**
 * @ngdoc directive
 * @name wm.widgets.live.directive:wmLivegrid
 * @restrict E
 *
 * @description
 * The `wmLiveGrid` is the Combination of grid and grid form. Using Livegrid user can insert,update,delete the data in database
 * `wmLiveGrid` can be bound to variables and display the data associated with them.
 *
 * @scope
 *
 * @requires $templateCache
 * @requires WidgetUtilService
 * @requires $compile
 * @requires $controller
 * @requires $timeout
 * @requires DialogService
 * @requires Utils
 *
 * @param {string=} name
 *                  Name of the live grid.
 * @param {string=} width
 *                  Sets the width of the live grid.
 * @param {string=} height
 *                  Sets the height of the live grid.
 * @param {string=} formlayout
 *                  This property controls how the form appears. <br>
 *                  Possible values are `inline` and `dialog`. <br>
 *                  Default value is `inline`.
 * @param {boolean=} show
 *                  This is a bindable property. <br>
 *                  This property will be used to show/hide the button widget on the web page. <br>
 *                  Default value: `true`. <br>
 * @param {string=} confirmdelete
 *                  Sets the text to be displayed before delete operation on  any of the grid rows.<br>
 * @param {boolean=} gridfirstrowselect
 *                  When enabled, the first row of the grid is highlighted.<br>
 *                  Default value for `gridfirstrowselect` is `false`.
 * @param {boolean=} deleterow
 *                  When enabled, this displays Delete buttons in each row.<br>
 *                  When clicked on the button, the corresponding row is deleted.
 * @param {object=} dataset
 *                  Sets the data for the grid.<br>
 *                  The data is visible only in the run mode.<br>
 *                  This is a bindable property. <br>
 *                  When bound to a variable, the data associated with the variable is displayed in the grid.
 * @param {boolean=} showheader
 *                  Sets the display property of the grid header.<br>
 *                  When enabled, the grid header is not displayed.
 * @param {boolean=} gridsearch
 *                  When enabled, search is enabled for the grid to search through the grid data.<br>
 *                  The value entered in the Search text box is searched in the grid and the relevant rows are displayed.<br>
 *                  Default value for `gridsearch` is `false`.
 * @example
 *   <example module="wmCore">
 *       <file name="index.html">
 *           <div data-ng-controller="Ctrl" class="wm-app">
 *               <wm-livegrid dataset="gridVariable" gridsearch="true">
 *               </wm-livegrid>
 *           </div>
 *       </file>
 *       <file name="script.js">
 *           function Ctrl($scope) {
 *               var deptData = '{"type":"Department","isList":false,"owner":"Main","editJson":"","isBound":"","dataSet":[{"budget":1936760,"deptcode":"Eng","deptid":1,"location":"San Francisco","name":"Engineering","q1":445455,"q2":522925,"q3":426087,"q4":542293,"tenantid":1},{"budget":1129777,"deptcode":"Mktg","deptid":2,"location":"New York","name":"Marketing","q1":225955,"q2":271146,"q3":327635,"q4":305040,"tenantid":1},{"budget":1452570,"deptcode":"G&A","deptid":3,"location":"San Francisco","name":"General and Admin","q1":435771,"q2":290514,"q3":348617,"q4":377668,"tenantid":1},{"budget":2743744,"deptcode":"Sales","deptid":4,"location":"Austin","name":"Sales","q1":493874,"q2":658499,"q3":713373,"q4":877998,"tenantid":1},{"budget":806984,"deptcode":"PS","deptid":5,"location":"San Francisco","name":"Professional Services","q1":201746,"q2":201746,"q3":177536,"q4":225955,"tenantid":2}],"dataBinding":{},"saveInPhonegap":false,"activePage":"","operation":"read","liveSource":"hrdb","firstRow":0,"maxResults":500,"designMaxResults":50,"ignoreCase":false,"matchMode":"start","orderBy":"","autoUpdate":true,"startUpdate":true,"onCanUpdate":"","onBeforeUpdate":"","onResult":"","onSuccess":"","onError":"","onPrepareSetData":"","category":"wm.LiveVariable","_id":"wm-wm.LiveVariable1394024169342","name":"DepartmentLiveVariable1","package":"com.hrdb.data.Department","propertiesMap":{"columns":[{"propertyName":"BUDGET","type":"integer","fullyQualifiedType":"integer","columnName":"budget","isPrimaryKey":false,"notNull":"false","length":"null","precision":"null","generator":null,"isRelated":false},{"propertyName":"DEPTID","type":"integer","fullyQualifiedType":"integer","columnName":"deptid","isPrimaryKey":true,"notNull":"true","length":"null","precision":"null","generator":"identity","isRelated":false},{"propertyName":"Q2","type":"integer","fullyQualifiedType":"integer","columnName":"q2","isPrimaryKey":false,"notNull":"false","length":"null","precision":"null","generator":null,"isRelated":false},{"propertyName":"Q1","type":"integer","fullyQualifiedType":"integer","columnName":"q1","isPrimaryKey":false,"notNull":"false","length":"null","precision":"null","generator":null,"isRelated":false},{"propertyName":"LOCATION","type":"string","fullyQualifiedType":"string","columnName":"location","isPrimaryKey":false,"notNull":"false","length":"null","precision":"null","generator":null,"isRelated":false},{"propertyName":"Q4","type":"integer","fullyQualifiedType":"integer","columnName":"q4","isPrimaryKey":false,"notNull":"false","length":"null","precision":"null","generator":null,"isRelated":false},{"propertyName":"DEPTCODE","type":"string","fullyQualifiedType":"string","columnName":"deptcode","isPrimaryKey":false,"notNull":"false","length":"20","precision":"null","generator":null,"isRelated":false},{"propertyName":"NAME","type":"string","fullyQualifiedType":"string","columnName":"name","isPrimaryKey":false,"notNull":"false","length":"null","precision":"null","generator":null,"isRelated":false},{"propertyName":"Q3","type":"integer","fullyQualifiedType":"integer","columnName":"q3","isPrimaryKey":false,"notNull":"false","length":"null","precision":"null","generator":null,"isRelated":false},{"propertyName":"TENANTID","type":"integer","fullyQualifiedType":"integer","columnName":"tenantid","isPrimaryKey":false,"notNull":"false","length":"null","precision":"null","generator":null,"isRelated":false}],"entityName":"Department"},"relatedData":{},"data":[{"budget":1936760,"deptcode":"Eng","deptid":1,"location":"San Francisco","name":"Engineering","q1":445455,"q2":522925,"q3":426087,"q4":542293,"tenantid":1},{"budget":1129777,"deptcode":"Mktg","deptid":2,"location":"New York","name":"Marketing","q1":225955,"q2":271146,"q3":327635,"q4":305040,"tenantid":1},{"budget":1452570,"deptcode":"G&A","deptid":3,"location":"San Francisco","name":"General and Admin","q1":435771,"q2":290514,"q3":348617,"q4":377668,"tenantid":1},{"budget":2743744,"deptcode":"Sales","deptid":4,"location":"Austin","name":"Sales","q1":493874,"q2":658499,"q3":713373,"q4":877998,"tenantid":1},{"budget":806984,"deptcode":"PS","deptid":5,"location":"San Francisco","name":"Professional Services","q1":201746,"q2":201746,"q3":177536,"q4":225955,"tenantid":2}]}',
 *                   deptVar = JSON.parse(deptData);
 *               $scope.$root.variables["gridVariable"] = deptVar;
 *           }
 *       </file>
 *   </example>
 */
/*global WM*/
/*Directive for List*/

WM.module('wm.layouts.containers')
    .directive('wmListtemplate', [
        'PropertiesFactory',
        'WidgetUtilService',
        '$rootScope',
        'CONSTANTS',
        '$timeout',

        function (PropertiesFactory, WidgetUtilService, $rootScope, CONSTANTS, $timeout) {
            'use strict';

            var widgetProps, notifyFor,
                directiveDefn = {
                    'restrict'  : 'E',
                    'replace'   : true
                };

            if (CONSTANTS.isStudioMode) {
                widgetProps = PropertiesFactory.getPropertiesOf('wm.layouts.listtemplate', ['wm.containers']);
                notifyFor = {
                    'layout': true
                };
            }

            function updateLiveListTemplate($is) {
                $timeout(function () {
                    /* emit event to modify the liveList template*/
                    $rootScope.$emit('livelist-template-modified', {
                        'widgetName'        : $is.name,
                        'bindDataset'       : null,
                        'fields'            : null,
                        'forceUpdate'       : true,
                        'isTemplateUpdate'  : true
                    });
                }, undefined);
            }

            /* Define the property change handler. This function will be triggered when there is a change in the widget property */
            function propertyChangeHandler($is, key, newVal) {
                switch (key) {
                case 'layout':
                    if (newVal) {
                        if ($is.newcolumns) {
                            updateLiveListTemplate($is);
                            $is.newcolumns = false;
                        }
                    }
                    break;
                }
            }

            // template function of studio directive
            function templateFn() {
                return '<li init-widget class="app-listtemplate list-group-item app-list-item" data-ng-show="show" apply-styles="container" wmtransclude></li>';
            }

            // pre link function of studio directive
            function preLinkFn($is) {
                $is.widgetProps = widgetProps;
            }

            // post link function of studio directive
            function studioMode_postLinkFn($is, $el, attrs) {
                var onPropertyChange = propertyChangeHandler.bind(undefined, $is);
                onPropertyChange.notifyFor = notifyFor;
                $is.propertyManager.add($is.propertyManager.ACTIONS.CHANGE, onPropertyChange);
                WidgetUtilService.postWidgetCreate($is, $el, attrs);
            }

            function runMode_preLinkFn($is, $el, attrs, listCtrl) {
                listCtrl.$set('listTemplate', $el.children());
                $el.remove();
            }

            if (CONSTANTS.isStudioMode) {
                WM.extend(directiveDefn, {
                    'transclude': true,
                    'scope'     : {},
                    'template'  : templateFn,
                    'link'      : {
                        'pre' : preLinkFn,
                        'post': studioMode_postLinkFn
                    }
                });
            } else {
                WM.extend(directiveDefn, {
                    'terminal': true,
                    'require' : '^wmLivelist',
                    'link'    : {
                        'pre' : runMode_preLinkFn
                    }
                });
            }

            return directiveDefn;
        }
    ]);

/*global WM, window, _, document, Hammer*/
/*jslint todo: true */
/*Directive for liveList */

WM.module('wm.widgets.live')
    .run(['$templateCache', function ($tc) {
        'use strict';

        $tc.put('template/widget/list.html',
                    '<div class="app-livelist panel" init-widget live-actions apply-styles="shell" data-ng-show="show">' +
                        '<div class="form-header panel-heading" data-ng-if="title">' +
                            '<h4 class="panel-title">' +
                                '<i class="{{iconclass}}" data-ng-style="{width:iconwidth, height:iconheight, margin:iconmargin}"></i>' +
                                '<span>{{title}}</span>' +
                            '</h4>' +
                        '</div>' +
                        '<ul data-identifier="list" class="app-livelist-container clearfix" title="{{hint}}" data-ng-class="listclass" wmtransclude ' +
                                'data-ng-style="{height: height, overflow: overflow, paddingTop: paddingtop + paddingunit, paddingRight: paddingright + paddingunit, paddingLeft: paddingleft + paddingunit, paddingBottom: paddingbottom + paddingunit}">' +
                        '</ul>' +
                        '<div class="no-data-msg" data-ng-show="noDataFound">{{::$root.appLocale.MESSAGE_LIVELIST_NO_DATA}}</div>' +
                        '<div class="panel-footer" data-ng-if="navigation !== \'None\'">' +
                            '<wm-datanavigator showrecordcount="true" navcontrols="{{navControls}}"></wm-datanavigator>' +
                        '</div>' +
                    '</div>'
                );

    }])
    .controller('listController', [

        function () {
            'use strict';
            var _map = {};

            this.$set = function (key, value) {
                _map[key] = value;
            };

            this.$get = function (key) {
                return _map[key];
            };
        }
    ])
    .directive('wmLivelist', [
        'WidgetUtilService',
        'PropertiesFactory',
        '$templateCache',
        'CONSTANTS',
        '$compile',
        'Utils',
        '$rootScope',
        '$servicevariable',
        '$timeout',

        function (WidgetUtilService, PropertiesFactory, $tc, CONSTANTS, $compile, Utils, $rs, $servicevariable, $timeout) {
            'use strict';

            var widgetProps             = PropertiesFactory.getPropertiesOf('wm.livelist', ['wm.base', 'wm.base.editors', 'wm.base.events']),
                liTemplateWrapper_start = '<li data-ng-repeat="item in fieldDefs track by $index" class="app-list-item" data-ng-class="[itemsPerRowClass, itemclass]" ',
                liTemplateWrapper_end   = '></li><li data-ng-show="fetchInProgress"><i class="fa fa-spinner fa-spin fa-2x"></i> loading...</li>',
                notifyFor = {
                    'dataset'        : true,
                    'height'         : true,
                    'navigation'     : CONSTANTS.isStudioMode,
                    'itemsperrow'    : CONSTANTS.isStudioMode
                },
                directiveDefn,
                NAVIGATION = {
                    'BASIC'    : 'Basic',
                    'ADVANCED' : 'Advanced',
                    'SCROLL'   : 'Scroll'
                };

            /* to return the bootstrap classes for the <li> w.r.t no. of items per row */
            function getRowClass(itemsperrow) {
                if (!itemsperrow) {
                    return undefined;
                }
                var col = itemsperrow && 12 / (+itemsperrow);

                return $rs.isMobileApplicationType ?  ' col-xs-' + col : 'col-sm-' + col;
            }

            function getVariable($is, variableName) {

                if (!variableName) {
                    return undefined;
                }

                var variables = $is.Variables || {};
                return variables[variableName];
            }

            /* update the selectedItem dataType onchange of bindDataSet*/
            function updateSelectedItemDataType($is, variable) {
                if (variable) {
                    /* set the variable type info to the live-list selected-entry type, so that type matches to the variable for which variable is created*/
                    $is.widgetProps.selecteditem.type = variable.type;
                }
            }

            /*to get the list of columns from the dataSet/scopeDataSet*/
            function getColumnsFromDataSet(dataset) {
                if (WM.isObject(dataset)) {
                    if (WM.isArray(dataset) && WM.isObject(dataset[0])) {
                        return _.keys(dataset[0]);
                    }
                    return _.keys(dataset);
                }
                return [];
            }

            /*to get list of all the columns from the properties-map */
            function getColumnsFromPropertiesMap(propertiesMap) {
                if (propertiesMap && propertiesMap.columns) {
                    //populating the column definition in the columns
                    return propertiesMap.columns.map(function (column) {
                        return column.fieldName;
                    });
                }
                return [];
            }

            /* Function to get details of widget the live list is bound to.
             * Example: If live list is bound to the selected items of a grid
             * (binddataset - bind:Widgets.gridId.selecteditem), we first find the
             * variable bound to the grid, get its type and columns, and then generate
             * corresponding bindings for the live list.*/
            function getBoundWidgetDatasetDetails($is) {
                var dataSetParts,
                    refVariable,
                    refVariableName,
                    relFieldName,
                    relFieldType,
                    fields,
                    details,
                    isBoundToSelectedItemSubset = _.includes($is.binddataset, 'selecteditem.');

                dataSetParts = $is.binddataset.split('.');
                refVariableName = Utils.getVariableName($is);
                refVariable = getVariable($is, refVariableName);

                relFieldName = isBoundToSelectedItemSubset && dataSetParts[3];

                fields = $rs.dataTypes[refVariable.package].fields;
                details = {
                    'refVariableName': refVariableName,
                    'refVariable': refVariable
                };
                /* If binddataset is of the format: bind:Widgets.widgetName.selecteditem.something,
                 * i.e. widget is bound to a subset of selected item, get type of that subset.*/
                if (relFieldName) {
                    relFieldType = fields[relFieldName].type;
                    details.relFieldType = relFieldType;
                } else {
                    /* When binddataset is of the format: bind:Widgets.widgetName.selecteditem */
                    details.fields = fields;
                }
                return details;
            }

            /* Fetch column bindings for the live list in case it is bound to a widget. */
            function fetchDynamicColumns($is) {
                var fields = [],
                    result;
                result = getBoundWidgetDatasetDetails($is);
                if (result.fields) {
                    fields = result.fields;
                } else if (result.relFieldType) {
                    /*Invoke the function to fetch sample data-structure for the field.*/
                    fields = $servicevariable.getServiceModel({
                        typeRef: result.relFieldType,
                        variable: result.refVariable
                    });
                }
                return WM.isObject(fields) ? _.keys(fields) : fields;
            }

            function updateLiveListBindings($is, forceUpdate) {
                var columns;

                if ($is.dataset && $is.dataset.propertiesMap) {
                    columns = getColumnsFromPropertiesMap($is.dataset.propertiesMap);
                } else {
                    columns = getColumnsFromDataSet($is.dataset);
                }

                if (!columns || !columns.length) {
                    /* If live list is bound to a widget, fetch the columns accordingly. */
                    if (_.includes($is.binddataset, 'bind:Widgets.')) {
                        columns = fetchDynamicColumns($is);
                    }
                }
                /* emit event to modify the liveList template*/
                $rs.$emit('livelist-template-modified', {
                    'widgetName' : $is.name,
                    'bindDataset': $is.binddataset,
                    'fields'     : columns,
                    'forceUpdate': forceUpdate
                });
            }

            function handlePageSizeDisplay($is, variableObj) {
                if (variableObj) {
                    var isBoundToLiveVariable = (variableObj.category === 'wm.LiveVariable'),
                        isBoundToQueryServiceVariable = (variableObj.category === 'wm.ServiceVariable') && (variableObj.serviceType === 'DataService');
                    /*Make the "pageSize" property hidden so that no editing is possible for live and query service variables*/
                    $is.widgetProps.pagesize.show = !(isBoundToLiveVariable || isBoundToQueryServiceVariable);
                }
            }

            function setFetchInProgress($is, inProgress) {
                $is.$liScope.fetchInProgress = inProgress;
            }

            function bindScrollEvt($is, $el) {
                var $dataNavigator = $el.find('> .panel-footer > [data-identifier=datanavigator]'),
                    navigator = $dataNavigator.isolateScope();

                $el.find('> ul')
                    .children()
                    .first()
                    .scrollParent(false)
                    .off('scroll.livelist')
                    .on('scroll.livelist', function (evt) {
                        var target = evt.target,
                            clientHeight,
                            totalHeight,
                            scrollTop;

                        target =  target === document ? target.scrollingElement : target;

                        clientHeight = target.clientHeight;
                        totalHeight  = target.scrollHeight;
                        scrollTop    = target.scrollTop;

                        if (totalHeight * 0.9 < scrollTop + clientHeight) {
                            $rs.$safeApply($is, function () {
                                setFetchInProgress($is, true);
                                navigator.navigatePage('next');
                                if (navigator.isLastPage()) {
                                    setFetchInProgress($is, false);
                                }
                            });
                        }
                    });
            }

            /** With given data, creates list items and updates the markup*/
            function updateFieldDefs($is, $el, data) {
                var unbindWatcher,
                    _s = $is.$liScope,
                    fieldDefs = _s.fieldDefs;

                if ($is.infScroll) {
                    if (WM.isUndefined(fieldDefs)) {
                        _s.fieldDefs = fieldDefs = [];
                    }
                    _.forEach(data, function (item) {
                        fieldDefs.push(item);
                    });

                    $timeout(function () {
                        setFetchInProgress($is, false);
                        if (fieldDefs.length) {
                            bindScrollEvt($is, $el);
                        }
                    });
                } else {
                    _s.fieldDefs = data;
                }

                if (!data.length) {
                    $is.noDataFound = true;
                    $is.selecteditem = undefined;
                }

                /* In run mode, making the first element selected, if flag is set */
                if ($is.selectfirstitem) {
                    unbindWatcher = $is.$watch(function () {
                        var items = $el.find('.list-group li.app-list-item:first-of-type');
                        if (items.length) {
                            $rs.$safeApply($is, function () {
                                $timeout(function () {
                                    var item = items.first();
                                    /*If item has active class already, no need to click again*/
                                    if (!item.hasClass('active')) {
                                        item.click();
                                    }
                                }, 0, false);
                                unbindWatcher();
                            });
                        }
                    });
                }
            }

            function onDataChange($is, $el, nv) {
                if (nv) {
                    $is.noDataFound = false;

                    if (nv.data) {
                        nv = nv.data;
                    } else {
                        if (!_.includes($is.binddataset, 'bind:Widgets.')) {
                            var boundVariableName = Utils.getVariableName($is),
                                variable = getVariable($is, boundVariableName);
                            // data from the live list must have .data filed
                            if (variable && variable.category === 'wm.LiveVariable') {
                                return;
                            }
                        }
                    }

                    /*If the data is a pageable object, then display the content.*/
                    if (WM.isObject(nv) && Utils.isPageable(nv)) {
                        nv = nv.content;
                    }

                    if (WM.isObject(nv) && !WM.isArray(nv)) {
                        nv = [nv];
                    }
                    if (!$is.binddataset) {
                        if (WM.isString(nv)) {
                            nv = nv.split(',');
                        }
                    }
                    if (WM.isArray(nv)) {
                        updateFieldDefs($is, $el, nv);
                    }
                } else {
                    if (CONSTANTS.isRunMode) {
                        updateFieldDefs($is, $el, []);
                    }
                }
            }

            function setupDataSource($is, $el, nv) {

                var $dataNavigator, // dataNavigator element
                    dataNavigator,  // dataNavigator scope
                    binddataset;
                if ($is.navControls || $is.infScroll) {

                    binddataset = $is.binddataset;
                    Utils.triggerFn($is._watchers.dataset);

                    $timeout(function () {
                        $dataNavigator = $el.find('> .panel-footer > [data-identifier=datanavigator]');
                        dataNavigator = $dataNavigator.isolateScope();

                        dataNavigator.pagingOptions = {
                            maxResults: $is.pagesize || 20
                        };

                        // remove the existing watchers
                        Utils.triggerFn($is._watchers.dataNavigatorResult);
                        Utils.triggerFn($is._watchers.dataNavigatorMaxResults);

                        // create a watch on dataNavigator.result
                        $is._watchers.dataNavigatorResult = dataNavigator.$watch('result', function (_nv) {
                            onDataChange($is, $el, _nv);
                        }, true);
                        $is._watchers.dataNavigatorMaxResults = dataNavigator.$watch('maxResults', function (_nv) {
                            $is.pagesize = _nv;
                        }, true);

                        dataNavigator.dataset = binddataset;
                    });
                } else {
                    onDataChange($is, $el, nv);
                }
            }

            function studioMode_onDataSetChange($is, doNotRemoveTemplate) {
                var boundVariableName = Utils.getVariableName($is),
                    variable = getVariable($is, boundVariableName);
                //Assign variable name and type on widget scope if variable is available.
                if (variable) {
                    $is.variableName = variable.name;
                    $is.variableType = variable.category;
                }
                if ($is.oldbinddataset !== $is.binddataset && $is._isInitialized) {
                    if (!doNotRemoveTemplate) {
                        updateLiveListBindings($is, true);
                    }
                }
                handlePageSizeDisplay($is, variable);
                updateSelectedItemDataType($is, variable);
            }

            function runMode_onDataSetChange($is, $el, nv) {
                if ($is.oldbinddataset !== $is.binddataset) {
                    setupDataSource($is, $el, nv);
                } else {
                    onDataChange($is, $el, nv);
                }
            }

            function onDataSetChange($is, $el, doNotRemoveTemplate, nv) {

                if (CONSTANTS.isStudioMode) {
                    studioMode_onDataSetChange($is, doNotRemoveTemplate);
                } else {
                    runMode_onDataSetChange($is, $el, nv);
                }

                $is.oldbinddataset = $is.binddataset;
            }

            function resetNavigation($is) {
                $is.navControls = undefined;
                $is.infScroll   = false;
            }

            function enableBasicNavigation($is) {
                $is.navControls = NAVIGATION.BASIC;
            }

            function enableAdvancedNavigation($is) {
                $is.navControls = NAVIGATION.ADVANCED;
            }

            function enableInfiniteScroll($is) {
                $is.infScroll = true;
            }

            function onNavigationTypeChange($is, type) {
                resetNavigation($is);
                switch (type) {
                case NAVIGATION.BASIC:
                    enableBasicNavigation($is);
                    break;
                case NAVIGATION.ADVANCED:
                    enableAdvancedNavigation($is);
                    break;
                case NAVIGATION.SCROLL:
                    enableInfiniteScroll($is);
                    break;
                }
            }

            /** In case of run mode, the field-definitions will be generated from the markup*/
            /* Define the property change handler. This function will be triggered when there is a change in the widget property */
            function propertyChangeHandler($is, $el, attrs, key, nv, ov) {
                var doNotRemoveTemplate,
                    oldClass,
                    newClass;
                /**checking if the height is set on the element then we will enable the overflow**/

                switch (key) {
                case 'height':
                    if (nv) {
                        $is.overflow = 'auto';
                    }
                    break;
                case 'dataset':
                    doNotRemoveTemplate = attrs.template === 'true';
                    onDataSetChange($is, $el, doNotRemoveTemplate, nv);
                    break;
                case 'itemsperrow':
                    if (CONSTANTS.isStudioMode) {
                        oldClass = ov && 'col-md-' + 12 / (+ov);
                        newClass = nv && 'col-md-' + 12 / (+nv);
                        $el.find('.app-listtemplate').removeClass(oldClass).addClass(newClass);
                    }
                    break;
                case 'navigation':
                    if (CONSTANTS.isStudioMode) {
                        onNavigationTypeChange($is, nv);
                    }
                    break;
                }
            }

            function defineProps($is, $el) {
                /*This is to make the "Variables" & "Widgets" available in the Data-navigator it gets compiled with the live-list isolate Scope
                 * and "Variables", "Widgets" will not be available in that scope.
                 * element.scope() might refer to the controller scope/parent scope.*/
                var _scope = $el.scope(); // scope inherited from controller's scope

                Object.defineProperties($is, {
                    'Variables': {
                        'get': function () {
                            return _scope.Variables;
                        }
                    },
                    'Widgets': {
                        'get': function () {
                            return _scope.Widgets;
                        }
                    }
                });
            }

            function createChildScope($is, $el, attrs) {
                var _scope = $el.scope(), // scop which inherits controller's scope
                    $liScope = _scope.$new(); // create a new child scope. List Items will be compiled with this scope.

                // evt handlers will be created by isolateScope. redefine them on $liScope.
                WM.extend($liScope, {
                    'onClick'               : $is.onClick,
                    'onDblclick'            : $is.onDblclick,
                    'onTap'                 : $is.onTap,
                    'onDoubletap'           : $is.onDoubletap,
                    'onMouseenter'          : $is.onMouseenter,
                    'onMouseleave'          : $is.onMouseleave,
                    'onEnterkeypress'       : $is.onEnterkeypress,
                    'onSetrecord'           : $is.onSetrecord,
                    'itemclass'             : $is.itemclass,
                    'itemsPerRowClass'      : getRowClass(attrs.itemsperrow),
                    'addRow'                : $is.addRow,
                    'updateRow'             : $is.updateRow,
                    'deleteRow'             : $is.deleteRow
                });

                return $liScope;
            }

            function applyWrapper($tmplContent, attrs) {
                var tmpl = liTemplateWrapper_start;

                if (attrs.hasOwnProperty('onMouseenter')) {
                    tmpl += ' data-ng-mouseenter="onMouseenter({$event: $event, $scope: this})" ';
                }

                if (attrs.hasOwnProperty('onMouseleave')) {
                    tmpl += ' data-ng-mouseleave="onMouseleave({$event: $event, $scope: this})" ';
                }

                tmpl += liTemplateWrapper_end;
                tmpl = WM.element(tmpl);
                tmpl.first().append($tmplContent);
                return tmpl;
            }

            function prepareLITemplate(tmpl, attrs) {
                var $tmpl = WM.element(tmpl),
                    $div  = WM.element('<div></div>').append($tmpl),
                    parentDataSet = attrs.dataset || attrs.scopedataset;

                if (parentDataSet) {
                    Utils.updateTmplAttrs($div, parentDataSet);
                }
                $tmpl = applyWrapper($tmpl, attrs);

                return $tmpl;
            }
            /*Function to get data of all active elements*/
            function getSelectedItems($el, items) {
                items.length = 0;
                $el.find('li.active').each(function () {
                    var liScope = WM.element(this).scope();
                    items.push(liScope.item);
                });
                return items;
            }
            //Triggers event to update or delete list item
            function triggerWMEvent($is, evt, name) {
                $is.selecteditem = WM.element(evt.delegateTarget).item;
                $rs.$emit('wm-event', $is.name, name);
            }

            function setupEvtHandlers($is, $el, attrs) {
                var pressStartTimeStamp = 0,
                    $hammerEl = new Hammer($el[0], {}),
                    selectCount = 0,
                    isMultiSelect = false;// Setting to true on first long press
                /*listen on to the click event for the ul element & get li clicked of the live-list */
                $el.on('click.wmActive', 'ul', function (evt) {
                    /*returning if click event is triggered within 50ms after pressup event occurred*/
                    if (pressStartTimeStamp + 50 > Date.now()) {
                        return;
                    }
                    var $li = WM.element(evt.target).closest('li.app-list-item'),
                        $liScope = $li && $li.scope(),
                        isActive = $li.hasClass('active');
                    if ($liScope) {
                        if (isMultiSelect) {
                            if (!$is.selectionlimit || selectCount < $is.selectionlimit || $li.hasClass('active')) {
                                $li.toggleClass('active');
                                selectCount += (isActive ? -1 : 1);
                                isMultiSelect = selectCount > 0;//Setting 'isMultiSelect' to false if no items are selected
                            } else {
                                Utils.triggerFn($is.onSelectionlimitexceed, {$event: evt, $scope: $is});
                            }
                        } else {
                            selectCount = 0;
                            $el.find('li.active').removeClass('active'); // removing active class from previous selectedItem
                            if (!isActive) {
                                $li.addClass('active');
                            }
                            /*trigger $apply, as 'click' or 'tap' is out of angular-scope*/
                            if (attrs.onClick) {
                                Utils.triggerFn($liScope.onClick, {$event: evt, $scope: $liScope});
                            }
                            if (attrs.onTap) {
                                Utils.triggerFn($liScope.onTap, {$event: evt, $scope: $liScope});
                            }
                        }
                    }
                    $rs.$safeApply($is);
                });

                /*listen on to the dblclick event for the ul element & get li dblclicked of the live-list */
                $el.on('dblclick.wmActive', 'ul', function (evt) {
                    var $li = WM.element(evt.target).closest('li.app-list-item'),
                        $liScope = $li && $li.scope();

                    /*trigger $apply, as 'dblclick' or 'doubleTap' is out of angular-scope*/
                    if (attrs.onDblclick) {
                        Utils.triggerFn($liScope.onDblclick, {$event: evt, $scope: $liScope});
                    }
                    if (attrs.onDoubletap) {
                        Utils.triggerFn($liScope.onDoubletap, {$event: evt, $scope: $liScope});
                    }
                    $rs.$safeApply($is);
                });

                $hammerEl.on('pressup', function (evt) {
                    if (!isMultiSelect) {
                        selectCount = 0;
                        pressStartTimeStamp = evt.timeStamp;//Recording pressup event's timestamp
                        var $li = WM.element(evt.target).closest('li.app-list-item');
                        $el.find('li.active').removeClass('active'); // removing active class from previous selectedItem
                        selectCount += 1;
                        $li.addClass('active'); // adding active class to current selectedItem
                        isMultiSelect = true;
                        $rs.$safeApply($is);
                    }
                });
                //Triggered on click of edit action
                $el.on('click', '[class*="edit-list-item"]', function (evt) {
                    triggerWMEvent($is, evt, 'update');
                });
                //Triggered on click of delete action
                $el.on('click', '[class*="delete-list-item"]', function (evt) {
                    triggerWMEvent($is, evt, 'delete');
                });
            }

            function preLinkFn($is, $el, attrs) {
                if (CONSTANTS.isStudioMode) {
                    $is.widgetProps = Utils.getClonedObject(widgetProps);
                } else {
                    $is.widgetProps = widgetProps;
                }

                // initialising oldDataSet to -1, so as to handle live-list with variable binding with live variables, during page 'switches' or 'refreshes'
                $is.oldbinddataset = CONSTANTS.isStudioMode ? attrs.dataset : undefined;
                $is.dataset     = [];   // The data that is bound to the list. Stores the name for reference.
                $is.fieldDefs   = []; // The data required by the wmListItem directive to populate the items
                $is.noDataFound = false;
                Object.defineProperty($is, 'selecteditem', {
                    configurable: true
                });
                defineProps($is, $el);
            }

            function configureDnD($el, $is) {
                var data;
                $el.find('.app-livelist-container').sortable({
                    'appendTo'    : 'body',
                    'containment' : '.app-livelist-container',
                    'delay'       : 100,
                    'opacity'     : 0.8,
                    'helper'      : 'clone',
                    'z-index'     : 100,
                    'tolerance'   : 'pointer',
                    'start'       : function (evt, ui) {
                        ui.placeholder.height(ui.item.height());
                        WM.element(this).data('oldIndex', ui.item.index());
                    },
                    'update'      : function (evt, ui) {
                        var newIndex,
                            oldIndex,
                            draggedItem,
                            $dragEl;

                        $dragEl     = WM.element(this);
                        newIndex    = ui.item.index();
                        oldIndex    = $dragEl.data('oldIndex');
                        data        = data || Utils.getClonedObject($is.dataset.data);
                        draggedItem = _.pullAt(data, oldIndex)[0];

                        data.splice(newIndex, 0, draggedItem);
                        Utils.triggerFn($is.onReorder, {$event: evt, $data: data });
                        $dragEl.removeData('oldIndex');
                    }
                });
                $el.find('.app-livelist-container').droppable({'accept': '.app-list-item'});
            }

            function defineSelectedItemProp($is, $el, items) {
                Object.defineProperty($is, 'selecteditem', {
                    get: function () {
                        //update the items with out changing the reference.
                        items = getSelectedItems($el, items);
                        if (items && items.length === 1) {
                            return items[0];
                        }
                        return items;
                    },
                    set: function (items) {
                        $el.find('li.active').removeClass('active'); // removing active class from previous selectedItem
                        if (_.isArray(items)) {
                            _.forEach(items, function (item) {
                                $is.selectItem(item);
                            });
                        } else {
                            $is.selectItem(items);
                        }
                    }
                });
            }
            /*Based on the given item, find the index of the list item*/
            function getItemIndex(listItems, item) {
                var matchIndex;
                listItems.each(function (index) {
                    var $li = WM.element(this),
                        liScope = $li.scope();
                    if (_.isEqual(liScope.item, item)) {
                        matchIndex = index;
                        return false;
                    }
                });
                return matchIndex;
            }
            /*Select or delselect the live list item*/
            function toggleSelectedItem($el, item, isSelect) {
                var listItems = $el.find('.list-group li.app-list-item'),
                    itemIndex = WM.isNumber(item) ? item : getItemIndex(listItems, item),
                    $li = WM.element(listItems[itemIndex]);
                if (isSelect) {
                    $li.addClass('active');
                } else {
                    $li.removeClass('active');
                }
            }

            function postLinkFn($is, $el, attrs, listCtrl) {
                var $liScope,
                    $liTemplate;

                $liScope = createChildScope($is, $el, attrs);
                $is.$liScope = $liScope;

                if (CONSTANTS.isRunMode) {

                    $liTemplate = prepareLITemplate(listCtrl.$get('listTemplate'), attrs);
                    $el.find('> [data-identifier=list]').prepend($liTemplate);
                    $compile($liTemplate)($liScope);

                    if ($is.enablereorder) {
                        configureDnD($el, $is);
                    }

                    if (attrs.scopedataset) {
                        $is.$watch('scopedataset', function (nv) {
                            if (nv && !$is.dataset) {
                                updateFieldDefs($is, $el, nv);
                            }
                        }, true);
                    }

                    setupEvtHandlers($is, $el, attrs);
                }
                /* register the property change handler */
                WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, $is, $el, attrs), $is, notifyFor);

                defineSelectedItemProp($is, $el, []);
                /* Select the given item*/
                $is.selectItem = function (item) {
                    toggleSelectedItem($el, item, true);
                };
                /* deselect the given item*/
                $is.deselectItem = function (item) {
                    toggleSelectedItem($el, item, false);
                };

                // in the run mode navigation can not be changed dynamically
                // process the navigation type before the dataset is set.
                if (attrs.hasOwnProperty('shownavigation') && (attrs.shownavigation === 'true')) {
                    // for legacy applications
                    $is.navigation = NAVIGATION.ADVANCED;
                }
                onNavigationTypeChange($is, $is.navigation);

                WidgetUtilService.postWidgetCreate($is, $el, attrs);
            }

            function compileFn($tEl, tAttrs) {
                /* in run mode there is separate controller for live-list widget but not in studio mode,
                 * to prevent errors in studio mode create and empty function
                 * with particular controller name */
                if (CONSTANTS.isStudioMode) {
                    window[tAttrs.name + 'Controller'] = WM.noop;
                }

                return {
                    'pre' : preLinkFn,
                    'post': postLinkFn
                };
            }

            directiveDefn = {
                'restrict'  : 'E',
                'replace'   : true,
                'transclude': true,
                'scope'     : {},
                'template'  : $tc.get('template/widget/list.html'),
                'compile'   : compileFn
            };

            if (CONSTANTS.isRunMode) {
                directiveDefn.controller = 'listController';
                directiveDefn.scope = {
                    'scopedataset'          : '=?',
                    'onClick'               : '&',
                    'onDblclick'            : '&',
                    'onMouseenter'          : '&',
                    'onMouseleave'          : '&',
                    'onEnterkeypress'       : '&',
                    'onSetrecord'           : '&',
                    'onTap'                 : '&',
                    'onDoubletap'           : '&',
                    'onSelectionlimitexceed': '&'
                };
            }

            return directiveDefn;
        }
    ]);

/**
 * @ngdoc directive
 * @name wm.widgets.live.directive:wmLivelist
 * @restrict E
 *
 * @description
 * The `wmLivelist` directive defines a Live list widget. <br>
 *
 * @requires PropertiesFactory
 * @requires $templateCache
 * @requires WidgetUtilService
 * @requires $compile
 * @requires CONSTANTS
 * @requires Utils
 * @requires $compile
 *
 * @param {string=} name
 *                  Name of the list container.
 * @param {string=} width
 *                  Width of the list container.
 * @param {string=} height
 *                  Height of the list container.
 * @param {string=} itemsperrow
 *                  This property controls the number of widgets displayed within this widget container for a horizontal layout. <br>
 *                  Possible values are `1`, `2`, `3`, `4`, `6`, and `12`. <br>
 *                  default value: `1`.
 * @param {string=} dataset
 *                  Sets the data for the list.<br>
 *                  This is a bindable property.<br>
 *                  When bound to a variable, the data associated with the variable is displayed in the list.
 * @param {object=} scopedataset
 *                  Populate data for the list which is defined in the script<br>
 *                  The data is visible only in the run mode.<br>
 * @param {boolean=} show
 *                  This is a bindable property. <br>
 *                  This property will be used to show/hide the list on the web page. <br>
 *                  default value: `true`.
 * @param {boolean=} selectfirstitem
 *                  This is a bindable property. <br>
 *                  When the value is true, the first item of the list is selected by default. <br>
 *                  default value: `false`.
 * @param {number=} pagesize
 *                  This property sets the number of items to show in the drop-down list.
 * @param {string=} navigation
 *                  Possible values are `None`, `Advanced`, `Scroll`. <br>
 *                  Navigation controls will be displayed based on the selected value.
 * @param {string=} on-click
 *                  Callback function which will be triggered when the widget is clicked.
 * @param {string=} on-dbclick
 *                  Callback function which will be triggered when the widget is double-clicked.
 * @param {string=} on-mouseenter.
 *                  Callback function which will be triggered when the mouse enters the widget.
 * @param {string=} on-mouseleave
 *                  Callback function which will be triggered when the mouse leaves the widget.
 * @param {string=} on-enterkeypress
 *                  Callback function which will be triggered when the user hits ENTER/Return while focus is in this editor.
 * @param {string=} on-setrecord
 *                  Callback function which will be triggered when the record is set using the data-navigator.
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
               <div>Selected Element: {{selectedItem}}</div>
               <wm-livelist
                   name="{{caption}}"
                   width="{{width}}"
                   height="{{height}}"
                   show="true"
                   scopedataset="dataset"
                   on-click="f($event)">
                    <wm-listtemplate layout="inline">
                        <wm-button class="btn btn-primary" caption="{{item}}"></wm-button>
                    </wm-listtemplate>
               </wm-livelist><br>
                <wm-composite>
                    <wm-label caption="caption:"></wm-label>
                    <wm-text scopedatavalue="caption"></wm-text>
                </wm-composite>
                <wm-composite>
                    <wm-label caption="width:"></wm-label>
                    <wm-text scopedatavalue="width"></wm-text>
                </wm-composite>
                <wm-composite>
                    <wm-label caption="height:"></wm-label>
                    <wm-text scopedatavalue="height"></wm-text>
                </wm-composite>
                <wm-composite>
                    <wm-label caption="dataset:"></wm-label>
                    <wm-text
                       on-blur="blur($event, $scope)"
                       scopedatavalue="dataStr">
                    </wm-text>
                </wm-composite>
            </div>
        </file>
         <file name="script.js">
           function Ctrl($scope) {
               $scope.width = "400px";
               $scope.height= "200px";
               $scope.caption = " Users ";

               $scope.dataset =
               $scope.dataStr = ["user", "admin", "superuser"];

               $scope.f = function (event) {
                   $scope.selectedItem = event.target.innerText;
               };
               $scope.blur = function (event, scope) {
                   $scope.dataset = [];
                   $scope.dataset = scope.datavalue.split(',');
               }
            }
        </file>
    </example>
 */

/*global WM,_ */
/*Directive for Calendar */

WM.module('wm.widgets.advanced')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/widget/calendar.html',
                '<div class="app-calendar" init-widget has-model ' +
                    ' data-ng-model ="_model_" data-ng-show = "show"' +
                    ' data-ng-change="_onChange({$event: $event, $scope: this})" apply-styles="shell">' +
                    '<div ui-calendar="calendarOptions.calendar" calendar="{{name}}" ng-model="eventSources"></div>' +
                '</div>');
    }])
    .directive('wmCalendar', [
        'PropertiesFactory',
        'WidgetUtilService',
        '$compile',
        '$locale',
        'CONSTANTS',
        'Utils',
        function (PropertiesFactory, WidgetUtilService, $compile, $locale, CONSTANTS, Utils) {
            'use strict';
            var widgetProps = PropertiesFactory.getPropertiesOf('wm.calendar', ['wm.base', 'wm.base.datetime']),
                notifyFor = {
                    'dataset': true,
                    'height': true,
                    'controls': true,
                    'calendartype': true,
                    'view': true,
                    'multiselect': true
                },
                defaultHeaderOptions = {
                    'left': 'prev next today',
                    'center': 'title',
                    'right': 'month basicWeek basicDay'
                },
                VIEW_TYPES = {
                    'BASIC': 'basic',
                    'AGENDA': 'agenda'
                };

            /* datavalue property is removed from the calendar widget.*/
            delete widgetProps.datavalue;
            function updateCalendarOptions(scope) {
                var ctrls = scope.controls, viewType = scope.calendartype, left = '', right = '',
                    regEx = new RegExp('\\bday\\b', 'g');
                if (ctrls && viewType) {
                    if (_.includes(ctrls, 'navigation')) {
                        left += ' prev next';
                    }

                    if (_.includes(ctrls, 'today')) {
                        left += ' today';
                    }

                    if (_.includes(ctrls, 'month')) {
                        right += ' month';
                    }

                    if (_.includes(ctrls, 'week')) {
                        right += viewType === VIEW_TYPES.BASIC ?  ' basicWeek' : ' agendaWeek';
                    }

                    if (regEx.test(ctrls)) {
                        right += viewType === VIEW_TYPES.BASIC ?  ' basicDay' : ' agendaDay';
                    }

                    WM.extend(scope.calendarOptions.calendar.header, {'left': left, 'right': right});
                }
            }

            /* Define the property change handler. This function will be triggered when there is a change in the widget property */
            function propertyChangeHandler(scope, key, newVal) {
                var calendar = scope.calendarOptions.calendar;
                switch (key) {
                case 'dataset':
                    scope.eventSources.length = 0;
                    newVal = WM.isObject(newVal) ? newVal : {};
                    scope.eventSources.push(newVal);
                    break;
                case 'height':
                    calendar.height = parseInt(newVal, 10);
                    break;
                case 'controls':
                case 'calendartype':
                    updateCalendarOptions(scope);
                    break;
                case 'view':
                    if (newVal !== 'month') {
                        calendar.defaultView = scope.calendartype + _.capitalize(newVal);
                    } else {
                        calendar.defaultView = newVal;
                    }
                    break;
                case 'multiselect':
                    scope.calendarOptions.calendar.selectable = newVal;
                    break;
                }
            }

            return {
                'restrict': 'E',
                'replace': true,
                'scope': {
                    "scopedataset": '=?',
                    "onEventdrop": "&",
                    "onEventresize": "&",
                    "onEventclick": "&",
                    "onViewrender": "&",
                    "onSelect": "&",
                    "onEventrender": "&"
                },
                'template': function (tElement, tAttrs) {
                    var template = WM.element(WidgetUtilService.getPreparedTemplate('template/widget/calendar.html', tElement, tAttrs));
                    /*Set name for the model-holder, to ease submitting a form*/
                    template.find('.model-holder').attr('name', tAttrs.name);
                    if (tAttrs.hasOwnProperty('disabled')) {
                        template.find('datepicker').attr('date-disabled', true);
                    }

                    return template[0].outerHTML;
                },
                'compile': function () {
                    return {
                        'pre': function (scope) {
                            scope.widgetProps = widgetProps;
                            scope.events = [];
                            scope.eventSources = [scope.events];
                        },
                        'post': function (scope, element, attrs) {
                            var handlers = [],
                                headerOptions = Utils.getClonedObject(defaultHeaderOptions),
                                uiCalScope,
                                oldData;

                            function eventProxy(method, event, delta, revertFunc, jsEvent, ui, view) {
                                var fn = scope[method] || WM.noop;
                                fn({$event: jsEvent, $data: event, $delta: delta, $revertFunc: revertFunc, $ui: ui, $view: view});
                            }
                            function eventClickProxy(event, jsEvent, view) {
                                scope.onEventclick({$event: jsEvent, $data: event, $view: view});
                            }
                            function viewRenderProxy(view) {
                                scope.currentview = {start: view.start._d.getTime(), end: view.end._d.getTime()};
                                scope.onViewrender({$view: view});
                            }
                            function eventRenderProxy(event, jsEvent, view) {
                                /*unable to pass jsEvent in angular expression, hence ignoring*/
                                scope.onEventrender({$event: {}, $data: event, $view: view});
                            }
                            function onSelectProxy(start, end, jsEvent, view) {
                                scope.selecteddates = {start: start._d.getTime(), end: end._d.getTime()};
                                scope.onSelect({$start: start._d.getTime(), $end: end._d.getTime(), $view: view});
                            }
                            function onEventdropProxy(event, delta, revertFunc, jsEvent, ui, view) {
                                scope.onEventdrop({$event: jsEvent, $newData: event, $oldData: oldData, $delta: delta, $revertFunc: revertFunc, $ui: ui, $view: view});
                            }
                            function onEventresizeProxy(event, delta, revertFunc, jsEvent, ui, view) {
                                scope.onEventresize({$event: jsEvent, $newData: event, $oldData: oldData, $delta: delta, $revertFunc: revertFunc, $ui: ui, $view: view});
                            }
                            function onEventChangeStart(event, jsEvent, ui, view) {
                                oldData = Utils.getClonedObject(event);
                            }
                            scope.calendarOptions = {
                                calendar: {
                                    height: parseInt(scope.height, 10),
                                    editable: true,
                                    selectable: false,
                                    header: headerOptions,
                                    eventDrop: onEventdropProxy,
                                    eventResizeStart: onEventChangeStart,
                                    eventDragStart: onEventChangeStart,
                                    eventResize: onEventresizeProxy,
                                    eventClick: eventClickProxy,
                                    select: onSelectProxy,
                                    eventRender: eventRenderProxy,
                                    viewRender: viewRenderProxy,
                                    dayNames: $locale.DATETIME_FORMATS.DAY,
                                    dayNamesShort: $locale.DATETIME_FORMATS.SHORTDAY
                                }
                            };
                            scope.$root.$on('locale-change', function () {
                                scope.calendarOptions.calendar.dayNames = $locale.DATETIME_FORMATS.DAY;
                                scope.calendarOptions.calendar.dayNamesShort = $locale.DATETIME_FORMATS.SHORTDAY;
                            });

                            /* add and removes an event source of choice */
                            scope.addRemoveEventSource = function (sources, source) {
                                var canAdd = 0;
                                WM.forEach(sources, function (value, key) {
                                    if (sources[key] === source) {
                                        sources.splice(key, 1);
                                        canAdd = 1;
                                    }
                                });
                                if (canAdd === 0) {
                                    sources.push(source);
                                }
                            };
                            /* add custom event*/
                            scope.addEvent = function (eventObject) {
                                scope.events.push(eventObject);
                            };
                            /* remove event */
                            scope.remove = function (index) {
                                scope.events.splice(index, 1);
                            };
                            /* Change View */
                            /*scope.changeView = function (view, calendar) {
                            };*/

                            /* Render Tooltip */
                            scope.eventRender = function (event, element) {
                                element.attr({'tooltip': event.title, 'tooltip-append-to-body': true});
                                $compile(element)(scope);
                            };
                            if (CONSTANTS.isRunMode) {
                                if (attrs.scopedataset) {
                                    handlers.push(scope.$watch('scopedataset', function (newVal) {
                                        scope.eventSources.push(newVal);
                                    }, true));
                                }
                                // find the isolateScope of the ui-calendar element
                                uiCalScope = element.children().first().isolateScope();
                                // define the redraw method. Accordion/tabs will trigger this
                                scope.redraw = _.debounce(function () {
                                    // destroy the calendar and re-initialize
                                    uiCalScope.destroy();
                                    uiCalScope.init();
                                }, 50);
                            }

                            scope.$on('$destroy', function () {
                                handlers.forEach(Utils.triggerFn);
                            });

                            scope.redraw = function () {
                                element.children().first().fullCalendar('render');
                            };
                            /* register the property change handler */
                            WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, scope), scope, notifyFor);

                            WidgetUtilService.postWidgetCreate(scope, element, attrs);
                        }
                    };
                }
            };
        }
    ]);


/**
 * @ngdoc directive
 * @name wm.widgets.advanced.directive:wmCalendar
 * @restrict E
 *
 * @description
 * The directive defines a calendar widget.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires $filter
 * @requires WidgetUtilService
 * @requires $timeout
 *
 * @param {string=} name
 *                  Name of the calendar widget.
 * @param {string=} placeholder
 *                  Placeholder for the Calendar widget.
 * @param {string=} hint
 *                  Title/hint for the date <br>
 *                  This property is bindable.
 * @param {number=} tabindex
 *                  This property specifies the tab order of Calendar widget. <br>
 *                  Default value : 0
 * @param {string=} scopedatavalue
 *                  This property accepts the initial value for the Calendar widget from a variable defined in the script workspace. <br>
 * @param {string=} currentview
 *                  This property has two sub properties start and end. <br>
 *                  start is the first date in the calendar view.
 *                  end is the last date in the calendar view
 *                  This property is bindable
 * @param {string=} selecteddates
 *                  This property has two sub properties start and end. <br>
 *                  start is the first date in the selected dates.
 *                  end is the last date in selectd dates.
 *                  This property is bindable
 * @param {boolean=} show
 *                  Show is a bindable property. <br>
 *                  This property will be used to show/hide the widget on the web page. <br>
 *                  Default value: `true`.
 * @param {string=} calendartype
 *                  This property specifies the type of the calendar widget. <br>
 *                  Possible Values: `basic`, `agenda` <br>
 *                  Default value: `basic`.
 * @param {string=} controls
 *                  This property specifies the controls to be shown on the calendar widget calendar widget. <br>
 *                  Accepts string in CSV format. <br>
 *                  Possible Values: `navigation`, `today`, `month`, `week`, `day` <br>
 *                  By default all these controls will be shown.
 * @param {string=} view
 *                  This property specifies defaultView of the calendar widget. <br>
 *                  Possible Values: `month`, `week`, `day` <br>
 *                  Default value: `month`.
 * @param {string=} on-select
 *                  Callback function which will be triggered when multiple dates are selected. The callback comes with following parameters: <br>
 *                  start: date object for start date <br>
 *                  end: date object for end date <br>
 *                  view: consisting all the properties related to current view of a calendar.
 * @param {string=} on-viewrender
 *                  Callback function which will be triggered when calendar view is changed. The callback comes with following parameter: <br>
 *                  view: consisting all the properties related to current view of a calendar.
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
                <div>Selected Date: {{currentDate | date:'medium'}}</div><br>
                    <wm-calendar name="calendar1"
                        on-change="f($event, $scope)"
                        placeholder="{{placeholder}}"
                        datepattern="{{datepattern}}">
                    </wm-calendar><br>
            </div>
        </file>
        <file name="script.js">
            function Ctrl($scope) {
                $scope.placeholder="Select a date";
                $scope.f = function (event, scope) {
                    $scope.currentDate = scope.datavalue;
                }
                $scope.events = [
                    {
                        "title": "All Day Event",
                        "start": "Fri May 06 2015 00:00:00 GMT+0530 (India Standard Time)"
                    },
                    {
                        "title": "Long Event",
                        "start": "Fri May 04 2015 00:00:00 GMT+0530 (India Standard Time)",
                        "end": "Fri May 21 2015 00:00:00 GMT+0530 (India Standard Time)"
                    },
                    {
                        "id": 999,
                        "title": "Repeating Event",
                        "start": "Fri May 01 2015 00:00:00 GMT+0530 (India Standard Time)",
                        "allDay": false
                    },
                    {
                        "id": 999,
                        "title": "Repeating Event",
                        "start": "Fri May 01 2015 00:00:00 GMT+0530 (India Standard Time)",
                        "allDay": false
                    },
                    {
                        "title": "Birthday Party",
                        "start": "Fri May 06 2015 00:00:00 GMT+0530 (India Standard Time)",
                        "end": "Fri May 09 2015 00:00:00 GMT+0530 (India Standard Time)",
                        "allDay": false
                    },
                    {
                        "title": "Click for Google",
                        "start": "Fri May 23 2015 00:00:00 GMT+0530 (India Standard Time)",
                        "end": "Fri May 24 2015 00:00:00 GMT+0530 (India Standard Time)",
                        "url": "http://google.com/"
                    }
                ]
            }
        </file>
    </example>
 */

/*global WM, window*/
/*jslint sub: true*/
/*Directive for login-from */

WM.module("wm.widgets.advanced")
    .run(['$templateCache', function ($templateCache) {
        "use strict";
        $templateCache.put("template/widget/advanced/login.html",
            '<div init-widget class="app-login" data-ng-show="show" apply-styles="container">' +
                '<wm-message scopedataset="loginMessage" class="app-login-message"></wm-message>' +
                '<form autocomplete="off" class="app-form app-login-form" method="post" wmtransclude>' +
                '</form>' +
            '</div>');

    }]).directive('wmLogin', ['PropertiesFactory', '$rootScope', '$templateCache', 'WidgetUtilService', 'CONSTANTS', '$controller', function (PropertiesFactory, $rootScope, $templateCache, WidgetUtilService, CONSTANTS, $controller) {
        "use strict";
        var widgetProps = PropertiesFactory.getPropertiesOf("wm.login", ["wm.base", "wm.base.editors", "wm.base.events.successerror"]);

        return {
            'restrict': 'E',
            'replace': true,
            'scope': {
                'onSuccess': '&',
                'onError': '&'
            },
            transclude: true,
            'template': $templateCache.get("template/widget/advanced/login.html"),
            'compile': function (tElement, tAttr) {

                /* in run mode there is separate controller for login widget but not in studio mode,
                 * to prevent errors in studio mode create and empty function
                 * with particular controller name */
                if (CONSTANTS.isStudioMode) {
                    window[tAttr.name + "Controller"] = WM.noop;
                }

                return {
                    'pre': function (scope) {
                        scope.widgetProps = widgetProps;
                    },
                    'post': function (scope, element, attrs) {
                        if (CONSTANTS.isRunMode) {
                            var loginController;
                            /*
                             * Extend the properties from the login controller exposed to end user in page script
                             * Kept in try/catch as the controller may not be available sometimes
                             */
                            try {
                                loginController = scope.name + "Controller";
                                $controller(loginController, {$scope: element.scope()});
                            } catch (ignore) {
                            }
                            /* submit button click-handler */
                            element.find('.app-login-button').unbind('click');

                            /* when on-submit not defined, then call the app-login service, else call custom service*/
                            element.find('.app-login-button').click(function (event) {
                                var loginDetails,
                                    successFn = attrs.onSuccess || '',
                                    errorFn = attrs.onError || '',
                                    submitFn = attrs.onSubmit || '',
                                    clickFn = WM.element(this).isolateScope().onClick || '',
                                    onSuccess = function () {
                                        element.trigger("success");
                                        if (successFn.indexOf('(') !== -1) {
                                            scope.onSuccess({$event: event, $scope: scope});
                                        } else {
                                            $rootScope.$emit('invoke-service', successFn, {scope: element.scope()});
                                        }
                                    },
                                    onError = function (error) {
                                        scope.loginMessage = {
                                            type: 'error',
                                            caption: scope.errormessage || error || $rootScope.appLocale['LABEL_INVALID_USERNAME_OR_PASSWORD']
                                        };
                                        element.trigger("error");
                                        if (errorFn.indexOf('(') !== -1) {
                                            scope.onError({$event: event, $scope: scope});
                                        } else {
                                            $rootScope.$emit('invoke-service', errorFn, {scope: element.scope()});
                                        }
                                    };
                                scope.loginMessage = null;
                                /* when on-submit not defined, then call the app-login service, else call custom service*/
                                if (!submitFn && !clickFn) {
                                    loginDetails = {
                                        username: element.find('[name="usernametext"]').val(),
                                        password: element.find('[name="passwordtext"]').val()
                                    };
                                    element.scope().Variables.loginVariable.login({loginInfo: loginDetails}, onSuccess, onError);
                                } else {
                                    if (clickFn) {
                                        clickFn({$event: event, $scope: scope});
                                    }
                                    if (submitFn.indexOf('(') !== -1) {
                                        scope.onSubmit({$event: event, $scope: scope});
                                    } else {
                                        $rootScope.$emit('invoke-service', submitFn, {scope: element.scope()}, onSuccess, onError);
                                    }
                                }
                            });
                        }

                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.widgets.advanced.directive:wmLogin
 * @restrict E
 *
 * @description
 * The `wmLogin` directive defines the loginForm widget.
 * It can be dragged and moved in the canvas.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires $rootScope
 * @requires $templateCache
 * @requires WidgetUtilService

 * @param {string=}  name
 *                   Name of the login widget.
 * @param {string=} width
 *                  Width of the login widget.
 * @param {string=} height
 *                  Height of the login widget.
 * @param {boolean=} show
 *                   Show is a bindable property. <br>
 *                   This property will be used to show/hide the login widget on the web page. <br>
 *                   Default value: `true`. <br>
 * @param {string=}  errormessage
 *                   string containing the error-message.
 * @param {string=}  on-success
 *                   Callback function for `success` event.
 * @param {string=}  on-error
 *                   Callback function for `error` event.
 * @param {string=}  on-submit
 *                   Callback function for `submit` event.
 *
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div class="wm-app" data-ng-controller="Ctrl">
                <wm-panel>
                    <wm-login>
                        <wm-composite>
                            <wm-label caption="Username"></wm-label>
                            <wm-text placeholder="Enter username" class="app-login-username"></wm-text>
                        </wm-composite>
                        <wm-composite widget="text">
                            <wm-label caption="Password"></wm-label>
                            <wm-text type="password" placeholder="Enter password" class="app-login-password"></wm-text>
                        </wm-composite>
                        <wm-container>
                            <wm-container textalign="right">
                                <wm-button type="submit" caption="Sign in" class="app-login-button btn-primary"></wm-button>
                            </wm-container>
                            <wm-composite widget="checkbox">
                                <wm-checkbox class="app-login-rememberme col-md-7" scopedatavalue="user.rememberMe" caption="Remember Me"></wm-checkbox>
                                <wm-anchor caption="Forgot Password" class="app-login-forgotlink col-md-5"></wm-anchor>
                            </wm-composite>
                        </wm-container>
                    </wm-login>
                </wm-panel>
            </div>
        </file>
        <file name="script.js">
            function Ctrl($scope) {}
        </file>
    </example>
 */
/*global WM,_ */
/*jslint todo: true */
/*Directive for carousel */
WM.module('wm.widgets.advanced')
    .run(['$templateCache', function ($tc) {
        'use strict';
        $tc.put('template/widget/advanced/carousel/static/carousel.html',
                '<div init-widget class="app-carousel carousel slide" data-ng-show="show" apply-styles>' +
                    '<ol class="carousel-indicators">' +
                        '<li data-ng-repeat="content in contents" data-ng-class="{\'active\': activeIndex === $index}" data-ng-click="goTo($index)"></li>' +
                    '</ol>' +
                    '<div class="carousel-inner" wmtransclude></div>' +
                    '<a class="left carousel-control" data-ng-click="previous()">' +
                        '<i class="glyphicon glyphicon-chevron-left"></i>' +
                    '</a>' +
                    '<a class="right carousel-control" data-ng-click="next()">' +
                        '<i class="glyphicon glyphicon-chevron-right"></i>' +
                    '</a>' +
                '</div>'
            );
        $tc.put('template/widget/advanced/carousel/design/dynamic/carousel.html',
            '<div apply-styles init-widget class="app-carousel carousel slide" data-ng-show="show" wmtransclude></div>'
            );

        $tc.put('template/widget/advanced/carousel/design/static/carousel.html',
                 '<div init-widget class="app-carousel carousel slide" data-ng-show="show" apply-styles>' +
                     '<div class="carousel-inner" wmtransclude></div>' +
                     '<div class="carousel-actions">' +
                        '<ul class="pagination" >' +
                            '<li data-ng-repeat="content in contents" data-ng-class="{\'active\': activeIndex === $index}"">' +
                                '<a href="javascript:void(0);" data-ng-click="goTo($index)">{{$index + 1}}</a>' +
                            '</li>' +
                        '</ul>' +
                     '</div>' +
                 '</div>'
            );

        $tc.put('template/widget/advanced/carousel/dynamic/carousel.html',
            '<div class="app-carousel" init-widget wmtransclude apply-styles data-identifier="carousel"></div>'
            );

        $tc.put('template/widget/advanced/carousel/carousel-content.html',
            '<div class="app-carousel-item item" apply-styles init-widget wmtransclude></div>'
            );

    }])
    .directive('wmCarousel', [
        '$interval',
        'PropertiesFactory',
        '$templateCache',
        'CONSTANTS',
        '$timeout',
        'WidgetUtilService',
        '$compile',
        'Utils',

        function ($interval, PropertiesFactory, $templateCache, CONSTANTS, $timeout, WidgetUtilService, $compile, Utils) {
            'use strict';

            var widgetProps,
                directiveDefn,
                notifyFor,
                slideTemplateWrapper,
                CAROUSEL_TYPE = {'STATIC': 'static', 'DYNAMIC': 'dynamic'};

            widgetProps = PropertiesFactory.getPropertiesOf('wm.carousel', ['wm.base', 'wm.containers']);
            notifyFor   = {
                'dataset' : true,
                'type'    : true
            };

            slideTemplateWrapper =
                '<uib-carousel interval="interval" active="active" no-wrap="noWrapSlides"> ' +
                    '<uib-slide ng-repeat="item in fieldDefs track by $index"  index="$index"></uib-slide>' +
                '</uib-carousel>';

            function updateFieldDefs($is, data) {
                $is.fieldDefs = data;
            }

            function getVariable($is, variableName) {

                if (!variableName) {
                    return undefined;
                }

                var variables = $is.Variables || {};
                return variables[variableName];
            }

            function onDataChange($is, nv) {
                if (nv) {
                    if (nv.data) {
                        nv = nv.data;
                    } else {
                        if (!_.includes($is.binddataset, 'bind:Widgets.')) {
                            var boundVariableName = Utils.getVariableName($is),
                                variable = getVariable($is, boundVariableName);
                            // data from the live list must have .data filed
                            if (variable && variable.category === 'wm.LiveVariable') {
                                return;
                            }
                        }
                    }

                    //If the data is a pageable object, then display the content.
                    if (WM.isObject(nv) && Utils.isPageable(nv)) {
                        nv = nv.content;
                    }

                    if (WM.isObject(nv) && !WM.isArray(nv)) {
                        nv = [nv];
                    }
                    if (!$is.binddataset) {
                        if (WM.isString(nv)) {
                            nv = nv.split(',');
                        }
                    }
                    if (WM.isArray(nv)) {
                        updateFieldDefs($is, nv);
                    }
                } else {
                    if (CONSTANTS.isRunMode) {
                        updateFieldDefs($is, []);
                    }
                }
            }


            function propertyChangeHandler($is, attrs, key, newVal) {
                var widgetProperties = $is.widgetProps;

                switch (key) {
                case 'dataset':
                    if (attrs.type === CAROUSEL_TYPE.DYNAMIC) {
                        onDataChange($is, newVal);
                    }
                    break;
                case 'type':
                    if ($is.widgetid) {
                        widgetProperties.addchild.show = newVal !== CAROUSEL_TYPE.DYNAMIC;
                        widgetProperties.dataset.show  = newVal === CAROUSEL_TYPE.DYNAMIC;
                    }
                    break;
                }
            }

            function applyWrapper($tmplContent) {
                var $tmpl = WM.element(slideTemplateWrapper);
                $tmpl.children().first().append($tmplContent);
                return $tmpl;
            }

            function prepareSlideTemplate(tmpl, attrs) {
                var $tmpl = WM.element(tmpl),
                    $div  = WM.element('<div></div>'),
                    parentDataSet = attrs.dataset || attrs.scopedataset;

                $tmpl = $div.append($tmpl);
                if (parentDataSet) {
                    Utils.updateTmplAttrs($tmpl, parentDataSet);
                }
                $tmpl = applyWrapper($tmpl, attrs);
                return $tmpl;
            }

            //this function decides which template should be set based on the condition.
            function templateFn($el, attrs) {
                // if type attribute is set then dynamic carousel template is used.
                if (attrs.type) {
                    return $templateCache.get('template/widget/advanced/carousel' + (CONSTANTS.isStudioMode ? '/design/dynamic/' : '/dynamic/') + 'carousel.html');
                }
                return $templateCache.get('template/widget/advanced/carousel' + (CONSTANTS.isStudioMode ? '/design/static/' : '/static/') + 'carousel.html');
            }

            directiveDefn = {
                'restrict'  : 'E',
                'scope'     : {},
                'transclude': true,
                'template'  : templateFn,
                'replace'   : true,
                'controller': function ($scope) {
                    var _map = {};
                    // this keeps a copy of carousel-template
                    this.$set = function (key, value) {
                        _map[key] = value;
                    };
                    // this gets a template based on the key.
                    this.$get = function (key) {
                        return _map[key];
                    };
                    this.register = function (contentScope) {
                        // check for the first index of the slide deck and class active
                        if (!$scope.contents.length) {
                            contentScope.getElement().addClass('active');
                        }

                        $scope.contents.push(contentScope);
                        //In studio mode the last slide is selected after add
                        if ($scope.widgetid) {
                            $scope.last();
                        }
                    };
                    this.unregister = function (contentScope) {
                        var i, len = $scope.contents.length;
                        for (i = 0; i < len; i++) {
                            if ($scope.contents[i].$id === contentScope.$id) {
                                break;
                            }
                        }
                        $scope.contents.splice(i, 1);
                        $scope.goTo($scope.activeIndex);
                    };
                },
                'link' : {
                    'pre': function ($is, $el, attrs) {
                        //Animation function to move the slides
                        function animateSlide($active, $next, type) {
                            var direction = type === 'next' ? 'left' : 'right';
                            $next.addClass(type);
                            $next[0].offsetWidth; // force reflow
                            $active.addClass(direction);
                            $next.addClass(direction);
                            $timeout(function () {
                                $next.removeClass([type, direction].join(' ')).addClass('active');
                                $active.removeClass(['active', direction].join(' '));
                            }, 600, false);
                        }
                        if (!attrs.type) {
                            $is.widgetProps = widgetProps;
                            $is.contents    = [];
                            $is.activeIndex = 0;

                            //function for slide  to move to a specific slide index
                            $is.goTo = function (index) {
                                if (!$is.contents[$is.activeIndex] || $is.activeIndex === index) {
                                    return;
                                }
                                var oldElement = $is.contents[$is.activeIndex].getElement(),
                                    newElement = $is.contents[index].getElement(),
                                    type = 'next';

                                if ($is.widgetid) {
                                    oldElement.removeClass('active');
                                    newElement.addClass('active');
                                    $is.activeIndex  = index;
                                } else {
                                    $is.stop();
                                    if ($is.activeIndex > index) {
                                        type = 'prev';
                                    }
                                    animateSlide(oldElement, newElement, type);
                                    $is.activeIndex  = index;
                                    $is.play();
                                }
                            };

                            //function to move to next slide
                            $is.next = function () {
                                if ($is.activeIndex > $is.contents.length - 2) {
                                    $is.goTo(0);
                                } else {
                                    $is.goTo($is.activeIndex + 1);
                                }
                            };

                            //function to move to previous slide
                            $is.previous = function () {
                                if ($is.activeIndex < 1) {
                                    $is.goTo($is.contents.length - 1);
                                } else {
                                    $is.goTo($is.activeIndex - 1);
                                }
                            };

                            //function to move to first slide
                            $is.first = function () {
                                $is.goTo(0);
                            };

                            //function to move to last slide
                            $is.last = function () {
                                $is.goTo($is.contents.length - 1);
                            };

                            //define play and stop methods
                            if (CONSTANTS.isRunMode) {
                                //function to play the slides
                                $is.play = function () {
                                    if (!$is.autoPlay && $is.animationinterval >= 1) {
                                        $is.autoPlay = $interval(function () {
                                            $is.next();
                                        }, $is.animationinterval * 1000);
                                    }
                                };

                                //function to stop the slides
                                $is.stop = function () {
                                    if ($is.autoPlay) {
                                        $interval.cancel($is.autoPlay);
                                    }
                                    $is.autoPlay = undefined;
                                };
                            }
                        } else {
                            $is.widgetProps = attrs.widgetid ? Utils.getClonedObject(widgetProps) : widgetProps;
                        }
                    },
                    'post': function ($is, $el, attrs, listCtrl) {
                        var $s = $el.scope(),
                            $slideTemplate;

                        $is.interval = $is.animationinterval * 1000;
                        Object.defineProperties($is, {
                            'Variables': {
                                get: function () {
                                    return $s.Variables;
                                }
                            },
                            'Widgets': {
                                get: function () {
                                    return $s.Widgets;
                                }
                            }
                        });
                        if (CONSTANTS.isRunMode) {
                            if (!attrs.type) {
                                $is.play();
                            } else {
                                $slideTemplate = prepareSlideTemplate(listCtrl.$get('carouselTemplate'), attrs);
                                $el.prepend($slideTemplate);
                                $compile($slideTemplate)($el.closest('[data-identifier="carousel"]').isolateScope());
                            }
                        }
                        WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, $is, attrs), $is, notifyFor);
                        WidgetUtilService.postWidgetCreate($is, $el, attrs);
                    }
                }
            };

            return directiveDefn;
        }
    ])
    .directive('wmCarouselContent', [
        'PropertiesFactory',
        '$templateCache',
        'WidgetUtilService',

        function (PropertiesFactory, $templateCache, WidgetUtilService) {
            'use strict';

            var widgetProps = PropertiesFactory.getPropertiesOf('wm.carouselcontent', ['wm.base', 'wm.layouts']);
            return {
                'restrict'  : 'E',
                'scope'     : {},
                'transclude': true,
                'template'  : $templateCache.get('template/widget/advanced/carousel/carousel-content.html'),
                'replace'   : true,
                'require'   : '^wmCarousel',
                'compile'   : function () {
                    return {
                        'pre': function ($is) {
                            $is.widgetProps = widgetProps;
                        },
                        'post': function ($is, $el, attrs, controller) {
                            $is.getElement = function () {
                                return $el;
                            };
                            $is.$on('$destroy', function () {
                                controller.unregister($is);
                            });
                            controller.register($is);
                            WidgetUtilService.postWidgetCreate($is, $el, attrs);
                        }
                    };
                }
            };
        }
    ])
    .directive('wmCarouselTemplate', [
        'PropertiesFactory',
        '$templateCache',
        'WidgetUtilService',
        'CONSTANTS',

        function (PropertiesFactory, $templateCache, WidgetUtilService, CONSTANTS) {
            'use strict';
            var widgetProps = PropertiesFactory.getPropertiesOf('wm.carouselcontent', ['wm.base', 'wm.layouts']),
                directiveDefn;

            function preLinkFn($is) {
                $is.widgetProps = widgetProps;
            }

            function studioMode_postLinkFn($is, $el, attrs) {
                WidgetUtilService.postWidgetCreate($is, $el, attrs);
            }

            function runMode_preLinkFn($is, $el, attrs, listCtrl) {
                listCtrl.$set('carouselTemplate', $el.children());
                $el.remove();
            }

            directiveDefn = {
                'restrict' : 'E',
                'replace'   : true
            };

            if (CONSTANTS.isStudioMode) {
                WM.extend(directiveDefn, {
                    'transclude': true,
                    'scope'     : {},
                    'template'  : $templateCache.get('template/widget/advanced/carousel/carousel-content.html'),
                    'link'      : {
                        'pre' : preLinkFn,
                        'post': studioMode_postLinkFn
                    }
                });
            } else {
                WM.extend(directiveDefn, {
                    'scope'     : {},
                    'terminal'  : true,
                    'require'   : '^wmCarousel',
                    'link'      : {
                        'pre' : runMode_preLinkFn
                    }
                });
            }

            return directiveDefn;
        }
    ]);

/**
 * @ngdoc directive
 * @name wm.widgets.advanced.directive:wmCarousel
 * @restrict E
 *
 * @description
 * The `wmCarousel` directive defines wm-carousel widget.
 *
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires $templateCache
 * @requires CONSTANTS
 * @requires $timeout
 * @requires WidgetUtilService
 * @requires $compile
 * @requires Utils
 *
 *
 * @param {string=} name
 *                  Name of the carousel.
 * @param {string=} width
 *                  Width of the carousel widget.
 * @param {string=} height
 *                  Height of the carousel widget.
 * @param {boolean=} show
 *                  Show is a bindable property. <br>
 *                  This property will be used to show/hide the carousel on the web page. <br>
 *                  Default value: `true`.
 * @param {number=} animationinterval
 *                  Defines the time interval (in seconds) between two slide transitions.  <br>
 *                  Default value: `3`.
 *
 * @param {string=} dataset
 *                  Sets the data for the list.<br>
 *                  This is a bindable property.<br>
 *                  When bound to a variable, the data associated with the variable is displayed in the list.
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
                <wm-carousel animationinterval="5" height="100%">
                    <wm-carousel-content>
                        <wm-picture width="100%" name="picture3" picturesource="https://farm8.staticflickr.com/7555/16037316110_f0bef69033_z.jpg"></wm-picture>
                    </wm-carousel-content>
                    <wm-carousel-content>
                        <wm-picture width="100%" name="picture5" picturesource="https://farm6.staticflickr.com/5002/5237179864_552d6098f5_z_d.jpg"></wm-picture>
                    </wm-carousel-content>
                    <wm-carousel-content>
                        <wm-picture name="picture6" width="100%" picturesource="https://farm4.staticflickr.com/3024/3103220799_16f3b1db98_z_d.jpg"></wm-picture>
                    </wm-carousel-content>
                </wm-carousel>
            </div>
        </file>
        <file name="script.js">
            function Ctrl($scope) {
                $scope.demo = true;
            }
        </file>
    </example>
 */
/**
 * @ngdoc directive
 * @name wm.widgets.advanced.directive:wmCarouselContent
 * @restrict E
 *
 * @description
 * The `wmCarouselContent` directive defines wm-carousel-content widget.<br>
 * This widget has to be used with in wm-carousel.
 *
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires $templateCache
 * @requires CONSTANTS
 *
 * @param {string=} name
 *                  Name of the carousel content.
 * @param {boolean=} show
 *                  Show is a bindable property. <br>
 *                  This property will be used to show/hide the carousel on the web page. <br>
 *                  Default value: `true`.
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
                <wm-carousel animationinterval="5" height="100%">
                    <wm-carousel-content>
                        <wm-picture width="100%" name="picture3" picturesource="https://farm8.staticflickr.com/7555/16037316110_f0bef69033_z.jpg"></wm-picture>
                    </wm-carousel-content>
                    <wm-carousel-content>
                        <wm-picture width="100%" name="picture5" picturesource="https://farm6.staticflickr.com/5002/5237179864_552d6098f5_z_d.jpg"></wm-picture>
                    </wm-carousel-content>
                    <wm-carousel-content>
                        <wm-picture name="picture6" width="100%" picturesource="https://farm4.staticflickr.com/3024/3103220799_16f3b1db98_z_d.jpg"></wm-picture>
                    </wm-carousel-content>
                </wm-carousel>
            </div>
        </file>
        <file name="script.js">
            function Ctrl($scope) {
                $scope.demo = true;
            }
        </file>
    </example>
 */
/**
 * @ngdoc directive
 * @name wm.widgets.advanced.directive:wmCarouselContentTemplate
 * @restrict E
 *
 * @description
 * The `wmCarouselContentTemplate` directive defines wm-carousel-content-template widget.<br>
 * This widget has to be used with in wm-carousel.
 *
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires $templateCache
 * @requires CONSTANTS
 * @requires WidgetUtilService
 *
 * @param {string=} name
 *                  Name of the carousel content template.
 * @param {boolean=} show
 *                  Show is a bindable property. <br>
 *                  This property will be used to show/hide the carousel on the web page. <br>
 *                  Default value: `true`.
 * @example
    <example module="wmCore">
        <file name="index.html">
            <div data-ng-controller="Ctrl" class="wm-app">
                <wm-carousel animationinterval="5" height="100%">
                    <wm-carousel-content-template type='dynamic'>
                         <wm-picture width="100%" name="picture3" picturesource="https://farm8.staticflickr.com/7555/16037316110_f0bef69033_z.jpg"></wm-picture>
                    </wm-carousel-content-template>
                </wm-carousel>
            </div>
        </file>
        <file name="script.js">
            function Ctrl($scope) {
                $scope.demo = true;
            }
        </file>
     </example>
 */
/*global WM,  _ */
/*Directive for rating widget */

WM.module('wm.widgets.advanced')
    .run(['$templateCache', function ($templateCache) {
        'use strict';

        $templateCache.put('template/widget/advanced/rating.html',
            '<div data-ng-model="_model_" data-ng-show="show" class="app-ratings" init-widget has-model apply-styles role="input" data-ng-focus="onFocus($event)">' +
                '<div data-ng-if="!readonly" class="rating-style">' +
                    '<label data-ng-class="{active : rate.value <= datavalue}" for="{{$id}}+{{rate.value}}" data-ng-mouseleave="onMouseleave($event, rate)" data-ng-mouseover="onMouseover($event, rate)" data-ng-style="{\'font-size\':iconsize, \'color\': rate.value <= datavalue && iconcolor}" data-ng-repeat="rate in range track by $index" title="{{rate.label || rate.value}}">' +
                        '<input type="radio" id="{{$id}}+{{rate.value}}" data-ng-click="getActiveElements($event)" name="{{ratingname}}" value="{{rate.value}}"/>' +
                    '</label>' +
                '</div>' +
                '<div data-ng-if="readonly" data-ng-style="{\'font-size\':iconsize}" class="ratings-container disabled" >' +
                    '<div class="ratings active" data-ng-style="{width: ratingsWidth(), color: iconcolor}"></div>' +
                '</div>' +
            '<label data-ng-show="showcaptions" class="caption" data-ng-bind="caption"></label>' +
            '</div>'
            );
    }])
    .directive('wmRating', ['PropertiesFactory', 'WidgetUtilService', 'FormWidgetUtils', 'CONSTANTS', 'Utils', '$rootScope', function (PropertiesFactory, WidgetUtilService, FormWidgetUtils, CONSTANTS, Utils, $rs) {
        'use strict';

        var widgetProps = PropertiesFactory.getPropertiesOf('wm.rating', ['wm.base', 'wm.base.editors']),
            notifyFor = {
                'maxvalue': true,
                'readonly': true,
                'dataset' : true,
                'displayexpression' : true
            },
            DEFAULT_RATING = 5,
            MAX_RATING = 10;

        /*
         * parse dataSet to filter the options based on the datafield, displayfield & displayexpression
         */
        function parseDataSet(dataSet, scope) {
            /*store parsed data in 'data'*/
            var data = dataSet,
                dataField = scope.datafield,
                displayField = FormWidgetUtils.getDisplayField(dataSet, scope.displayfield || scope.datafield);

            /*if filter dataSet if dataField is selected other than 'All Fields'*/
            if (dataField) {
                data = {};
                //Widget selected item dataset will be object instead of array.
                if (WM.isObject(dataSet) && !WM.isArray(dataSet)) {
                    data[WidgetUtilService.getObjValueByKey(dataSet, dataField)] = WidgetUtilService.getEvaluatedData(scope, dataSet, {fieldName: 'displayfield', expressionName: 'displayexpression'}, displayField);
                } else {
                    _.forEach(dataSet, function (option) {
                        data[WidgetUtilService.getObjValueByKey(option, dataField)] = WidgetUtilService.getEvaluatedData(scope, option, {fieldName: 'displayfield', expressionName: 'displayexpression'}, displayField);
                    });
                }
            }
            return data;
        }

        /*
         * gets the key to map the select options out of dataSet
         * if only one key is there in the option object it returns that key
         * else the default key to be looked is 'dataValue'
         */
        function getKey(optionObject) {
            var keys = Object.keys(optionObject);
            /* if only one key, return it (can be anything other than 'dataValue' as well */
            if (keys.length === 1) {
                return keys[0];
            }

            /* return dataValue to be the default key */
            return 'dataValue';
        }

        /* gets the item whose value is equal to rating value */
        function getLabel(options, i) {
            return _.find(options, function (item) {
                return Math.round(parseInt(item.key, 10)) === i;
            });
        }

        /* returns the rating widget dataset containing the value and label */
        function prepareRatingDataset(maxvalue, options) {
            var i,
                range = [],
                maxValue,
                result;
            maxvalue = parseInt(maxvalue, 10);
            maxValue = maxvalue > MAX_RATING ? MAX_RATING : maxvalue;
            for (i = maxValue || DEFAULT_RATING; i > 0; i--) {
                result = getLabel(options, i);
                if (result) {
                    range.push({'value': i, 'label': result.value});
                } else {
                    range.push({'value': i});
                }
            }
            return range;
        }

        /*function to create the options for the rating widget, based on the different configurations that can be provided.
         Options can be provided as
         * 1. comma separated string, which is captured in the options property of the scope
         * 2. application scope variable which is assigned to the dataSet attribute of the rating widget from the studio.
         * 3. a wm-studio-variable which is bound to the widget's dataSet property.*/
        function createRatingOptions(dataset, scope) {
            /* check for dataSet*/
            if (!dataset) {
                return;
            }
            /*assign dataSet according to liveVariable or other variable*/
            dataset = dataset.hasOwnProperty('data') ? dataset.data : dataset;
            var key;
            /*checking if dataSet is present and it is not a string.*/
            if (dataset && dataset.dataValue !== '') {
                /*initializing select options*/
                scope.selectOptions = [];
                /*check if dataset is array*/
                if (WM.isArray(dataset)) {
                    /*filter the dataSet based on datafield & displayfield*/
                    dataset = parseDataSet(dataset, scope);
                    /* if dataSet is an array of objects, convert it to object */
                    if (WM.isObject(dataset[0])) {
                        key = getKey(dataset[0]);
                        /* if dataSet is an array, convert it to object */
                        _.forEach(dataset, function (option) {
                            scope.selectOptions.push({'key': key, 'value': option.name || option[key]});
                        });
                    } else if (WM.isArray(dataset)) {
                        /* if dataSet is an array, convert it to object */
                        _.forEach(dataset, function (option, index) {
                            scope.selectOptions.push({"key": index + 1, "value": option});
                        });
                    } else if (WM.isObject(dataset)) {
                        _.forEach(dataset, function (val, key) {
                            scope.selectOptions.push({"key": key, "value": val});
                        });
                    }
                } else if (WM.isObject(dataset)) {
                    /*filter the dataSet based on datafield & displayfield*/
                    dataset = parseDataSet(dataset, scope);
                    _.forEach(dataset, function (val, key) {
                        scope.selectOptions.push({"key": key, "value": val});
                    });
                } else {
                    /* if dataSet is an string, convert it to object */
                    if (WM.isString(dataset)) {
                        _.forEach(dataset.split(','), function (opt, index) {
                            opt = opt.trim();
                            scope.selectOptions.push({"key": index + 1, "value": opt});
                        });
                    } else {
                        scope.selectOptions.push({"key": dataset, "value": dataset});
                    }
                }
                scope.range = prepareRatingDataset(scope.maxvalue, scope.selectOptions);
                scope.caption = getCaption(scope);
            }
        }

        /* This function returns the caption for the hovered item or the selected datavalue */
        function getCaption(iScope, selecteditem) {
            var captionItem = _.find(iScope.range, function (item) {
                /* item value can be string / integer*/
                return item.value == (selecteditem ? selecteditem.value : Math.round(parseInt(iScope.datavalue, 10)));
            });
            if (captionItem && captionItem.hasOwnProperty('label')) {
                return captionItem.label;
            }
            if (!iScope.dataset && iScope.displayexpression) { /* set the caption as displayexpression value if there is no dataset bound */
                return iScope.displayexpression;
            }
            return '';
        }

        /* onMouseover of the rating widget */
        function onMouseover(iScope, attrs, evt, item) {
            /* support if the caption is binded in the old projects for backward compatibility*/
            if (!attrs.caption) {
                iScope.caption = getCaption(iScope, item);
            }
            /* apply iconcolor to the rating widget on hover */
            WM.element(evt.target).nextAll().andSelf().css('color', iScope.iconcolor);
        }

        /* onMouseleave of the rating widget */
        function onMouseout(iScope, attrs, $el) {
            /* support if the caption is binded in the old projects for backward compatibility*/
            if (!attrs.caption) {
                iScope.caption = getCaption(iScope);
            }
            /* apply iconcolor to the selected value of rating widget on mouseout*/
            $el.find('label').css('color', '');
            $el.find('label.active').css('color', iScope.iconcolor);
        }

        /* accessibility purpose - on focus of the widget, the up-arrow and down-arrow key press should change the datavalue */
        function onKeyDown(iScope, attrs, event) {
            var action = Utils.getActionFromKey(event);
            /*  if widget is focused and keydown is detected */
            if (iScope.isFocused) {
                if (!iScope.datavalue) {
                    iScope.datavalue = 0;
                }
                /* if up-arrow key is pressed then increase the rating value */
                if (action === 'UP-ARROW') {
                    $rs.$safeApply(iScope, function () {
                        if (iScope.datavalue < iScope.maxvalue) {
                            /* update the datavlue and caption accordingly */
                            iScope.datavalue = iScope.datavalue + 1;
                            /* support if the caption is binded in the old projects for backward compatibility*/
                            if (!attrs.caption) {
                                iScope.caption = getCaption(iScope);
                            }
                        }
                    });
                } else if (action === 'DOWN-ARROW') {  /* if down-arrow key is pressed then decrease the rating value */
                    $rs.$safeApply(iScope, function () {
                        if (iScope.datavalue > 0) {
                            /* update the datavlue and caption accordingly */
                            iScope.datavalue = iScope.datavalue - 1;
                            /* support if the caption is binded in the old projects for backward compatibility*/
                            if (!attrs.caption) {
                                iScope.caption = getCaption(iScope);
                            }
                        }
                    });
                }
            }
        }

        /* function which will be triggered on change of scopedataset */
        function scopeDatasetWatcher(scope, element) {
            /*if studio-mode, then update the displayField & dataField in property panel*/
            if (scope.widgetid) {
                FormWidgetUtils.updatePropertyPanelOptions(scope.scopedataset, scope, false);
            }
            createRatingOptions(scope.scopedataset, scope, element);
        }


        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
        function propertyChangeHandler(scope, attrs, key, newVal) {
            switch (key) {
            case 'dataset':
                if (CONSTANTS.isStudioMode && WM.isDefined(newVal) && newVal !== null) {
                    FormWidgetUtils.updatePropertyPanelOptions(newVal.data || newVal, newVal.propertiesMap, scope, false);
                }
                /*if studio-mode, then update the displayField & dataField in property panel*/
                if (WM.isDefined(newVal) && newVal !== null) {
                    //Get variable and properties map only on binddataset change
                    createRatingOptions(scope.dataset, scope);
                }

                break;
            case 'maxvalue':
                if (!scope.dataset) {
                    scope.range = prepareRatingDataset(newVal);
                    /* support if the caption is binded in the old projects for backward compatibility*/
                    if (!attrs.caption) {
                        scope.caption = getCaption(scope);
                    }
                }
                scope.ratingname = 'ratings-' + scope.$id;
                break;
            case 'displayexpression':
                if (!scope.dataset) {
                    scope.caption = newVal;
                }
                break;
            }
        }

        return {
            'restrict': 'E',
            'replace': true,
            'scope': {
                'scopedataset': '=?'
            },
            'template': WidgetUtilService.getPreparedTemplate.bind(undefined, 'template/widget/advanced/rating.html'),
            'compile': function () {
                return {
                    'pre': function (scope) {
                        /*Applying widget properties to directive scope*/
                        scope.widgetProps = widgetProps;

                        /*  flag to set if the rating widget is focused or not */
                        scope.isFocused = false;

                    },
                    'post': function (iScope, $el, attrs) {
                        if (WM.isString(iScope.datavalue)) {
                            iScope.datavalue = parseInt(iScope.datavalue, 10);
                        }

                        /* this function sets the caption */
                        /* support if the caption is binded in the old projects for backward compatibility*/
                        if (!attrs.caption) {
                            iScope.caption = getCaption(iScope);
                        }

                        /*  onMouseover of the rating widget apply the iconcolor  */
                        iScope.onMouseover = onMouseover.bind(undefined, iScope, attrs);

                        /* This function is called onMouseleave of the rating widget */
                        iScope.onMouseleave = onMouseout.bind(undefined, iScope, attrs, $el);

                        /* fields defined in scope: {} MUST be watched explicitly */
                        /*watching scopedataset attribute to create options for the select element.*/
                        if (!attrs.widgetid) {
                            iScope.$watch('scopedataset', scopeDatasetWatcher.bind(undefined, iScope, $el));
                        }

                        /*  This function is called when the rating widget is focused  */
                        iScope.onFocus = function () {
                            iScope.isFocused = true;
                        };

                        /* keydown events for accessibility  */
                        $el.bind('keydown', onKeyDown.bind(undefined, iScope, attrs));

                        iScope.getActiveElements = function ($event) {
                            iScope._model_ = $el.find(':checked').val();
                            /* support if the caption is binded in the old projects for backward compatibility*/
                            if (!attrs.caption) {
                                iScope.caption = getCaption(iScope);
                            }
                            iScope._onChange($event);
                        };

                        /* get the ratingsWidth for readonly mode */
                        iScope.ratingsWidth = function () {
                            var dataValue = parseFloat(iScope.datavalue),
                                starWidth = 0.925,
                                maxValue = parseInt(iScope.maxvalue, 10) || DEFAULT_RATING;
                            $el.find('.ratings-container').css("width", (starWidth * maxValue) + 'em');
                            if (iScope.datavalue === undefined || iScope.datavalue === '' || iScope.datavalue === null) {
                                return 0;
                            }
                            if (dataValue <= maxValue && dataValue >= 0) {
                                return dataValue * starWidth + 'em';
                            }
                            if (dataValue > maxValue) {
                                return maxValue * starWidth + 'em';
                            }
                        };

                        /*Called from form reset when users clicks on form reset*/
                        iScope.reset = function () {
                            iScope.datavalue = '';
                        };

                        WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, iScope, attrs), iScope, notifyFor);
                        WidgetUtilService.postWidgetCreate(iScope, $el, attrs);

                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.widgets.form.directive:wmRating
 * @restrict E
 *
 * @description
 * The `wmRating` directive defines the rating widget.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 *
 * @param {string=} caption
 *                  This property specifies the label of the rating. <br>
 *                  This property is bindable.
 * @param {string=} name
 *                  Name of the rating widget.
 * @param {boolean=} show
 *                  Show is a bindable property. <br>
 *                  This property will be used to show/hide the button widget on the web page. <br>
 *                  Default value: `true`. <br>
 * @param {string=} scopedatavalue
 *                  This property accepts the initial value for the rating widget from a variable defined in the script workspace. <br>
 * @param {string=} datavalue
 *                  This property defines the initial selected value of the rating widget.
 * @param {string=} dataset
 *                  This property accepts the options to create the rating widget from a wavemaker studio variable which is of datatype entry.
 * @param {string=} datafield
 *                  This property sets the dataValue to be returned by the rating widget when the data is populated using the dataSet property.
 * @param {string=} displayfield
 *                  This property sets the caption to show in the rating widget when the data is populated using the dataSet property.
 * @param {expression=} displayexpression
 *                      This is an advanced property that gives more control over what is displayed in the  rating widget's caption. <br>
 *                      A Display Expression uses a Javascript expression to format exactly what is shown. <br>
 *                      This property is bindable. <br>
 *                      For readonly mode, If dataset is null then the caption can be bound directly to display expression.
 * @param {boolean=} disabled
 *                  Disabled is a bindable property. <br>
 *                  This property will be used to disable/enable the button widget on the web page. <br>
 *                  Default value: `false`. <br>
 * @param {string=} showcaptions
 *                  This property will show the captions for the widget if set to true. Default value is true.
 * @param {string=} on-click
 *                  Callback function which will be triggered when the widget is clicked.
 * @example
 *   <example module="wmCore">
 *       <file name="index.html">
 *           <div data-ng-controller="Ctrl" class="wm-app">
 *               <wm-rating
 *                   caption="{{caption}}"
 *                   on-click="f('click');"
 *                   datavalue="{{datavalue}}"
 *                   maxvalue="{{maxvalue}}"
 *                   datafield="{{datafield}}"
 *                   displayfield="{{displayfield}}"
 *                   scopedataset="data"
 *                   >
 *               </wm-rating><br>
 *                   <br>
 *               <wm-composite>
 *                    <wm-label caption="scopedataset:"></wm-label>
                    <label>{{data}}</label>
                </wm-composite>
                 <wm-composite>
                     <wm-label caption="datafield:"></wm-label>
                     <wm-text readonly="true"
                     scopedatavalue="datafield">
                     </wm-text>
                 </wm-composite>
                 <wm-composite>
                     <wm-label caption="displayfield:"></wm-label>
                     <wm-text readonly="true"
                     scopedatavalue="displayfield">
                     </wm-text>
                 </wm-composite>
 *           </div>
 *       </file>
 *       <file name="script.js">
 *          function Ctrl($scope) {
 *              $scope.maxvalue = 5;
 *              $scope.datavalue = 2;
 *              $scope.data = [
                        {
                          "label": "good",
                          "value": "1"
                        },
                        {
                          "label": "vgood",
                          "value": "2"
                        },
                        {
                          "label": "awesome",
                          "value": "3"
                        },
                        {
                          "label": "excellent",
                          "value": "4"
                        },
                        {
                          "label": "outstanding",
                          "value": "5"
                        }
                        ];
                $scope.datafield =  "value";
                $scope.displayfield = "label";
 *              $scope.f = function (eventtype) {
 *                  $scope[eventtype + 'Count']++;
 *              }
 *           }
 *       </file>
 *   </example>
 */

/*global WM, */
/*Directive for Marquee */

WM.module('wm.widgets.advanced')
    .run(['$templateCache', 'CONSTANTS', function ($tc, CONSTANTS) {
        'use strict';
        var template;
        if (CONSTANTS.isStudioMode) {
            template = '<div class="app-marquee app-container" ng-show="show" title="{{hint}}" init-widget apply-styles wmtransclude></div>';
        } else {
            template = '<marquee class="app-marquee app-container" ng-show="show" title="{{hint}}" init-widget apply-styles wmtransclude onmouseover="this.stop();" onmouseout="this.start();"></marquee>';
        }
        $tc.put('template/widget/advanced/marquee/marquee.html', template);
    }])
    .directive('wmMarquee', [
        'PropertiesFactory',
        '$templateCache',
        'WidgetUtilService',

        function (PropertiesFactory, $tc, WidgetUtilService) {
            'use strict';
            var widgetProps = PropertiesFactory.getPropertiesOf('wm.marquee', ['wm.base', 'wm.base.editors', 'wm.containers']);

            return {
                'restrict'  : 'E',
                'scope'     : {},
                'transclude': true,
                'replace'   : true,
                'template'  : $tc.get('template/widget/advanced/marquee/marquee.html'),
                'link': {
                    'pre': function ($is) {
                        $is.widgetProps = widgetProps;
                    },
                    'post': function ($is, $el, attrs) {
                        WidgetUtilService.postWidgetCreate($is, $el, attrs);
                    }
                }
            };
        }]);

/**
 * @ngdoc directive
 * @name wm.widgets.advanced.directive:wmMarquee
 * @restrict E
 *
 * @description
 * The `wmMarquee` directive defines the marquee widget.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 *
 * @param {string=} name
 *                  Name of the marquee widget.
 * @param {string=} hint
 *                  Title/hint for the marquee. <br>
 *                  This is a bindable property.
 * @param {string=} caption
 *                  Content of the marquee. <br>
 *                  This is a bindable property.
 * @param {string=} width
 *                  Width of the marquee.
 * @param {string=} height
 *                  Height of the marquee.
 * @param {number=} scrolldelay
 *                  Defines how long to delay between each jump. <br>
 * @param {number=} scrollamount
 *                  Defines how far the animation jumps <br>
 * @param {string=} direction
 *                  This property will be used to set the direction of the marquee animation. <br>
 *                  Possible values are : 'up','down','left','right'. <br>
 * @param {boolean=} show
 *                  This is a bindable property. <br>
 *                  This property will be used to show/hide the marquee widget on the web page. <br>
 *                  Default value: `true`. <br>
 * @example
 <example module="wmCore">
     <file name="index.html">
         <div data-ng-controller="Ctrl" class="wm-app">
             <marquee direction="left" scrolldelay="25">This text scrolls infinite times</marquee>
             <marquee direction="left" scrollamount="15">This text scrolls with scrollamount specified</marquee>
             <marquee direction="up">This text scrolls up with direction property specified to be 'up'</marquee>
         </div>
     </file>
 </example>
 */
/*global WM, wm, document, _*/
/*Directive for prefabs */

WM.module('wm.prefabs')
/**
 * @ngdoc directive
 * @name wm.prefab.directive:wmPrefab
 * @restrict E
 * @element ANY
 * @requires PrefabManager
 * @requires Utils
 * @requires $compile
 * @requires PropertiesFactory
 * @description
 * The 'wmPrefab' directive defines a prefab in editors. It is draggable over the canvas.
*/
    .factory('debugModePrefabResourceInterceptor',
        [
            function () {
                'use strict';

                var configs = [],
                    cache   = {},
                    enableInterceptor;

                function getDevModePrefabUrl(requestUrl) {

                    var matchFound,
                        redirectUrl,
                        url;

                    url = cache[requestUrl];
                    if (url) {
                        return url;
                    }

                    matchFound = _.some(configs, function (config) {
                        var resourceMatch = config.resourceMatch,
                            servicesMatch = config.servicesMatch,
                            prefabName    = config.prefabName,
                            _url,
                            index;

                        index = requestUrl.indexOf(resourceMatch);

                        if (index !== -1) {
                            _url = requestUrl.substr(index + prefabName.length + 13);
                        } else {
                            index = requestUrl.indexOf(servicesMatch);
                            if (index !== -1) {
                                _url = requestUrl.substr(index + prefabName.length + 10);

                                _url = '/services/' + _url;
                            }
                        }

                        redirectUrl = config.prefabAppUrl + _url;
                        return !!_url;
                    });

                    if (matchFound) {
                        cache[requestUrl] = redirectUrl;
                        return redirectUrl;
                    }
                }

                function requestInterceptor(config) {

                    if (enableInterceptor) {
                        var _url = getDevModePrefabUrl(config.url);

                        if (_url) {
                            config.url = _url;
                        }
                    }
                    return config;
                }

                function registerConfig(pfName, url) {
                    enableInterceptor = true;

                    if (!url.endsWith('/')) {
                        url = url + '/';
                    }

                    configs.push(
                        {
                            'prefabName'    : pfName,
                            'prefabAppUrl'  : url,
                            'resourceMatch' : 'app/prefabs/' + pfName + '/',
                            'servicesMatch' : '/prefabs/' + pfName + '/'
                        }
                    );
                }

                return {
                    'request' : requestInterceptor,
                    'register': registerConfig
                };
            }
        ])
    /*.config(function ($httpProvider) {
        'use strict';

        $httpProvider.interceptors.push('debugModePrefabResourceInterceptor');
    })*/
    .directive('wmPrefab', [
        'PrefabManager',
        'Utils',
        '$compile',
        'PropertiesFactory',
        'WidgetUtilService',
        'CONSTANTS',
        '$timeout',
        'WIDGET_CONSTANTS',
        '$rootScope',
        'DialogService',
        'PrefabService',
        'debugModePrefabResourceInterceptor',

        function (PrefabManager, Utils, $compile, PropertiesFactory, WidgetUtilService, CONSTANTS, $timeout, WIDGET_CONSTANTS, $rootScope, DialogService, PrefabService, debugModePrefabResourceInterceptor) {
            'use strict';

            var prefabDefaultProps = PropertiesFactory.getPropertiesOf('wm.prefabs', ['wm.base']),
                depsMap = {},
                propertyGroups,
                propertiesGroup,
                eventsGroup,
                prefabWidgetPropsMap = {},
                prefabMethodsMap = {};

            if (CONSTANTS.isStudioMode) {
                (function () {
                    var groups = PropertiesFactory.getPropertyGroups();

                    propertyGroups = groups.filter(function (group) {

                        if (group.name === 'properties') {
                            propertiesGroup = group;
                        } else if (group.name === 'events') {
                            eventsGroup = group;
                        }

                        return !!group.parent;
                    });

                }());
            }

            function onConfigLoad(iScope, serverProps, config) {

                if (prefabWidgetPropsMap[iScope.prefabname]) {
                    iScope.widgetProps = Utils.getClonedObject(prefabWidgetPropsMap[iScope.prefabname]);
                    iScope._methodsMap = prefabMethodsMap[iScope.prefabname];
                    if (CONSTANTS.isStudioMode) {
                        iScope.serverProps = serverProps;
                    }
                    return;
                }

                var prefabProperties,
                    prefabEvents,
                    widgetProps = {},
                    userDefinedProps,
                    methodsMap = {};

                if (CONSTANTS.isStudioMode) {
                    prefabProperties = [];
                    prefabEvents = [];

                    propertiesGroup.subGroups.splice(1, 0, {
                        'boundPrefabName': iScope.prefabname,
                        'name': iScope.prefabname + '_' + 'properties',
                        'parent': 'properties',
                        'properties': prefabProperties
                    });

                    eventsGroup.subGroups.push({
                        'boundPrefabName': iScope.prefabname,
                        'name': iScope.prefabname + '_' + 'events',
                        'parent': 'events',
                        'properties': prefabEvents
                    });

                    iScope.serverProps = serverProps;
                }

                userDefinedProps = config.properties || {};
                iScope.prefabid = config.id;

                WM.forEach(userDefinedProps, function (prop, key) {

                    if (prop.type === 'method') {
                        methodsMap[key] = prop;
                        return;
                    }

                    widgetProps[key] = prop;

                    if (Utils.stringStartsWith(prop.value, 'bind:')) {
                        prop.__value = prop.value;
                        prop.value = undefined;
                    }

                    if (CONSTANTS.isStudioMode) {
                        var found = propertyGroups.some(function (group) {
                            return group.properties.indexOf(key) !== -1;
                        });

                        if (!found) {
                            if (prop.type === 'event') {
                                prefabEvents.push(key);
                            } else {
                                prefabProperties.push(key);
                            }
                        }

                        if (!prop.hasOwnProperty('show')) {
                            prop.show = true;
                        }

                        if (!prop.hasOwnProperty('disabled')) {
                            prop.disabled = false;
                        }

                        if (prop.type === 'event') {
                            prop.options = WIDGET_CONSTANTS.EVENTS_OPTIONS;
                        } else {
                            prop.label = Utils.initCaps(key);
                        }
                    }
                });

                WM.forEach(prefabDefaultProps, function (prop, key) {
                    if (WM.isUndefined(widgetProps[key])) {
                        widgetProps[key] = prop;
                    }
                });

                prefabWidgetPropsMap[iScope.prefabname] = widgetProps;
                prefabMethodsMap[iScope.prefabname] = methodsMap;

                iScope.widgetProps = Utils.getClonedObject(prefabWidgetPropsMap[iScope.prefabname]);
                iScope._methodsMap = prefabMethodsMap[iScope.prefabname];
                if (CONSTANTS.isStudioMode) {
                    iScope.serverProps = serverProps;
                }
            }

            return {
                'restrict': 'E',
                'scope': {
                    'prefabname': '@'
                },
                'replace': true,
                'template':
                    '<section  data-role="prefab" init-widget class="app-prefab" ' +
                        'data-ng-style="{' +
                            'width:width, height:height,' +
                            'marginBottom: marginbottom + marginunit, ' +
                            'marginLeft: marginleft + marginunit, ' +
                            'marginRight: marginright + marginunit, ' +
                            'marginTop: margintop + marginunit ' +
                        '}" data-ng-show="show">' +
                    '</section>',
                'compile': function () {
                    return {
                        'pre': function (iScope, element, attrs) {
                            /*
                            if (attrs.debugurl) {
                                debugModePrefabResourceInterceptor.register(iScope.prefabname, attrs.debugurl);
                            }
                            */

                            var serverProps;
                            function loadDependencies() {
                                if (CONSTANTS.isStudioMode) {
                                    PrefabService.getAppPrefabServerProps({
                                        'projectID': $rootScope.project.id,
                                        'prefabName': iScope.prefabname
                                    }, function (response) {
                                        serverProps = response || {};
                                    });

                                }
                                PrefabManager.loadAppPrefabConfig(iScope.prefabname, onConfigLoad.bind(undefined, iScope, serverProps));
                            }
                            if (CONSTANTS.isStudioMode && attrs.registrationRequired !== undefined) {
                                PrefabManager.registerPrefab(
                                    iScope.prefabname,
                                    loadDependencies
                                );
                            } else {
                                loadDependencies();
                            }
                        },

                        'post': function (iScope, element, attrs) {
                            var prefabName = iScope.prefabname;

                            iScope.__compileWithIScope = true;

                            Object.defineProperty(iScope, 'appLocale', {
                                get: function () {
                                    return iScope.$root.appLocale;
                                }
                            });

                            function listenerFn(event, eventName) {
                                var parts, methodProps, fn, fnName, subParts, dialogId;
                                if (!eventName) {
                                    return;
                                }

                                // split the event name by dot.
                                // If the first part is event Name process the event, ignore otherwise
                                parts = eventName.split('.');
                                if (parts[0] === iScope.name) {
                                    if (parts.length === 2) { // eventName should not have more than two parts when split with dot
                                        if (iScope._methodsMap[parts[1]]) {
                                            event.stopPropagation(); // This is a method of THIS prefab, do not let other prefabs to process the same event.
                                            methodProps = iScope._methodsMap[parts[1]]; // get the properties related to the method
                                            fnName = methodProps.method; // function to be invoked
                                            fn = iScope.ctrlScope[fnName]; // get the function reference
                                            if (WM.isFunction(fn)) { // if function is defined on prefab's controller, invoke it
                                                Utils.triggerFn(fn);
                                            } else { // if it is custom event
                                                subParts = fnName.split('.');
                                                if (subParts.length === 2) { // check if it is related to dialogs placed inside prefab
                                                    dialogId = subParts[0];
                                                    if (subParts[1] === 'show') { // handle dialog related events
                                                        DialogService.showDialog(dialogId, {'scope': iScope.ctrlScope});
                                                    } else if (subParts[1] === 'hide') {
                                                        DialogService.hideDialog(dialogId);
                                                    }
                                                } else { // Handle other events.
                                                    $rootScope.$emit('invoke-service', fnName, {'scope': iScope.ctrlScope});
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            iScope.$on('$destroy', $rootScope.$on('invoke-service', listenerFn));

                            /* called on load of the prefab template*/
                            function onTemplateLoad() {
                                var pfScope = element.find('[data-ng-controller]').scope();
                                /* scope of the controller */

                                WM.forEach(iScope.widgetProps, function (propDetails, propName) {
                                    if (propDetails.__value && !attrs.hasOwnProperty(propName)) {
                                        var key = propDetails.__value.replace('bind:', '');
                                        iScope._watchers[propName] = pfScope.$watch(key, function (nv) {
                                            iScope[propName + '__updateFromWatcher'] = true;
                                            iScope[propName] = nv;
                                        });
                                    }
                                });
                                WidgetUtilService.postWidgetCreate(iScope, element, attrs);

                                Utils.triggerFn(pfScope.onInitPrefab);
                                if (CONSTANTS.isRunMode) {
                                    Utils.triggerFn(iScope.onLoad);

                                    iScope.$on('$destroy', iScope.onDestroy);
                                }

                                iScope.ctrlScope = pfScope;
                            }

                            function compileTemplate(prefabContent) {
                                var prefabEle = WM.element('<div class="full-width full-height">' + prefabContent + '</div>');
                                element.append(prefabEle);
                                $compile(element.children())(iScope);
                                $timeout(onTemplateLoad);
                            }

                            if (!depsMap[prefabName]) {
                                PrefabManager.loadDependencies(prefabName).then(function (templateContent) {
                                    depsMap[prefabName] = {
                                        "templateContent": templateContent
                                    };
                                    compileTemplate(templateContent);
                                });
                            } else { //dependencies already loaded.
                                compileTemplate(depsMap[prefabName].templateContent);
                            }
                            iScope.showServerProps = iScope.serverProps && Object.keys(iScope.serverProps).length;
                        }
                    };
                }
            };
        }
    ])
/**
 * @ngdoc directive
 * @name wm.prefab.directive:wmPrefabRun
 * @restrict E
 * @element ANY
 * @requires $rootScope
 * @requires Utils
 * @requires $compile
 * @description
 * 'wmPrefabRun' creates a container for the prefab project to work properly in run mode.
 */
    .directive("wmPrefabRun", [
        "$rootScope",
        "Utils",
        "$compile",
        "PrefabManager",
        "WidgetUtilService",
        function ($rootScope, Utils, $compile, PrefabManager, WidgetUtilService) {
            "use strict";

            function isExternalResource(path) {
                return Utils.stringStartsWith(path, 'http://|https://|//');
            }

            return {
                "restrict": "E",
                "scope": {},
                "replace": true,
                "template": '<section  data-role="prefab" init-widget class="app-prefab app-prefab-run"></section>',
                "compile": function () {
                    return {
                        "pre": function (scope) {
                            var config = $rootScope.prefabConfig;
                            // for the initWidget to create properties handler we need to have widgetProps defined.
                            scope.widgetProps = config.properties || [];
                        },
                        "post": function (scope, element, attrs) {
                            var config = $rootScope.prefabConfig,
                                resources; // config read while bootstrapping the app
                            scope.__compileWithIScope = true;

                            //compile the prefab template and trigger postWidgetCreate and onInitPrefab methods
                            function compileTemplate() {
                                element.append(WM.element($rootScope.prefabTemplate));
                                $compile(element.children())(scope);

                                // get the scope of prefab controller
                                var pfScope = element.find("[data-ng-controller]").scope();

                                // expose the Page Variables and Widgets on the outer scope.
                                Object.defineProperties(element.scope(), {
                                    'Widgets': {
                                        'get': function () {
                                            return pfScope.Widgets;
                                        }
                                    },
                                    'Variables': {
                                        'get': function () {
                                            return pfScope.Variables;
                                        }
                                    }
                                });

                                WidgetUtilService.postWidgetCreate(scope, element, attrs);

                                Utils.triggerFn(pfScope.onInitPrefab);

                                scope.ctrlScope = pfScope;
                            }

                            Object.defineProperty(scope, "appLocale", {
                                get: function () {
                                    return scope.$root.appLocale;
                                }
                            });

                            if (config) {
                                resources = Utils.getClonedObject(config.resources);
                                if (resources.scripts) { // modify the script urls if necessary
                                    resources.scripts = resources.scripts.map(function (script) {
                                        var _script = script && script.trim();
                                        if (!isExternalResource(_script) && _script.charAt(0) === '/') {
                                            _script = "." + _script;
                                        }
                                        return _script;
                                    });
                                }

                                if (resources.styles) { // modify the style urls if necessary
                                    resources.styles = resources.styles.map(function (style) {
                                        var _style = style && style.trim();
                                        if (!isExternalResource(_style) && _style.charAt(0) === '/') {
                                            _style = "." + _style;
                                        }
                                        return _style;
                                    });
                                }

                                if (resources.modules) {
                                    // modify the module files urls if necessary
                                    resources.modules = resources.modules.map(function (module) {
                                        module.files = module.files.map(function (file) {
                                            var _file = file && file.trim();
                                            if (!isExternalResource(_file) && _file.charAt(0) === '/') {
                                                _file = "." + _file;
                                            }
                                            return _file;
                                        });
                                        return module;
                                    });
                                }

                                Utils.loadStyleSheets(resources.styles);
                                PrefabManager.loadScripts(resources.scripts)
                                    .then(PrefabManager.loadModules.bind(undefined, resources.modules))
                                    .then(compileTemplate);

                            }
                        }
                    };
                }
            };
        }
    ]);

/*global WM, wm*/

/*Defining module for Database services*/
wm.plugins.database = WM.module('wm.plugins.database', []);

/*Creating namespaces for the controllers, services etc. of the module*/
wm.plugins.database.directives = {};
wm.plugins.database.controllers = {};
wm.plugins.database.services = {};
wm.plugins.database.factories = {};

/*Defining the controllers, services etc. required for the Database services module*/
wm.plugins.database.directive(wm.plugins.database.directives);
wm.plugins.database.controller(wm.plugins.database.controllers);
wm.plugins.database.service(wm.plugins.database.services);
wm.plugins.database.factory(wm.plugins.database.factories);

/*defining urls as constants in the database services module*/
wm.plugins.database.constant('DB_SERVICE_URLS', {
    Database: {
        testConnection: {
            url: "services/projects/:projectID/database/testConnection",
            method: "POST"
        },
        importDB: {
            url: "services/projects/:projectID/database/import",
            method: "POST"
        },
        reImportDB: {
            url: "services/projects/:projectID/database/reimport?serviceId=:serviceId",
            method: "POST"
        },
        exportDB: {
            url: "services/projects/:projectID/database/export",
            method: "POST"
        },
        loadModelInfo: {
            url: "services/projects/:projectID/database/loadModelInfo",
            method: "POST"
        },
        listTables: {
            url: "services/projects/:projectID/database/listTables",
            method: "POST"
        },

        /*DataModel related services*/
        getAllDataModels: {
            url: "services/projects/:projectID/datamodels/",
            method: "GET"
        },
        getDataModel: {
            url: "services/projects/:projectID/datamodels/:dataModelName?isdraft=:isdraft",
            method: "GET"
        },
        createDataModel: {
            url: "services/projects/:projectID/datamodels",
            method: "POST"
        },
        deleteDataModel: {
            url: "services/projects/:projectID/datamodels/:dataModelName",
            method: "DELETE"
        },
        saveDataModel: {
            url: "services/projects/:projectID/datamodels/:dataModelName/save",
            method: "POST"
        },
        applyDataModel: {
            url: "services/projects/:projectID/database/update?serviceId=:serviceId",
            method: "POST"
        },
        revertDataModel: {
            url: "services/projects/:projectID/datamodels/:dataModelName/revert",
            method: "POST"
        },

        /*Entities related services*/

        getAllEntities: {
            url: "services/projects/:projectID/datamodels/:dataModelName/tables",
            method: "GET"
        },
        getEntity: {
            url: "services/projects/:projectID/datamodels/:dataModelName/tables/:tableName",
            "method": "GET"
        },
        createEntity: {
            url: "services/projects/:projectID/datamodels/:dataModelName/tables",
            method: "POST"
        },
        updateEntity: {
            url: "services/projects/:projectID/datamodels/:dataModelName/tables/:entityName",
            method: "POST"
        },
        deleteEntity: {
            url: "services/projects/:projectID/datamodels/:dataModelName/tables/:entityName",
            method: "DELETE"
        },

        /*Entity Columns related services*/
        addPrimaryKey: {
            url: "services/projects/:projectID/datamodels/:dataModelName/tables/:entityName/primaryKey",
            method: "PUT"
        },
        addColumns: {
            url: "services/projects/:projectID/datamodels/:dataModelName/tables/:entityName/columns",
            method: "POST"
        },
        updateColumn: {
            url: "services/projects/:projectID/datamodels/:dataModelName/tables/:entityName/columns/:columnName?forceDataLoss=:forceDataLoss",
            method: "PUT"
        },
        deleteColumn: {
            url: "services/projects/:projectID/datamodels/:dataModelName/tables/:entityName/columns/:columnName",
            method: "DELETE"
        },

        /*Services related to relations*/

        addRelation: {
            url: "services/projects/:projectID/datamodels/:dataModelName/tables/:entityName/relations",
            method: "POST"
        },
        updateRelation: {
            url: "services/projects/:projectID/datamodels/:dataModelName/tables/:entityName/relations/:relationName",
            method: "PUT"
        },
        deleteRelation: {
            url: "services/projects/:projectID/datamodels/:dataModelName/tables/:entityName/relations/:relationName",
            method: "DELETE"
        },
        getTypesMap: {
            url: "services/projects/:projectID/services/typesmap",
            method: "GET"
        },

        /*Queries Related services*/

        getAllQueries: {
            url: "services/projects/:projectID/datamodels/:dataModelName/queries",
            method: "GET"
        },
        getQuery: {
            url: "services/projects/:projectID/datamodels/:dataModelName/queries/:queryName",
            method: "GET"
        },
        createQuery: {
            url: "services/projects/:projectID/datamodels/:dataModelName/queries",
            method: "POST"
        },
        updateQuery: {
            url: "services/projects/:projectID/datamodels/:dataModelName/queries/:queryName",
            method: "PUT"
        },
        deleteQuery: {
            url: "services/projects/:projectID/datamodels/:dataModelName/queries/:queryName",
            method: "DELETE"
        },
        setQueryMetaData: {
            url: "services/projects/:projectID/datamodels/:dataModelName/queries/:queryName/metadata",
            method: "POST"
        },
        validateQuery: {
            url: "services/projects/:projectID/datamodels/:dataModelName/query/validate",
            method: "POST"
        },
        executeQuery: {
            url: "services/projects/:projectID/datamodels/:dataModelName/query/execute",
            method: "POST"
        },

        /*Procedure Related services*/

        getAllProcedures: {
            url: "services/projects/:projectID/datamodels/:dataModelName/procedures",
            method: "GET"
        },
        getProcedure: {
            url: "services/projects/:projectID/datamodels/:dataModelName/procedures/:procedureName",
            method: "GET"
        },
        createProcedure: {
            url: "services/projects/:projectID/datamodels/:dataModelName/procedures",
            method: "POST"
        },
        updateProcedure: {
            url: "services/projects/:projectID/datamodels/:dataModelName/procedures/:procedureName",
            method: "PUT"
        },
        deleteProcedure: {
            url: "services/projects/:projectID/datamodels/:dataModelName/procedures/:procedureName",
            method: "DELETE"
        },
        setProcedureMetaData: {
            url: "services/projects/:projectID/datamodels/:dataModelName/procedures/:procedureName/metadata",
            method: "POST"
        },
        executeProcedure: {
            url: "services/projects/:projectID/datamodels/:dataModelName/procedures/execute",
            method: "POST"
        },


        readTableData: {
            url: "/:service/:dataModelName/:entityName/?page=:page&size=:size&:sort",
            method: "GET"
        },
        insertTableData: {
            url: "/:service/:dataModelName/:entityName/",
            method: "POST"
        },
        insertMultiPartTableData: {
            url: "/:service/:dataModelName/:entityName/",
            method: "POST",
            headers: {
                'Content-Type': undefined
            },
            transformRequest: WM.identity
        },
        updateTableData: {
            url: "/:service/:dataModelName/:entityName/:id",
            method: "PUT"
        },
        updateMultiPartTableData: {
            url: "/:service/:dataModelName/:entityName/:id",
            method: "POST",
            headers: {
                'Content-Type': undefined
            },
            transformRequest: WM.identity
        },
        deleteTableData: {
            url: "/:service/:dataModelName/:entityName/:id",
            method: "DELETE"
        },
        updateCompositeTableData: {
            url: "/:service/:dataModelName/:entityName/composite-id?:id",
            method: "PUT"
        },
        deleteCompositeTableData: {
            url: "/:service/:dataModelName/:entityName/composite-id?:id",
            method: "DELETE"
        },
        searchTableData: {
            url: "/:service/:dataModelName/:entityName/search?page=:page&size=:size&:sort",
            method: "POST"
        },
        readTableRelatedData: {
            url: "/:service/:dataModelName/:entityName/:id/:relatedFieldName?page=:page&size=:size&:sort",
            method: "GET"
        },
        executeNamedQuery: {
            url: "/:service/:dataModelName/queryExecutor/queries/:queryName?page=:page&size=:size&:queryParams",
            method: "GET"
        },
        executeCustomQuery: {
            url: "/:service/:dataModelName/queryExecutor/queries/wm_custom?page=:page&size=:size",
            method: "POST"
        },
        getCustomQueryMetaData: {
            url: "/:service/:dataModelName/queries/wm_querymetadata",
            method: "POST"
        },
        executeCustomUpdateQuery: {
            url: "/:service/:dataModelName/queryExecutor/queries/wm_custom_update",
            method: "POST"
        },

        /*Procedure related properties*/
        executeNamedProcedure: {
            url: "/:service/:dataModelName/procedureExecutor/procedure/execute/:procedureName?page=:page&size=:size&:procedureParams",
            method: "GET"
        },
        executeCustomProcedure: {
            url: "/:service/:dataModelName/procedureExecutor/procedure/execute/wm_custom",
            method: "POST"
        },
        getCustomProcedureMetaData: {
            url: "/:service/:dataModelName/procedures/wm_proceduremetadata",
            method: "POST"
        },

        /*Database connection properties*/
        getSampleDbConnectionProperties: {
            url: "services/projects/:projectID/database/sample/connectionProps",
            method: "GET"
        },
        getConnectionProperties: {
            url: "services/projects/:projectID/database/connectionproperties?serviceId=:serviceId",
            method: "GET"
        },
        updateConnectionProperties: {
            url: "services/projects/:projectID/database/connectionproperties?serviceId=:serviceId",
            method: "PUT"
        }
    }
});

/*Defining the constants for the database service module*/
wm.plugins.database.constant('DB_CONSTANTS', {
    "DATABASE_WORKSPACE_TYPE": "db",
    "WAVEMAKER_SAMPLE_DB_NAME": "hrdb",
    "DEFAULT_DB_NAME": "MyTestDatabase",
    "HSQL_DB_TYPE": "HSQLDB",
    "MYSQL_DB_TYPE": "MySQL",
    "POSTGRESQL_DB_TYPE": "PostgreSQL",
    "ORACLE_DB_TYPE": "Oracle",
    "SQL_SERVER_DB_TYPE": "SQLServer",
    "MYSQL_CLOUD_HOST": "{WM_CLOUD_MYSQL_HOST}",
    "MYSQL_CLOUD_DB_TYPE": "MySQL-Cloud",
    "LOGIN": {
        "SAAS_MYSQL_CLOUD": {
            "USERNAME": "{WM_CLOUD_MYSQL_USERNAME}",
            "PASSWORD": "{WM_CLOUD_MYSQL_PASSWORD}"
        }
    },
    "PERMISSIONS": {
        "HSQLDB": {
            "CREATE": false,
            "UPDATE": false,
            "DELETE": false,
            "READ"  : true
        },
        "MySQL-Cloud": {
            "CREATE": true,
            "UPDATE": true,
            "DELETE": true,
            "READ"  : true
        },
        "MySQL": {
            "CREATE": true,
            "UPDATE": true,
            "DELETE": true,
            "READ"  : true
        },
        "DB2": {
            "CREATE": false,
            "UPDATE": false,
            "DELETE": false,
            "READ"  : true
        },
        "PostgreSQL":  {
            "CREATE": true,
            "UPDATE": true,
            "DELETE": true,
            "READ"  : true
        },
        "Oracle" : {
            "CREATE": true,
            "UPDATE": true,
            "DELETE": true,
            "READ"  : true
        },
        "SQLServer" : {
            "CREATE": true,
            "UPDATE": true,
            "DELETE": true,
            "READ"  : true
        },
        "Other": {
            "CREATE": false,
            "UPDATE": false,
            "DELETE": false,
            "READ"  : true
        }
    },
    "IDENTITY_GENERATORS" : ['integer', 'short', 'long', 'big_integer'],
    "DATABASE_NUMERIC_DATA_TYPES": {
        "short": "short",
        "integer": "integer",
        "long" : "long",
        "big_integer": "big_integer",
        "float": "float",
        "double": "double",
        "big_decimal": "big_decimal"
    },
    "DATABASE_DATA_TYPES": {
        "big_decimal": {
            "java_type": "big_decimal",
            "default_value": "0",
            "precision": true
        },
        "big_integer": {
            "java_type": "big_integer",
            "default_value": "0",
            "precision": true
        },
        "blob": {
            "java_type": "blob",
            "default_value": "null"
        },
        "boolean": {
            "java_type": "boolean",
            "default_value": "false"
        },
        "byte": {
            "java_type": "byte",
            "default_value": "null",
            "precision": true
        },
        "character": {
            "java_type": "character",
            "default_value": "null"
        },
        "clob": {
            "java_type": "clob",
            "default_value": "null"
        },
        "date": {
            "java_type": "date",
            "default_value": "null"
        },
        "date_time": {
            "java_type": "date_time",
            "default_value": "null"
        },
        "double": {
            "java_type": "double",
            "default_value": "0"
        },
        "float": {
            "java_type": "float",
            "default_value": "0"
        },
        "integer": {
            "java_type": "integer",
            "default_value": "0",
            "precision": true
        },
        "long": {
            "java_type": "long",
            "default_value": "0",
            "precision": true
        },
        "string": {
            "java_type": "string",
            "default_value": "null",
            "length": true
        },
        "short": {
            "java_type": "short",
            "default_value": "0",
            "precision": true
        },
        "text": {
            "java_type": "text",
            "default_value": "null"
        },
        "time": {
            "java_type": "time",
            "default_value": "null"
        },
        "time_stamp": {
            "java_type": "time_stamp",
            "default_value": "null"
        }
    },
    "DATABASE_SECONDARY_DATA_TYPES": {
        "binary": {
            "java_type": "blob",
            "default_value": "null"
        },
        "long": {
            "java_type": "double",
            "default_value": "null"
        }
    },
    "DATABASE_GENERATORS": {
        "assigned": "assigned",
        "identity": "auto increment",
        "sequence": "sequence"
    },
    "DATABASE_MATCH_MODES": {
        "start"            : "STARTING_WITH",
        "end"              : "ENDING_WITH",
        "anywhere"         : "CONTAINING",
        "exact"            : "EQUALS",
        "notequals"        : "NOT_EQUALS",
        "between"          : "BETWEEN",
        "lessthan"         : "LESS_THAN",
        "lessthanequal"    : "LESS_THAN_OR_EQUALS",
        "greaterthan"      : "GREATER_THAN",
        "greaterthanequal" : "GREATER_THAN_OR_EQUALS",
        "null"             : "NULL",
        "empty"            : "EMPTY",
        "nullorempty"      : "NULL_OR_EMPTY"
    },
    "DATABASE_EMPTY_MATCH_MODES": ["NULL", "EMPTY", "NULL_OR_EMPTY"],
    "DATABASE_RANGE_MATCH_MODES": ["BETWEEN", "LESS_THAN", "LESS_THAN_OR_EQUALS", "GREATER_THAN", "GREATER_THAN_OR_EQUALS"],
    "ACTIONS": {
        "CREATE": "CREATE",
        "UPDATE": "UPDATE",
        "DELETE": "DELETE",
        "SAVED": "SAVED"
    },
    "OBJECTS": {
        "DATABASE": "wm-db",
        "TABLE": "wm-db-table",
        "COLUMN": "wm-db-table-column",
        "RELATION": "wm-db-column-relation"
    },
    "DML_QUERY_INDICATORS": {
        "SELECT": "SELECT",
        "UPDATE": ["INSERT INTO", "UPDATE", "DELETE FROM"]
    },
    "DDL_QUERY_INDICATORS": ["CREATE", "ALTER", "RENAME", "DROP"],
    "SERVER_SIDE_PROPERTIES": {
        "CURRENT_DATE": {
            "property": "Current Date",
            "value": "CURRENT_DATE"
        },
        "CURRENT_TIME": {
            "property": "Current Time",
            "value": "CURRENT_TIME"
        },
        "CURRENT_USER_ID": {
            "property": "Current Userid",
            "value": "CURRENT_USER_ID"
        },
        "CURRENT_USER_NAME": {
            "property": "Current Username",
            "value": "CURRENT_USER_NAME"
        }
    }
});

/*Defining the config for the database plugins*/
wm.plugins.database.config(function (BaseServiceManagerProvider, DB_SERVICE_URLS) {
    'use strict';

    BaseServiceManagerProvider.register(DB_SERVICE_URLS);
});

/*global WM, wm*/
/**
 * @ngdoc service
 * @name wm.database.$QueryBuilder
 * @requires $rootScope
 * @requires DatabaseService
 * @requires Utils
 * @description
 * The `$QueryBuilder` provides services to build and execute queries.
 *
 */

wm.plugins.database.services.QueryBuilder = [
    "$rootScope",
    "DatabaseService",
    "Utils",
    "ProjectService",
    "$liveVariable",
    function ($rootScope, DatabaseService, Utils, ProjectService, $liveVariable) {
        'use strict';

        return {
            'getQuery': function (options) {
                var selectClause,
                    columnClause = "",
                    fromClause,
                    whereClause = "",
                    groupByClause,
                    orderByClause,
                    logicalOp = options.logicalOp && options.logicalOp.toLowerCase() === "or" ? " OR " : " AND ",
                    logicalOpSliceLength = logicalOp === " OR " ? -4 : -5,
                    query;

                selectClause = "SELECT ";

                if (options.columns) {
                    columnClause = "";
                    WM.forEach(options.columns, function (column) {
                        columnClause += column + ",";
                    });
                    columnClause = columnClause.slice(0, -1);
                } else {
                    selectClause = '';
                }

                fromClause = " FROM " + options.tableName;
                if (WM.isArray(options.filterFields) && options.filterFields.length) {
                    whereClause = " WHERE ";
                    WM.forEach(options.filterFields, function (field) {
                        if (field.clause) {
                            whereClause += field.clause + logicalOp;
                        } else {
                            /*If value is an array, loop through the array and build the query with OR clause*/
                            if (WM.isArray(field.value)) {
                                whereClause += "(" + field.column + "='";
                                field.value.forEach(function (element, index) {
                                    if (index + 1 === field.value.length) {
                                        whereClause += element;
                                    } else {
                                        whereClause += element + "' OR " + field.column + "='";
                                    }
                                });
                                whereClause += "')" + logicalOp;
                            } else {
                                /*If the field is a boolean value, quotes should not be added to the values*/
                                if (field.noQuotes) {
                                    whereClause += field.column + "=" + field.value + logicalOp;
                                } else {
                                    whereClause += field.column + "='" + field.value + "'" + logicalOp;
                                }

                            }
                        }
                    });
                    whereClause = whereClause.slice(0, logicalOpSliceLength);
                } else if (!WM.element.isEmptyObject(options.filterFields)) {
                    whereClause = " WHERE ";
                    WM.forEach(options.filterFields, function (field, fieldName) {
                        var fieldValue;
                        /*Set appropriate value for fieldValue based on the type of data passed for the field.*/
                        if (field.value) {
                            fieldValue = field.value;
                        } else if (!WM.isObject(field)) {
                            fieldValue = field;
                        } else {
                            return;
                        }
                        whereClause += fieldName + "='" + fieldValue + "'" + logicalOp;
                    });
                    whereClause = whereClause.slice(0, logicalOpSliceLength);
                }
                groupByClause = options.groupby ? (" GROUP BY " + options.groupby) : "";
                orderByClause = options.orderby ? (" ORDER BY " + options.orderby) : "";

                query = selectClause + columnClause + fromClause + whereClause + groupByClause + orderByClause;

                return query;
            },
            'executeQuery': function (options, success, error) {
                var executeQuery = function () {
                    DatabaseService.executeCustomQuery({
                        "projectID": $rootScope.project.id,
                        "dataModelName": options.databaseName,
                        "page": options.page,
                        "size": options.size,
                        "data": {
                            "queryStr": options.query,
                            "queryParams": options.queryParams || [],
                            "nativeSql": options.nativeSql
                        },
                        "service": options.prefabName ? "" : "services",
                        "url": options.prefabName ? ($rootScope.project.deployedUrl + "/prefabs/" + options.prefabName) : $rootScope.project.deployedUrl
                    }, function (response) {
                        if (response.errors) {
                            Utils.triggerFn(error, response);
                        } else {
                            $liveVariable.processResponse(response.content);
                            Utils.triggerFn(success, response);
                        }
                    }, function (response) {
                        Utils.triggerFn(error, response);
                    });
                };
                /*If the project is not yet deployed,
                deploy the project and then execute the query.*/
                if (!$rootScope.project.deployedUrl) {
                    ProjectService.run({
                        projectId: $rootScope.project.id
                    }, function (result) {
                        /*Save the deployed url of the project in the $rootScope so that it could be used in all calls to services of deployed app*/
                        $rootScope.project.deployedUrl = Utils.removeProtocol(result);
                        executeQuery();
                    });
                } else {
                    executeQuery();
                }
            }
        };
    }
];
/*global WM, wm*/
/*jslint todo: true */
/**
 * @ngdoc service
 * @name wm.database.$DatabaseService
 * @requires BaseService
 * @description
 * The `$DatabaseService` provides the details about the database apis
 *
 * # Shortcut Methods
 * Complete list of the methods:
 *
 * - {@link wm.database.$DatabaseService#methods_importDB importDB}
 * - {@link wm.database.$DatabaseService#methods_exportDB exportDB}
 * - {@link wm.database.$DatabaseService#methods_getAllDataModels getAllDataModels}
 * - {@link wm.database.$DatabaseService#methods_getDataModel getDataModel}
 * - {@link wm.database.$DatabaseService#methods_createDataModel createDataModel}
 * - {@link wm.database.$DatabaseService#methods_deleteDataModel deleteDataModel}
 * - {@link wm.database.$DatabaseService#methods_saveDataModel saveDataModel}
 * - {@link wm.database.$DatabaseService#methods_applyDataModel applyDataModel}
 * - {@link wm.database.$DatabaseService#methods_revertDataModel revertDataModel}
 * - {@link wm.database.$DatabaseService#methods_getAllEntities getAllEntities}
 * - {@link wm.database.$DatabaseService#methods_getEntity getEntity}
 * - {@link wm.database.$DatabaseService#methods_createEntity createEntity}
 * - {@link wm.database.$DatabaseService#methods_updateEntity updateEntity}
 * - {@link wm.database.$DatabaseService#methods_deleteEntity deleteEntity}
 * - {@link wm.database.$DatabaseService#methods_addColumns addColumns}
 * - {@link wm.database.$DatabaseService#methods_addPrimaryKey addPrimaryKey}
 * - {@link wm.database.$DatabaseService#methods_updateColumn updateColumn}
 * - {@link wm.database.$DatabaseService#methods_deleteColumn deleteColumn}
 * - {@link wm.database.$DatabaseService#methods_addRelation addRelation}
 * - {@link wm.database.$DatabaseService#methods_updateRelation updateRelation}
 * - {@link wm.database.$DatabaseService#methods_deleteRelation deleteRelation}
 * - {@link wm.database.$DatabaseService#methods_getAllQueries getAllQueries}
 * - {@link wm.database.$DatabaseService#methods_getQuery getQuery}
 * - {@link wm.database.$DatabaseService#methods_createQuery createQuery}
 * - {@link wm.database.$DatabaseService#methods_updateQuery updateQuery}
 * - {@link wm.database.$DatabaseService#methods_deleteQuery deleteQuery}
 * - {@link wm.database.$DatabaseService#methods_validateQuery validateQuery}
 * - {@link wm.database.$DatabaseService#methods_executeQuery executeQuery}
 * - {@link wm.database.$DatabaseService#methods_readTableData readTableData}
 * - {@link wm.database.$DatabaseService#methods_insertTableData insertTableData}
 * - {@link wm.database.$DatabaseService#methods_updateTableData updateTableData}
 * - {@link wm.database.$DatabaseService#methods_deleteTableData deleteTableData}
 */

wm.plugins.database.services.DatabaseService = [
    "$rootScope",
    "BaseService",
    "BaseServiceManager",
    "CONSTANTS",
    "Utils",
    "WebService",
    "$window",

    function ($rootScope, BaseService, BaseServiceManager, CONSTANTS, Utils, WebService, $window) {
        'use strict';

        var initiateAction = function (action, params, successCallback, failureCallback) {
            var param,
                val,
                config,
                connectionParams,
                urlParams,
                requestData;

            config = BaseServiceManager.getConfig();
            config = Utils.getClonedObject(config.Database[action]);
            requestData = params.data;

            urlParams = {
                projectID: params.projectID,
                service: WM.isDefined(params.service) ? params.service : "services",
                dataModelName: params.dataModelName,
                entityName: params.entityName,
                queryName: params.queryName,
                queryParams: params.queryParams,
                procedureName: params.procedureName,
                procedureParams: params.procedureParams,
                id: params.id,
                relatedFieldName: params.relatedFieldName,
                page: params.page,
                size: params.size,
                sort: params.sort
            };
            /*In the SAAS studio mode, if we directly try to access the runtime urls, it results in cross-domain request issues.,
             * Hence use the WebService's testRestService call to initiate the request.*/
            if (params.url && CONSTANTS.isStudioMode && $rootScope.preferences.workspace.loadXDomainAppDataUsingProxy) {

                /* Check for url parameters to replace the URL.
                 * So the variable parameters in the URL will be replaced by the actual parameter values.*/
                if (urlParams) {
                    for (param in urlParams) {
                        if (urlParams.hasOwnProperty(param)) {
                            val = urlParams[param];
                            if (WM.isDefined(val) && val !== null) {
                                config.url = config.url.replace(new RegExp(":" + param, "g"), val);
                            }
                        }
                    }
                }

                connectionParams = {
                    "endpointAddress": $window.location.protocol + params.url + config.url,
                    "method": config.method,
                    "contentType": "application/json",
                    "requestBody": JSON.stringify(requestData),
                    "headers": {
                        "skipSecurity": "true"
                    }
                };
                WebService.testRestService(connectionParams, function (response) {
                    var parsedData = Utils.getValidJSON(response.responseBody),
                        errMsg,
                        localeObject;
                    if (parsedData.hasOwnProperty('result')) {
                        Utils.triggerFn(successCallback, parsedData.result);
                    } else if (parsedData.hasOwnProperty('error')) {
                        Utils.triggerFn(failureCallback, (parsedData.error && parsedData.error.message) || parsedData.error);
                    } else if (parsedData.hasOwnProperty('errorDetails')) {
                        localeObject = $rootScope.locale || $rootScope.appLocale;
                        errMsg = Utils.getClonedObject(localeObject[parsedData.errorDetails.code]);
                        Utils.triggerFn(failureCallback, Utils.replace(errMsg, parsedData.errorDetails.data) || parsedData.errorDetails);
                    } else {
                        Utils.triggerFn(successCallback, parsedData);
                    }
                }, failureCallback);
            } else {
                connectionParams = {
                    target: "Database",
                    action: action,
                    urlParams: urlParams,
                    data: requestData,
                    config: {
                        "url": params.url
                    }
                };

                /* append the skipSecurity header to skip security-check in STUDIO MODE*/
                if (CONSTANTS.isStudioMode) {
                    connectionParams.headers = {"skipSecurity": "true"};
                }

                return BaseService.execute(connectionParams, successCallback, failureCallback);
            }
        };
        /* APIs returned by the DatabaseService.*/
        return {

            /**
             * Internal function
             * @name wm.database.$DatabaseService#testConnection
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to test connection to the specified database.
             *
             * @param {object} params
             *                 Object containing name of the project & details of the database.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            testConnection: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "testConnection",
                    data: {
                        "username": params.username,
                        "password": params.password,
                        "url": params.url,
                        "driverClass": params.driverClass,
                        "dialect": params.dialect
                    },
                    urlParams: {
                        "projectID": params.projectID
                    }
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#importDB
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to import the specified database.
             *
             * @param {object} params
             *                 Object containing name of the project & details of the database.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            importDB: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "importDB",
                    data: {
                        "serviceId": params.serviceId,
                        "packageName": params.packageName,
                        "username": params.username,
                        "password": params.password,
                        "url": params.url,
                        "tableFilter": params.tableFilter,
                        "schemaFilter": params.schemaFilter,
                        "driverClass": params.driverClass,
                        "dialect": params.dialect,
                        "revengNamingStrategyClassName": params.revengNamingStrategyClassName,
                        "impersonateUser": false,
                        "activeDirectoryDomain": params.activeDirectoryDomain,
                        "dbType": params.dbType,
                        "host": params.host,
                        "port": params.port,
                        "dbName": params.dbName
                    },
                    urlParams: {
                        "projectID": params.projectID
                    }
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#reimportDB
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to re-import the specified database.
             *
             * @param {object} params
             *                 Object containing name of the project & details of the database.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            reImportDB: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "reImportDB",
                    urlParams: {
                        "projectID": params.projectID,
                        "serviceId": params.serviceId
                    }
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#exportDB
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to export the specified database.
             *
             * @param {object} params
             *                 Object containing name of the project & details of the database.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            exportDB: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "exportDB",
                    data: {
                        "serviceId": params.serviceId,
                        "username": params.username,
                        "password": params.password,
                        "url": params.url,
                        "schemaName": params.schemaName,
                        "schemaFilter": params.schemaFilter,
                        "driverClass": params.driverClass,
                        "dialect": params.dialect,
                        "revengNamingStrategyClassName": params.revengNamingStrategyClassName,
                        "impersonateUser": false,
                        "overwrite": params.overwrite,
                        "dbType": params.dbType,
                        "host": params.host,
                        "port": params.port,
                        "dbName": params.dbName
                    },
                    urlParams: {
                        "projectID": params.projectID
                    }
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#listTables
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to load all the tables.
             *
             * @param {object} params
             *                 Object containing name of the project & details of the database.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            listTables: function (params, successCallback, failureCallback) {
                BaseService.execute({
                    target: "Database",
                    action: "listTables",
                    data: {
                        "serviceId": params.serviceId,
                        "packageName": params.packageName,
                        "username": params.username,
                        "password": params.password,
                        "url": params.url,
                        "schemaFilter": params.schemaFilter,
                        "tableFilter": null,
                        "driverClass": params.driverClass,
                        "dialect": params.dialect,
                        "revengNamingStrategyClassName": params.revengNamingStrategyClassName,
                        "impersonateUser": false,
                        "dbType": params.dbType,
                        "host": params.host,
                        "port": params.port,
                        "dbName": params.dbName
                    },
                    urlParams: {
                        "projectID": params.projectID
                    }
                }, successCallback, failureCallback);
            },
            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#loadModelInfo
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to load all the datamodels and their info.
             *
             * @param {object} params
             *                 Object containing name of the project & details of the database.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            loadModelInfo: function (params, successCallback, failureCallback) {
                BaseService.execute({
                    target: "Database",
                    action: "loadModelInfo",
                    data: {
                        "serviceId": params.serviceId,
                        "packageName": params.packageName,
                        "username": params.username,
                        "password": params.password,
                        "url": params.url,
                        "schemaFilter": params.schemaFilter,
                        "tableFilter": params.tableFilter,
                        "driverClass": params.driverClass,
                        "dialect": params.dialect,
                        "revengNamingStrategyClassName": params.revengNamingStrategyClassName,
                        "impersonateUser": false,
                        "dbType": params.dbType,
                        "host": params.host,
                        "port": params.port,
                        "dbName": params.dbName
                    },
                    urlParams: {
                        "projectID": params.projectID
                    }
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#getAllDataModels
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to get all the databases in the project.
             *
             * @param {string} projectID
             *                 ID of the Project.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */
            getAllDataModels: function (projectID, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "getAllDataModels",
                    urlParams: {
                        projectID: projectID
                    }
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#getDataModel
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to get complete meta data(i.e., tables, columns, relations etc.) of the specified database.
             *
             * @param {object} params
             *                 Object containing name of the project and name of the datamodel.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */
            getDataModel: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "getDataModel",
                    urlParams: {
                        projectID: params.projectID,
                        dataModelName: params.dataModelName,
                        isdraft: params.isdraft
                    }
                }, successCallback, failureCallback);
            },
            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#createDataModel
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to create a datamodel with the specified name.
             *
             * @param {string} projectID
             *                 ID of the Project.
             * @param {string} dataModelName
             *                 Name of the database.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            createDataModel: function (projectID, dataModelName, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "createDataModel",
                    urlParams: {
                        projectID: projectID
                    },
                    data: dataModelName
                }, successCallback, failureCallback);
            },
            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#deleteDataModel
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to delete the specified database.
             *
             * @param {object} params
             *                 Object containing name of the project and name of the database to be deleted.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            deleteDataModel: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "deleteDataModel",
                    urlParams: {
                        projectID: params.projectID,
                        dataModelName: params.dataModelName
                    }
                }, successCallback, failureCallback);
            },
            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#saveDataModel
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to save the specified datamodel.
             *
             * @param {object} params
             *                 Object containing name of the project and name of the datamodel.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            saveDataModel: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "saveDataModel",
                    urlParams: {
                        projectID: params.projectID,
                        dataModelName: params.dataModelName
                    }
                }, successCallback, failureCallback);
            },
            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#applyDataModel
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to apply(save & export) the specified database.
             *
             * @param {object} params
             *                 Object containing name of the project and name of the datamodel.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            applyDataModel: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "applyDataModel",
                    urlParams: {
                        projectID: params.projectID,
                        serviceId: params.dataModelName
                    }
                }, successCallback, failureCallback);
            },
            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#revertDataModel
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to revert the specified database to the published version.
             *
             * @param {object} params
             *                 Object containing name of the project and name of the datamodel.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            revertDataModel: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "revertDataModel",
                    urlParams: {
                        projectID: params.projectID,
                        dataModelName: params.dataModelName
                    }
                }, successCallback, failureCallback);
            },


            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#getAllEntities
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to get all the tables in the specified database.
             *
             * @param {object} params
             *                 Object containing name of the project & details of the database.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            getAllEntities: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "getAllEntities",
                    urlParams: {
                        projectID: params.projectID,
                        dataModelName: params.dataModelName
                    }
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#getEntity
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to get the details of the specified table from the database.
             *
             * @param {object} params
             *                 Object containing name of the project, database & table.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            getEntity: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "getEntity",
                    urlParams: {
                        projectID: params.projectID,
                        dataModelName: params.dataModelName,
                        tableName: params.tableName
                    }
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#createEntity
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to create a new entity in the specified database.
             *
             * @param {object} params
             *                 Object containing name of the project & details of the table to be created.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            createEntity: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "createEntity",
                    urlParams: {
                        projectID: params.projectID,
                        dataModelName: params.dataModelName
                    },
                    data: params.data
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#updateEntity
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to update the specified entity in the specified database.
             *
             * @param {object} params
             *                 Object containing name of the project & details of the table to be created.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            updateEntity: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "updateEntity",
                    urlParams: {
                        projectID: params.projectID,
                        dataModelName: params.dataModelName,
                        entityName: params.entityName
                    },
                    data: params.data
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#deleteEntity
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to delete the specified entity in the specified database.
             *
             * @param {object} params
             *                 Object containing name of the project & details of the table to be created.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            deleteEntity: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "deleteEntity",
                    urlParams: {
                        projectID: params.projectID,
                        dataModelName: params.dataModelName,
                        entityName: params.entityName
                    }
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#addPrimaryKey
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to add columns to the specified table in the specified database.
             *
             * @param {object} params
             *                 Object containing name of the project & details of the database, table, column to be created/updated.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            addPrimaryKey: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "addPrimaryKey",
                    urlParams: {
                        projectID: params.projectID,
                        dataModelName: params.dataModelName,
                        entityName: params.entityName
                    },
                    data: params.data
                }, successCallback, failureCallback);
            },
            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#addColumns
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to add columns to the specified table in the specified database.
             *
             * @param {object} params
             *                 Object containing name of the project & details of the database, table, column to be created/updated.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            addColumns: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "addColumns",
                    urlParams: {
                        projectID: params.projectID,
                        dataModelName: params.dataModelName,
                        entityName: params.entityName
                    },
                    data: params.data
                }, successCallback, failureCallback);
            },
            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#updateColumn
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to update the columns of the specified table in the specified database.
             *
             * @param {object} params
             *                 Object containing name of the project & details of the database, table, column to be created/updated.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            updateColumn: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "updateColumn",
                    urlParams: {
                        projectID: params.projectID,
                        dataModelName: params.dataModelName,
                        entityName: params.entityName,
                        columnName: params.columnName,
                        forceDataLoss: params.forceDataLoss || false
                    },
                    data: params.data
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#deleteColumn
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to delete the specified column of the specified table in the specified database.
             *
             * @param {object} params
             *                 Object containing name of the project & details of the database, table, column to be created/updated.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            deleteColumn: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "deleteColumn",
                    urlParams: {
                        projectID: params.projectID,
                        dataModelName: params.dataModelName,
                        entityName: params.entityName,
                        columnName: params.columnName
                    }
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#addRelation
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to add a relation to the specified table in the specified database.
             *
             * @param {object} params
             *                 Object containing name of the project, name of the database, table and relations to be updated.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            addRelation: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "addRelation",
                    urlParams: {
                        projectID: params.projectID,
                        dataModelName: params.dataModelName,
                        entityName: params.entityName
                    },
                    data: params.data
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#updateRelation
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to update the specified relation of the specified table in the specified database.
             *
             * @param {object} params
             *                 Object containing name of the project, name of the database, table and relations to be updated.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            updateRelation: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "updateRelation",
                    urlParams: {
                        projectID: params.projectID,
                        dataModelName: params.dataModelName,
                        entityName: params.entityName,
                        relationName: params.relationName
                    },
                    data: params.data
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#deleteRelation
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to delete the specified relation of the specified table in the specified database.
             *
             * @param {object} params
             *                 Object containing name of the project, name of the database, table and relations to be updated.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            deleteRelation: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "deleteRelation",
                    urlParams: {
                        projectID: params.projectID,
                        dataModelName: params.dataModelName,
                        entityName: params.entityName,
                        relationName: params.relationName
                    }
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#getAllQueries
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to list/retrieve all the queries in the specified database.
             *
             * @param {object} params
             *                 Object containing name of the project, name of the database, table and relations to be updated.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            getAllQueries: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "getAllQueries",
                    urlParams: {
                        projectID: params.projectID,
                        dataModelName: params.dataModelName
                    }
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#getQuery
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to retrieve the specified query from the specified database.
             *
             * @param {object} params
             *                 Object containing name of the project, name of the database and query to be fetched.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            getQuery: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "getQuery",
                    urlParams: {
                        projectID: params.projectID,
                        dataModelName: params.dataModelName,
                        queryName: params.queryName
                    }
                }, successCallback, failureCallback);
            },
            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#createQuery
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to create a query in the specified database.
             *
             * @param {object} params
             *                 Object containing name of the project, name of the database and query to be fetched.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            createQuery: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "createQuery",
                    urlParams: {
                        projectID: params.projectID,
                        dataModelName: params.dataModelName
                    },
                    data: params.data
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#setQueryMetaData
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to set the meta-data for the specified query from the specified database.
             *
             * @param {object} params
             *                 Object containing name of the project, name of the database and query for which meta-data needs to be set.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */
            setQueryMetaData: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "setQueryMetaData",
                    urlParams: {
                        projectID: params.projectID,
                        dataModelName: params.dataModelName,
                        queryName: params.queryName
                    },
                    data: params.data
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#updateQuery
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to update the specified query from the specified database.
             *
             * @param {object} params
             *                 Object containing name of the project, name of the database and query to be fetched.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            updateQuery: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "updateQuery",
                    urlParams: {
                        projectID: params.projectID,
                        dataModelName: params.dataModelName,
                        queryName: params.queryName
                    },
                    data: params.data
                }, successCallback, failureCallback);
            },
            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#deleteQuery
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to delete the specified query from the specified database.
             *
             * @param {object} params
             *                 Object containing name of the project, name of the database and query to be deleted.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            deleteQuery: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "deleteQuery",
                    urlParams: {
                        projectID: params.projectID,
                        dataModelName: params.dataModelName,
                        queryName: params.queryName
                    }
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#validateQuery
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to validate the specified query in the specified database.
             *
             * @param {object} params
             *                 Object containing name of the project, name of the database, table and relations to be updated.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            validateQuery: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "validateQuery",
                    urlParams: {
                        projectID: params.projectID,
                        dataModelName: params.dataModelName
                    },
                    data: params.queryDetails
                }, successCallback, failureCallback);
            },
            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#executeQuery
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to execute the specified query in the specified database.
             *
             * @param {object} params
             *                 Object containing name of the project, name of the database, table and relations to be updated.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            executeQuery: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "executeQuery",
                    urlParams: {
                        projectID: params.projectID,
                        dataModelName: params.dataModelName
                    },
                    data: params.data
                }, successCallback, failureCallback);
            },
            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#getAllProcedures
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to list/retrieve all the procedures in the specified database.
             *
             * @param {object} params
             *                 Object containing name of the project, name of the database, table and relations to be updated.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            getAllProcedures: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "getAllProcedures",
                    urlParams: {
                        projectID: params.projectID,
                        dataModelName: params.dataModelName
                    }
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#getProcedure
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to retrieve the specified procedure from the specified database.
             *
             * @param {object} params
             *                 Object containing name of the project, name of the database and procedure to be fetched.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            getProcedure: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "getProcedure",
                    urlParams: {
                        projectID: params.projectID,
                        dataModelName: params.dataModelName,
                        procedureName: params.procedureName
                    }
                }, successCallback, failureCallback);
            },
            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#createProcedure
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to create a procedure in the specified database.
             *
             * @param {object} params
             *                 Object containing name of the project, name of the database and procedure to be fetched.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            createProcedure: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "createProcedure",
                    urlParams: {
                        projectID: params.projectID,
                        dataModelName: params.dataModelName
                    },
                    data: params.data
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#setProcedureMetaData
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to set the meta-data for the specified query from the specified database.
             *
             * @param {object} params
             *                 Object containing name of the project, name of the database and query for which meta-data needs to be set.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */
            setProcedureMetaData: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "setProcedureMetaData",
                    urlParams: {
                        projectID: params.projectID,
                        dataModelName: params.dataModelName,
                        procedureName: params.procedureName
                    },
                    data: params.data
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#updateProcedure
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to update the specified procedure from the specified database.
             *
             * @param {object} params
             *                 Object containing name of the project, name of the database and query to be fetched.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            updateProcedure: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "updateProcedure",
                    urlParams: {
                        projectID: params.projectID,
                        dataModelName: params.dataModelName,
                        procedureName: params.procedureName
                    },
                    data: params.data
                }, successCallback, failureCallback);
            },
            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#deleteProcedure
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to delete the specified query from the specified database.
             *
             * @param {object} params
             *                 Object containing name of the project, name of the database and query to be deleted.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            deleteProcedure: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "deleteProcedure",
                    urlParams: {
                        projectID: params.projectID,
                        dataModelName: params.dataModelName,
                        procedureName: params.procedureName
                    }
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#validateProcedure
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to validate the specified query in the specified database.
             *
             * @param {object} params
             *                 Object containing name of the project, name of the database, table and relations to be updated.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            validateProcedure: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "validateProcedure",
                    urlParams: {
                        projectID: params.projectID,
                        dataModelName: params.dataModelName
                    },
                    data: params.queryDetails
                }, successCallback, failureCallback);
            },
            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#executeProcedure
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to execute the specified query in the specified database.
             *
             * @param {object} params
             *                 Object containing name of the project, name of the database, table and relations to be updated.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            executeProcedure: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "executeProcedure",
                    urlParams: {
                        projectID: params.projectID,
                        dataModelName: params.dataModelName
                    },
                    data: params.data
                }, successCallback, failureCallback);
            },
            /**
             * Internal function
             * @name wm.database.$DatabaseService#getSampleDbConnectionProperties
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to retrieve the connection properties for sample database.
             *
             * @param {object} params
             *                 Object containing name of the project.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            getSampleDbConnectionProperties: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "getSampleDbConnectionProperties",
                    urlParams: {
                        projectID: params.projectID
                    }
                }, successCallback, failureCallback);
            },
            /**
             * Internal function
             * @name wm.database.$DatabaseService#getConnectionProperties
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to retrieve the connection properties for the specified database.
             *
             * @param {object} params
             *                 Object containing name of the project & name of the database.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            getConnectionProperties: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "getConnectionProperties",
                    urlParams: {
                        projectID: params.projectID,
                        serviceId: params.dataModelName
                    }
                }, successCallback, failureCallback);
            },

            /**
             * Internal function
             * @name wm.database.$DatabaseService#updateConnectionProperties
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to update the connection properties for the specified database.
             *
             * @param {object} params
             *                 Object containing name of the project, name of the database and connection settings to be updated.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            updateConnectionProperties: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "updateConnectionProperties",
                    urlParams: {
                        projectID: params.projectID,
                        serviceId: params.dataModelName
                    },
                    data: params.data
                }, successCallback, failureCallback);
            },
            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#getTypesMap
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to get types map having sql and java types.
             *
             * @param {object} params
             *                 Object containing project id.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */
            getTypesMap: function (params, successCallback, failureCallback) {

                BaseService.execute({
                    target: "Database",
                    action: "getTypesMap",
                    urlParams: {
                        projectID: params.projectID
                    }
                }, successCallback, failureCallback);
            },
            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#readTableData
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to read the data from the specified table.
             *
             * @param {object} params
             *                 Object containing name of the project & details of the table.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            readTableData: function (params, successCallback, failureCallback) {
                return initiateAction("readTableData", params, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#searchTableData
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to read the related data from the specified table.
             *
             * @param {object} params
             *                 Object containing name of the project & details of the table.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            searchTableData: function (params, successCallback, failureCallback) {
                return initiateAction("searchTableData", params, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#readTableRelatedData
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to refor data matching the specified criteria in the specified table.
             *
             * @param {object} params
             *                 Object containing name of the project & details of the table.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            readTableRelatedData: function (params, successCallback, failureCallback) {
                return initiateAction("readTableRelatedData", params, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#insertTableData
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to insert data into the specified table.
             *
             * @param {object} params
             *                 Object containing name of the project & table data to be inserted.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            insertTableData: function (params, successCallback, failureCallback) {
                return initiateAction("insertTableData", params, successCallback, failureCallback);
            },
            /**
             * @name wm.database.$DatabaseService#insertMultiPartTableData
             * @ngdoc function
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to insert data into the specified table.
             *
             * @param {object} params
             *                 Object containing name of the project & table data to be inserted.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */
            insertMultiPartTableData: function (params, successCallback, failureCallback) {
                return initiateAction("insertMultiPartTableData", params, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#updateTableData
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to update data in the specified table.
             *
             * @param {object} params
             *                 Object containing name of the project & table data to be updated.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            updateTableData: function (params, successCallback, failureCallback) {
                return initiateAction("updateTableData", params, successCallback, failureCallback);
            },
            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#updateMultiPartTableData
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to update data in the specified table.
             *
             * @param {object} params
             *                 Object containing name of the project & table data to be updated.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            updateMultiPartTableData: function (params, successCallback, failureCallback) {
                return initiateAction("updateMultiPartTableData", params, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#deleteTableData
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to delete data from the specified table.
             *
             * @param {object} params
             *                 Object containing name of the project & table data to be deleted.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            deleteTableData: function (params, successCallback, failureCallback) {
                return initiateAction("deleteTableData", params, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#updateCompositeTableData
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to update data in the specified table (table with composite key).
             *
             * @param {object} params
             *                 Object containing name of the project & table data to be updated.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            updateCompositeTableData: function (params, successCallback, failureCallback) {
                return initiateAction("updateCompositeTableData", params, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.database.$DatabaseService#deleteCompositeTableData
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to delete data from the specified table (table with composite key).
             *
             * @param {object} params
             *                 Object containing name of the project & table data to be deleted.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            deleteCompositeTableData: function (params, successCallback, failureCallback) {
                return initiateAction("deleteCompositeTableData", params, successCallback, failureCallback);
            },

            /*
             * @ngdoc function
             * @name wm.database.$DatabaseService#executeNamedQuery
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to execute the specified named query.
             *
             * @param {object} params
             *                 Object containing name of the project, name of the database and query to be executed.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            executeNamedQuery: function (params, successCallback, failureCallback) {
                return initiateAction("executeNamedQuery", params, successCallback, failureCallback);
            },

            /*
             * @ngdoc function
             * @name wm.database.$DatabaseService#executeNamedProcedure
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to execute the specified named procedure.
             *
             * @param {object} params
             *                 Object containing name of the project, name of the database and query to be executed.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            executeNamedProcedure: function (params, successCallback, failureCallback) {
                return initiateAction("executeNamedProcedure", params, successCallback, failureCallback);
            },

            /*
             * @ngdoc function
             * @name wm.database.$DatabaseService#executeCustomQuery
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to execute a custom query.
             *
             * @param {object} params
             *                 Object containing name of the project, name of the database and query to be executed.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            executeCustomQuery: function (params, successCallback, failureCallback) {
                return initiateAction("executeCustomQuery", params, successCallback, failureCallback);
            },

            /*
             * @ngdoc function
             * @name wm.database.$DatabaseService#executeCustomProcedure
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to execute a custom procedure.
             *
             * @param {object} params
             *                 Object containing name of the project, name of the database and procedure to be executed.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            executeCustomProcedure: function (params, successCallback, failureCallback) {
                return initiateAction("executeCustomProcedure", params, successCallback, failureCallback);
            },

            /*
             * @ngdoc function
             * @name wm.database.$DatabaseService#getCustomQueryMetaData
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to execute a custom query and get the meta-data.
             *
             * @param {object} params
             *                 Object containing name of the project, name of the database and query to be executed.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            getCustomQueryMetaData: function (params, successCallback, failureCallback) {
                return initiateAction("getCustomQueryMetaData", params, successCallback, failureCallback);
            },
            /*
             * @ngdoc function
             * @name wm.database.$DatabaseService#getCustomProcedureMetaData
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to execute a custom procedure and get the meta-data.
             *
             * @param {object} params
             *                 Object containing name of the project, name of the database and procedure to be executed.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            getCustomProcedureMetaData: function (params, successCallback, failureCallback) {
                return initiateAction("getCustomProcedureMetaData", params, successCallback, failureCallback);
            },

            /*
             * @ngdoc function
             * @name wm.database.$DatabaseService#executeCustomUpdateQuery
             * @methodOf wm.database.$DatabaseService
             * @function
             *
             * @description
             * Method to execute a custom query that updates the database.
             *
             * @param {object} params
             *                 Object containing name of the project, name of the database and query to be executed.
             * @param {function=} successCallback
             *                    Callback function to be triggered on success.
             * @param {function=} failureCallback
             *                    Callback function to be triggered on failure.
             */

            executeCustomUpdateQuery: function (params, successCallback, failureCallback) {
                return initiateAction("executeCustomUpdateQuery", params, successCallback, failureCallback);
            }
        };
    }
];

/*global WM, wm*/

/*Defining module for Web services */
wm.plugins.webServices = WM.module('wm.plugins.webServices', ['base64']);

wm.plugins.webServices.controllers = {};
wm.plugins.webServices.services = {};
wm.plugins.webServices.factories = {};

wm.plugins.webServices.controller(wm.plugins.webServices.controllers);
wm.plugins.webServices.service(wm.plugins.webServices.services);
wm.plugins.webServices.factory(wm.plugins.webServices.factories);

/*defining constants for web services module*/
wm.plugins.webServices.constant('WS_SERVICE_URLS', {
    WebService: {
        invokeRestCall: {
            url: "services/restservices/invoke",
            method: "POST"
        },
        generateRESTWsdlSettings: {
            url: "services/projects/:projectID/restservice/settings",
            method: "POST"
        },
        buildRestService: {
            url: "services/projects/:projectID/restservice",
            method: "POST"
        },
        updateRestService: {
            url: "services/projects/:projectID/restservice",
            method: "PUT"
        },
        importWSDL: {
            url: "services/projects/:projectID/soapservice/import",
            method: "POST"
        },
        uploadWSDL: {
            url: "services/projects/:projectID/soapservice/import",
            method: "POST",
            headers: {
                'Content-Type': undefined
            },
            transformRequest: WM.identity
        },
        registerFeedService: {
            url: "services/projects/:projectID/feed/register",
            method: "POST"
        },
        getRESTDetails: {
            url: "services/projects/:projectID/restservice/:serviceID",
            method: "GET"
        },
        getWSDL: {
            url: "services/projects/:projectID/soapservice/:serviceID/wsdl",
            method: "GET"
        },
        getBindingProperties: {
            url: "services/projects/:projectID/services/:serviceID/properties",
            method: "GET"
        },
        setBindingProperties: {
            url: "services/projects/:projectID/services/:serviceID/properties",
            method: "POST"
        },
        listTypes: {
            url: "services/projects/:projectID/services/types",
            method: "GET"
        },
        listPrefabTypes: {
            url: "services/projects/:projectID/prefabs/:prefabName/types",
            method: "GET"
        },
        listServicesWithType: {
            url: "services/projects/:projectID/services",
            method: "GET"
        },
        getServiceMethods: {
            url: 'services/projects/:projectID/services/:serviceID/operations',
            method: "GET"
        },
        getServiceOperationParams: {
            url: 'services/projects/:projectID/services/:serviceID/operations/:operationID',
            method: "GET"
        },
        invoke: {
            url: '/:serviceFile',
            method: "POST"
        },
        invokeRestService: {
            url: '/services/:serviceID/:operationID',
            method: "POST"
        },
        invokePrefabRestService: {
            url: '/:serviceID/:operationID',
            method: "POST"
        },
        remove: {
            url: 'services/projects/:projectID/services/:serviceID',
            method: "DELETE"
        },
        retrieveServiceOperations: {
            url: 'services/projects/:projectId/services/:serviceId/servicedef',
            method: "GET"
        },
        invokeRuntimeRestCall: {
            url: ''
        },
        buildApiRestService: {
            url: "services/restservices/create",
            method: "POST"
        },
        getSoapServiceSettings: {
            url: "services/projects/:projectId/soapservice/:serviceId/settings",
            method: "GET"
        },
        setSoapServiceSettings: {
            url: "services/projects/:projectId/soapservice/:serviceId/settings",
            method: "POST"
        }
    }
});

/*Defining the constants for the web services module*/
wm.plugins.webServices.constant('WS_CONSTANTS', {
    WEBSERVICE_WORKSPACE_TYPE: "ws",
    HTTP_METHODS: ["GET", "POST", "PUT", "HEAD", "PATCH", "DELETE", "TRACE", "OPTIONS"],
    NON_BODY_HTTP_METHODS: ["GET", "HEAD"],
    PRIMITIVE_DATA_TYPES: ["number", "integer", "string", "boolean", "file"],
    OPERATION_NAME_KEY: "x-WM-METHOD_NAME",
    CONTENT_TYPES: {
        FORM_URL_ENCODED: "application/x-www-form-urlencoded",
        MULTIPART_FORMDATA: "multipart/form-data",
        OCTET_STREAM: "application/octet-stream"
    }
});

/*Defining the config for the web service plugins*/
wm.plugins.webServices.config(function (BaseServiceManagerProvider, WS_SERVICE_URLS) {
    'use strict';

    BaseServiceManagerProvider.register(WS_SERVICE_URLS);
});
/*End of Web services Modules*/

/*global WM, wm*/
/*jslint todo: true */
/**
 * @ngdoc service
 * @name wm.webservice.$WebService
 * @description
 * The `WebService` provides the details about the web based service apis
 */

wm.plugins.webServices.services.WebService = function (BaseService) {
    'use strict';

    /* APIs returned by the WebService.*/
    return {

        /**
         * @ngdoc function
         * @name wm.webservice.$WebService#testRestService
         * @methodOf wm.webservice.$WebService
         * @function
         *
         * @description
         * tests a REST service through the specified url of teh service. Returns the response of the service (else throws an error message)
         *
         * @param {object} connectionParams object containing parameters for the request
         * @param {function} successCallback to be called on success
         * @param {function} failureCallback to be called on failure
         */

        testRestService: function (connectionParams, successCallback, failureCallback) {

            BaseService.send({
                target: 'WebService',
                action: 'invokeRestCall',
                data: connectionParams
            }, successCallback, failureCallback);
        },

        /**
         * @ngdoc function
         * @name wm.webservice.$WebService#populateRestService
         * @methodOf wm.webservice.$WebService
         * @function
         *
         * @description
         * takes a REST service url and gives out the default field values required to build/import the REST service
         *
         * @param {object} connectionParams object containing parameters for the request (else throws an error message)
         * @param {function} successCallback to be called on success
         * @param {function} failureCallback to be called on failure
         */

        populateRestService: function (connectionParams, successCallback, failureCallback) {

            BaseService.send({
                target: 'WebService',
                action: 'generateRESTWsdlSettings',
                data : connectionParams.data,
                urlParams: connectionParams.urlParams
            }, successCallback, failureCallback);
        },

        /**
         * @ngdoc function
         * @name wm.webservice.$WebService#buildRestService
         * @methodOf wm.webservice.$WebService
         * @function
         *
         * @description
         * builds/imports a REST service
         *
         * @param {object} connectionParams object containing parameters for the request
         * @param {function} successCallback to be called on success
         * @param {function} failureCallback to be called on failure
         */

        buildRestService: function (connectionParams, successCallback, failureCallback) {

            BaseService.send({
                target: 'WebService',
                action: 'buildRestService',
                data : connectionParams.data,
                urlParams: connectionParams.urlParams
            }, successCallback, failureCallback);
        },

        /**
         * @ngdoc function
         * @name wm.webservice.$WebService#updateRestService
         * @methodOf wm.webservice.$WebService
         * @function
         *
         * @description
         * updates a REST service
         *
         * @param {object} connectionParams object containing parameters for the request
         * @param {function} successCallback to be called on success
         * @param {function} failureCallback to be called on failure
         */

        updateRestService: function (connectionParams, successCallback, failureCallback) {

            BaseService.send({
                target: 'WebService',
                action: 'updateRestService',
                data : connectionParams.data,
                urlParams: connectionParams.urlParams
            }, successCallback, failureCallback);
        },

        /**
         * @ngdoc function
         * @name wm.webservice.$WebService#importWSDL
         * @methodOf wm.webservice.$WebService
         * @function
         *
         * @description
         * imports a soap service through the WSDL URL of the service (else throws an error message)
         *
         * @param {object} connectionParams object containing parameters for the request
         * @param {function} successCallback to be called on success
         * @param {function} failureCallback to be called on failure
         */

        importWSDL: function (connectionParams, successCallback, failureCallback) {

            BaseService.send({
                target: 'WebService',
                action: 'importWSDL',
                params: connectionParams.params,
                urlParams: connectionParams.urlParams
            }, successCallback, failureCallback);
        },

        /**
         * @ngdoc function
         * @name wm.webservice.$WebService#importWSDL
         * @methodOf wm.webservice.$WebService
         * @function
         *
         * @description
         * imports a soap service through the WSDL URL of the service (else throws an error message)
         *
         * @param {object} connectionParams object containing parameters for the request
         * @param {function} successCallback to be called on success
         * @param {function} failureCallback to be called on failure
         */

        uploadWSDL: function (connectionParams, successCallback, failureCallback) {

            BaseService.send({
                target: 'WebService',
                action: 'uploadWSDL',
                params: connectionParams.params,
                urlParams: connectionParams.urlParams,
                data: connectionParams.content
            }, successCallback,failureCallback);
        },

        /**
         * @ngdoc function
         * @name wm.webservice.$WebService#listServicesWithType
         * @methodOf wm.webservice.$WebService
         * @function
         *
         * @description
         * fetches all the services in a project from backend (else throws an error message)
         *
         * @param {function} urlParams params required for the service
         * @param {function} successCallback to be called on success
         * @param {function} failureCallback to be called on failure
         */

        listServicesWithType: function (urlParams, successCallback, failureCallback) {

            BaseService.send({
                target: 'WebService',
                action: 'listServicesWithType',
                urlParams: urlParams
            }, successCallback, failureCallback);
        },

        /**
         * @ngdoc function
         * @name wm.webservice.$WebService#getServiceOperations
         * @methodOf wm.webservice.$WebService
         * @function
         *
         * @description
         * gets the operations corresponding to a service (else throws an error message)
         *
         * @param {object} urlParams parameters required for the service
         * @param {function} successCallback to be called on success
         * @param {function} failureCallback to be called on failure
         */

        getServiceOperations: function (urlParams, successCallback, failureCallback) {

            BaseService.send({
                target: 'WebService',
                action: 'getServiceMethods',
                urlParams : urlParams
            }, successCallback, failureCallback);
        },

        /**
         * @ngdoc function
         * @name wm.webservice.$WebService#getServiceOperationParams
         * @methodOf wm.webservice.$WebService
         * @function
         *
         * @description
         * gets the params and return types corresponding to an operation of a service (else throws an error message)
         *
         * @param {object} urlParams parameters required for the service
         * @param {function} successCallback to be called on success
         * @param {function} failureCallback to be called on failure
         */
        getServiceOperationParams: function (urlParams, successCallback, failureCallback) {

            BaseService.send({
                target: 'WebService',
                action: 'getServiceOperationParams',
                urlParams : urlParams
            }, successCallback, failureCallback);
        },

        /**
         * @ngdoc function
         * @name wm.webservice.$WebService#getRESTDetails
         * @methodOf wm.webservice.$WebService
         * @function
         *
         * @description
         * gets the details for an existing REST web service in a project.
         *
         * @param {object} urlParams parameters required for the service
         * @param {function} successCallback to be called on success
         * @param {function} failureCallback to be called on failure
         */
        getRESTDetails: function (urlParams, successCallback, failureCallback) {

            BaseService.send({
                target: 'WebService',
                action: 'getRESTDetails',
                urlParams: urlParams
            }, successCallback, failureCallback);
        },

        /**
         * @ngdoc function
         * @name wm.webservice.$WebService#getSoapServiceSettings
         * @methodOf wm.webservice.$WebService
         * @function
         *
         * @description
         * gets the details for an existing SOAP web service in a project.
         *
         * @param {object} urlParams parameters required for the service
         * @param {function} successCallback to be called on success
         * @param {function} failureCallback to be called on failure
         */
        getSoapServiceSettings: function (urlParams, successCallback, failureCallback) {

            BaseService.send({
                target: 'WebService',
                action: 'getSoapServiceSettings',
                urlParams: urlParams
            }, successCallback, failureCallback);
        },

        /**
         * @ngdoc function
         * @name wm.webservice.$WebService#setSoapServiceSettings
         * @methodOf wm.webservice.$WebService
         * @function
         *
         * @description
         * gets the details for an existing SOAP web service in a project.
         *
         * @param {object} urlParams parameters required for the service
         * @param {function} successCallback to be called on success
         * @param {function} failureCallback to be called on failure
         */
        setSoapServiceSettings: function (connectionParams, successCallback, failureCallback) {

            BaseService.send({
                target: 'WebService',
                action: 'setSoapServiceSettings',
                data : connectionParams.data,
                urlParams: connectionParams.urlParams
            }, successCallback,failureCallback);
        },


        /**
         * @ngdoc function
         * @name wm.webservice.$WebService#getWSDL
         * @methodOf wm.webservice.$WebService
         * @function
         *
         * @description
         * gets the wsdl corresponding to a service (else throws an error message)
         *
         * @param {object} urlParams parameters required for the service
         * @param {function} successCallback to be called on success
         * @param {function} failureCallback to be called on failure
         */
        getWSDL: function (urlParams, successCallback, failureCallback) {

            BaseService.send({
                target: 'WebService',
                action: 'getWSDL',
                urlParams: urlParams
            }, successCallback, failureCallback);
        },

        /**
         * @ngdoc function
         * @name wm.webservice.$WebService#getBindingProperties
         * @methodOf wm.webservice.$WebService
         * @function
         *
         * @description
         * gets the binding properties corresponding to a service (else throws an error message)
         *
         * @param {string} projectName current project name
         * @param {string} serviceId id of the service for which methods are required
         * @param {function} successCallback to be called on success
         * @param {function} failureCallback to be called on failure
         */
        getBindingProperties: function (urlParams, successCallback, failureCallback) {

            BaseService.send({
                target: 'WebService',
                action: 'getBindingProperties',
                urlParams: urlParams
            }, successCallback, failureCallback);
        },

        /**
         * @ngdoc function
         * @name wm.webservice.$WebService#setBindingProperties
         * @methodOf wm.webservice.$WebService
         * @function
         *
         * @description
         * sets the(modified) binding properties corresponding to a service (else throws an error message)
         *
         * @param {object} urlParams parameters required for the service
         * @param {object} data post data parameters required for the service
         * @param {function} successCallback to be called on success
         * @param {function} failureCallback to be called on failure
         */
        setBindingProperties: function (urlParams, data, successCallback, failureCallback) {

            BaseService.send({
                target: 'WebService',
                action: 'setBindingProperties',
                urlParams: urlParams,
                data: data
            }, successCallback, failureCallback);
        },

        /**
         * @ngdoc function
         * @name wm.webservice.$WebService#listTypes
         * @methodOf wm.webservice.$WebService
         * @function
         *
         * @description
         * gets the available data types corresponding to a project (else throws an error message)
         *
         * @param {object} urlParams parameters required for the service
         * @param {function} successCallback to be called on success
         * @param {function} failureCallback to be called on failure
         */
        listTypes: function (urlParams, successCallback, failureCallback) {

            BaseService.send({
                target: 'WebService',
                action: 'listTypes',
                urlParams: urlParams
            }, successCallback, failureCallback);
        },

        /**
         * @ngdoc function
         * @name wm.webservice.$WebService#listTypes
         * @methodOf wm.webservice.$WebService
         * @function
         *
         * @description
         * gets the available data types corresponding to a prefab (else throws an error message)
         *
         * @param {object} urlParams parameters required for the service
         * @param {function} successCallback to be called on success
         * @param {function} failureCallback to be called on failure
         */
        listPrefabTypes: function (urlParams, successCallback, failureCallback) {

            BaseService.send({
                target: 'WebService',
                action: 'listPrefabTypes',
                urlParams: urlParams
            }, successCallback, failureCallback);
        },

        /**
         * @ngdoc function
         * @name wm.webservice.$WebService#registerFeedService
         * @methodOf wm.webservice.$WebService
         * @function
         *
         * @description
         * registers a feed service to a project (else throws an error message)
         *
         * @param {object} connectionParams parameters required for the service
         * @param {function} successCallback to be called on success
         * @param {function} failureCallback to be called on failure
         */
        registerFeedService: function (connectionParams, successCallback, failureCallback) {

            BaseService.send({
                target: 'WebService',
                action: 'registerFeedService',
                urlParams: connectionParams
            }, successCallback, failureCallback);
        },

        /**
         * @ngdoc function
         * @name wm.webservice.$WebService#invoke
         * @methodOf wm.webservice.$WebService
         * @function
         *
         * @description
         * calls a web service and retrieves the data from the service(used in run mode)
         *
         * @param {object} connectionParams parameters required for the service
         * @param {function} successCallback to be called on success
         * @param {function} failureCallback to be called on failure
         */
        invoke: function (connectionParams, successCallback, failureCallback) {
            return BaseService.send({
                target: 'WebService',
                action: 'invoke',
                urlParams: {
                    "serviceFile": connectionParams.serviceFile
                },
                data: {
                    "id": 123,
                    "method": connectionParams.method,
                    "params": connectionParams.params
                },
                config: {
                    "url": connectionParams.url
                },
                "byPassResult": true
            }, successCallback, failureCallback);
        },

        /**
         * @ngdoc function
         * @name wm.webservice.$WebService#invokeRestService
         * @methodOf wm.webservice.$WebService
         * @function
         *
         * @description
         * calls a REST web service and retrieves the data from the service(used in run mode)
         *
         * @param {object} connectionParams parameters required for the service
         * @param {function} successCallback to be called on success
         * @param {function} failureCallback to be called on failure
         */
        invokeRestService: function (connectionParams, successCallback, failureCallback) {
            return BaseService.send({
                target: 'WebService',
                action: connectionParams.target,
                data: connectionParams.params[2],
                urlParams: {
                    serviceID: connectionParams.params[0] ,
                    operationID: connectionParams.params[1]
                },
                config: {
                    "url": connectionParams.url
                },
                "byPassResult": true
            }, successCallback, failureCallback);
        },

        /**
         * @ngdoc function
         * @name wm.webservice.$WebService#remove
         * @methodOf wm.webservice.$WebService
         * @function
         *
         * @description
         * removes the specified web service from the project
         *
         * @param {object} urlParams parameters required for the service
         * @param {function} successCallback to be called on success
         * @param {function} failureCallback to be called on failure
         */

        remove: function (urlParams, successCallback, failureCallback) {

            BaseService.send({
                target: 'WebService',
                action: 'remove',
                urlParams : urlParams
            }, successCallback, failureCallback);
        },

        /**
         * @ngdoc function
         * @name wm.webservice.$WebService#retrieveServiceOperations
         * @methodOf wm.webservice.$WebService
         * @function
         *
         * @description
         * retrieves the specific operations for the specified service
         *
         * @param {object} params parameters required for the service
         * @param {function} successCallback to be called on success
         * @param {function} failureCallback to be called on failure
         */
        retrieveServiceOperations: function (params, successCallback, failureCallback) {
            BaseService.send({
                target: 'WebService',
                action: 'retrieveServiceOperations',
                urlParams: params.urlParams
            }, successCallback, failureCallback);
        },
        /**
         * @ngdoc function
         * @name wm.webservice.$WebService#invokeJavaService
         * @methodOf wm.webservice.$WebService
         * @function
         *
         * @description
         * invokes the java service
         *
         * @param {object} params parameters required for the service
         * @param {function} successCallback to be called on success
         * @param {function} failureCallback to be called on failure
         */
        invokeJavaService: function (params, successCallback, failureCallback) {
            BaseService.send({
                target: 'WebService',
                action: 'invokeRuntimeRestCall',
                method: params.method,
                config: {
                    url : params.url,
                    method: params.method,
                    headers: params.headers
                },
                data: params.dataParams || undefined,
                "byPassResult": true
            }, successCallback, failureCallback);
        },
        /**
         * @ngdoc function
         * @name wm.webservice.$WebService#buildApiRestService
         * @methodOf wm.webservice.$WebService
         * @function
         *
         * @description
         * takes a REST service url and gives out the default field values required to build/import the REST service
         *
         * @param {object} connectionParams object containing parameters for the request (else throws an error message)
         * @param {function} successCallback to be called on success
         * @param {function} failureCallback to be called on failure
         */
        buildApiRestService: function (connectionParams, successCallback, failureCallback) {

            BaseService.send({
                target: 'WebService',
                action: 'buildApiRestService',
                data: connectionParams
            }, successCallback, failureCallback);
        }
    };
};
/*global WM, wm*/
/*jslint sub: true */

/**
 * @ngdoc service
 * @name wm.webservice.$ServiceFactory
 * @description
 * The `ServiceFactory` keeps and exposes the services and their details in an object.
 */
wm.plugins.webServices.factories.ServiceFactory = [
    "WebService",
    "wmToaster",
    "$rootScope",
    "Utils",
    "VARIABLE_CONSTANTS",
    "WS_CONSTANTS",

    function (WebService, wmToaster, $rootScope, Utils, VARIABLE_CONSTANTS, WS_CONSTANTS) {
        "use strict";

        /*Array to hold service objects*/
        var services = [],
            projectId = $rootScope.project && $rootScope.project.id,
            requestQueue = {
                'services': [],
                'operations': {},
                'serviceDef': {}
            },
            serviceDefMap = {},
            supportedOperations = WS_CONSTANTS.HTTP_METHODS.map(function(method){return method.toLowerCase();}),
            primitiveDataTypes = WS_CONSTANTS.PRIMITIVE_DATA_TYPES,
            IS_LIST_KEY = 'x-WM-IS_LIST',
            UNIQUE_ITEMS_KEY = 'uniqueItems',
            FULLY_QUALIFIED_NAME_KEY = 'x-WM-FULLY_QUALIFIED_NAME',
            parameterTypeKey = 'in',
            AUTH_TYPE_KEY = 'WM_Rest_Service_Authorization',

        /*function to get service object matching its name*/
            getServiceObjectByName = function (name) {
                var serviceObject = {operations: []};
                WM.forEach(services, function (serviceObj) {
                    if (serviceObj.name === name) {
                        serviceObject = serviceObj;
                    }
                });
                return serviceObject;
            },

        /*function to get service operation object matching its name*/
            getServiceOperationObjectByName = function (serviceName, operationName) {
                var serviceObj, operationObject = {};
                serviceObj = getServiceObjectByName(serviceName);
                WM.forEach(serviceObj.operations, function (operation) {
                    if (operation.name === operationName) {
                        operationObject = operation;
                    }
                });
                return operationObject;
            },

        /*function to get list of services from the backend*/
            getServicesWithType = function (successCallBack, reloadFlag) {
                /*sanity checking of the params*/
                reloadFlag = !((!reloadFlag || reloadFlag === 'false'));

                /*if services already fetched once and reloadFlag not set, return the fetched services*/
                if (services.length > 0 && !reloadFlag) {
                    Utils.triggerFn(successCallBack, services);
                    return;
                }

                requestQueue['services'] = requestQueue['services'] || [];
                requestQueue['services'].push(successCallBack);
                /* if same queue is already in progress, do not send another request */
                if (requestQueue['services'].length > 1) {
                    return;
                }

                /*data for the request*/
                var urlParams = {
                    projectID: projectId || $rootScope.project.id
                };

                /* Fetch the available web/data services for the current project*/
                WebService.listServicesWithType(urlParams, function (response) {
                    /*clean the array before inserting the fetched services*/
                    services = [];

                    /*loop over the response to fill the services variable*/
                    WM.forEach(response, function (serviceObj) {
                        services.push({
                            type: serviceObj.type,
                            name: serviceObj.name,
                            url: serviceObj.url,
                            operations: []
                        });
                    });

                    /*send the services to the callback*/
                    WM.forEach(requestQueue['services'], function (fn) {
                        Utils.triggerFn(fn, services);
                    });
                    requestQueue['services'] = null;
                }, function () {
                    wmToaster.show("error", $rootScope.locale["MESSAGE_ERROR_TITLE"], $rootScope.locale["MESSAGE_ERROR_FETCH_WEB_DATA_SERVICES_DESC"]);
                });
            },

            /*function to get the full serviceDef (api doc)*/
            getServiceDef = function (serviceId, success, error, forceReload) {
                var callback,
                    urlParams = {
                        "urlParams": {
                            serviceId: serviceId,
                            projectId: $rootScope.project.id
                        }
                    };
                if (serviceDefMap[serviceId] && !forceReload) {
                    /*if operations are already present, return the cached response*/
                    Utils.triggerFn(success, serviceDefMap[serviceId]);
                    return;
                }

                requestQueue['serviceDef'][serviceId] = requestQueue['serviceDef'][serviceId] || [];
                requestQueue['serviceDef'][serviceId].push(success);
                /* if same queue is already in progress, do not send another request */
                if (requestQueue['serviceDef'][serviceId].length > 1) {
                    return;
                }

                /*invoking a service to get the operations that a particular service has and it's
                 * parameters to create a unique url pattern*/
                WebService.retrieveServiceOperations(urlParams, function (response) {
                    serviceDefMap[serviceId] = response;
                    /*while loop is used so that any requests that come when the response is being served; are also handled.*/
                    while (true) {
                        callback = requestQueue['serviceDef'][serviceId].shift();
                        Utils.triggerFn(callback, response);
                        if (!requestQueue['serviceDef'][serviceId].length) {
                            break;
                        }
                    }
                }, function (errMsg) {
                    Utils.triggerFn(error, errMsg);
                });
            },

            /*Getting the fully qualified name*/
            getFullyQualifiedName = function (refValue, definitions) {
                var returnType;
                refValue = refValue.split('/').pop();
                returnType = definitions[refValue];
                returnType = returnType ? returnType[FULLY_QUALIFIED_NAME_KEY] : 'Object';
                return returnType;
            },

            getReturnType = function (responseObject, definitions) {
                var type;
                if (responseObject.type) {
                    /*In case of primitive type*/
                    if (primitiveDataTypes.indexOf(responseObject.type) !== -1) {
                        return responseObject.type;
                    }
                    if (responseObject.type === 'array') {
                        /*In case of list type*/
                        if (responseObject[IS_LIST_KEY]) {
                            if (responseObject.items.type) {
                                type = responseObject.items.type;
                            } else {
                                if (responseObject.items.$ref) {
                                    type = getFullyQualifiedName(responseObject.items.$ref, definitions);
                                }
                            }
                        } else {
                            if (responseObject.items.type) {
                                type = responseObject.items.type;
                            } else {
                                if (responseObject.items.$ref) {
                                    type = getFullyQualifiedName(responseObject.items.$ref, definitions);
                                }
                            }
                        }
                        return type;
                    }
                } else {
                    /*In case of object type*/
                    return getFullyQualifiedName(responseObject.$ref, definitions);
                }
            },

            isRESTSupported = function (type) {
                return (VARIABLE_CONSTANTS.REST_SUPPORTED_SERVICES.indexOf(type) !== -1);// || VARIABLE_CONSTANTS.SERVICE_TYPE_DATA === type);
            },

            processOperations = function (serviceObj, operations, swagger) {
                var paramsKey,
                    isRestSupportedService = isRESTSupported(serviceObj.type),
                    definitions,
                    securityDefinitions,
                    schemaObject,
                    typeArgumentsObject;

                /*Empty the "operations" so that they are set based on the response.*/
                serviceObj.operations = [];

                if (isRestSupportedService) {
                    definitions = swagger.definitions;
                    securityDefinitions = swagger.securityDefinitions;
                }

                function getFormatFromMap (format)  {
                    var MAP = {
                        "int32": "integer",
                        "int64": "long"
                    };

                    return MAP[format] || format;
                }

                /*loop through the operations to append them to the respective service object*/
                WM.forEach(operations, function (operation) {
                    /*variable to determine if the fetched operation already exists*/
                    var operationObject = {},
                        isList,
                        typeRef,
                        format,
                        returnObj,
                        returnType,
                        returnFormat,
                        dbOperationName,
                        isDbServiceOp = function (type) {
                            return type === "hqlquery" || type === "nativequery" || type === "procedure";
                        };

                    if (isDbServiceOp(operation.operationType)) {
                        returnType = operation.return;
                    } else {
                        dbOperationName = operation.relativePath && operation.relativePath.split("/").pop();
                        /* special case for user created query/procedure operations, actual type info is not given by swagger */
                        if ((operation.tags[0] === "QueryExecutionController" || operation.tags[0] === "ProcedureExecutionController") && dbOperationName !== "wm_custom" && dbOperationName !== "wm_custom_update") {
                            returnType = serviceObj.name + dbOperationName + "rtnType";
                            schemaObject = operation.responses['200'].schema;
                            isList = schemaObject.$ref === "#/definitions/Page";
                        } else if (operation.responses && operation.responses['200'].schema) {
                            schemaObject = operation.responses['200'].schema;
                            typeArgumentsObject = schemaObject["x-WM-TYPE_ARGUMENTS"];
                            isList = schemaObject.$ref === "#/definitions/Page";
                            /*If the typeArguments is specified obtain the return type from it*/
                            if (typeArgumentsObject && typeArgumentsObject[0]) {
                                schemaObject = typeArgumentsObject[0];
                            }
                            returnType = getReturnType(schemaObject, definitions);
                            returnFormat = schemaObject.format;
                            if (!isList) {
                                isList = schemaObject.type && schemaObject.type === 'array';
                            }
                        } else {
                            returnType = "void";
                        }
                        returnFormat = getFormatFromMap(returnFormat);
                    }

                    /* special case for pageable return type */
                    if (isRestSupportedService) {
                        returnObj = {typeRef: returnType};
                        paramsKey = "parameters";

                    } else {
                        returnObj = returnType;
                        paramsKey = "parameter";
                        IS_LIST_KEY = 'isList';
                        parameterTypeKey = 'parameterType';
                    }

                    /*push the operation only if does not exist previously*/
                    operationObject = {
                        name: operation[WS_CONSTANTS.OPERATION_NAME_KEY] || operation.operationId || operation.name,
                        operationType: operation.operationType || null,
                        parameter: undefined,
                        isList: isList,
                        return: returnObj,
                        returnFormat: returnFormat,
                        controller: operation.tags && operation.tags[0]
                    };
                    serviceObj.operations.push(operationObject);

                    /* process the operation params as well */
                    if (!WM.element.isEmptyObject(operation[paramsKey])) {
                        operationObject.parameter = [];
                        WM.forEach(operation[paramsKey], function (param) {
                            isList = param[IS_LIST_KEY];

                            /* special cases for MultiPart type params */
                            if (param[parameterTypeKey].toLowerCase() === "formdata") {
                                if (param.type === "ref") {
                                    typeRef = param['x-WM-FULLY_QUALIFIED_TYPE'];
                                } else if (param.type === 'array') {
                                    isList = true;
                                    typeRef = param.items && param.items.type;
                                } else {
                                    typeRef = param.type;
                                }
                            } else {
                                if (param.type) {
                                    if (param.type === "array") {
                                        isList = true;
                                        typeRef = param.items && param.items.type;
                                    } else {
                                        typeRef = param.type;
                                        format = param.format;
                                    }
                                } else {
                                    if (param.schema) {
                                        typeRef = getReturnType(param.schema, definitions);
                                        format = param.schema.format;
                                    } else if (param.items) {
                                        typeRef = getReturnType(param.items, definitions);
                                    }
                                }
                            }
                            format =    getFormatFromMap(format);

                            /* push the param info into operation object */
                            operationObject.parameter.push({
                                name: param.name,
                                typeRef: typeRef,
                                format: format,
                                isList: isList,
                                parameterType: param[parameterTypeKey]
                            });
                        });
                    }

                    if (securityDefinitions && securityDefinitions[AUTH_TYPE_KEY] && securityDefinitions[AUTH_TYPE_KEY].type === "basic" && operation.security[0][AUTH_TYPE_KEY]) {
                        if (!operationObject.parameter) {
                            operationObject.parameter = [];
                        }
                        operationObject.parameter.push({
                            "name": "wm_auth_username",
                            "parameterType": "auth"
                        });
                        operationObject.parameter.push({
                            "name": "wm_auth_password",
                            "parameterType": "auth"
                        });
                    }
                });
            },

        /*function to get list of operations for a service from the backend*/
            getServiceOperations = function (serviceId, successCallBack, reloadFlag) {
                /*sanity checking of the params*/
                if (!serviceId || serviceId === '') {
                    return;
                }
                reloadFlag = !(!reloadFlag || reloadFlag === 'false');

                /*get the required service object*/
                var serviceObj = getServiceObjectByName(serviceId),
                    urlParams,
                    operations,
                    onOperationsFetch = function (operations, swagger) {
                        processOperations(serviceObj, operations, swagger);
                        var callback;

                        /*while loop is used so that any requests that come when the response is being served; are also handled.*/
                        while (true) {
                            callback = requestQueue['operations'][serviceId].shift();
                            Utils.triggerFn(callback, serviceObj.operations);
                            if (!requestQueue['operations'][serviceId].length) {
                                break;
                            }
                        }
                    };

                /*if service's operations already fetched once and reloadFlag not set, return the fetched operations*/
                if (serviceObj.operations.length > 0 && !reloadFlag) {
                    Utils.triggerFn(successCallBack, serviceObj.operations);
                    return;
                }

                requestQueue['operations'][serviceId] = requestQueue['operations'][serviceId] || [];
                requestQueue['operations'][serviceId].push(successCallBack);
                /* if same queue is already in progress, do not send another request */
                if (requestQueue['operations'][serviceId].length > 1) {
                    return;
                }


                if (isRESTSupported(serviceObj.type)) {
                    operations = [];

                    /* invoking a service to get the operations that a particular service has and it's
                     * parameters to create a unique url pattern
                     */
                    getServiceDef(serviceId, function (response) {
                        /*iterate over the paths received from the service response*/
                        WM.forEach(response.paths, function (path) {
                            /*iterate over the operations available in each path*/
                            WM.forEach(supportedOperations, function (operation) {
                                if (path[operation]) {
                                    path[operation].operationType = operation;
                                    path[operation].relativePath = path['x-WM-RELATIVE_PATH'];

                                    /* set operationType for Query/Procedure operations */
                                    if (path[operation].tags && path[operation].tags[0] === "ProcedureExecutionController") {
                                        path[operation].serviceSubType = "procedure";
                                    } else if (path[operation].tags && path[operation].tags[0] === "QueryExecutionController") {
                                        path[operation].serviceSubType = "query";
                                        /* here we have to set operationType to either hqlquery or nativequery (have to check how)*/
                                    }
                                    operations.push(path[operation]);
                                }
                            });
                        });
                        /*pass the data prepared to the success callback function*/
                        onOperationsFetch(operations, response);
                    }, function () {
                        /*handle error response*/
                        wmToaster.show("error", $rootScope.locale["MESSAGE_ERROR_TITLE"], $rootScope.locale["MESSAGE_ERROR_FETCH_SERVICE_METHODS_DESC"]);
                    }, reloadFlag);
                } else {
                    /*data for the request*/
                    urlParams = {
                        projectID: projectId || $rootScope.project.id,
                        serviceID: serviceId
                    };
                    /*Get the operations for the service*/
                    WebService.getServiceOperations(urlParams, function (response) {
                        onOperationsFetch(response);
                    }, function () {
                        wmToaster.show("error", $rootScope.locale["MESSAGE_ERROR_TITLE"], $rootScope.locale["MESSAGE_ERROR_FETCH_SERVICE_METHODS_DESC"]);
                    });
                }
            },
        /*function to get list of params and return type for an operation of a service from the backend*/
            getServiceOperationParams = function (serviceId, operationId, successCallBack, reloadFlag) {
                /*sanity checking of the params*/
                if (!serviceId || serviceId === '' || !operationId || operationId === '') {
                    return;
                }
                reloadFlag = !(!reloadFlag || reloadFlag === 'false');

                /*get the required operation object*/
                var serviceObj = getServiceObjectByName(serviceId),
                    operationObj = getServiceOperationObjectByName(serviceId, operationId),
                    urlParams,
                    onOperationParamsFetch = function (response, isRestSupported) {
                        var parameters = isRestSupported ? response.parameters : response.parameter;
                        /*Create parameter property for the operations object, if parameters exist.*/
                        if (!WM.element.isEmptyObject(parameters)) {
                            operationObj.parameter = [];

                            /*loop through the operation params to append them to the tree*/
                            WM.forEach(parameters, function (param) {
                                var paramExists = false,
                                    paramTypeRefsKey,
                                    paramTypeListRefsKey,
                                    isList,
                                    typeRef,
                                    isRestSupportedService = isRESTSupported(serviceObj.type);
                                if (isRestSupportedService) {
                                    paramTypeRefsKey = "fullyQualifiedType";
                                    paramTypeListRefsKey = "fullyQualifiedTypeArguments";
                                } else {
                                    paramTypeRefsKey = "typeRef";
                                }

                                /*loop through the existing params for the operation object to check existence of fetched params*/
                                WM.forEach(operationObj.parameter, function (existingParam) {
                                    /*if the param already exists, set flag to prevent duplicate entry*/
                                    if (param.name === existingParam.name) {
                                        paramExists = true;
                                    }
                                });

                                isList = param[IS_LIST_KEY];
                                if (isRestSupportedService) {
                                    typeRef = isList ? (param[paramTypeListRefsKey][0] || 'java.lang.Object') : param[paramTypeRefsKey];
                                } else {
                                    typeRef = param[paramTypeRefsKey];
                                }

                                /*if the param is not already fetched push it to the list*/
                                if (!paramExists) {
                                    operationObj.parameter.push({
                                        name: param.name,
                                        typeRef: typeRef,
                                        isList: isList,
                                        parameterType: param[parameterTypeKey]
                                    });
                                }
                            });
                        }

                        /*append the return types for this operation*/
                        operationObj['return'] = response['return'] || {'typeRef': 'java.lang.String', 'isList': false};
                        Utils.triggerFn(successCallBack, operationObj);
                    };

                /*if service's operation's params already fetched once and reloadFlag not set, return the fetched params*/
                if (operationObj.parameter && !reloadFlag) {
                    Utils.triggerFn(successCallBack, operationObj);
                    return;
                }

                if (isRESTSupported(serviceObj.type)) {
                    getServiceOperations(serviceId, function () {
                        onOperationParamsFetch(getServiceOperationObjectByName(serviceId, operationId), true);
                    }, true);
                } else {
                    urlParams = {
                        projectID: projectId || $rootScope.project.id,
                        serviceID: serviceId,
                        operationID: operationId
                    };
                    /*call web service to fetch the data*/
                    WebService.getServiceOperationParams(urlParams, function (response) {
                        onOperationParamsFetch(response);
                    }, function () {
                        wmToaster.show("error", $rootScope.locale["MESSAGE_ERROR_TITLE"], $rootScope.locale["MESSAGE_ERROR_FETCH_SERVICE_METHOD_PARAMS_DESC"]);
                    });
                }
            },
            addService = function (service) {
                /*variable to decide if service already exists*/
                var serviceExists = false;

                WM.forEach(services, function (existingService) {
                    /*if service exists set the flag to prevent duplicate entry*/
                    if (service.name === existingService.name && service.type === existingService.type) {
                        serviceExists = true;
                    }
                });

                /*if service does not exist, do not append*/
                if (!serviceExists) {
                    services.push({name: service.name, type: service.type, operations: [], url: service.url || "/services/" + service.name, sampleResponse: service.sampleResponse});
                }

                /* return true/false for the status */
                return !serviceExists;
            },

            /* gets the sample response for a webservice */
            getSampleResponse = function (serviceId) {
                var service = getServiceObjectByName(serviceId);

                return service.sampleResponse;
            },

            /* stores the sample response fpr a webservice */
            setSampleResponse = function (serviceId, response) {
                var service = getServiceObjectByName(serviceId);

                service.sampleResponse = response;
            };

        return {
            /**
             * @ngdoc function
             * @name wm.webservice.$ServiceFactory#getServicesWithType
             * @methodOf wm.webservice.$ServiceFactory
             * @function
             *
             * @description
             * gets a list of all services in the project (else throws an error).
             *
             * @param {function} successCallback providing the services list
             * @param {boolean} reloadFlag to determine if a refreshed list is required form backend (default false)
             */
            getServicesWithType: getServicesWithType,

            /**
             * @ngdoc function
             * @name wm.webservice.$ServiceFactory#getServiceOperations
             * @methodOf wm.webservice.$ServiceFactory
             * @function
             *
             * @description
             * gets a list of all operations in a service (else throws an error).
             *
             * @param {string} serviceId name of the service for which operations are required
             * @param {function} successCallback providing the operation list as function parameter
             * @param {boolean} reloadFlag to determine if a refreshed list is required form backend (default false)
             */
            getServiceOperations: getServiceOperations,

            /**
             * @ngdoc function
             * @name wm.webservice.$ServiceFactory#getServiceOperationParams
             * @methodOf wm.webservice.$ServiceFactory
             * @function
             *
             * @description
             * gets a list of all params of an operation in a service (else throws an error).
             *
             * @param {string} serviceId name of the service containing the operation
             * @param {string} operationId name of the operation of the service for which params are required
             * @param {function} successCallback providing the params list as function parameter
             * @param {boolean} reloadFlag to determine if a refreshed list is required form backend (default false)
             */
            getServiceOperationParams: getServiceOperationParams,

            /**
             * @ngdoc function
             * @name wm.webservice.$ServiceFactory#add
             * @methodOf wm.webservice.$ServiceFactory
             * @function
             *
             * @description
             * adds a service to the existing services list factory.
             *
             * @param {object} service details of the service to be added

             * @returns {boolean} true if service added, else false
             */
            add: addService,

            /**
             * @ngdoc function
             * @name wm.webservice.$ServiceFactory#getServiceObjectByName
             * @methodOf wm.webservice.$ServiceFactory
             * @function
             *
             * @description
             * returns an object having details of a service matching the supplied name
             *
             * @param {string} name name of the service the details of which are required.

             * @returns {object} having service details
             */
            getServiceObjectByName: getServiceObjectByName,

            /**
             * @ngdoc function
             * @name wm.webservice.$ServiceFactory#getSampleOutput
             * @methodOf wm.webservice.$ServiceFactory
             * @function
             *
             * @description
             * returns the sample output returned while testing the service
             *
             * @param {string} name name of the service

             * @returns {object} having service output
             */
            getSampleResponse: getSampleResponse,

            /**
             * @ngdoc function
             * @name wm.webservice.$ServiceFactory#setSampleOutput
             * @methodOf wm.webservice.$ServiceFactory
             * @function
             *
             * @description
             * stores the sample output returned while testing the service against that service namespace
             *
             * @param {serviceId} service id
             * @param {object} having service output
             */
            setSampleResponse: setSampleResponse,

            /**
             * @ngdoc function
             * @name wm.webservice.$ServiceFactory#getServiceDef
             * @methodOf wm.webservice.$ServiceFactory
             * @function
             *
             * @description
             * gets the api-doc service definition for provided serviceId
             *
             * @param {serviceId} service id
             * @param {object} having service output
             */
            getServiceDef: getServiceDef
        };
    }
];
/*global WM, wm*/

/*Defining module for Security */
wm.plugins.security = WM.module('wm.plugins.security', []);

wm.plugins.security.controllers = {};
wm.plugins.security.services = {};
wm.plugins.security.factories = {};
wm.plugins.security.directives = {};

wm.plugins.security.controller(wm.plugins.security.controllers);
wm.plugins.security.service(wm.plugins.security.services);
wm.plugins.security.factory(wm.plugins.security.factories);
wm.plugins.security.directive(wm.plugins.security.directives);

/*defining constants for Security module*/
wm.plugins.security.constant('SECURITY_URLS', {
    Security : {
        getMethods: {
            url: "services/projects/:projectID/services/securityService/operations",
            method: "GET"
        },
        getGeneralOptions: {
            url: "services/projects/:projectID/securityservice/general",
            method: "GET"
        },
        configDemo: {
            url: "services/projects/:projectID/securityservice/providers/demo",
            method: "POST"
        },
        getDemoOptions: {
            url: "services/projects/:projectID/securityservice/providers/demo",
            method: "GET"
        },
        configDatabase: {
            url: "services/projects/:projectID/securityservice/providers/database",
            method: "POST"
        },
        getDatabaseOptions: {
            url: "services/projects/:projectID/securityservice/providers/database",
            method: "GET"
        },
        configAD: {
            url: "services/projects/:projectID/securityservice/providers/activedirectory",
            method: "POST"
        },
        getADOptions: {
            url: "services/projects/:projectID/securityservice/providers/activedirectory",
            method: "GET"
        },
        configLDAP: {
            url: "services/projects/:projectID/securityservice/providers/ldap",
            method: "POST"
        },
        getLDAPOptions: {
            url: "services/projects/:projectID/securityservice/providers/ldap",
            method: "GET"
        },
        testLDAPConnection: {
            url: "services/projects/:projectID/securityservice/providers/ldap/testconnection",
            method: "POST"
        },
        getCASOptions: {
            url: "services/projects/:projectID/securityservice/providers/cas",
            method: "GET"
        },
        configCAS: {
            url: "services/projects/:projectID/securityservice/providers/cas",
            method: "POST"
        },
        configCustomAuth: {
            url: "services/projects/:projectID/securityservice/providers/customauth",
            method: "POST"
        },
        getCustomAuthOptions: {
            url: "services/projects/:projectID/securityservice/providers/customauth",
            method: "GET"
        },
        getPortMapping: {
            url: "services/projects/:projectID/securityservice/portmapping",
            method: "GET"
        },
        getSecurityInterceptURLs: {
            url: "services/projects/:projectID/securityservice/intercepturls",
            method: "GET"
        },
        setSecurityInterceptURLs: {
            url: "services/projects/:projectID/securityservice/intercepturls",
            method: "POST"
        },
        getRoles: {
            url: "services/projects/:projectID/securityservice/roles",
            method: "GET"
        },
        setRoles: {
            url: "services/projects/:projectID/securityservice/roles",
            method: "POST"
        },
        getRolesConfig: {
            url: "services/projects/:projectID/securityservice/rolesconfig",
            method: "GET"
        },
        setRolesConfig: {
            url: "services/projects/:projectID/securityservice/rolesconfig",
            method: "POST"
        },
        appLogin: {
            url: "j_spring_security_check",
            method: "POST",
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded'
            }
        },
        appLogout: {
            url: "services/security/logout",
            method: "POST"
        },
        getLoggedInUser: {
            url: "services/security/user",
            method: "GET"
        },
        getConfig: {
            url: "services/security/info",
            method: "GET"
        },
        configCustomSecurity: {
            url: "services/projects/:projectID/securityservice/providers/customauth",
            method: "POST"
        },
        getCustomSecurityConfig: {
            url: "services/projects/:projectID/securityservice/providers/customauth",
            method: "GET"
        },
        testADConnection: {
            url: "services/projects/:projectID/securityservice/providers/ad/testconnection",
            method: "POST"
        }
    }
});

/*Defining the config for the Security plugins*/
wm.plugins.security.config(function (BaseServiceManagerProvider, SECURITY_URLS) {
    'use strict';

    BaseServiceManagerProvider.register(SECURITY_URLS);
});
/*End of security services Modules*/
/*global WM, wm, _, _WM_APP_PROPERTIES*/
/*jslint todo: true */
/*jslint nomen: true*/
/**
 * @ngdoc service
 * @name wm.security.$SecurityService
 * @description
 * The `SecurityService` provides the details about the security based service apis
 */

wm.plugins.security.services.SecurityService = [
    "BaseService",
    "Utils",
    "$rootScope",

    function (BaseService, Utils, $rs) {
        'use strict';

        /* to store general options & roles */
        var _roles,
            _rolesConfig,
            _interceptUrls,
            _generalOptions,
            _lastUser,
            _config,
            loggedInUser,
            serviceOperationsMap = {},
            getConfig = function (successCallback, failureCallback) {
                if (!_config) {
                    BaseService.send({
                        target: 'Security',
                        action: 'getConfig'
                    }, function (config) {
                        /* TEMP CODE */
                        config.homePage = _WM_APP_PROPERTIES.homePage;
                        if (config.userInfo) {
                            config.userInfo.homePage = config.userInfo.landingPage;
                        }
                        /* TEMP CODE */
                        _config = config;
                        loggedInUser = config.userInfo;
                        _lastUser = loggedInUser;
                        Utils.triggerFn(successCallback, _config);
                    }, function (error) {
                        if ($rs.isMobileApplicationType) {
                            _config = {
                                "securityEnabled": false,
                                "authenticated": false,
                                "homePage": _WM_APP_PROPERTIES.homePage,
                                "userInfo": null,
                                "login": null
                            };
                            Utils.triggerFn(successCallback, _config);
                        } else {
                            Utils.triggerFn(failureCallback, error);
                        }
                    });
                } else {
                    Utils.triggerFn(successCallback, _config);
                }
            },
            setConfig = function (config) {
                _lastUser = loggedInUser;
                _config = config;
                loggedInUser = config && config.userInfo;
            },
        /*Function to get the details of the logged-in user in the Application/RUN mode.*/
            getLoggedInUser = function (successCallback, failureCallback) {
                /*If the details of the logged-in user have already been fetched, trigger the success callback.
                * Else, make a call to the service to fetch details and then trigger the callback.*/
                if (!loggedInUser) {
                    getConfig(successCallback, failureCallback);
                } else {
                    Utils.triggerFn(successCallback, loggedInUser);
                }

            };

        /* APIs returned by the SecurityService.*/
        return {

            /**
             * @ngdoc function
             * @name wm.security.$SecurityService#getMethods
             * @methodOf wm.security.$SecurityService
             * @function
             *
             * @description
             * The API is used to get the methods exposed by the security service in RUN mode
             *
             * @param {string} projectID project id
             * @param {function} successCallback to be called on success
             * @param {function} failureCallback to be called on failure
             */

            getMethods: function (projectID, successCallback, failureCallback) {
                BaseService.send({
                    target: 'Security',
                    action: 'getMethods',
                    urlParams: {
                        projectID: projectID
                    }
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.security.$SecurityService#getGeneralOptions
             * @methodOf wm.security.$SecurityService
             * @function
             *
             * @description
             * The API is used to get values of general options. These values can determine if security config is enabled or not and also stores the type of datasource to be used. Following are the fields associated in generaloptions object:
             * 1. enforceSecurity - it signifies whether security is enabled or not for the associated project.
             * 2. enforceIndexHtml - it signifies whether default login or custom login page to be used.
             * 3. useSSL - it depicts whether secure socket layer to be used or not.
             * 4. sslPort - if useSSL is true then the value of this parameter to be used. This is invalid in SaaS.
             * 5. dataSourceType - It indicates which Security Provider to be use. Generally, it is chosen from following 5 Security Providers:
             * a) Demo
             * b) Database
             * c) LDAP
             * d) Active Directory
             * e) CAS
             *
             * @param {string} projectID project id
             * @param {function} successCallback to be called on success
             * @param {function} failureCallback to be called on failure
             */

            getGeneralOptions: function (projectID, successCallback, failureCallback) {
                if (!_generalOptions) {
                    BaseService.send({
                        target: 'Security',
                        action: 'getGeneralOptions',
                        urlParams: {
                            projectID: projectID
                        }
                    }, function (generalOptions) {
                        _generalOptions = generalOptions;
                        Utils.triggerFn(successCallback, generalOptions);
                    }, failureCallback);
                } else {
                    Utils.triggerFn(successCallback, _generalOptions);
                }
            },
            /**
             * @ngdoc function
             * @name wm.security.$SecurityService#setGeneralOptions
             * @methodOf wm.security.$SecurityService
             * @function
             *
             * @description
             * to store the general Options of the security in this service
             *
             * @param {object} generalOptions general options
             */

            setGeneralOptions: function (generalOptions) {
                _generalOptions = generalOptions;
            },

            /**
             * @ngdoc function
             * @name wm.security.$SecurityService#configDemo
             * @methodOf wm.security.$SecurityService
             * @function
             *
             * @description
             * The API is used to configure Security Provider as Demo. This security provider must be used when the limited default logins must be allowed. Hence, this security provider stores the configuration values in an xml file (project-security.xml), as it is assumed that users will be limited.
             *
             * While calling this API, it is mandatory to set the requestBody.
             * RequestBody consist of two data members:
             * 1. demoUsers - It consist of userid, password and roles (list of string) as its data member. The userid and password must be filled to make it work correctly.
             * 2. generalOptions - It consist of 5 fields viz., enforceSecurity, enforceIndexHtml, useSSL, sslPort and dataSourceType respectively. To configure Demo, dataSourceType must be set to Demo and enforceSecurity must be true. Other options must be set as per the requirement.
             *
             * @param {object} params object containing parameters for the request
             * @param {function} successCallback to be called on success
             * @param {function} failureCallback to be called on failure
             */

            configDemo: function (params, successCallback, failureCallback) {
                BaseService.send({
                    target: 'Security',
                    action: 'configDemo',
                    urlParams: {
                        projectID: params.projectID
                    },
                    data: params.config
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.security.$SecurityService#configDemo
             * @methodOf wm.security.$SecurityService
             * @function
             *
             * @description
             * The API is used to configure Security Provider as Demo. This security provider must be used when the limited default logins must be allowed. Hence, this security provider stores the configuration values in an xml file (project-security.xml), as it is assumed that users will be limited.
             *
             * While calling this API, it is mandatory to set the requestBody.
             * RequestBody consist of two data members:
             * 1. demoUsers - It consist of userid, password and roles (list of string) as its data member. The userid and password must be filled to make it work correctly.
             * 2. generalOptions - It consist of 5 fields viz., enforceSecurity, enforceIndexHtml, useSSL, sslPort and dataSourceType respectively. To configure Demo, dataSourceType must be set to Demo and enforceSecurity must be true. Other options must be set as per the requirement.
             *
             * @param {string} projectID project id
             * @param {function} successCallback to be called on success
             * @param {function} failureCallback to be called on failure
             */

            getDemoOptions: function (projectID, successCallback, failureCallback) {
                BaseService.send({
                    target: 'Security',
                    action: 'getDemoOptions',
                    urlParams: {
                        projectID: projectID
                    }
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.security.$SecurityService#configDatabase
             * @methodOf wm.security.$SecurityService
             * @function
             *
             * @description
             * The API is used to store and access login details from the database. A table is maintained in the database to store the username and password of the user. During login, values of username and password is compared with the values present in the database. On the basis of which it is decided to authorize user or not.
             * To configure Security Provider as Database. It requires RequestBody as input in which values for databaseoptions and general options are set. The details of these fields are as follows:
             * 1. Databaseoptions
             *      a) modelName - name of the database.
             *      b) entityName - An entity name.
             *      c) tableName - a table name.
             *      d) unamePropertyName - username property.
             *      e) unameColumnName - username column in the database.
             *      f) uidPropertyName - userid property.
             *      g) uidColumnName - userid column.
             *      h) pwPropertyName - password property.
             *      i) pwColumnName - password column.
             *      j) rolePropertyName - role property.
             *      k) roleColumnName - role column.
             *      l) useRolesQuery - Roles query
             *      m) rolesByUsernameQuery - roles by username query.
             *      n) tenantIdField - tenant ID
             *      o) defTenantId - default tenant ID.
             * 2. GeneralOptions - a generaloptions object
             * The difference between column name and property name is that the column name refers to the database whereas property name refers to the field of an object which is later used for many purposes like in Queries.
             *
             * @param {object} params object containing parameters for the request
             * @param {function} successCallback to be called on success
             * @param {function} failureCallback to be called on failure
             */

            configDatabase: function (params, successCallback, failureCallback) {
                BaseService.send({
                    target: 'Security',
                    action: 'configDatabase',
                    urlParams: {
                        projectID: params.projectID
                    },
                    data: params.config
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.security.$SecurityService#getDatabaseOptions
             * @methodOf wm.security.$SecurityService
             * @function
             *
             * @description
             * The API is used to get the configured values of Database Options. This API should be used when the Security Provider is selected as Database. This security provider provides a facility to configure login values with the database which means the authentication details are stored in the database. To execute this API, it is important to configure database first before using configdatabase api.
             *
             * @param {string} projectID project id
             * @param {function} successCallback to be called on success
             * @param {function} failureCallback to be called on failure
             */

            getDatabaseOptions: function (projectID, successCallback, failureCallback) {
                BaseService.send({
                    target: 'Security',
                    action: 'getDatabaseOptions',
                    urlParams: {
                        projectID: projectID
                    }
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.security.$SecurityService#configAD
             * @methodOf wm.security.$SecurityService
             * @function
             *
             * @description
             * The API is used to configure Security Provider as Active Directory. Active Directory security provider supports its own non-standardized authentication option and its normal usage pattern is also different from standardized LDAP which uses distinguished name. Hence, it is used instead of LDAP. It require RequestBody as input in which values for LDAPOption is set.
             * Following is the structure of LDAPOptions:
             * 1. Domain - A domain name.
             * 2. Url - a projects url
             * 3. managerDn - manager domain
             * 4. managerPassword - manager password
             * 5. userDnPattern - user domain pattern
             * 6. groupSearchDisabled - a field which represents the group search enable/disable value (boolean).
             * 7. groupSearchBase - a string which contains group search base value.
             * 8. groupRoleAttribute - a string which contains role attribute value.
             * 9. groupSearchFilter - a string which contains group search filter value.
             * 10. roleModel - model name for a role.
             * 11. roleEntity - entity name of the role.
             * 12. roleTable - a table name of the role in the database.
             * 13. roleUsername - username of the role.
             * 14. roleProperty - property of the role.
             * 15. roleQuery - role query.
             * 16. roleProvider - role provider.
             * 17. generalOptions - a general option object.
             *
             * @param {object} params object containing parameters for the request
             * @param {function} successCallback to be called on success
             * @param {function} failureCallback to be called on failure
             */

            configAD: function (params, successCallback, failureCallback) {
                BaseService.send({
                    target: 'Security',
                    action: 'configAD',
                    urlParams: {
                        projectID: params.projectID
                    },
                    data: params.config
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.security.$SecurityService#getADOptions
             * @methodOf wm.security.$SecurityService
             * @function
             *
             * @description
             * The API is used to get the configured values of Active Directory (Security Provider). Note that before using this API, it is important to execute configAD api as it will configure the values for Active Directory Security Provider otherwise it will throw an exception. This API returns the LDAPOption object.
             *
             * @param {string} projectID project id
             * @param {function} successCallback to be called on success
             * @param {function} failureCallback to be called on failure
             */

            getADOptions: function (projectID, successCallback, failureCallback) {
                BaseService.send({
                    target: 'Security',
                    action: 'getADOptions',
                    urlParams: {
                        projectID: projectID
                    }
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.security.$SecurityService#configLDAP
             * @methodOf wm.security.$SecurityService
             * @function
             *
             * @description
             * The API is used to configure Security Provider as LDAP (Lightweight Directory Access Protocol). This security provider is used when authentication values must be stored in directory rather than database. The advantage is less processing time required compared to retrieving values from database. To call this API, a RequestBody in which values for LDAPOption is set (Similar to Active Directory) and passed with the call.
             *
             * @param {object} params object containing parameters for the request
             * @param {function} successCallback to be called on success
             * @param {function} failureCallback to be called on failure
             */

            configLDAP: function (params, successCallback, failureCallback) {
                BaseService.send({
                    target: 'Security',
                    action: 'configLDAP',
                    urlParams: {
                        projectID: params.projectID
                    },
                    data: params.config
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.security.$SecurityService#getADOptions
             * @methodOf wm.security.$SecurityService
             * @function
             *
             * @description
             * The API is used to get the values of configured LDAP (Lightweight Directory Access Protocol) security provider. LDAP security provider is used as a central repository for user information and as an authentication service. This API returns LDAPOptions object.
             *
             * @param {string} projectID project id
             * @param {function} successCallback to be called on success
             * @param {function} failureCallback to be called on failure
             */

            getLDAPOptions: function (projectID, successCallback, failureCallback) {
                BaseService.send({
                    target: 'Security',
                    action: 'getLDAPOptions',
                    urlParams: {
                        projectID: projectID
                    }
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.security.$SecurityService#testLDAPConnection
             * @methodOf wm.security.$SecurityService
             * @function
             *
             * @description
             * The API is used to test the LDAP Connection whether it is valid and working or not. To do this, a requestBody is set with LDAPOption object which contains connection detail.
             *
             * @param {object} params object containing parameters for the request
             * @param {function} successCallback to be called on success
             * @param {function} failureCallback to be called on failure
             */

            testLDAPConnection: function (params, successCallback, failureCallback) {
                BaseService.send({
                    target: 'Security',
                    action: 'testLDAPConnection',
                    urlParams: {
                        projectID: params.projectID
                    },
                    data: params.config
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.security.$SecurityService#getCASOptions
             * @methodOf wm.security.$SecurityService
             * @function
             *
             * @description
             * The API is used to get the values of configured CAS (Central Authentication Service) security provider.
             * This API returns appropriate values on the basis of what is set earlier using configureCAS API.
             *
             * Following are the fields which need to be set for using CAS:
             * a) casURL - A CAS url
             * b) projectURL - projects url.
             * c) userDetailsProvider - A string which contains the value CAS.
             * d) DatabaseOptions - DatabaseOptions object
             *
             * @param {string} projectID project id
             * @param {function} successCallback to be called on success
             * @param {function} failureCallback to be called on failure
             */

            getCASOptions: function (projectID, successCallback, failureCallback) {
                BaseService.send({
                    target: 'Security',
                    action: 'getCASOptions',
                    urlParams: {
                        projectID: projectID
                    }
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.security.$SecurityService#configCAS
             * @methodOf wm.security.$SecurityService
             * @function
             *
             * @description
             * The URL configures the CAS as the service provider. This mechanism enables the
             * Configuration parameters should be sent through json object using RequestBody.
             * Following 3 data members value to be set for using CAS:
             * e) casURL - A CAS url.
             * f) projectURL - project url.
             * g) userDetailsProvider - A string which contains the value CAS.
             *
             * @param {object} params object containing parameters for the request
             * @param {function} successCallback to be called on success
             * @param {function} failureCallback to be called on failure
             */

            configCAS: function (params, successCallback, failureCallback) {
                BaseService.send({
                    target: 'Security',
                    action: 'configCAS',
                    urlParams: {
                        projectID: params.projectID
                    },
                    data: params.config
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.security.$SecurityService#configCustomAuth
             * @methodOf wm.security.$SecurityService
             * @function
             *
             * @description
             * The API is used to customize the Authorization as per the need. This mechanism provides facility to directly update xml file and customize any authorization as per the requirement. To do this, a RequestBody which consist of config and general option attributes, must be set and sent to configure the values.
             *
             * @param {string} projectID project id
             * @param {function} successCallback to be called on success
             * @param {function} failureCallback to be called on failure
             */

            configCustomAuth: function (projectID, successCallback, failureCallback) {
                BaseService.send({
                    target: 'Security',
                    action: 'configCustomAuth',
                    urlParams: {
                        projectID: projectID
                    }
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.security.$SecurityService#getCustomAuthOptions
             * @methodOf wm.security.$SecurityService
             * @function
             *
             * @description
             * The API is used to get values of Customize Authorization Option. It returns the XML file as a string which contains the detail of authorization mechanism. This XML File is nothing but custom user security bean.
             *
             * @param {object} params object containing parameters for the request
             * @param {function} successCallback to be called on success
             * @param {function} failureCallback to be called on failure
             */

            getCustomAuthOptions: function (params, successCallback, failureCallback) {
                BaseService.send({
                    target: 'Security',
                    action: 'getCustomAuthOptions',
                    urlParams: {
                        projectID: params.projectID
                    },
                    data: params.config
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.security.$SecurityService#getPortMapping
             * @methodOf wm.security.$SecurityService
             * @function
             *
             * @description
             * The API is used to get the port detail which is currently in use. Port details are stored in project-security.xml file. On executing this api, the values are returned from this xml. Following is the representation of port values in xml file:
             *  <security:port-mappings>
             *      <security:port-mapping http="8080" https="8443"/>
             *  </security:port-mappings>
             * Where attributes http and https refers to unsecured and secured port.  This method is not valid in SaaS.
             *
             * @param {object} params object containing parameters for the request
             * @param {function} successCallback to be called on success
             * @param {function} failureCallback to be called on failure
             */

            getPortMapping: function (params, successCallback, failureCallback) {
                BaseService.send({
                    target: 'Security',
                    action: 'getPortMapping',
                    urlParams: {
                        projectID: params.projectID
                    },
                    data: params.config
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.security.$SecurityService#getSecurityInterceptURLs
             * @methodOf wm.security.$SecurityService
             * @function
             *
             * @description
             * The API is used to get the security intercept url list of the application. These urls determines the authentication or validation for the urls. This data is retrieved from project-security.xml file under <security:http> tag. In the xml file the entry for security intercept url looks like this:
             * <security:intercept-url pattern="/app.css" access="permitAll"/>
             * where pattern attribute refers to the url pattern and access attribute refers to the authentication level.
             * Also note that there are default 15 url present in the xml file which is entered automatically on enabling security for the first time. Also, it is important to enable security before executing this API otherwise the API will throw an exception.
             *
             * @param {string} projectID project id
             * @param {function} successCallback to be called on success
             * @param {function} failureCallback to be called on failure
             */

            getSecurityInterceptURLs: function (projectID, successCallback, failureCallback) {
                if (_interceptUrls === undefined) {
                    BaseService.send({
                        target: 'Security',
                        action: 'getSecurityInterceptURLs',
                        urlParams: {
                            projectID: projectID
                        }
                    }, function (response) {
                        _interceptUrls = response;
                        Utils.triggerFn(successCallback, response);
                    }, failureCallback);
                } else {
                    Utils.triggerFn(successCallback, _interceptUrls);
                }
            },

            /**
             * @ngdoc function
             * @name wm.security.$SecurityService#setSecurityInterceptURLs
             * @methodOf wm.security.$SecurityService
             * @function
             *
             * @description
             * The API is used to add security intercept urls in the project-security.xml file. The intercept urls is used to authenticate url while its execution. When this api is executed an entry is made in <security:http> tag of project-security.xml file. The entry is as follows:
             * <security:intercept-url pattern="/app.css" access="permitAll"/>
             * where pattern attribute refers to the url pattern and access attribute refers to the authentication level.
             * During calling this api, a RequestBody object has to be set which consist of general options and securityURLMap. SecurityURLMap accepts pattern and access as its key value pair. Please see example for more detail.
             *
             * @param {object} params object containing parameters for the request
             * @param {function} successCallback to be called on success
             * @param {function} failureCallback to be called on failure
             */

            setSecurityInterceptURLs: function (params, successCallback, failureCallback) {
                BaseService.send({
                    target: 'Security',
                    action: 'setSecurityInterceptURLs',
                    urlParams: {
                        projectID: params.projectID
                    },
                    data: params.config
                }, function (response) {
                    _interceptUrls = params.config;
                    Utils.triggerFn(successCallback, response);
                }, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.security.$SecurityService#getRoles
             * @methodOf wm.security.$SecurityService
             * @function
             *
             * @description
             * The API is used to retrieve the role configuration details. This configuration determines the level of authorization for any given user. The values are present in project-security.xml file. On executing this api, a values in role property is retrieved in the form of string and returned.
             *
             * @param {string} projectID project id
             * @param {function} successCallback to be called on success
             * @param {function} failureCallback to be called on failure
             */

            getRoles: function (projectID, successCallback, failureCallback) {
                if (_roles === undefined) {
                    BaseService.send({
                        target: 'Security',
                        action: 'getRoles',
                        urlParams: {
                            projectID: projectID
                        }
                    }, function (response) {
                        _roles = response;
                        Utils.triggerFn(successCallback, response);
                    }, failureCallback);
                } else {
                    Utils.triggerFn(successCallback, _roles);
                }
            },
            /**
             * @ngdoc function
             * @name wm.security.$SecurityService#getRolesConfig
             * @methodOf wm.security.$SecurityService
             * @function
             *
             * @description
             * The API is used to retrieve the role config landing page details.
             * This configuration defines the landing page configurations for each role. User will be re-directed
             * to the landing page configured for the user's specific role.
             *
             * @param {string} projectID project id
             * @param {function} successCallback to be called on success
             * @param {function} failureCallback to be called on failure
             */

            getRolesConfig: function (projectID, successCallback, failureCallback) {
                if (!_rolesConfig) {
                    BaseService.send({
                        target: 'Security',
                        action: 'getRolesConfig',
                        urlParams: {
                            projectID: projectID
                        }
                    }, function (response) {
                        _rolesConfig = response;
                        Utils.triggerFn(successCallback, response);
                    }, failureCallback);
                } else {
                    Utils.triggerFn(successCallback, _rolesConfig);
                }
            },

            /**
             * @ngdoc function
             * @name wm.security.$SecurityService#setRolesConfig
             * @methodOf wm.security.$SecurityService
             * @function
             *
             * @description
             * The API is used to set the role configuration details with the landing page configured for each role.
             * The property tag in the xml file is as follows:
             * <property name="roles">
             *      <list>
             *          <role name="admin" desc="">
             *              <role-config landing-page="Admin" />
             *          </role>
             *          <role name="guest" desc="">
             *              <role-config landing-page="Main" />
             *          </role>
             *      </list>
             * </property>
             *
             * @param {object} params object containing parameters for the request
             * @param {function} successCallback to be called on success
             * @param {function} failureCallback to be called on failure
             */

            setRolesConfig: function (params, successCallback, failureCallback) {
                BaseService.send({
                    target: 'Security',
                    action: 'setRolesConfig',
                    urlParams: {
                        projectID: params.projectID
                    },
                    data: params.config
                }, function (response) {
                    _rolesConfig = params.config;
                    Utils.triggerFn(successCallback, response);
                }, failureCallback);
            },
            /**
             * @ngdoc function
             * @name wm.security.$SecurityService#setRoles
             * @methodOf wm.security.$SecurityService
             * @function
             *
             * @description
             * The API is used to set the role configuration detail. The role configuration is required to manage the level of authorization for any user. This detail is present in project-security.xml file. On executing this api, role property of securityservice bean is updated with values passed into it. The property tag in the xml file is as follows:
             * <property name="roles">
             *      <list>
             *          <value>admin</value>
             *          <value>guest</value>
             *      </list>
             * </property>
             * Roles values are passed in an RequestBody as an array of string. Please see RequestBody example for more detail.
             *
             * @param {object} params object containing parameters for the request
             * @param {function} successCallback to be called on success
             * @param {function} failureCallback to be called on failure
             */

            setRoles: function (params, successCallback, failureCallback) {
                BaseService.send({
                    target: 'Security',
                    action: 'setRoles',
                    urlParams: {
                        projectID: params.projectID
                    },
                    data: params.config
                }, function (response) {
                    _roles = params.config;
                    Utils.triggerFn(successCallback, response);
                }, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.security.$SecurityService#appLogin
             * @methodOf wm.security.$SecurityService
             * @function
             *
             * @description
             * The API is used to login into the app.
             *
             * @param {object} params object containing parameters for the request
             * @param {function} successCallback to be called on success
             * @param {function} failureCallback to be called on failure
             */

            appLogin: function (params, successCallback, failureCallback) {
                return BaseService.send({
                    target: 'Security',
                    action: 'appLogin',
                    data: "j_username=" + encodeURIComponent(params.username) + "&j_password=" + encodeURIComponent(params.password)
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.security.$SecurityService#appLogout
             * @methodOf wm.security.$SecurityService
             * @function
             *
             * @description
             * The API is used to logout of the app.
             *
             * @param {function} successCallback to be called on success
             * @param {function} failureCallback to be called on failure
             */

            appLogout: function (successCallback, failureCallback) {
                return BaseService.send({
                    target: 'Security',
                    action: 'appLogout'
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.security.$SecurityService#isAuthenticated
             * @methodOf wm.security.$SecurityService
             * @function
             *
             * @description
             * The API is used to check if the user is authenticated in the RUN mode.
             *
             * @param {function} successCallback to be called on success
             * @param {function} failureCallback to be called on failure
             */

            isAuthenticated: function (successCallback, failureCallback) {
                getConfig(function (config) {
                    Utils.triggerFn(successCallback, config.authenticated);
                }, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.security.$SecurityService#getUserName
             * @methodOf wm.security.$SecurityService
             * @function
             *
             * @description
             * The API is used to get the name of the logged in user in RUN mode
             *
             * @param {function} successCallback to be called on success
             * @param {function} failureCallback to be called on failure
             */

            getUserName: function (successCallback, failureCallback) {
                getLoggedInUser(function (loggedInUser) {
                    Utils.triggerFn(successCallback, loggedInUser.userName);
                }, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.security.$SecurityService#getUserId
             * @methodOf wm.security.$SecurityService
             * @function
             *
             * @description
             * The API is used to get the id of the logged in user in RUN mode
             *
             * @param {function} successCallback to be called on success
             * @param {function} failureCallback to be called on failure
             */

            getUserId: function (successCallback, failureCallback) {
                getLoggedInUser(function (loggedInUser) {
                    Utils.triggerFn(successCallback, loggedInUser.userId);
                }, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.security.$SecurityService#getTenantId
             * @methodOf wm.security.$SecurityService
             * @function
             *
             * @description
             * The API is used to get the tenant Id of the logged in user in RUN mode
             *
             * @param {function} successCallback to be called on success
             * @param {function} failureCallback to be called on failure
             */

            getTenantId: function (successCallback, failureCallback) {
                getLoggedInUser(function (loggedInUser) {
                    Utils.triggerFn(successCallback, loggedInUser.tenantId);
                }, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.security.$SecurityService#getUserRoles
             * @methodOf wm.security.$SecurityService
             * @function
             *
             * @description
             * The API is used to get the roles for the logged in users in RUN mode
             *
             * @param {function} successCallback to be called on success
             * @param {function} failureCallback to be called on failure
             */

            getUserRoles: function (successCallback, failureCallback) {
                getConfig(function (config) {
                    Utils.triggerFn(successCallback, config.userInfo.userRoles, config.authenticated);
                }, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.security.$SecurityService#isSecurityEnabled
             * @methodOf wm.security.$SecurityService
             * @function
             *
             * @description
             * The API is used to get the status of security service in the project (enabled or not)
             *
             * @param {function} successCallback to be called on success
             * @param {function} failureCallback to be called on failure
             */

            isSecurityEnabled: function (successCallback, failureCallback) {
                getConfig(function (loggedInUser) {
                    Utils.triggerFn(successCallback, config.securityEnabled);
                }, failureCallback);
            },
            /**
             * @ngdoc function
             * @name wm.security.$SecurityService#configCustomSecurity
             * @methodOf wm.security.$SecurityService
             * @function
             *
             * @description
             * Set the custom security config
             *
             * @param {object} params to be used for setting security
             * @param {function} successCallback to be called on success
             * @param {function} failureCallback to be called on failure
             */
            configCustomSecurity: function (params, successCallback, failureCallback) {
                BaseService.send({
                    target: 'Security',
                    action: 'configCustomSecurity',
                    urlParams: {
                        projectID: params.projectID
                    },
                    data: params.config
                }, successCallback, failureCallback);
            },
            /**
             * @ngdoc function
             * @name wm.security.$SecurityService#getCustomSecurityConfig
             * @methodOf wm.security.$SecurityService
             * @function
             *
             * @description
             * Get the custom security config
             *
             * @param {object} params to be used for getting custom security config
             * @param {function} successCallback to be called on success
             * @param {function} failureCallback to be called on failure
             */
            getCustomSecurityConfig: function (params, successCallback, failureCallback) {
                BaseService.send({
                    target: 'Security',
                    action: 'getCustomSecurityConfig',
                    urlParams: {
                        projectID: params.projectID
                    },
                    data: params.config
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.security.$SecurityService#testADConnection
             * @methodOf wm.security.$SecurityService
             * @function
             *
             * @description
             * The API is used to test the AD(Active Directory) Connection whether it is valid and working or not.
             * To do this, a requestBody is set with ADOption object which contains connection detail.
             *
             * @param {object} params object containing parameters for the request
             * @param {function} successCallback to be called on success
             * @param {function} failureCallback to be called on failure
             */
            testADConnection: function (params, successCallback, failureCallback) {
                BaseService.send({
                    target: 'Security',
                    action: 'testADConnection',
                    urlParams: {
                        projectID: params.projectID
                    },
                    data: params.config
                }, successCallback, failureCallback);
            },

            /**
             * @ngdoc function
             * @name wm.security.$SecurityService#setLoggedInUser
             * @methodOf wm.security.$SecurityService
             * @function
             *
             * @description
             * to cache the logged in user object
             *
             * @param {object} user user object
             */
            setLoggedInUser: function (user) {
                _lastUser = loggedInUser;
                loggedInUser = user;
            },

            /**
             * @ngdoc function
             * @name wm.security.$SecurityService#updateCachedRolesInfo
             * @methodOf wm.security.$SecurityService
             * @function
             *
             * @description
             * to update the roles info in cache
             *
             * @param {object} rolesConfig array of roles config objects
             */
            updateCachedRolesInfo: function (rolesConfig) {
                /* sanity check */
                if (!WM.isArray(rolesConfig) || !rolesConfig.length) {
                    return;
                }
                _rolesConfig = rolesConfig;
                _roles = _.map(rolesConfig, "name");
            },

            /**
             * @ngdoc function
             * @name wm.security.$SecurityService#getLastLoggedInUser
             * @methodOf wm.security.$SecurityService
             * @function
             *
             * @description
             * returns the previous loggedInUser
             *
             * @param {object} rolesConfig array of roles config objects
             */
            getLastLoggedInUser: function () {
                return _lastUser && _lastUser.userName;
            },

            /**
             * @ngdoc function
             * @name wm.security.$SecurityService#getConfig
             * @methodOf wm.security.$SecurityService
             * @function
             *
             * @description
             * to update the roles info in cache
             *
             * @param {object} rolesConfig array of roles config objects
             */
            getConfig: getConfig,

            /**
             * @ngdoc function
             * @name wm.security.$SecurityService#setConfig
             * @methodOf wm.security.$SecurityService
             * @function
             *
             * @description
             * to update the roles info in cache
             *
             * @param {object} rolesConfig array of roles config objects
             */
            setConfig: setConfig
        };
    }];

/*global wm, WM, _*/
/*jslint todo: true */
/*jslint sub: true */


/**
 * @ngdoc service
 * @name wm.variables.LoginVariable
 * @requires $rootScope
 * @requires $routeParams
 * @requires BaseVariablePropertyFactory
 * @description
 * The 'LoginVariable' provides methods to work with LoginVariables
 */

wm.variables.services.LoginVariableService = ['Variables',
    'BaseVariablePropertyFactory',
    'SecurityService',
    'Utils',
    '$window',
    '$rootScope',
    'VARIABLE_CONSTANTS',
    'CONSTANTS',
    '$location',
    'BaseService',
    function (Variables, BaseVariablePropertyFactory, SecurityService, Utils, $window, $rootScope, VARIABLE_CONSTANTS, CONSTANTS, $location, BaseService) {
        "use strict";

        var methods, loginVariableObj, initiateCallback;

        /*function to initiate the callback and obtain the data for the callback variable.*/
        initiateCallback = Variables.initiateCallback;

        methods = {
            login: function (variable, options, success, error) {
                var params = {},
                    variableOwner = variable.owner,
                    variableEvents = VARIABLE_CONSTANTS.EVENTS,
                    callBackScope,
                    errMsg,
                    paramKey,
                    loginInfo = {};

                /* get the callback scope for the variable based on its owner */
                if (variableOwner === "App") {
                    /* TODO: to look for a better option to get App/Page the controller's scope */
                    callBackScope = $rootScope || {};
                } else {
                    if (variable.prefabName) {
                        callBackScope = options.scope || {};
                    } else {
                        callBackScope = (options.scope && options.scope.$$childTail) ? options.scope.$$childTail : {};
                    }
                }

                /* If login info provided along explicitly with options, don't look into the variable bindings for the same */
                if (options.loginInfo) {
                    loginInfo = options.loginInfo;
                } else {
                    loginInfo = variable.dataBinding;
                }

                for (paramKey in loginInfo) {
                    if (loginInfo.hasOwnProperty(paramKey) && (loginInfo[paramKey] === '' || loginInfo[paramKey] === undefined)) {
                        errMsg = "Please provide " + paramKey + ".";
                        break;
                    }
                    params[paramKey] = loginInfo[paramKey];
                }

                /* if error message initialized, return error */
                if (errMsg) {
                    /* if in RUN mode, trigger error events associated with the variable */
                    if (CONSTANTS.isRunMode) {
                        Utils.triggerFn(error, errMsg);
                        initiateCallback("onError", variable, callBackScope, errMsg);
                    }
                    return;
                }
                variable.promise = SecurityService.appLogin(params, function (response) {
                    var redirectUrl = response && response.url ? response.url : 'index.html';
                    if (CONSTANTS.isRunMode) {
                        $rootScope.isUserAuthenticated = true;
                        Utils.triggerFn(success);
                        $rootScope.$emit("update-loggedin-user");
                        WM.forEach(variableEvents, function (event) {
                            if (event !== "onError") {
                                initiateCallback(event, variable, callBackScope);
                            }
                        });
                    }
                    if (variable.useDefaultSuccessHandler) {
                        if (CONSTANTS.hasCordova && _.includes(redirectUrl, '/')) {
                            /*
                             * when the application is running as a mobile application,
                             * use the local app files instead of server files.
                             */
                            redirectUrl = redirectUrl.substr(redirectUrl.lastIndexOf('/') + 1);
                        }
                        var redirectPage = $location.search().redirectTo;
                        if (redirectPage && WM.isString(redirectPage) && SecurityService.getLastLoggedInUser() === params.username) {
                            BaseService.executeErrorCallStack();
                            $location.url(redirectPage);
                        } else {
                            $window.location = $window.location.pathname;
                        }
                    }
                    /*
                     * IN CASE OF NOT USING DEFAULT-SUCCESS-HANDLER the new securityConfig are expected
                     * If they are fetched on login response, they can be simply updated
                     * Else a fresh call need to update the same
                     */
                }, function () {
                    /* if in RUN mode, trigger error events associated with the variable */
                    if (CONSTANTS.isRunMode) {
                        initiateCallback("onError", variable, callBackScope, "Invalid username or password.");
                    }
                    Utils.triggerFn(error, "Invalid username or password.");
                });
            },
            cancel: function (variable) {
                /* process only if current variable is actually active */
                if (variable.promise) {
                    variable.promise.abort();
                }
            }
        };

        loginVariableObj = {
            login: function (options, success, error) {
                options = options || {};
                options.scope = this.activeScope || options.scope;
                methods.login(this, options, success, error);
            },
            cancel: function () {
                return methods.cancel(this);
            }
        };

        /* register the variable to the base service */
        BaseVariablePropertyFactory.register('wm.LoginVariable', loginVariableObj, ['wm.Variable', 'wm.ServiceVariable'], methods);

        return {
        };
    }];
/*global wm, WM*/
/*jslint todo: true */
/*jslint sub: true */


/**
 * @ngdoc service
 * @name wm.variables.LogoutVariableService
 * @requires $rootScope
 * @requires $routeParams
 * @requires BaseVariablePropertyFactory
 * @description
 * The 'LogoutVariableService' provides methods to work with LogoutVariable
 */

wm.variables.services.LogoutVariableService = ['Variables',
    'BaseVariablePropertyFactory',
    'SecurityService',
    'Utils',
    '$window',
    '$location',
    'CONSTANTS',
    'VARIABLE_CONSTANTS',
    '$rootScope',
    function (Variables, BaseVariablePropertyFactory, SecurityService, Utils, $window, $location, CONSTANTS, VARIABLE_CONSTANTS, $rootScope) {
        "use strict";

        var methods, logoutVariableObj, initiateCallback;

        /*function to initiate the callback and obtain the data for the callback variable.*/
        initiateCallback = Variables.initiateCallback;

        methods = {
            logout: function (variable, options, success, error) {
                var variableOwner = variable.owner,
                    variableEvents = VARIABLE_CONSTANTS.EVENTS,
                    callBackScope,
                    logoutErrorMessage = "No authenticated user to logout.",
                    handleError;

                /* get the callback scope for the variable based on its owner */
                if (variableOwner === "App") {
                    /* TODO: to look for a better option to get App/Page the controller's scope */
                    callBackScope = $rootScope || {};
                } else {
                    if (variable.prefabName) {
                        callBackScope = options.scope || {};
                    } else {
                        callBackScope = (options.scope && options.scope.$$childTail) ? options.scope.$$childTail : {};
                    }
                }

                handleError = function (msg) {
                    /* if in RUN mode, trigger error events associated with the variable */
                    if (CONSTANTS.isRunMode) {
                        initiateCallback("onError", variable, callBackScope, msg);
                    }
                    Utils.triggerFn(error, msg);
                };

                SecurityService.isAuthenticated(function (isAuthenticated) {
                    if (isAuthenticated) {
                        variable.promise = SecurityService.appLogout(function () {
                            $rootScope.isUserAuthenticated = false;
                            Utils.triggerFn(success);
                            if (variable.useDefaultSuccessHandler) {
                                var redirectPage = variable.redirectTo;
                                if (!redirectPage || redirectPage === "login.html" || redirectPage === "index.html") {
                                    redirectPage = "";
                                }
                                $location.url(redirectPage);
                                $window.location.reload();
                            } else {
                                if (CONSTANTS.isRunMode) {
                                    WM.forEach(variableEvents, function (event) {
                                        if (event !== "onError") {
                                            initiateCallback(event, variable, callBackScope);
                                        }
                                    });
                                }
                            }
                            /* clear the logged in user variable */
                            $rootScope.$emit("update-loggedin-user");
                        }, handleError);
                    } else {
                        handleError();
                    }
                }, function () {
                    handleError(logoutErrorMessage);
                });
            },
            cancel: function (variable) {
                /* process only if current variable is actually active */
                if (variable.promise) {
                    variable.promise.abort();
                }
            }
        };

        function onLogoutSuccess() {
            $rootScope.$emit('app-logout-success');
        }

        logoutVariableObj = {
            logout: function (options, success, error) {
                options = options || {};
                options.scope = options.scope || this.activeScope;
                methods.logout(this, options, function () {
                    onLogoutSuccess();
                    Utils.triggerFn(success);
                }, error);
            },
            cancel: function () {
                return methods.cancel(this);
            }
        };

        /* register the variable to the base service */
        BaseVariablePropertyFactory.register('wm.LogoutVariable', logoutVariableObj, ['wm.Variable', 'wm.ServiceVariable'], methods);

        return {
        };
    }];
/*global wm, WM*/
/*jslint todo: true */
/*jslint sub: true */


/**
 * @ngdoc service
 * @name wm.variables.TimerVariableService
 * @requires $rootScope
 * @requires $routeParams
 * @requires BaseVariablePropertyFactory
 * @description
 * The 'TimerVariableService' provides methods to work with TimerVariable
 */

wm.variables.services.TimerVariableService = ['Variables',
    'BaseVariablePropertyFactory',
    '$rootScope',
    '$interval',
    '$timeout',
    'CONSTANTS',
    function (Variables, BaseVariablePropertyFactory, $rootScope, $interval, $timeout, CONSTANTS) {
        "use strict";

        var methods, timerVariableObj, initiateCallback, timerMap = {}, DEFAULT_TIMER_DELAY = 500;

        /*function to initiate the callback and obtain the data for the callback variable.*/
        initiateCallback = Variables.initiateCallback;

        methods = {
            fire: function (variable, options, success, error) {
                if (WM.isDefined(timerMap[variable.name]) || CONSTANTS.isStudioMode) {
                    return;
                }
                var repeatTimer = variable.repeating,
                    delay = variable.delay || DEFAULT_TIMER_DELAY,
                    event = "onTimerFire",
                    callBackScope = options.scope || $rootScope,
                    exec = function () {
                        initiateCallback(event, variable, callBackScope);
                    };

                timerMap[variable.name] = repeatTimer ? $interval(exec, delay) : $timeout(function () {
                    exec();
                    timerMap[variable.name] = undefined;
                }, delay);
            },
            cancel: function (variable, options) {
                if (WM.isDefined(timerMap[variable.name])) {
                    if (variable.repeating) {
                        $interval.cancel(timerMap[variable.name]);
                    } else {
                        $timeout.cancel(timerMap[variable.name]);
                    }
                    timerMap[variable.name] = undefined;
                }
            }
        };

        timerVariableObj = {
            fire: function (success, error) {
                methods.fire(this, {scope: this.activeScope}, success, error);
            },
            cancel: function () {
                return methods.cancel(this);
            }
        };

        /* register the variable to the base service */
        BaseVariablePropertyFactory.register('wm.TimerVariable', timerVariableObj, [], methods);

        return {
        };
    }];
/*global WM, studio, wm*/

/* Module for il8n */
WM.module("i18n", []);
/*global WM, studio, window, wm*/
/*jslint todo: true */
/**
 * @ngdoc service
 * @name i18nService
 * @requires $rootScope
 * @requires $http
 * @requires Utils
 * @description
 * The `i18nService` service provides functionality required for localization & internationalization support.
 */

WM.module("i18n").service("i18nService", [
    "$rootScope",
    "Utils",
    "$http",
    "$locale",
    "CONSTANTS",
    "$q",

    function ($rootScope, Utils, $http, $locale, CONSTANTS, $q) {
        "use strict";

        var _supportedLocale = [],
            _defaultLocale,
            _appLocaleRootPath,
            _ngLocaleRootPath,
            _selectedLocale,
            localeKey = CONSTANTS.isStudioMode ? "locale" : "appLocale",
            _componentLocalePaths = [],
            _initSuccess = false,
            localeCodesMap = {};

        localeCodesMap = {
            "af": "Afrikaans",
            "af-na": "Afrikaans (Namibi)",
            "af-za": "Afrikaans (Suid-Afrika)",
            "am": "",
            "am-et": " ()", // Amharic (Ethiopia)
            "ar": "", //Arabic
            "ar-001": "() ",// Arabic (world)
            "ar-ae": "(  )  ", // Arabic (United Arab Emirates)
            "ar-bh": "() ", // Arabic (Bahrain)
            "ar-dz": "() ", // Arabic (Algeria)
            "ar-eg": "() ", // Arabic (Egypt)
            "ar-iq": "() ", // Arabic (Iraq)
            "ar-jo": "() ", // Arabic (Jordan)
            "ar-kw": "() ", // Arabic (Kuwait)
            "ar-lb": "() ", // Arabic (Lebanon)
            "ar-ly": "() ", // Arabic (Libya)
            "ar-ma": "() ", // Arabic (Morocco)
            "ar-om": "()  ", // Arabic (Oman)
            "ar-qa": "()  ", // Arabic (Qatar)
            "ar-sa": "(  ) ", // Arabic (Saudi Arabia)
            "ar-sd": "() ", // Arabic (Sudan)
            "ar-sy": "() ", // Arabic (Syria)
            "ar-tn": "() ", // Arabic (Tunisia)
            "ar-ye": "() ", // Arabic (Yemen)
            "bg": "", // Bulgarian
            "bg-bg": " ()", // Bulgarian (Bulgaria)
            "bn": "", // Bengali
            "bn-bd": " ()", // Bengali (Bangladesh)
            "bn-in": " ()", // Bengali (India)
            "ca": "catal", // Catalan
            //"ca-ad": "", //
            "ca-es": "catal (Espanya)", // Catalan (Spain)
            "cs": "etina", // Czech
            "cs-cz": "etina (esk republika)", // Czech (Czech Republic)
            "da": "dansk", // Danish
            "da-dk": "dansk (Danmark)", // Danish (Denmark)
            "de": "Deutsch", // German
            "de-at": "Deutsch (sterreich)", // German (Austria)
            "de-be": "Deutsch (Belgien)", // German (Belgium)
            "de-ch": "Deutsch (Schweiz)", // German (Switzerland)
            "de-de": "Deutsch (Deutschland)", // German (Germany)
            "de-li": "Deutsch (Liechtenstein)", // German (Liechtenstein)
            "de-lu": "Deutsch (Luxemburg)", // German (Luxembourg)
            "el": "", // Greek
            "el-cy": " ()", // Greek (Cyprus)
            "el-gr": " ()", // Greek (Greece)
            "en": "English", // English
            "en-as": "English (American Samoa)", // English (American Samoa)
            "en-au": "English (Australia)", // English (Australia)
            "en-bb": "English (Barbados)", // English (Barbados)
            "en-be": "English (Belgium)", // English (Belgium)
            "en-bm": "English (Bermuda)", // English (Bermuda)
            "en-bw": "English (Botswana)", // English (Botswana)
            "en-bz": "English (Belize)", // English (Belize)
            "en-ca": "English (Canada)", // English (Canada)
            //"en-dsrt":
            //"en-dsrt-us":
            //"en-fm":
            "en-gb": "English (United Kingdom)", // English (United Kingdom)
            "en-gu": "English (Guam)", // English (Guam)
            "en-gy": "English (Guyana)", // English (Guyana)
            "en-hk": "English (Hong Kong SAR China)", // English (Hong Kong SAR China)
            "en-ie": "English (Ireland)", // English (Ireland)
            "en-in": "English (India)", // English (India)
            //"en-iso":
            "en-jm": "English (Jamaica)", // English (Jamaica)
            "en-mh": "English (Marshall Islands)", // English (Marshall Islands)
            "en-mp": "English (Northern Mariana Islands)", // English (Northern Mariana Islands)
            "en-mt": "English (Malta)", // English (Malta)
            "en-mu": "English (Mauritius)", // English (Mauritius)
            "en-na": "English (Namibia)", // English (Namibia)
            "en-nz": "English (New Zealand)", // English (New Zealand)
            "en-ph": "English (Philippines)", // English (Philippines)
            "en-pk": "English (Pakistan)", // English (Pakistan)
            //"en-pr":
            //"en-pw":
            "en-sg": "English (Singapore)", // English (Singapore)
            //"en-tc":
            "en-tt": "English (Trinidad and Tobago)", // English (Trinidad and Tobago)
            "en-um": "English (U.S. Minor Outlying Islands)", // English (U.S. Minor Outlying Islands)
            "en-us": "English (United States)", // English (United States)
            //"en-vg":
            "en-vi": "English (U.S. Virgin Islands)", // English (U.S. Virgin Islands)
            "en-za": "English (South Africa)", // English (South Africa)
            "en-zw": "English (Zimbabwe)", // English (Zimbabwe)
            "es": "espaol", // Spanish
            "es-419": "espaol (Latinoamrica)", // Spanish (Latin America)
            "es-ar": "espaol (Argentina)", // Spanish (Argentina)
            "es-bo": "espaol (Bolivia)", // Spanish (Bolivia)
            "es-cl": "espaol (Chile)", // Spanish (Chile)
            "es-co": "espaol (colombia)", // Spanish (Colombia)
            "es-cr": "espaol (Costa Rica)", // Spanish (Costa Rica)
            "es-do": "espaol (Repblica Dominicana)", // Spanish (Dominican Republic)
            //"es-ea":
            "es-ec": "espaol (Ecuador)", // Spanish (Ecuador)
            "es-es": "espaol (Espaa)", // Spanish (Spain)
            "es-gq": "espaola (Guinea Ecuatorial)", // Spanish (Equatorial Guinea)
            "es-gt": "espaol (Guatemala)", // Spanish (Guatemala)
            "es-hn": "espaol (Honduras)", // Spanish (Honduras)
            //"es-ic": "", //
            "es-mx": "espaol (Mxico)", // Spanish (Mexico)
            "es-ni": "espaol (Nicaragua)", // Spanish (Nicaragua)
            "es-pa": "espaol (Panam)", // Spanish (Panama)
            "es-pe": "espaol (Per)", // Spanish (Peru)
            "es-pr": "espaol (Puerto Rico)", // Spanish (Puerto Rico)
            "es-py": "espaol (Paraguay)", // Spanish (Paraguay)
            "es-sv": "espaol (El Salvador)", // Spanish (El Salvador)
            "es-us": "espaol (estados unidos)", // Spanish (United States)
            "es-uy": "espaol (Uruguay)", // Spanish (Uruguay)
            "es-ve": "espaol (Venezuela)", // Spanish (Venezuela)
            "et": "eesti", // Estonian
            "et-ee": "eesti (Eesti)", // Estonian (Estonia)
            "eu": "euskara", // Basque
            "eu-es": "euskara (euskara)", // Basque (Spain)
            "fa": "", // Persian
            "fa-af": "() ", // Persian (Afghanistan)
            "fa-ir": "() ", // Persian (Iran)
            "fi": "suomi", // Finnish
            "fi-fi": "suomi (Suomi)", // Finnish (Finland)
            "fil": "Filipino", // Filipino
            "fil-ph": "Filipino (Pilipinas)", // Filipino (Pilipinas
            "fr": "franais", // French
            "fr-be": "franais (belgique)", // French (Belgium)
            "fr-bf": "franais (Burkina Faso)", // French (Burkina Faso)
            "fr-bi": "franais (Burundi)", // French (Burundi)
            "fr-bj": "franais (Bnin)", // French (Benin)
            "fr-bl": "franais (saints Barthlemy)", // French (Saint Barthlemy)
            "fr-ca": "franais (Canada)", // French (Canada)
            "fr-cd": "franais (Congo-Kinshasa)", // French (Congo - Kinshasa)
            "fr-cf": "franais (Rpublique centrafricaine)", // French (Central African Republic)
            "fr-cg": "franais (Congo-Brazzaville)", // French (Congo - Brazzaville)
            "fr-ch": "franais (Suisse)", // French (Switzerland)
            "fr-ci": "franais (Cte dIvoire)", // French (Cte dIvoire)
            "fr-cm": "franais (Cameroun)", // French (Cameroon)
            "fr-dj": "franais (Djibouti)", // French (Djibouti)
            "fr-fr": "franais (France)", // French (France)
            "fr-ga": "franais (Gabon)", // French (Gabon)
            "fr-gf": "franais (Guyane franaise)", // French (French Guiana)
            "fr-gn": "franais (Guine)", // French (Guinea)
            "fr-gp": "franais (Guadeloupe)", // French (Guadeloupe)
            "fr-gq": "franais (Guine quatoriale)", // French (Equatorial Guinea)
            "fr-km": "franais (Comores)", // French (Comoros)
            "fr-lu": "franais (luxembourg)", // French (Luxembourg)
            "fr-mc": "franais (Monaco)", // French (Monaco)
            "fr-mf": "franais (Saint-Martin)", // French (Saint Martin)
            "fr-mg": "franais (Madagascar)", // French (Madagascar)
            "fr-ml": "franais (Mali)", // French (Mali)
            "fr-mq": "franais (Martinique)", // French (Martinique)
            "fr-ne": "franais (Niger)", // French (Niger)
            "fr-re": "franais (Runion)", // French (Runion)
            "fr-yt": "franais (Mayotte)", // French (Mayotte)
            "gl": "galego", // Galician
            "gl-es": "galego (Espaa)", // Galician (Spain)
            "gsw": "Elsssisch", // Alsatian
            //"gsw-ch": "", //
            "gu": "", // Gujarati
            "gu-in": " ()", // Gujarati (India)
            "he": "", // Hebrew
            "he-il": "() ", // Hebrew (Israel)
            "hi": "", // Hindi
            "hi-in": " ()", // Hindi (India)
            "hr": "hrvatski", // Croatian
            "hr-hr": "hrvatski (Hrvatska)", // Croatian (Croatia)
            "hu": "magyar", // Hungarian
            "hu-hu": "magyar (Magyarorszg)", // Hungarian (Hungary)
            "id": "indonesia", // Indonesian
            "id-id": "indonesia (Indonesia)", // Indonesian (Indonesia)
            //"in": "", //
            "is": "slenska", // Icelandic
            "is-is": "slenska (sland)", // Icelandic (Iceland)
            "it": "italiano", // Italian
            "it-it": "italiano (svizzera)", //Italian (Switzerland)
            //"it-sm": "", //
            //"iw": "", //
            "ja": "", // Japanese
            "ja-jp": "", // Japanese (Japan)
            "kn": "", // Kannada
            "kn-in": " ()", // Kannada (India)
            "ko": "", // Korean
            "ko-kr": " ()", // Korean (South Korea)
            "ln": "Lingala", // Lingala
            "ln-cd": "Lingala (Congo - Kinshasa)", //Lingala (Congo - Kinshasa)
            "lt": "lietuvi", // Lithuanian
            "lt-lt": "lietuvi (Lietuva)", // Lithuanian (Lithuania)
            "lv": "latvieu", // Latvian
            "lv-lv": "latvieu (Latvija)", // Latvian (Latvia)
            "ml": "", // Malayalam
            "ml-in": " ()", // Malayalam (India)
            "mr": "", // Marathi
            "mr-in": " ()", // Marathi (India)
            "ms": "Melayu", // Malay
            "ms-my": "Melayu (Malaysia)", // Malay (Malaysia)
            "mt": "Malti", // Maltese
            "mt-mt": "Malti (Malta)", // Maltese (Malta)
            "nl": "nederlands", // Dutch
            "nl-cw": "nederlands (Curacao)", // Dutch (Curaao)
            "nl-nl": "nederlands (Nederland)", // Dutch (Netherlands)
            "nl-sx": "nederlands (Sint Maarten)", // Dutch (Sint Maarten)
            "no": "norsk", // Norwegian
            "or": "", // Oriya
            "or-in": " ()", // Oriya (India)
            "pl": "polski", // Polish
            "pl-pl": "polski (Polska)", // Polish (Poland)
            "pt": "Portugus", // Portuguese
            "pt-br": "Portugus (Brasil)", // Portuguese (Brazil)
            "pt-pt": "portugus (Portugal)", // Portuguese (Portugal)
            "pt-st": "portugus (So Tom and Prncipe)", // Portuguese (So Tom and Prncipe)
            //"pt-tl": "", //
            "ro": "romn", // Romanian
            "ro-ro": "romn (Romnia)", // Romanian (Romania)
            "ru": "", // Russian
            "ru-ru": " ()", // Russian (Russia)
            "sk": "slovenina", // Slovak
            "sk-sk": "Slovak (Slovakia)", // slovenina (Slovensk republika)
            "sl": "slovenski", // Slovenian
            "sl-si": "slovenski (Slovenija)", // Slovenian (Slovenia)
            "sq": "shqipe", // Albanian
            "sq-al": "shqipe (Shqipria)", // Albanian (Albania)
            "sr": "srpski", // Serbian
            "sr-cyrl-rs": " ()", // Serbian (Cyrillic, Serbia)
            "sr-latn-rs": "srpski (Srbija)", // Serbian (Latin, Serbia)
            "sv": "svenska", // Swedish
            "sv-se": "svenska (Sverige)", // Swedish (Sweden)
            "sw": "Swahili", //Swahili
            "sw-tz": "Swahili (Tanzania)", // Swahili (Tanzania)
            "ta": "", // Tamil
            "ta-in": " ()", // Tamil (India)
            "te": "", // Telugu
            "te-in": " ( )", // Telugu (India)
            "th": "", // Thai
            "th-th": " ()", // Thai (Thailand)
            "tl": "Tigrinya ", // Tigrinya
            "tr": "Trke", // Turkish
            "tr-tr": "Trke (Trkiye)", // Turkish (Turkey)
            "uk": "", // Ukrainian
            "uk-ua": " ()", // Ukrainian (Ukraine)
            "ur": "", // Urdu
            "ur-pk": " () ", // Urdu (Islamic Republic of Pakistan)
            "vi": "Ting Vit", // Vietnamese
            "vi-vn": "Ting Vit (Vit Nam)", // Vietnamese (Vietnam)
            "zh": "", // Chinese
            "zh-cn": "()", // Chinese (Simplified, PRC)
            "zh-hans-cn": "", //Chinese (Simplified, China)
            "zh-hk": "()", // Chinese (Traditional, Hong Kong S.A.R.)
            "zh-tw": "()", // Chinese (Traditional, Taiwan)
            "zu": "isiZulu", // Zulu
            "zu-za": "isiZulu (iNingizimu Afrika)" // Zulu (South Africa)
        };

        $rootScope[localeKey] = {}; /* reset the locale object on the rootScope */

        // function to get the parameterized localized messages.
        $rootScope.getLocalizedMessage = function () {
            var args = Array.prototype.slice.call(arguments),
                key = $rootScope[localeKey][args.shift()];

            return Utils.replace(key, args);
        };

        /* helper function VERY SPECIFIC to extend $locale */
        function extendLocale(dst, src) {
            dst.id = src.id;
            dst.pluralCat = src.pluralCat;
            ["DATETIME_FORMATS", "NUMBER_FORMATS"].forEach(function (type) {
                Object.keys(src[type]).forEach(function (key) {
                    dst[type][key] = src[type][key];
                });
            });
        }

        function loadComponentLocaleBundles() {
            var deferred = $q.defer(),
                count = _componentLocalePaths.length,
                content = {};

            if (!count) {
                deferred.resolve(content);
            }

            _componentLocalePaths.forEach(function (path) {
                path  += _selectedLocale + ".json";
                $http
                    .get(path)
                    .success(function (response) {
                        /* extend the $rootScope.locale object with the response json */
                        WM.extend(content, response);
                        count--;
                        if (!count) {
                            deferred.resolve(content);
                        }
                    });
            });

            return deferred.promise;
        }

        /**
         * Loads the localeBundle.
         * Placeholders in the path will be replaced with the selected locale value and localeBundle will be loaded using the constructed path.
         */
        function loadAppLocaleBundle(content) {
            var path = _appLocaleRootPath + _selectedLocale + ".json";
            /* load the localeBundle */

            $http
                .get(path)
                .success(function (response) {
                    /* extend the $rootScope.locale object with the response json */
                    WM.extend($rootScope[localeKey], response, content);
                });
        }

        /**
         * Loads the angular ngLocale resource of the selected locale.
         */
        function loadNgLocaleBundle() {
            var deferred = $q.defer(),
                ngLocaleFilePath = _ngLocaleRootPath;

            if (!ngLocaleFilePath) {
                deferred.resolve();
            }

            ngLocaleFilePath += "angular-locale_" + _selectedLocale + ".js";

            /* load ngLocale module for the selected locale */

            /* load the script tag */
            WM.element.ajax({
                dataType: "script",
                url: ngLocaleFilePath,
                cache: true /* read the script tag from the cache when available */
            }).done(function () {
                extendLocale($locale, WM.injector(["ngLocale"]).get("$locale"));
                deferred.resolve();
            });
            return deferred.promise;
        }

        /* loads the locale bundles */
        function loadLocaleBundles(emitEvent) {
            loadNgLocaleBundle()
                .then(loadComponentLocaleBundles)
                .then(loadAppLocaleBundle)
                .then(function () {
                    if (emitEvent) {
                        $rootScope.$emit('locale-change');
                    }
                });
        }

        /*
         * this method will be triggered when there is a change in the locale selection.
         * load the localeBundles related to the selected locale.
         * This method emits "locale-change" event on the $rootScope.
         */
        function setSelectedLocale(locale) {
            if (!_initSuccess) {
                return;
            }

            if (_supportedLocale.indexOf(locale) === -1) {
                return;
            }

            if (!locale || locale === _selectedLocale) {
                return;
            }

            _selectedLocale = locale;

            /* reset the $rootScope.locale object */
            $rootScope[localeKey] = {};

            /* load the locale bundles of the selected locale */
            loadLocaleBundles(true);
        }

        /* returns the default locale */
        function getDefaultLocale() {
            return _defaultLocale;
        }

        /* returns the selected locale */
        function getSelectedLocale() {
            return _selectedLocale;
        }

        function init(supportedLocale, defaultLocale, appLocaleRootPath, ngLocaleRootPath) {
            /* supportedLocale must be a non empty array */
            if (!supportedLocale || !WM.isArray(supportedLocale) || supportedLocale.length === 0) {
                return;
            }

            _supportedLocale = supportedLocale;

            /* appLocaleRootPath must be a non empty string */
            if (!appLocaleRootPath || appLocaleRootPath.length === 0) {
                return;
            }
            _appLocaleRootPath = appLocaleRootPath;
            _defaultLocale = defaultLocale || supportedLocale[0];
            _ngLocaleRootPath = ngLocaleRootPath;
            _initSuccess = true;

            /* load the default locale bundle */
            setSelectedLocale(_defaultLocale);
        }

        function extendAppLocale(path) {
            path  += _selectedLocale + ".json";
            $http
                .get(path)
                .success(function (response) {
                    /* extend the $rootScope.locale object with the response json */
                    WM.extend($rootScope.appLocale, response);
                });
        }

        // loads the locale bundle related to a component
        function loadComponentLocaleBundle(path) {
            if (!_initSuccess) {
                return;
            }
            if (path && _componentLocalePaths.indexOf(path) === -1) {
                _componentLocalePaths.push(path);
                extendAppLocale(path);
            }
        }

        function getLocaleCodesMap() {
            return localeCodesMap;
        }

        return {
            /**
             * @ngdoc function
             * @name i18nService#init
             * @methodOf i18nService
             * @function
             *
             * @description
             * initialize the i18nService.
             * load the default locale bundle
             *
             * @param {Array} supportedLocale array of supported locale
             * @param {String} defaultLocale default locale
             * @param {String} appLocaleRootPath root path of the application related locale files
             * @param {String} appLocaleRootPath root path of the ngLocale files
             */
            init: init,

            /**
             * @ngdoc function
             * @name i18nService#getDefaultLocale
             * @methodOf i18nService
             * @function
             *
             * @description
             * returns the default locale.
             */
            getDefaultLocale: getDefaultLocale,

            /**
             * @ngdoc function
             * @name i18nService#getSelectedLocale
             * @methodOf i18nService
             * @function
             *
             * @description
             * returns the locale for the the locale bundle is recently loaded.
             */
            getSelectedLocale: getSelectedLocale,

            /**
             * @ngdoc function
             * @name i18nService#setSelectedLocale
             * @methodOf i18nService
             * @function
             *
             * @description
             * sets the localeid passed as selected and load the locale bundle related to it.
             *
             * @param {String} locale locale id for which the bundle needs to be loaded.
             */
            setSelectedLocale: setSelectedLocale,

            /**
             * @ngdoc function
             * @name i18nService#loadComponentLocaleBundle
             * @methodOf i18nService
             * @function
             *
             * @description
             * load the locale bundle of a component
             *
             * @param {String} path path from where the component locale bundle needs to be loaded
             */
            loadComponentLocaleBundle: loadComponentLocaleBundle,

            /**
             * @ngdoc function
             * @name i18nService#getLocaleCodesMap
             * @methodOf i18nService
             * @function
             *
             * @description
             * returns the available locale codes - name map
             */
            getLocaleCodesMap: getLocaleCodesMap
        };
    }
]);
/*global WM, window, _, cordova, document*/

WM.module('wm.mobile', ['wm.variables', 'wm.layouts', 'wm.widgets', 'ngCordova'])
    //Initialize project
    .run(['$rootScope', '$location', 'CONSTANTS', 'Utils', 'AppAutoUpdateService',
        function ($rootScope, $location, CONSTANTS, Utils, AppAutoUpdateService) {
            'use strict';
            /* Mark the mobileApplication type to true */
            $rootScope.isMobileApplicationType = true;

            if ($location.protocol() === 'file') {
                CONSTANTS.hasCordova = true;
                $rootScope.$on('application-ready', function () {
                    AppAutoUpdateService.start();
                });
            }
            if (CONSTANTS.isRunMode) {
                $rootScope.$on('$routeChangeStart', function () {
                    WM.element('body >.app-spinner:first').removeClass('ng-hide');
                });
                $rootScope.$on('page-ready', function () {
                    WM.element('body >.app-spinner:first').addClass('ng-hide');
                });
                $rootScope.$on('template-ready', function () {
                    WM.element('body >.app-spinner:first').addClass('ng-hide');
                });
            }
        }])
    //Initialize variables
    .run(['Variables', 'WIDGET_CONSTANTS', 'BaseVariablePropertyFactory', 'DeviceVariableService', 'NavigationVariableService',
        function (Variables, WIDGET_CONSTANTS, BaseVariablePropertyFactory, DeviceVariableService) {
            'use strict';

            /* Register Mobile specific Variables*/
            Variables.addVariableConfig({
                'collectionType': 'data',
                'category': 'wm.DeviceVariable',
                'labelKey': 'LABEL_VARIABLE_DEVICE',
                'defaultName': 'deviceVariable'
            });
            /* Add additional event options.*/
            WIDGET_CONSTANTS.EVENTS_OPTIONS.push('New DeviceVariable');
            /* Add segment navigation option */
            BaseVariablePropertyFactory.addNavigationOption('gotoSegment', 'gotoSegment');
            //Register the Mobile variable.
            BaseVariablePropertyFactory.register('wm.DeviceVariable',
                {'invoke': DeviceVariableService.invoke},
                ['wm.DeviceVariable'],
                {});
            /* enable page transitions.*/
            BaseVariablePropertyFactory.getPropertyMap('wm.NavigationVariable').pageTransitions.hide = false;
        }])
    //Apply platform OS specific stylesheets
    .run(['$rootScope', 'CONSTANTS', 'Utils', function ($rootScope, CONSTANTS, Utils) {
        'use strict';
        var selectedOs = '';

        function applyOSTheme(os) {
            var themeUrl = '',
                oldStyleSheet = WM.element('link[theme="wmtheme"]:first'),
                newStyleSheet;
            selectedOs = os || selectedOs;
            themeUrl = 'themes/' + $rootScope.project.activeTheme + '/' + selectedOs.toLowerCase() + '/' + 'style.css';
            if (CONSTANTS.isStudioMode) {
                themeUrl = Utils.getProjectResourcePath($rootScope.project.id) + themeUrl;
            }
            newStyleSheet = Utils.loadStyleSheet(themeUrl, {name: 'theme', value: 'wmtheme'});
            if (newStyleSheet) {
                WM.element(newStyleSheet).insertAfter(oldStyleSheet);
                oldStyleSheet.remove();
            }
        }
        if (CONSTANTS.isStudioMode) {
            $rootScope.$on('switch-device', function (event, device) {
                applyOSTheme(device.os);
            });
        } else if (CONSTANTS.isRunMode) {
            //This is for preview page
            window.onmessage = function (msg) {
                var data = Utils.isIE9() ? JSON.parse(msg.data) : msg.data;
                if (WM.isObject(data) && data.key === 'switch-device') {
                    applyOSTheme(data.device.os);
                }
            };
            //On Application start
            $rootScope.$on('application-ready', function () {
                 var msgContent = {key: 'on-load'};
                //Notify preview window that application is ready. Otherwise, identify the OS.
                if (window.top !== window) {
                    window.top.postMessage(Utils.isIE9() ? JSON.stringify(msgContent) : msgContent, '*');
                } else if (Utils.isAndroid()) {
                    applyOSTheme('android');
                } else if (Utils.isIphone()) {
                    applyOSTheme('ios');
                }
            });
        }
    }]);

/*global wm, WM, cordova*/
/*jslint sub: true */
WM.module('wm.widgets.advanced')
    .run(['$templateCache', function ($templateCache) {
        'use strict';

        $templateCache.put('template/widget/advanced/appUpdate.html',
            '<div class="modal fade in" data-ng-style="{display : show ? \'block\' : \'none\'}">' +
                '<div class="modal-dialog">' +
                    '<div class="modal-content">' +
                        '<div class="modal-body">' +
                            '<span>{{message}}</span>' +
                            '<div class="progress" data-ng-show="downloading">' +
                                '<div class="progress-bar" data-ng-style="{ \'width\' : downloadProgress + \'%\'}"></div>' +
                            '</div>' +
                        '</div>' +
                        '<div class="modal-footer">' +
                            '<button type="button" class="btn btn-default" data-dismiss="modal" data-ng-click="cancel()">' +
                                'Continue with existing App.' +
                            '</button>' +
                            '<button type="button" class="btn btn-primary" data-ng-hide="downloading" data-ng-click="updateApp()">' +
                                'Update' +
                            '</button>' +
                        '</div>' +
                    '</div>' +
                '</div>' +
            '</div>');
    }]);

wm.modules.wmCommon.services.AppAutoUpdateService = [
    '$compile',
    '$cordovaFile',
    '$cordovaFileOpener2',
    '$cordovaFileTransfer',
    '$http',
    '$q',
    '$rootScope',
    '$templateCache',
    function ($compile, $cordovaFile, $cordovaFileOpener2, $cordovaFileTransfer, $http, $q, $rootScope, $templateCache) {
        'use strict';
        var config, ele, scope, fileName = 'app-auto-update.apk';

        function cleanAutoUpdateFile() {
            $cordovaFile.removeFile(cordova.file.externalApplicationStorageDirectory, fileName);
        }

        function installLatestVersion() {
            var downloadLink = config.host + '/appBuild/rest/mobileBuilds/android/download?',
                apkFile =  cordova.file.externalApplicationStorageDirectory + fileName;

            downloadLink += 'token=' + config.token
                            + '&buildNumber=' + config.latestBuildNumber
                            + '&fileName=' + fileName;
            $cordovaFileTransfer.download(downloadLink, apkFile, {}, true)
                .then(function () {
                    $cordovaFileOpener2.open(apkFile, 'application/vnd.android.package-archive');
                }, function () {
                    scope.message = 'Failed to download latest version.';
                }, function (progress) {
                    scope.downloadProgress = (progress.loaded / progress.total) * 100;
                });
            scope.message = 'Downloading the latest version ['+ config.latestVersion +'].';
            scope.downloading = true;
        }

        function getUserConfirmationAndInstall() {
            scope = $rootScope.$new();
            scope.downloadProgress = 0;
            scope.updateApp = installLatestVersion;
            scope.show = true;
            scope.downloading = false;
            scope.message = 'There is an update available. Would you like to update the app?';
            scope.cancel = function () {
                ele.remove();
                scope.$destroy();
            };
            ele = $compile($templateCache.get('template/widget/advanced/appUpdate.html'))(scope);
            WM.element('body:first').append(ele);
            $templateCache.remove('template/widget/advanced/appUpdate.html');
        }

        function checkForUpdate() {
            var deferred = $q.defer();
            $http.get(config.host + '/appBuild/rest/mobileBuilds/latest_build?token=' + config.token)
                .then(function (response) {
                    var latestBuildNumber = response.data.success.body.buildNumber,
                        latestVersion =  response.data.success.body.version;
                    if (config.buildNumber < latestBuildNumber) {
                        config.latestBuildNumber = latestBuildNumber;
                        config.latestVersion = latestVersion;
                        deferred.resolve(latestBuildNumber);
                    } else {
                        deferred.reject();
                    }
                });
            return deferred.promise;
        }

        this.start = function () {
            $http.get('./build_meta.json')
                .then(function (response) {
                    config = response.data;
                    if (config.buildMode === 'DEVELOPMENT_MODE') {
                        cleanAutoUpdateFile();
                        checkForUpdate().then(getUserConfirmationAndInstall.bind(undefined));
                    }
                });
        };
    }];
/*global WM,LocalFileSystem*/
/*jslint sub: true */
/*global window*/
/*Directive for fileupload */

wm.modules.wmCommon.services.FileSelectorService = ['$compile', '$rootScope',
    function ($compile, $rootScope) {
        var ele = $compile('<wm-mobile-file-browser/>')($rootScope.$new()),
            fileSelector = ele.isolateScope();
        WM.element('body:first').append(ele);
        this.open = function (config, onSelect) {
            config = WM.extend({ multiple : false }, config);
            fileSelector.multiple = config.multiple || false;
            fileSelector.onSelect = function (result) {
                onSelect(result.files);
            };
            fileSelector.show = true;
        };
        this.close = function () {
            fileSelector.show = false;
        };
    }];
/*global wm, _, WM*/
/*jslint sub: true */
/*Directive for pageTransition */

/**
 * @ngdoc service
 * @name wm.common.$NavigationService
 * @requires $rootScope
 * @requires ViewService
 * @requires DialogService
 * @description
 * This is the factory responsible for page navigation. It manages page navigation and also handles the page transitions.
 * Page transitions include Slide, Pop, Fade, Flip. Default value is none.
 */

wm.modules.wmCommon.services.NavigationService = [
    '$rootScope',
    '$window',
    'ViewService',
    'DialogService',
    '$timeout',

    function ($rs, $window, ViewService, DialogService, $timeout) {
        'use strict';

        var nextTransitionToApply,
            parentSelector = 'body:first >#wm-app-content:last',
            pageStackObject;

        pageStackObject = (function () {
            var stack = [], currentPage;
            return {
                'getCurrentPage' : function () {
                    return currentPage;
                },
                'addPage' : function (pageInfo) {
                    if (currentPage) {
                        stack.push(currentPage);
                    }
                    currentPage = pageInfo;
                },
                'goBack' : function () {
                    currentPage = stack.pop();
                },
                'getLastPage' : function () {
                    return stack.length > 0 ? stack[stack.length - 1] : undefined;
                },
                'isLastVisitedPage' : function (pageName) {
                    return stack.length > 0 ? this.getLastPage().name === pageName : false;
                }
            };
        }());

        //checks if the pagecontainer has the pageName.
        function isPartialWithNameExists(name) {
            return WM.element('[page-container][content="' + name + '"]').length;
        }

        /*
         * shows all the parent container view elements for a given view element
         */
        function showAncestors(element) {
            var ancestorSearchQuery = '[wm-navigable-element="true"]';

            element
                .parents(ancestorSearchQuery)
                .toArray()
                .reverse()
                .forEach(function (parent) {
                    //get the isolateScope of the widget
                    var $is = WM.element(parent).isolateScope();
                    switch ($is._widgettype) {
                    case 'wm-view':
                        ViewService.showView($is.name);
                        break;
                    case 'wm-accordionpane':
                        $is.expand();
                        break;
                    case 'wm-tabpane':
                        $is.select();
                        break;
                    case 'wm-segment-content':
                        $is.navigate();
                        break;
                    case 'wm-panel':
                        /* flip the active flag */
                        $is.expanded = true;
                        break;
                    }
                });
        }

        /*
         * searches for a given view element inside the available dialogs in current page
         * if found, the dialog is displayed, the dialog id is returned.
         */
        function showAncestorDialog(viewName) {
            var dialogId;
            WM.element('#wm-app-content [dialogtype]')
                .each(function () {
                    var dialog = WM.element(this);
                    if (WM.element(dialog.html()).find("[name='" + viewName + "']").length) {
                        dialogId = dialog.attr("name");
                        DialogService.closeAllDialogs();
                        DialogService.showDialog(dialogId);
                        return false;
                    }
                });
            return dialogId;
        }


        /*
         * navigates the user to a view element with given name
         * if the element not found in the compiled markup, the same is searched in the available dialogs in the page
         */
        function goToView(viewElement, viewName) {
            var $is = viewElement.isolateScope(),
                parentDialog;

            if (viewElement.length) {
                switch ($is._widgettype) {
                case 'wm-view':
                    showAncestors(viewElement);
                    ViewService.showView(viewName);
                    break;
                case 'wm-accordionpane':
                    showAncestors(viewElement);
                    $is.expand();
                    break;
                case 'wm-tabpane':
                    showAncestors(viewElement);
                    $is.select();
                    break;
                case 'wm-segment-content':
                    showAncestors(viewElement);
                    $is.navigate();
                    break;
                case 'wm-panel':
                    /* flip the active flag */
                    $is.expanded = true;
                    break;
                }
            } else {
                parentDialog = showAncestorDialog(viewName);
                $timeout(function () {
                    if (parentDialog) {
                        goToView(WM.element('[name="' + viewName + '"]'), viewName, false);
                    }
                });
            }
        }

        //listens for the event only once and destroys the listener.
        function listenOnce(eventName, callBack) {
            var removeListener = $rs.$on(eventName, function () {
                removeListener();
                callBack.call(undefined, arguments);
            });
        }

        $rs.$on('$routeChangeStart', function (evt, $next) {
            var pageName = $next.params.name;
            if (pageName) {
                if (pageStackObject.isLastVisitedPage(pageName)) {
                    nextTransitionToApply = pageStackObject.getCurrentPage().transition + '-exit';
                    pageStackObject.goBack();
                } else {
                    pageStackObject.addPage({
                        'name' : pageName,
                        'transition' : nextTransitionToApply
                    });
                }
                WM.element('#wm-app-content:first').addClass('page-transition-' + nextTransitionToApply);
                nextTransitionToApply = '';
            }
        });

        /**
         * @ngdoc function
         * @name wm.common.$NavigationService#goToPage
         * @methodOf wm.common.$NavigationService
         * @function
         *
         * @description
         * Navigates to the page.
         *
         * @param {string} pageName Name of the page.
         * @param {string} transition Page-transition applied to the page.
         * @param {string} viewName Name of the view within the page.
         */
        this.goToPage = function (pageName, transition, viewName) {
            nextTransitionToApply = transition || '';

            var _location = '#/' + pageName;
            if (viewName) {
                _location +=  '.' + viewName;
            }

            $window.location = _location;
        };

        /**
         * @ngdoc function
         * @name wm.common.$NavigationService#goToView
         * @methodOf wm.common.$NavigationService
         * @function
         *
         * @description
         * Navigates to the view.
         *
         * @param {string} pageName Name of the page.
         * @param {string} viewName Name of the view within the page.
         * @param {string} transition Page-transition applied to the page.
         */
        this.goToView = function (pageName, viewName, transition) {

            if (!pageName || pageName === $rs.activePageName || isPartialWithNameExists(pageName)) {
                goToView(WM.element(parentSelector).find('[name="' + viewName + '"]'), viewName);
            } else {
                this.goToPage(pageName, transition, viewName);
                listenOnce('page-ready', function () {
                    goToView(WM.element(parentSelector).find('[name="' + viewName + '"]'), viewName);
                });
            }
        };

        /**
         * @ngdoc function
         * @name wm.common.$NavigationService#goToPrevious
         * @methodOf wm.common.$NavigationService
         * @function
         *
         * @description
         * Navigates to last visited page.
         */
        this.goToPrevious = function () {
            var lastPage = pageStackObject.getLastPage();
            if (lastPage) {
                this.goToPage(lastPage.name);
                return true;
            }
            return false;
        };
    }
];
/*global WM*/
/**
 * DeviceViewService is not required for Mobile Apps. But, this is being used app-runtime.
 * So, to circumvent the injection errors, this dummy service is being initialized.
 */
WM.module("wm.layouts.device").service("DeviceViewService", [function () {
    'use strict';
    return {
        update: WM.noop
    };
}]);
/*global WM, _*/
WM.module('wm.variables').run(['DeviceVariableService', '$cordovaCalendar', function (DeviceVariableService, $cordovaCalendar) {
    "use strict";
    var event = {
            title: '',
            message: '',
            location: '',
            startDate: '',
            endDate: ''
        },
        parseDate = function (dateStr, defaultDate) {
            return (dateStr && dateStr.length > 0) ? new Date(dateStr) : defaultDate;
        },
        defaultStartDate = new Date(new Date().getTime() - (3 * 30 * 24 * 60 * 60 * 1000)), // 3 months previous date
        defaultEndDate = new Date(new Date().getTime() + (3 * 30 * 24 * 60 * 60 * 1000)),   // 3 months later date
        operations = {
            createEvent: {
                properties : [
                    {"target": "eventTitle", "type": "string", "dataBinding": true},
                    {"target": "eventNotes", "type": "string", "dataBinding": true},
                    {"target": "eventLocation", "type": "string", "dataBinding": true},
                    {"target": "eventStart", "type": "string", "dataBinding": true},
                    {"target": "eventEnd", "type": "string", "dataBinding": true}
                ],
                requriedCordovaPlugins: ['CALENDAR'],
                invoke : function (variable, options, success, error) {
                    var createEventOptions = {
                        title: variable.eventTitle,
                        location: variable.eventLocation,
                        notes: variable.eventNotes,
                        startDate: variable.eventStart,
                        endDate: variable.eventEnd
                    };
                    $cordovaCalendar.createEvent(createEventOptions).then(success, error);
                }
            },
            deleteEvent: {
                properties : [
                    {"target": "eventTitle", "type": "string", "dataBinding": true},
                    {"target": "eventLocation", "type": "string", "dataBinding": true},
                    {"target": "eventNotes", "type": "string", "dataBinding": true},
                    {"target": "eventStart", "type": "string", "dataBinding": true},
                    {"target": "eventEnd", "type": "string", "dataBinding": true}
                ],
                requriedCordovaPlugins: ['CALENDAR'],
                invoke : function (variable, options, success, error) {
                    var removeEventOptions = {
                        newTitle: variable.eventTitle,
                        location: variable.eventLocation,
                        notes: variable.eventNotes,
                        startDate: variable.eventStart,
                        endDate: variable.eventEnd
                    };
                    $cordovaCalendar.deleteEvent(removeEventOptions).then(success, error);
                }
            },
            getEvents: {
                model : [event],
                properties : [
                    {"target": "eventTitle", "type": "string", "dataBinding": true},
                    {"target": "eventLocation", "type": "string", "dataBinding": true},
                    {"target": "eventNotes", "type": "string", "dataBinding": true},
                    {"target": "eventStart", "type": "string", "dataBinding": true},
                    {"target": "eventEnd", "type": "string", "dataBinding": true},
                    {"target": "startUpdate", "type": "boolean"}
                ],
                requriedCordovaPlugins: ['CALENDAR'],
                invoke : function (variable, options, success, error) {
                    var listEventOptions = {
                        title: variable.eventTitle,
                        location: variable.eventLocation,
                        notes: variable.eventNotes,
                        startDate: parseDate(variable.eventStart, defaultStartDate),
                        endDate: parseDate(variable.eventEnd, defaultEndDate)
                    };
                    $cordovaCalendar.findEvent(listEventOptions).then(success, error);
                }
            }
        };

    WM.forEach(operations, function (value, key) {
        DeviceVariableService.addOperation('calendar', key, value);
    });
}]);
/*global WM, _*/
WM.module('wm.variables').run(['DeviceVariableService', '$cordovaContacts', function (DeviceVariableService, $cordovaContacts) {
    "use strict";

    var operations = {
        getContacts : {
            model : [{
                id: '',
                displayName: '',
                phoneNumbers: [{value : ''}]
            }],
            requriedCordovaPlugins: ['CONTACTS'],
            properties : [
                {"target": "startUpdate", "type": "boolean", "value": ""},
                {"target": "contactFilter", "type": "string", "value": "", "dataBinding": true}
            ],
            invoke : function (variable, options, success) {
                var findOptions = {
                        filter : variable.contactFilter,
                        multiple : true,
                        fields:  ['displayName']
                    };
                $cordovaContacts.find(findOptions).then(function (data) {
                    data = _.filter(data, function (c) {
                        return c.phoneNumbers && c.phoneNumbers.length > 0;
                    });
                    success(data);
                });
            }
        }
    };
    WM.forEach(operations, function (value, key) {
        DeviceVariableService.addOperation('contacts', key, value);
    });
}]);
/*global wm, WM, _*/
WM.module('wm.variables').run(['DeviceVariableService', '$cordovaNetwork', '$cordovaGeolocation', '$cordovaVibration', '$cordovaDevice', '$cordovaAppVersion', '$rootScope', function (DeviceVariableService, $cordovaNetwork, $cordovaGeolocation, $cordovaVibration, $cordovaDevice, $cordovaAppVersion, $rootScope) {
    "use strict";
    $rootScope.$on('$cordovaNetwork:online', function () {
        $rootScope.networkStatus = true;
    });

    $rootScope.$on('$cordovaNetwork:offline', function () {
        $rootScope.networkStatus = false;
    });

    var operations = {
            getAppInfo: {
                model: {
                    appversion: 'X.X.X',
                    cordovaversion: 'X.X.X'
                },
                properties: [
                    {"target": "startUpdate", "type": "boolean", "value": ""}
                ],
                invoke: function (variable, options, success) {
                    $cordovaAppVersion.getVersionNumber().then(function (appversion) {
                        success({
                            appversion: appversion,
                            cordovaversion: $cordovaDevice.getCordova()
                        });
                    });
                }
            },
            getCurrentGeoPosition: {
                model: {
                    coords: {
                        latitude: 0,
                        longitude: 0,
                        altitude: 0,
                        accuracy: 0,
                        altitudeAccuracy: 0,
                        heading: 0,
                        speed: 0
                    },
                    timestamp: 0
                },
                requriedCordovaPlugins: ['GEOLOCATION'],
                properties: [
                    {"target": "startUpdate", "type": "boolean", "value": ""},
                    {"target": "geolocationHighAccuracy", "type": "boolean", "value": true, "dataBinding": true},
                    {"target": "geolocationMaximumAge", "type": "number", "value": 3, "dataBinding": true},
                    {"target": "geolocationTimeout", "type": "number", "value": 5, "dataBinding": true}
                ],
                invoke: function (variable, options, success, error) {
                    var geoLocationOptions = {
                        maximumAge: variable.geolocationMaximumAge * 1000,
                        timeout: variable.geolocationTimeout * 1000,
                        enableHighAccuracy: variable.geolocationHighAccuracy
                    };
                    $cordovaGeolocation.getCurrentPosition(geoLocationOptions).then(function (position) {
                        var result = {
                            coords: {
                                latitude: position.coords.latitude,
                                longitude: position.coords.longitude,
                                altitude: position.coords.altitude,
                                accuracy: position.coords.accuracy,
                                altitudeAccuracy: position.coords.altitudeAccuracy,
                                heading: position.coords.heading,
                                speed: position.coords.speed
                            },
                            timestamp: position.timestamp
                        };
                        success(result);
                    }, error);
                }
            },
            getDeviceInfo: {
                model: {
                    deviceModel: 'DEVICEMODEL',
                    os: 'DEVICEOS',
                    osVersion: 'X.X.X',
                    deviceUUID: 'DEVICEUUID'
                },
                properties: [
                    {"target": "startUpdate", "type": "boolean", "value": ""}
                ],
                invoke: function (variable, options, success) {
                    success({
                        deviceModel: $cordovaDevice.getModel(),
                        os: $cordovaDevice.getPlatform(),
                        osVersion: $cordovaDevice.getVersion(),
                        deviceUUID: $cordovaDevice.getUUID()
                    });
                }
            },
            getNetworkInfo: {
                model: {
                    connectionType: 'NONE',
                    isOnline: true,
                    isOffline: false
                },
                requriedCordovaPlugins: ['NETWORK'],
                properties: [
                    {"target": "autoUpdate", "type": "boolean", "value": true},
                    {"target": "startUpdate", "type": "boolean", "value": ""},
                    {"target": "networkStatus", "type": "boolean", value: "bind:$root.networkStatus", "dataBinding": true, hide: true}
                ],
                invoke: function (variable, options, success) {
                    success({
                        connectionType: $cordovaNetwork.getNetwork(),
                        isOnline: $cordovaNetwork.isOnline(),
                        isOffline: $cordovaNetwork.isOffline()
                    });
                }
            },
            vibrate: {
                properties: [
                    {"target": "vibrationtime", "type": "number", "value": 2, "dataBinding": true}
                ],
                requriedCordovaPlugins: ['VIBRATE'],
                invoke: function (variable) {
                    var vibrationTimeOptions = {
                        time: variable.vibrationtime * 1000
                    };
                    $cordovaVibration.vibrate(vibrationTimeOptions.time);
                }
            }
        };
    WM.forEach(operations, function (value, key) {
        DeviceVariableService.addOperation('device', key, value);
    });
}]);
/*global wm, WM, _*/
WM.module('wm.variables').run(['DeviceVariableService', '$cordovaCamera', '$cordovaCapture', function (DeviceVariableService, $cordovaCamera, $cordovaCapture) {
    "use strict";

    var operations = {
        captureImage: {
            model: {
                imagePath: 'resources/images/imagelists/default-image.png'
            },
            properties: [
                {"target": "allowImageEdit", "type": "boolean", "value" : false, "dataBinding": true},
                {"target": "imageQuality", "type": "number", "value": 80, "dataBinding": true},
                {"target": "imageEncodingType", "type": "list", "options": {"0" : "JPEG", "1" : "PNG"}, "value" : "0", "dataBinding": true},
                {"target": "correctOrientation", "type": "boolean", "value" : true, "dataBinding": true},
                {"target": "imageTargetWidth", "type": "number", "dataBinding": true},
                {"target": "imageTargetHeight", "type": "number", "dataBinding": true}
            ],
            requriedCordovaPlugins: ['CAMERA', 'CAPTURE'],
            invoke: function(variable, options, success, error) {
                var cameraOptions = {
                    quality           : variable.imageQuality,
                    destinationType   : 1, //only file url
                    sourceType        : 1, //camera
                    allowEdit         : variable.allowImageEdit,
                    encodingType      : parseInt(variable.imageEncodingType, 10),
                    mediaType         : 0, //always picture
                    correctOrientation: variable.correctOrientation,
                    targetWidth       : WM.isNumber(variable.imageTargetWidth) ?  variable.imageTargetWidth : undefined,
                    targetHeight      : WM.isNumber(variable.imageTargetHeight) ? variable.imageTargetHeight : undefined,
                };
                $cordovaCamera.getPicture(cameraOptions).then(function(data) {
                    success({imagePath: data});
                }, error);
            }
        },
        captureVideo: {
            model: {
                videoPath: ''
            },
            properties: [],
            requriedCordovaPlugins: ['CAMERA', 'CAPTURE'],
            invoke: function(variable, options, success, error) {
                var videoOptions = {
                    limit   : 1
                };
                $cordovaCapture.captureVideo(videoOptions).then(function(data) {
                    success({videoPath: data[0].fullPath});
                }, error);
            }
        }
    }
    WM.forEach(operations, function (value, key) {
        DeviceVariableService.addOperation('camera', key, value);
    });
}]);
/*global WM*/
WM.module('wm.variables').run(['$rootScope', 'DeviceVariableService', '$cordovaFileTransfer', function ($rootScope, DeviceVariableService, $cordovaFileTransfer) {
    "use strict";

    var operations = {
        upload : {
            model: {
                name: '',
                path: '',
                size: 0,
                type: ''
            },
            properties : [
                {"target": "localFile", "type": "string", "value": "", "dataBinding": true},
                {"target": "remoteFolder", "type": "string", "value": "", "dataBinding": true}
            ],
            requriedCordovaPlugins: ['FILE', 'FILETRANSFER'],
            invoke: function (variable, options, success, error) {
                var serverUrl = $rootScope.project.deployedUrl + '/services/file/uploadFile?relativePath=' + (variable.remoteFolder || ''),
                    fileName = variable.localFile,
                    fileNameStartIndex = fileName.lastIndexOf('/'),
                    ftOptions = {fileKey : 'files',
                                   fileName: fileName,
                                   chunkedMode : false};
                if (fileNameStartIndex >= 0) {
                    ftOptions.fileName  = fileName.substring(fileNameStartIndex + 1);
                }

                $cordovaFileTransfer.upload(serverUrl, variable.localFile, ftOptions)
                    .then(function (data) {
                        success(JSON.parse(data.response)[0]);
                    }, error);
            }
        }
    };
    WM.forEach(operations, function (value, key) {
        DeviceVariableService.addOperation('file', key, value);
    });
}]);
/*global wm, WM, _*/
/*jslint todo: true */
/*jslint sub: true */

/**
 * @ngdoc service
 * @name wm.variables.DeviceVariableService
 * @requires $rootScope
 * @requires Varibales
 * @requires Utils
 * @requires BaseVariablePropertyFactory
 * @requires CONSTANTS
 * @description
 * The 'DeviceVariableService' provides methods to work with Mobile API.
 */
wm.variables.services.DeviceVariableService = ['$rootScope', 'Variables', 'Utils', 'CONSTANTS',
    function ($rootScope, Variables, Utils, CONSTANTS) {
        "use strict";
        var initiateCallback = Variables.initiateCallback,
            availableServices = {};

        function getCallBackScope(variable, options) {
            /* get the callback scope for the variable based on its owner */
            if (variable.owner === "App") {
                return $rootScope || {};
            }
            if (variable.prefabName) {
                return options.scope || {};
            }
            return (options && options.scope && options.scope.$$childTail) ? options.scope.$$childTail : {};
        }

        function invoke(options, success, error) {
            var variable = this,
                operation = availableServices[this.service][this.operation],
                callBackScope = getCallBackScope(variable, options),
                successCb = function (data) {
                    variable.dataSet = data;
                    Utils.triggerFn(success);
                    initiateCallback('onSuccess', variable, callBackScope, data);
                },
                errorCb = function () {
                    Utils.triggerFn(error);
                    initiateCallback('onError', variable, callBackScope);
                };
            if (operation && CONSTANTS.hasCordova) {
                operation.invoke(this, options, successCb, errorCb);
            } else if (operation) {
                successCb(_.cloneDeep(operation.model || {}));
            } else {
                errorCb();
            }
        }
        return {
            /**
            * @ngdoc method
            * @name $DeviceVariableService#addOperation
            * @methodOf wm.variables.DeviceVariableService
            * @description
            * adds a new operation.
            * @params serviceName Name of the service to which this operation belongs
            * @params operationName Name of the operation
            * @params serviceInfo A Javascript that honors the below structure.
            *   {
            *       // model is used to understand the schema returned on successful invocation  of the variable.
            *       model: {},
            *       // An array of properties that are can be shown to the user.
            *       properties : [],
            *       // A function to be invoked
            *       invoke: function (variable, options, success, error) {}
            *   }
            */
            addOperation : function (serviceName, operationName, serviceInfo) {
                var service = availableServices[serviceName] =  (availableServices[serviceName] || {});
                service[operationName]  = serviceInfo;
            },
            listServices : function () {
                return _.sortBy(_.keys(availableServices));
            },
            getOperation : function (serviceName, operationName) {
                var operation =  {};
                if (serviceName && operationName) {
                    operation = availableServices[serviceName][operationName] || {};
                }
                return operation;
            },
            listAllOperations : function (serviceName) {
                return _.sortBy(_.keys(availableServices[serviceName]));
            },
            listAllProperties : function () {
                var allProperties = [],
                    properties = [];
                WM.forEach(availableServices, function (service) {
                    WM.forEach(service, function (api) {
                        properties = _.map(_.reject(api.properties, {dataBinding: true}), 'target');
                        allProperties.push(properties);
                    });
                });
                return _.chain(allProperties).flatten().uniq().value();
            },
            invoke : invoke
        };
    }];
/*global WM*/
WM.module('wm.variables').run(['DeviceVariableService', '$cordovaBarcodeScanner', function (DeviceVariableService, $cordovaBarcodeScanner) {
    "use strict";

    var operations = {
        scanBarCode : {
            model: {
                text : 'BAR CODE',
                format : "TEXT",
                cancelled : false
            },
            requriedCordovaPlugins: ['BARCODE_SCANNER'],
            properties : [],
            invoke: function (variable, options, success, error) {
                $cordovaBarcodeScanner.scan().then(function (data) {
                    success(data);
                }, error);
            }
        }
    };
    WM.forEach(operations, function (value, key) {
        DeviceVariableService.addOperation('scan', key, value);
    });
}]);
/*global WM, _ */
/*Directive for Navbar*/

WM.module('wm.layouts.containers')
    .run(['$templateCache', function ($tc) {
        'use strict';

        $tc.put('template/layouts/containers/mobile/navbar.html',
            '<header data-role="mobile-navbar" init-widget class="app-header app-mobile-navbar {{class}}" ng-show="show" apply-styles>' +
                '<nav class="navbar" ng-show="!showSearchbar">' +
                    '<div class="mobile-navbar-left">' +
                        '<ul class="nav navbar-nav navbar-left">' +
                            '<li ng-if="showLeftnav" >' +
                                '<a ng-click="leftNavPanel.toggle();">' +
                                    '<i ng-class="leftnavpaneliconclass"></i>' +
                                '</a>' +
                            '</li>' +
                            '<li ng-if="backbutton">' +
                                '<a class="btn-back" type="button" ng-click="goBack($event)">' +
                                    '<i ng-class="backbuttoniconclass"></i><span>{{backbuttonlabel}}</span>' +
                                '</a>' +
                            '</li>' +
                        '</ul>' +
                        '</div>' +
                        '<div class="mobile-navbar-center">' +
                            '<div class="navbar-header"><h1 class="navbar-brand"><img data-identifier="img" class="brand-image" alt="{{title}}" width="32" height="32" ng-if="imgsrc" ng-src="{{imagesrc}}"/><span>{{title}}</span></h1></div>' +
                        '</div>' +
                        '<div class="mobile-navbar-right">' +
                            '<ul class="nav navbar-nav navbar-right">' +
                                '<li wmtransclude></li>' +
                                '<li ng-if="searchbutton">' +
                                    '<a class="btn-search btn-transparent" type="button" ng-click="showSearchBar();">' +
                                        '<i ng-class="searchbuttoniconclass"></i><span>{{searchbuttonlabel}}</span>' +
                                    '</a>' +
                                '</li>' +
                            '</ul>' +
                    '</div>' +
                '</nav>' +
                '<nav class="navbar searchbar" ng-if="showSearchbar">' +
                    '<div class="mobile-navbar-left">' +
                        '<ul class="nav navbar-nav navbar-left">' +
                            '<li>' +
                                '<a class="btn-back" type="button" ng-click="goBacktoPreviousView($event)">' +
                                    '<i ng-class="backbuttoniconclass"></i>' +
                                '</a>' +
                            '</li>' +
                        '</ul>' +
                    '</div>' +
                    '<div class="mobile-navbar-center search-container">' +
                        '<wm-search query="{{query}}" scopedataset="_dataset" searchkey="{{searchkey}}" displaylabel="{{displaylabel}}" displayimagesrc="{{displayimagesrc}}" datavalue="{{datavalue}}" on-submit="onSubmission($event)" placeholder="{{searchplaceholder}}" navsearchbar="true"></wm-search>' +
                    '</div>' +
                    '<div class="mobile-navbar-right">' +
                        '<ul class="nav navbar-nav navbar-right">' +
                        '<li>' +
                        '<a class="btn-cancel btn-transparent" type="button" ng-click="goBacktoPreviousView($event);"> Cancel </a>' +
                        '</li>' +
                        '</ul>' +
                    '</div>' +
                '</nav>' +
            '</header>'
            );
    }])
    .directive('wmMobileNavbar', [
        '$templateCache',
        'PropertiesFactory',
        'WidgetUtilService',
        'CONSTANTS',
        'Utils',
        'NavigationService',
        '$window',

        function ($templateCache, PropertiesFactory, WidgetUtilService, CONSTANTS, Utils, NavigationService, $window) {
            'use strict';

            var widgetProps = PropertiesFactory.getPropertiesOf('wm.layouts.mobile.navbar', ['wm.layouts']),
                notifyFor = {
                    'imgsrc'         : true,
                    'dataset'        : true,
                    'searchkey'      : true,
                    'displaylabel'   : true,
                    'displayimagesrc': true,
                    'defaultview'    : true
                };

            // update search-key, display-label in the property panel
            function updatePropertyPanelOptions(dataset, $is) {
                var variableKeys = [],
                    wp           = $is.widgetProps; // widgetProperties
                // on binding of data
                if (dataset) {
                    dataset      = dataset[0] || dataset;
                    variableKeys = _.keys(dataset);
                }

                // re-initialize the property values
                if ($is.newcolumns) {
                    $is.newcolumns   = false;
                    $is.searchkey    = '';
                    $is.displaylabel = '';
                    $is.datafield    = '';
                    $is.$root.$emit('set-markup-attr', $is.widgetid, {'searchkey': $is.searchkey, 'datafield': $is.datafield, 'displaylabel': $is.displaylabel});
                }

                // assign all the keys to the options of the search widget
                wp.searchkey.options = wp.displaylabel.options = wp.displayimagesrc.options = [''].concat(variableKeys);
                wp.datafield.options = ['All Fields'].concat(variableKeys);
            }

            // update the query and datavalue before submit.
            function onSubmit($is, $el, event) {
                var $searchEle     = $el.find('.app-mobile-search'),
                    $searchElScope = $searchEle.isolateScope();

                $is.query       = $searchElScope.query;
                $is.datavalue   = $searchElScope.datavalue;
                if ($is.onSearch) {
                    $is.onSearch({$event: event, $scope: $is});
                }
            }

            // set the show property for the search related properties
            function enableWidgetProps(wp, bool) {
                wp.searchbuttoniconclass.show     = wp.searchbuttonlabel.show =
                    wp.searchplaceholder.show     = wp.scopedatavalue.show    =
                    wp.scopedataset.show          = wp.dataset.show           =
                    wp.searchkey.show             = wp.displaylabel.show      =
                    wp.displayimagesrc.show       = wp.datafield.show         =
                    wp.datavalue.show             =  bool;
            }

            // switches the view based on defaultview
            function switchView($is, view) {
                $is.showSearchbar = (view !== 'actionview');
            }

            // go to the previous visited page.
            function goBack(attrs, $is, $event) {
                if (attrs.onBackbtnclick && $is.onBackbtnclick) {
                    $is.onBackbtnclick({'$event' : $event, '$scope' : $is});
                } else if (CONSTANTS.hasCordova) {
                    $window.history.go(-1);
                } else {
                    NavigationService.goToPrevious();
                }
            }

            // enable the search view
            function showSearchBar($is) {
                $is.showSearchbar = true;
            }

            //goto previous view or page
            function goBacktoPreviousView($is, $event) {
                if ($is.defaultview === 'actionview') {
                    // switches the view from search to action or actio to search.
                    $is.switchView('actionview');
                } else {
                    // goes back to the previous visited page.
                    $is.goBack($event);
                }
            }

            // Define the property change handler. This function will be triggered when there is a change in the widget property
            function propertyChangeHandler($is, key, newVal) {
                switch (key) {
                case 'imgsrc':
                    $is.imagesrc = Utils.getImageUrl(newVal);
                    break;
                case 'dataset':
                    // if studio-mode, then update the search-key, display-label in property panel
                    if ($is.widgetid) {
                        updatePropertyPanelOptions((newVal && newVal.data) || newVal, $is);
                    }
                    $is._dataset = newVal.data;
                    break;
                case 'defaultview':
                    $is.showSearchbar = (newVal === 'searchview');

                    // show the search related properties only if default view is searchview.
                    if ($is.widgetid) {
                        var wp = $is.widgetProps;
                        enableWidgetProps(wp, newVal === 'searchview');
                    }
                    break;
                }
            }

            return {
                'restrict'  : 'E',
                'replace'   : true,
                'scope'     : {},
                'transclude': true,
                'template'  : $templateCache.get('template/layouts/containers/mobile/navbar.html'),
                'link'      : {
                    'pre' : function ($is) {
                        // Applying widget properties to directive scope
                        $is.widgetProps   = widgetProps;
                        $is.showSearchbar = false;
                    },
                    'post': function ($is, $el, attrs) {
                        $is.leftNavPanel = ($el.closest('.app-page').find('.app-left-panel:first')).isolateScope();

                        if ($is.leftNavPanel) {
                            $is.showLeftnav = attrs.showLeftnav !== 'false';
                        }

                        if (CONSTANTS.isRunMode) {
                            $is.goBack = goBack.bind(undefined, attrs, $is);

                            $is.switchView = switchView.bind(undefined, $is);

                            $is.goBacktoPreviousView = goBacktoPreviousView.bind(undefined, $is);

                            $is.showSearchBar = showSearchBar.bind(undefined, $is);

                            // this function is called when searchquery is submitted.
                            $is.onSubmission = onSubmit.bind(undefined, $is, $el);
                        }

                        // Register the property change handler
                        WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, $is), $is, notifyFor);
                        /*Cleaning the widget markup such that the widget wrapper is not cluttered with unnecessary property or
                         * style declarations.*/
                        WidgetUtilService.postWidgetCreate($is, $el, attrs);
                    }
                }
            };
        }]);

/**
 * @ngdoc directive
 * @name wm.layouts.containers.directive:wmMobileNavbar
 * @restrict E
 * @element ANY
 * @description
 * The 'wmMobileNavbar' directive defines a dynamic navigation bar for a mobile applicatino.
 * wmNavbar is internally used by wmTopNav.
 *
 * @param {string=} title
 *                  Title to show at the center.
 * @param {string=} name
 *                  Name of the navbar.
 * @param {string=} height
 *                  Height of the navabr.
 * @param {string=} backbutton
 *                  if true, back button will be shown. Default true.
 * @param {string=} backbuttonlabel
 *                  back button label.
 * @param {string=} searchbutton
 *                  if true, search button will be shown. Default false.
 * @param {string=} searchbuttonlabel
 *                  search button label.
 * @param {string=} searchplaceholder
 *                  search placeholder.
 * @param {string=} show
 *                  This property determines whether or not the navbar is visible. This property is a bindable property.
 * @param {string=} defaultview
 *                  This property shows searchbar if set to search-view and shows actionbar if set to action-view.
 * @param {string=} searchquery
 *                  This property is an outbound property. It contains the search query.
 * @param {string=} scopedataset
 *                  The script variable that contains the data to be provided to the search widget, that can be searched onto.
 * @param {string=} dataset
 *                  The data to be provided the search widget from a live variable or the property panel, that can be searched onto. <br>
 *                  This is a bindable property.
 * @param {string=} searchkey
 *                  The key to be searched in the data provided to the searchbar.
 * @param {string=} displaylabel
 *                  The property to be displayed in the search auto-complete.
 * @param {string=} imagesource
 *                  This property sets the image to be displayed in the search results.
 * @param {string=} datafield
 *                  This property sets the dataValue to be returned by a select editor when the list is populated using the dataSet property.
 * @param {string=} datavalue
 *                  This property sets the default text to the searchbar. Outbound datavalue property contains the search result.
 * @param {string=} onBackbtnclick
 *                  Callback function which will be triggered after the backbutton click.
 * @param {string=} onSearch
 *                  Callback function which will be triggered after the search.
 *
 * @example
 <example module="wmCore">
 <file name="index.html">
     <div ng-controller="Ctrl" class="wm-app">
     <wm-top-nav>
         <wm-mobile-navbar title="XMobile" fontweight="bold" fontsize="2" fontunit="em" paddingtop="5">
            <wm-button caption="Users" type="button" iconclass="fa fa-trash-o"></wm-button>
         </wm-mobile-navbar>
     </wm-top-nav>
     </div>
 </file>
 <file name="script.js">
 function Ctrl($scope) {}
 </file>
 </example>
 */






/*global WM, _ */
/*jslint todo: true */
/*Directive for segmented control */
WM.module('wm.layouts.containers')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/widget/mobile/segmentedcontrol/segmentedcontrol.html',
            '<div class="app-segmented-control {{class}}" hm-swipe-left="goToNext()" hm-swipe-right="goToPrev();" init-widget data-ng-show="show" apply-styles="container">' +
                '<div class="app-segments-container">' +
                    '<ul class="list-inline" wmtransclude></ul>' +
                '</div>' +
                '<div class="btn-group btn-group-justified">' +
                    '<a class="btn btn-default" data-ng-repeat="content in contents" data-ng-class="{\'active btn-primary\' : $index == currentSelectedIndex}" data-ng-click="$event.stopPropagation(); showContent($index);">' +
                        '<i class="app-icon" data-ng-class="content.iconclass"></i> {{content.caption}}' +
                    '</a>' +
                '</div>' +
            '</div>');
        $templateCache.put('template/widget/mobile/segmentedcontrol/segmentcontent.html',
            '<li init-widget wmtransclude class="app-segment-content clearfix" apply-styles="container" wm-navigable-element="true"></li>');
    }])
    .directive('wmSegmentedControl', ['$templateCache', 'PropertiesFactory', 'CONSTANTS', 'WidgetUtilService', function ($templateCache, PropertiesFactory, CONSTANTS, WidgetUtilService) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.layouts.segmentedcontrol', ['wm.base', 'wm.layouts', 'wm.containers']);
        return {
            'restrict' : 'E',
            'scope'    : {
                'onBeforesegmentchange' : '&',
                'onSegmentchange' : '&'
            },
            'replace' : 'true',
            'transclude': true,
            'template' : $templateCache.get('template/widget/mobile/segmentedcontrol/segmentedcontrol.html'),
            'controller' : function ($scope) {
                this.addContent = function ($contentScope) {
                    $scope.contents.push($contentScope);
                };

                this.showContent = function (content) {
                    var contentIndex = _.findIndex($scope.contents, function (_content) {
                        return _content.$id === content.$id;
                    });
                    $scope.showContent(contentIndex);
                };
                /**
                 * Hides the current content and displays the next in position.
                 */
                $scope.goToNext = function () {
                    $scope.showContent($scope.currentSelectedIndex + 1);
                };
                /**
                 * Hides the current content and displays the previous in position.
                 */
                $scope.goToPrev = function () {
                    $scope.showContent($scope.currentSelectedIndex - 1);
                };
                /**
                 * Removes the content.
                 */
                this.removeContent = function (content) {
                    var index;

                    index = _.findIndex($scope.contents, function (_content) {
                        return _content.$id === content.$id;
                    });

                    _.pullAt($scope.contents, index);

                    if (index < $scope.contents.length) {
                        $scope.showContent(index);
                    } else if ($scope.contents.length > 0) {
                        $scope.showContent(0);
                    }
                };
            },
            'compile' : function () {
                return {
                    'pre' : function ($scope) {
                        $scope.widgetProps = widgetProps;
                        $scope.contents = [];
                        $scope.animate = true;
                        $scope.currentSelectedIndex = 0;
                    },
                    'post' : function ($scope, $element, attrs) {
                        /**
                         * Displays content at the given index.
                         */
                        $scope.showContent = function (index) {
                            if (index < 0 || index >= $scope.contents.length) {
                                return;
                            }

                            var contents = $scope.contents,
                                currentContent = contents[index],
                                eventData = {
                                    $scope: this,
                                    $old  : $scope.currentSelectedIndex,
                                    $new  : index
                                },
                                $segmentsCtr = $element.find(".app-segments-container"),
                                $segment = $element.find(".app-segments-container > ul > li:nth-child(" + (index + 1) + ")"),
                                scrollPos = 0,
                                left = $segment.position().left;
                            $scope.currentSelectedIndex = index;
                            $scope.onBeforesegmentchange(eventData);
                            currentContent.onShow();
                            if (currentContent && currentContent.widgetid && CONSTANTS.isStudioMode && $scope.$root) {
                                $scope.$root.$emit('set-active-widget', currentContent.widgetid);
                            }

                            $segmentsCtr.animate(
                                { scrollLeft: (scrollPos + left)},
                                { duration: "fast" }
                            );
                            $scope.onSegmentchange(eventData);
                        };
                        $scope.showContent(0);
                        /**add studio mode changes**/
                        if (CONSTANTS.isStudioMode) {
                            $scope.add = function () {
                                $scope.$root.$emit('canvas-add-widget', {
                                    'parentId': $scope.widgetid,
                                    'widgetType': 'wm-segment-content'
                                });
                                $scope.currentSelectedIndex =  ($scope.contents.length - 1);
                            };
                        }
                        WidgetUtilService.postWidgetCreate($scope, $element, attrs);
                    }
                };
            }
        };
    }])
    .directive('wmSegmentContent', ['$templateCache', 'PropertiesFactory', 'CONSTANTS', 'Utils', 'WidgetUtilService', function ($templateCache, PropertiesFactory, CONSTANTS, Utils, WidgetUtilService) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.layouts.segmentcontent', ['wm.base', 'wm.layouts', 'wm.containers', 'wm.containers.lazy']);
        return {
            'restrict' : 'E',
            'replace' : 'true',
            'scope' : {},
            'transclude': true,
            'template' : $templateCache.get('template/widget/mobile/segmentedcontrol/segmentcontent.html'),
            'require': '^wmSegmentedControl',
            'compile' : function () {
                return {
                    'pre' : function ($scope) {
                        $scope.widgetProps = widgetProps;
                        $scope.onShow = function () {
                            $scope.__load();
                        };
                        $scope.__onTransclude = function () {
                            Utils.triggerFn($scope.onReady);
                        };
                    },
                    'post' : function ($scope, element, attrs, controller) {
                        controller.addContent($scope);
                        $scope.navigate = function () {
                            controller.showContent($scope);
                        };
                        //remove the segment links
                        if (CONSTANTS.isStudioMode) {
                            $scope.$on('$destroy', function () {
                                controller.removeContent($scope);
                            });
                        }
                        WidgetUtilService.postWidgetCreate($scope, element, attrs);
                    }
                };
            }
        };
    }]);
/**
 * @ngdoc directive
 * @name wm.layouts.containers:wmSegmentedControl
 * @restrict E
 *
 * @description
 * The `wmSegmentedControl` directive defines wm-segmented-control widget.
 *
 *
 * @scope
 *
 * @param {string=} name
 *                  Name of the widget.
 * @param {string=} width
 *                  width of the widget.
 * @param {string=} height
 *                  Height of the widget.
 * @param {string=} show
 *                  If true, then the widget will be shown.
 * @param {string=} class
 *                 class to apply to the widget
 * @example
 *   <example module="wmCore">
 *       <file name="index.html">
 *           <div data-ng-controller="Ctrl" class="wm-app">
 *                 <wm-segmented-control height="400" name="segmentedcontrol3">
 *                      <wm-segment-content caption="" name="segmentedcontrolcontent7" iconclass="glyphicon glyphicon-link">
 *                          <wm-tile name="tile1" width="100%" height="100%" backgroundcolor="#db6a2c"></wm-tile>
 *                      </wm-segment-content>
 *                      <wm-segment-content caption="" name="segmentedcontrolcontent9" iconclass="glyphicon glyphicon-facetime-video">
 *                          <wm-tile name="tile1" width="100%" height="100%" backgroundcolor="#72a68a"></wm-tile>
 *                      </wm-edcontent>
 *                      <wm-segment-content caption="" name="segmentedcontrolcontent4" iconclass="glyphicon glyphicon-picture">
 *                          <wm-tile name="tile1" width="100%" height="100%" backgroundcolor="#80d3ed"></wm-tile>
 *                      </wm-segment-content>
 *                  </wm-segmented-control>
 *           </div>
 *       </file>
 *       <file name="script.js">
 *           function Ctrl($scope) {
 *              $scope.demo = true;
 *           }
 *       </file>
 *   </example>
 */

/**
 * @ngdoc directive
 * @name wm.layouts.containers:wmSegmentContent
 * @restrict E
 *
 * @description
 * The `wmSegmentContent` directive defines wm-segment-content widget.
 *
 *
 * @scope
 *
 * @param {string=} name
 *                  Name of the widget.
 * @param {string=} caption
 *                  Title to display on the segment.
 * @param {string=} iconclass
 *                  class to use as an icon.
 * @param {string=} class
 *                 class to apply to the widget
 * @example
 *   <example module="wmCore">
 *       <file name="index.html">
 *           <div data-ng-controller="Ctrl" class="wm-app">
 *                 <wm-segmented-control height="400" name="segmentedcontrol3">
 *                      <wm-segment-content caption="" name="segmentedcontrolcontent7" iconclass="glyphicon glyphicon-link">
 *                          <wm-tile name="tile1" width="100%" height="100%" backgroundcolor="#db6a2c"></wm-tile>
 *                      </wm-segment-content>
 *                  </wm-segmented-control>
 *           </div>
 *       </file>
 *       <file name="script.js">
 *           function Ctrl($scope) {
 *              $scope.demo = true;
 *           }
 *       </file>
 *   </example>
 */

/*global WM, */
/*jslint todo: true */
/*Directive for tabbar*/
WM.module('wm.layouts.containers')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/layouts/containers/mobile/tabbar/tabbar.html',
            '<div data-role="mobile-tabbar" class="app-tabbar app-top-nav {{class}} {{position}}" init-widget>' +
                '<nav class="navbar navbar-default">' +
                    '<ul class="tab-items nav navbar-nav">' +
                        '<li class="tab-item" data-ng-repeat="item in tabItems" data-ng-show="(tabItems.length == layout.max) || $index+1 < layout.max" >' +
                            '<a data-ng-href="{{item.link}}" data-ng-click="onSelect({$event: $event, $scope: this, $item: item.value || item.label })">' +
                                '<i class="app-icon" data-ng-class="item.icon"></i><label>{{item.label}}</label>' +
                            '</a>' +
                        '</li>' +
                        '<li class="menu-items dropdown" data-ng-show="tabItems.length > layout.max" data-ng-class="{\'dropup\' : position == \'bottom\'}" uib-dropdown>' +
                            '<a uib-dropdown-toggle>' +
                                '<i class="app-icon {{morebuttoniconclass}}"></i><label>{{morebuttonlabel}}</label>' +
                            '</a>' +
                            '<ul class="dropdown-menu-right" uib-dropdown-menu data-ng-class="{\'nav navbar-nav\' : menutype == \'thumbnail\'}">' +
                                '<li class="menu-item" data-ng-repeat="item in tabItems" data-ng-show="$index+1 >= layout.max">' +
                                    '<a data-ng-href="{{item.link}}" data-ng-click="onSelect({$event: $event, $scope: this, $item: item.value || item.label });">' +
                                        '<i class="app-icon" data-ng-class="item.icon"></i><label>{{item.label}}</label>' +
                                    '</a>' +
                                '</li>' +
                            '</ul>' +
                        '</li>' +
                    '</ul>' +
                '</nav>' +
            '</div>');
    }]).directive('wmMobileTabbar', ['$window', '$templateCache', 'PropertiesFactory', 'WidgetUtilService', 'CONSTANTS', function ($window, $templateCache, PropertiesFactory, WidgetUtilService, CONSTANTS) {
        'use strict';
        var widgetProps = PropertiesFactory.getPropertiesOf('wm.tabbar', ['wm.base', 'wm.tabbar.dataProps']),
            notifyFor = { 'dataset': true},
            layouts = [{'minwidth' : 2048, 'max': 12},
                       {'minwidth' : 1024, 'max': 10},
                       {'minwidth' : 768, 'max': 7},
                       {'minwidth' : 480, 'max': 5},
                       {'minwidth' : 0, 'max': 4}],
            getSuitableLayout = function (avaiableWidth) {
                return _.find(layouts, function (l) {
                    return avaiableWidth >= l.minwidth;
                });
            };
        function getItems(newVal) {
            return newVal.map(function (item) {
                return {
                    'label': item,
                    'icon': 'glyphicon glyphicon-' + item
                };
            });
        }
        function getTabItems(newVal, scope) {
            if (WM.isArray(newVal)) {
                var transformFn;
                if (WM.isObject(newVal[0])) {
                    transformFn = function (item) {
                        return {
                            'label': WidgetUtilService.getEvaluatedData(scope, item, {expressionName: 'itemlabel'}) || item.label,
                            'icon': WidgetUtilService.getEvaluatedData(scope, item, {expressionName: 'itemicon'}) || item.icon,
                            'link': WidgetUtilService.getEvaluatedData(scope, item, {expressionName: 'itemlink'}) || item.link
                        };
                    };
                    scope.tabItems = newVal.map(transformFn);
                } else {
                    scope.tabItems = getItems(newVal);
                }
            } else if (WM.isString(newVal)) {
                scope.tabItems = getItems(newVal.split(","));
            }
        }
        function propertyChangeHandler(scope, element, key, newVal) {
            switch (key) {
            case 'dataset':
                /*if studio-mode, then update the itemlabel, itemicon, itemlink & itemchildren in property panel*/
                if (CONSTANTS.isStudioMode && WM.isDefined(newVal) && newVal !== null) {
                    WidgetUtilService.updatePropertyPanelOptions(newVal.data || newVal, newVal.propertiesMap, scope);
                }
                if (newVal) {
                    getTabItems(newVal.data || newVal, scope);
                }
                break;
            }
        }
        return {
            'scope' : {
                'onSelect': '&',
                'menutype': '&',
                'position': '&'
            },
            'restrict' : 'E',
            'replace' : true,
            'template' : $templateCache.get('template/layouts/containers/mobile/tabbar/tabbar.html'),
            'compile' : function () {
                return {
                    'pre' : function (scope) {
                        scope.widgetProps = widgetProps;
                        scope.position = "bottom"; /**top | bottom**/
                        scope.menutype = "thumbnail"; /**thumbnail | list**/
                    },
                    'post' : function (scope, element, attrs) {
                        var onPropertyChange = propertyChangeHandler.bind(undefined, scope, element);
                        WM.element($window).resize(function () {
                            scope.layout = getSuitableLayout(element.parent().width());
                            scope.$apply();
                        });
                        scope.layout = getSuitableLayout(element.parent().width());
                        /* register the property change handler */
                        WidgetUtilService.registerPropertyChangeListener(onPropertyChange, scope, notifyFor);
                        WidgetUtilService.postWidgetCreate(scope, element, attrs);
                    }
                };
            }
        };
    }]);

/**
 * @ngdoc directive
 * @name wm.layouts.containers:wmMobileTabbar
 * @restrict E
 *
 * @description
 * The `wmTabbar` directive defines wm-tabbar widget.
 *
 *
 * @scope
 *
 * @param {string=} name
 *                  Name of the widget.
 * @param {string=} dropposition
 *                  dropdown position, allowed values are 'up' or 'down'. Default value is up.
 * @param {string=} on-select
 *                  callback to be called when an item is clicked.
 * @param {string=} class
 *                 class to apply to the widget
 * @example
 *   <example module="wmCore">
 *       <file name="index.html">
 *           <div data-ng-controller="Ctrl" class="wm-app">
 *              <wm-mobile-tabbar dataset="home,star,music,cog,edit"></wm-mobile-tabbar>
 *           </div>
 *       </file>
 *       <file name="script.js">
 *           function Ctrl($scope) {
 *              $scope.demo = true;
 *           }
 *       </file>
 *   </example>
 */
/*global WM*/
/* This is an override to the existing leftpanel directive*/
WM.module('wm.layouts.page')
    .directive('wmLeftPanel', [function (){
        'use strict';

        return {
            restrict    : 'E',
            priority    : 1,
            link        : function ($scope, $ele) {
                $ele.addClass('wm-mobile-app-left-panel');
            }
        };
    }]);
/*global WM*/
/* This is an override to the existing leftpanel directive*/
WM.module('wm.layouts.page')
    .directive('wmPage', [function (){
        'use strict';

        return {
            restrict    : 'E',
            priority    : 1,
            link        : function ($scope, $ele) {
                $ele.addClass('mobile-app-page');
                /**fnding the tabbar so that we can adjust the layout**/
                if ($ele.find('[data-role="mobile-tabbar"]').length > 0 ) {
                    $ele.addClass("has-tabbar");
                }
            }
        };
    }]);
/*global WM, navigator */
/*Directive for camera */

WM.module('wm.widgets.advanced')
    .run([
        '$templateCache',

        function ($tc) {
            'use strict';

            $tc.put('template/widget/advanced/camera.html',
                    '<button class="btn app-camera" data-ng-model="_model_" data-ng-show="show" init-widget has-model apply-styles title="{{hint}}" data-ng-click="openCamera()" >' +
                        '<i class="{{iconclass}}" data-ng-style="{\'font-size\':iconsize}"></i> ' +
                        '<span class="btn-caption">{{caption}}</span>' +
                    '</button>'
                );
        }
    ])
    .directive('wmCamera', [
        '$templateCache',
        'PropertiesFactory',
        'WidgetUtilService',
        'CONSTANTS',
        '$rootScope',
        '$cordovaCamera',
        '$cordovaCapture',
        function ($tc, PropertiesFactory, WidgetUtilService, CONSTANTS, $rs, $cordovaCamera, $cordovaCapture) {
            'use strict';

            var widgetProps = PropertiesFactory.getPropertiesOf('wm.camera', ['wm.base', 'wm.base.editors']),
                cameraOptions,
                notifyFor = {
                    'capturetype': true
                },
                CAPTURE_TYPE = {
                    'IMAGE': 'IMAGE',
                    'VIDEO': 'VIDEO'
                },
                ENCODING_TYPE = {
                    'JPEG': 'JPEG',
                    'PNG' : 'PNG'
                };

            function propertyChangeHandler($is, key, newVal) {
                var showprops = false,
                    wp = $is.widgetProps;
                switch (key) {
                case 'capturetype':
                    if (newVal === CAPTURE_TYPE.IMAGE) {
                        showprops = true;
                        cameraOptions = {
                            'quality'         : $is.imagequality,
                            'destinationType' : 1, // 0-data url,1- file url
                            'sourceType'      : 1, // only camera
                            'allowEdit'       : $is.allowedit,
                            'encodingType'    : $is.imageencodingtype === ENCODING_TYPE.JPEG ? 0 : 1,
                            'saveToPhotoAlbum': $is.savetogallery,
                            'targetWidth'     : $is.imagetargetwidth,
                            'targetHeight'    : $is.imagetargetheight
                        };
                    } else {
                        cameraOptions = {
                            'limit': 1
                        };
                    }
                    if (CONSTANTS.isStudioMode) {
                        wp.imagequality.show = showprops;
                        wp.imageencodingtype.show = showprops;
                        wp.savetogallery.show = showprops;
                        wp.allowedit.show = showprops;
                    }
                    break;
                }
            }

            function updateModel($is, value) {
                $is.datavalue = $is._model_ = value;
                $is.onSuccess({ $scope: $is});
                $rs.$safeApply($is);
            }

            function captureVideoSuccess($is, mediaFiles) {
                updateModel($is, mediaFiles[0].fullPath);
            }

            function openCamera($is) {
                if (CONSTANTS.hasCordova) {
                    if ($is.capturetype === CAPTURE_TYPE.IMAGE) {
                        // start camera
                        $cordovaCamera.getPicture(cameraOptions).then(updateModel.bind(undefined, $is));
                    } else {
                        // start video capture
                        $cordovaCapture.captureVideo(cameraOptions).then(captureVideoSuccess.bind(undefined, $is));
                    }
                } else {
                    $is.onSuccess({$scope: $is});
                }
            }

            return {
                'restrict': 'E',
                'replace': true,
                'scope': {
                    'onSuccess' : '&'
                },
                'template': $tc.get('template/widget/advanced/camera.html'),
                'compile': function () {
                    return {
                        'pre': function ($is) {
                            $is.widgetProps = widgetProps;
                        },
                        'post': function ($is, $el, attrs) {
                            $is.openCamera = openCamera.bind(undefined, $is);
                            WidgetUtilService.registerPropertyChangeListener(propertyChangeHandler.bind(undefined, $is), $is, notifyFor);
                            WidgetUtilService.postWidgetCreate($is, $el, attrs);
                        }
                    };
                }
            };
        }
    ]);

/**
 * @ngdoc directive
 * @name wm.widgets.advanced.directive:wmCamera
 * @restrict E
 *
 * @description
 * The `wmCamera` directive defines the camera widget.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 * @requires $sce
 *
 * @param {string=} hint
 *                  Title/hint for the camera. <br>
 *                  This property is bindable.
 * @param {boolean=} show
 *                  Show is a bindable property. <br>
 *                  This property will be used to show/hide the camera widget on the web page. <br>
 *                  Default value: `true`. <br>
 * @param {string=} iconclass
 *                  CSS class of the icon.
 * @param {string=} iconsize
 *                  size of the icon.
 *                  Default value: 3em
 * @param {string=} capturetype
 *                  This specifies whether the image or video that is to be captured.
 *                  Default value : "IMAGE"
 * @param {string=} sourcetype
 *                  Set the source of the picture. The default is CAMERA
 * @param {string=} imagequality
 *                  Set the image quality of the picture. The default is 80.
 * @param {string=} imageencodingtype
 *                  Encoding the image to JPEG or PNG. The default is JPEG.
 * @param {string=} savetogallery
 *                  The captured image will be saved to gallery if true. The default is false.
 * @param {string=} allowedit
 *                  The captured image will be allowed to edit. The default is false.
 * @param {string=} on-click
 *                  Clicking on the camera button will open the camera for capturing video or image.
 * @param {string=} on-success
 *                  Callback function which will be triggered when the widget saves the captured media successfully.
 */


/*global WM, navigator */
/*Directive for barcode scanner */

WM.module('wm.widgets.advanced')
    .run([
        '$templateCache',

        function ($tc) {
            'use strict';

            $tc.put('template/widget/advanced/barcodeScanner.html',
                '<button class="btn app-barcode" data-ng-model="_model_" data-ng-show="show" init-widget has-model apply-styles title="{{hint}}" data-ng-click="openBarcodeScanner()" >' +
                '<i class="{{iconclass}}" data-ng-style="{\'font-size\':iconsize}"></i> ' +
                '<span class="btn-caption">{{caption}}</span> '+
                '</button>'
            );
        }
    ])
    .directive('wmBarcodescanner', [
        '$templateCache',
        'PropertiesFactory',
        'WidgetUtilService',
        'CONSTANTS',
        '$rootScope',
        '$cordovaBarcodeScanner',

        function ($tc, PropertiesFactory, WidgetUtilService, CONSTANTS, $rs, $cordovaBarcodeScanner) {
            'use strict';

            var widgetProps = PropertiesFactory.getPropertiesOf('wm.barcodescanner', ['wm.base', 'wm.base.editors']);

            function openBarcodeScanner($is) {
                if (CONSTANTS.isStudioMode) {
                    return;
                }
                if (CONSTANTS.hasCordova) {
                    $cordovaBarcodeScanner.scan()
                        .then(function (data) {
                            $is.datavalue = $is._model_ = data.text;
                            $is.onSuccess({$scope: $is});
                            $rs.$safeApply($is);
                        });
                } else {
                    $is.onSuccess({$scope: $is});
                }
            }
            return {
                'restrict': 'E',
                'replace': true,
                'scope': {
                    onSuccess: '&'
                },
                'template': $tc.get('template/widget/advanced/barcodeScanner.html'),
                'link': {
                    'pre': function ($is) {
                        $is.widgetProps = widgetProps;
                    },
                    'post': function ($is, $el, attrs) {
                        $is.openBarcodeScanner = openBarcodeScanner.bind(undefined, $is);
                        WidgetUtilService.postWidgetCreate($is, $el, attrs);
                    }
                }
            };
        }
    ]);

/**
 * @ngdoc directive
 * @name wm.widgets.advanced.directive:wmBarcodescanner
 * @restrict E
 *
 * @description
 * The `wmBarcodescanner` directive defines the Barcode scanner widget.
 *
 * @scope
 *
 * @requires PropertiesFactory
 * @requires WidgetUtilService
 * @requires $sce
 *
 * @param {string=} hint
 *                  Title/hint for the barcode scanner. <br>
 *                  This property is bindable.
 * @param {boolean=} show
 *                  Show is a bindable property. <br>
 *                  This property will be used to show/hide the camera widget on the web page. <br>
 *                  Default value: `true`. <br>
 * @param {string=} iconclass
 *                  CSS class of the icon.
 * @param {string=} iconsize
 *                  size of the icon.
 *                  Default value: 3em
 * @param {string=} on-click
 *                  Clicking on the barcodescanner button opens a camera view and automatically scans a barcode, returning the data back.
 * @param {string=} on-success
 *                  Callback function which will be triggered when the widget barcode is successfully scanned.
 */


/*global WM, window, cordova, _*/
/*jslint sub: true */

/*Directive for file Selector in mobile applications*/
WM.module('wm.widgets.advanced')
    .run(['$templateCache', function ($templateCache) {
        'use strict';
        $templateCache.put('template/widget/advanced/mobileFileBrowser.html',
                '<div class="app-file-browser" data-ng-show="show">' +
                    '<div class="modal-backdrop fade" data-ng-class="{in : show}"></div>' +
                    '<div class="modal fade" style="display: block;" data-ng-class="{in : show}" >' +
                        '<div class="modal-dialog">' +
                            '<div class="modal-content">' +
                                '<div class="modal-header">' +
                                    '<h4 class="modal-title pull-left">' +
                                        '<span data-ng-click="onFileClick(directory.parent)" data-ng-show="directory.parent">' +
                                            '<i class="fa fa-long-arrow-left"></i>' +
                                        '</span>' +
                                        ' {{directory.name}}' +
                                    '</h4>' +
                                    '<div data-ng-show="selectedFiles.length > 0" class="selected-file-button pull-right">' +
                                        '<i class="fa fa-file-o" data-ng-show="selectedFiles.length == 1"></i>' +
                                        '<i class="fa fa-files-o" data-ng-show="selectedFiles.length > 1"></i>' +
                                        ' {{selectedFiles.length}}' +
                                    '</div>' +
                                '</div>' +
                                '<div class="modal-body">' +
                                    '<div class="file-info-box" data-ng-repeat="file in directory.files">' +
                                        '<div class="file-info"  data-ng-class="{\'bg-primary\': file.isSelected}" data-ng-click="onFileClick(file)">' +
                                            '<i class="file-icon fa fa-folder" data-ng-if="!file.isFile"/>' +
                                            '<i class="file-icon fa fa-file-o {{getFileExtension(file.name)}}" data-ng-if="file.isFile"/>' +
                                            '<span class="file-name">{{file.name}}</span>' +
                                        '</div>' +
                                    '</div>' +
                                '</div>' +
                                '<div class="modal-footer">' +
                                    '<button type="button" class="btn btn-primary" data-ng-show="selectedFiles && selectedFiles.length > 0" data-ng-click="submit()">Done</button>' +
                                    '<button type="button" class="btn btn-default" data-ng-click="show = false;">Close</button>' +
                                '</div>' +
                            '</div>' +
                        '</div>' +
                    '</div>' +
                '</div>'
            );
    }]).directive('wmMobileFileBrowser', [ '$templateCache', function ($templateCache) {
        'use strict';
        function loadFileSize(files, onComplete, index) {
            index = index || 0;
            if (index < files.length) {
                files[index].file(function (file) {
                    files[index].size = file.size;
                    loadFileSize(files, onComplete, index + 1);
                });
            } else {
                onComplete && onComplete(files);
            }
        }
        return {
            restrict: 'E',
            replace: true,
            template : $templateCache.get('template/widget/advanced/mobileFileBrowser.html'),
            scope: {
                onSelect : '&'
            },
            link : function (scope) {
                scope.selectedFiles = [];
                scope.directory = undefined;
                scope.getFileExtension = function (fileName) {
                    var extIndex = fileName ? fileName.lastIndexOf('.') : -1;
                    if (extIndex > 0) {
                        return fileName.substring(extIndex + 1);
                    }
                    return '';
                };
                scope.selectFile = function (file) {
                    if (!scope.multiple && scope.selectedFiles.length > 0) {
                        scope.selectedFiles[0].isSelected = false;
                        scope.selectedFiles = [];
                    }
                    scope.selectedFiles.push(file);
                    file.isSelected = true;
                };
                scope.deselectFile = function (file) {
                    _.remove(scope.selectedFiles, file);
                    file.isSelected = false;
                };
                scope.onFileClick = function (file) {
                    if (file.isFile) {
                        if (file.isSelected) {
                            scope.deselectFile(file);
                        } else {
                            scope.selectFile(file);
                        }
                    } else {
                        scope.goToDirectory(file);
                    }
                };
                scope.goToDirectory = function (directory) {
                    if (!directory.files) {
                        directory.createReader().readEntries(function (entries) {
                            directory.files = _.sortBy(entries, function (e) {
                                return (e.isFile ? '1_' : '0_') + e.name.toLowerCase();
                            });
                            directory.parent = scope.directory;
                            scope.directory = directory;
                            scope.$apply();
                        });
                    } else {
                        scope.directory = directory;
                    }
                };
                scope.submit = function () {
                    var files = [];
                    loadFileSize(scope.selectedFiles, function () {
                        _.forEach(scope.selectedFiles, function (f) {
                            f.isSelected = false;
                            files.push({ path: f.nativeURL,
                                        name: f.name,
                                        size : f.size});
                        });
                        scope.selectedFiles = [];
                        scope.show = false;
                        scope.onSelect({files: files});
                    });
                };
                scope.$watch('show', function () {
                    if (scope.show && !scope.directory) {
                        window.resolveLocalFileSystemURL(cordova.file.externalRootDirectory, function (root) {
                            scope.goToDirectory(root);
                        });
                    }
                });
            }
        };
    }]);

/*global WM, window, device, _, _WM_APP_PROPERTIES, navigator, document */

WM.element.holdReady(true);
document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    WM.element('#wm-app-content').attr('ng-view', '');

    // add a node to the DOM to determine the mobile view
    WM.element('<i id="wm-mobile-display"></i>').appendTo('.wm-app');

    WM.element.holdReady(false);
});

var Application =
    WM.module('Application',
        [
            'ngRoute',
            'ui.bootstrap',
            'wm.common',
            'wm.variables',
            'wm.plugins.database',
            'wm.plugins.webServices',
            'wm.plugins.security',
            'wm.widgets',
            'wm.layouts',
            'wm.mobile',
            'wm.utils',
            'oc.lazyLoad',
            'wm.prefabs',
            'i18n',
            'angular-gestures',
            'ngAnimate'
        ]);

Application
    .constant('CONSTANTS', {
        'isRunMode'     : true,
        'INT_MAX_VALUE' : 2147483647
    })
    .service('PrefabService', WM.noop) // dummy service to avoid exceptions in run mode
    .config(
        [
            '$controllerProvider',
            '$httpProvider',
            '$compileProvider',
            '$filterProvider',
            function ($controllerProvider, $httpProvider, $compileProvider, $filterProvider) {
                'use strict';

                Application.$controller = $controllerProvider.register;
                Application.$directive  = $compileProvider.directive;
                Application.$filter     = $filterProvider.register;

                $httpProvider.useApplyAsync(true);
                $controllerProvider.allowGlobals();
            }
        ]
    )
    .service('AppManager',
        [
            '$q',
            'Utils',
            'BaseService',
            '$location',
            '$rootScope',
            'wmToaster',
            'SecurityService',
            'i18nService',
            '$compile',
            'Variables',
            '$cacheFactory',
            '$document',
            'CONSTANTS',
            'wmSpinner',
            '$timeout',

            function ($q, Utils, BaseService, $location, $rs, wmToaster, SecurityService, i18nService, $compile, Variables, $cacheFactory, $document, CONSTANTS, wmSpinner, $timeout) {
                'use strict';

                var prevRoute,
                    cache           = $cacheFactory('APP_PAGES'),
                    NG_LOCALE_PATH  = 'resources/ngLocale/',
                    APP_LOCALE_PATH = 'resources/i18n/';

                function defaultPageLoadSuccessHandler(pageName, response) {
                    cache.put(pageName, Utils.parseCombinedPageContent(response.data, pageName));
                    $rs.activePageName = pageName; // setting active page name in rootScope, required by the Variables service
                    prevRoute = $location.path();
                }

                /**
                 * Handles the app when a XHR request returns 401 response
                 * If no user was logged in before 401 occurred, First time Login is simulated
                 * Else, a session timeout has occurred and the same is simulated
                 * @param page  if provided, represents the page name for which XHR request returned 401, on re-login
                 *              if not provided, a service request returned 401
                 * @param onSuccess success handler
                 * @param onError error handler
                 */
                function handleSessionTimeout(page, onSuccess, onError) {
                    var sessionTimeoutConfig,
                        sessionTimeoutMethod,
                        loginConfig,
                        loginMethod,
                        LOGIN_METHOD = {
                            'DIALOG' : 'DIALOG',
                            'PAGE'   : 'PAGE'
                        };
                    SecurityService.getConfig(function (config) {
                        // if no user found, 401 was thrown for first time login
                        if (config.userInfo && config.userInfo.userName) {
                            sessionTimeoutConfig = config.login.sessionTimeout || {'type': LOGIN_METHOD.DIALOG};
                            sessionTimeoutMethod = sessionTimeoutConfig.type.toUpperCase();
                            if (sessionTimeoutMethod === LOGIN_METHOD.DIALOG) {
                                if (page) {
                                    BaseService.pushToErrorCallStack(null, function () {
                                        _load(page, onSuccess, onError);
                                    }, WM.noop);
                                }
                                BaseService.handleSessionTimeOut();
                            } else if (sessionTimeoutMethod === LOGIN_METHOD.PAGE) {
                                if (!page) {
                                    page = $location.path().replace('/', '');
                                }
                                $location.path(sessionTimeoutConfig.pageName);
                                $location.search('redirectTo', page);
                            }
                        } else {
                            loginConfig = config.login;
                            loginMethod = loginConfig.type.toUpperCase();
                            if (loginMethod === LOGIN_METHOD.DIALOG) {
                                BaseService.handleSessionTimeOut();
                                // Through loginDialog, user will be redirected to respective landing page as it is a first time login
                            } else if (loginMethod === LOGIN_METHOD.PAGE) {
                                $location.path(loginConfig.pageName);
                            }
                        }
                    });
                }

                function showPageSwitchSpinner() {
                    wmSpinner.show('', 'globalSpinner', 'app-page-switch');
                }

                function hidePageSwitchSpinner() {
                    $timeout(function () {
                        wmSpinner.hide('globalSpinner');
                    }, 200);
                }

                function defaultPageLoadErrorHandler(pageName, onSuccess, onError, jqxhr) {
                    if (jqxhr.status === 401 && !jqxhr.headers('X-WM-Login-ErrorMessage')) {
                        hidePageSwitchSpinner();
                        handleSessionTimeout(pageName, onSuccess, onError);
                    } else if (jqxhr.status === 403) {
                        // in-case of 403 forbidden error
                        // TODO: remove prevRoute variable when 403 page is implemented
                        wmToaster.show('error', $rs.appLocale.LABEL_ACCESS_DENIED || 'Access Denied', $rs.appLocale.LABEL_FORBIDDEN_MESSAGE || 'The requested resource access/action is forbidden.');
                        $location.path(prevRoute);
                    }
                }

                function _load(pageName, onSuccess, onError) {

                    BaseService.getHttpPromise({
                        'method': 'GET',
                        'url'   : Utils.preventCachingOf('pages/' + pageName + '/' + 'page.min.html')
                    }).then(function (response) {
                        defaultPageLoadSuccessHandler(pageName, response);
                        Utils.triggerFn(onSuccess, cache.get(pageName));
                    }, function (jqxhr) {
                        defaultPageLoadErrorHandler(pageName, onSuccess, onError, jqxhr);
                    });
                }

                function loadPage(pageName) {
                    var deferred = $q.defer(),
                        content;

                    // separate the page name from subview element names if any
                    pageName = pageName.split('.').shift();
                    content  = cache.get(pageName);

                    if (!content) {
                        _load(pageName, deferred.resolve, deferred.reject);
                    } else {
                        $rs.activePageName = pageName;
                        deferred.resolve(content);
                    }

                    return deferred.promise;
                }

                function getPageContent(pageName, type) {
                    return (cache.get(pageName) || {})[type];
                }

                // initialize the i18nService
                function initI18nService(supportedLocale, defaultLocale) {
                    var _acceptLang = (Utils.getCookieByName('X-Accept-Language') || '').split(','),
                        _sl         = supportedLocale,
                        _dl;

                    _dl = _.intersection(_acceptLang, _sl)[0] || defaultLocale || 'en';

                    // if the supportedLocale is not available set it to defaultLocale
                    _sl = _sl || [_dl];
                    i18nService.init(_sl, _dl, APP_LOCALE_PATH, NG_LOCALE_PATH);
                    i18nService.setSelectedLocale(_dl);
                }

                // Returns a promise that will be resolved when device is ready.
                function isDeviceReady() {
                    var d = $q.defer();
                    // Only in case of deployed mobile apps, wait for deviceready event.
                    if (CONSTANTS.hasCordova) {
                        $document.one('deviceready', d.resolve);
                    } else {
                        d.resolve();
                    }
                    return d.promise;
                }

                function loadCommonPage($s) {
                    var pageName = 'Common';
                    return loadPage(pageName)
                        .then(function (content) {
                            Variables.setPageVariables(pageName, content.variables);
                            var $html = WM.element(Utils.processMarkup(content.html));
                            WM.element('#wm-common-content').append($html);
                            $compile($html)($s);
                        });
                }

                function initAppVariables($s) {
                    var deferred = $q.defer();
                    Variables.initAppVariables($s, deferred.resolve, deferred.reject);
                    return deferred.promise;
                }

                /**
                 * Updates the loggedInUser Static Variable with current logged in user's details
                 * if security disabled, user not authenticated, it is reset.
                 */
                function updateLoggedInUserVariable() {
                    var loggedInUser = $rs.Variables && $rs.Variables.loggedInUser && $rs.Variables.loggedInUser.dataSet;

                    // sanity check
                    if (!loggedInUser) {
                        return;
                    }

                    // local function to clear the loggedInUser details.
                    function clearLoggedInUser() {
                        loggedInUser.isAuthenticated = false;
                        loggedInUser.roles           = [];
                        loggedInUser.name            = undefined;
                        loggedInUser.id              = undefined;
                        loggedInUser.tenantId        = undefined;
                    }

                    SecurityService.getConfig(function (config) {
                        if (config.securityEnabled) {
                            if (config.authenticated) {
                                loggedInUser.isAuthenticated = config.authenticated;
                                loggedInUser.roles           = config.userInfo.userRoles;
                                loggedInUser.name            = config.userInfo.userName;
                                loggedInUser.id              = config.userInfo.userId;
                                loggedInUser.tenantId        = config.userInfo.tenantId;
                                return;
                            }
                        }
                        clearLoggedInUser();
                    }, clearLoggedInUser);
                }

                function getPreparedPageContent(pageName) {

                    var content  = cache.get(pageName).html,
                        $content = content || '';

                    $content = WM.element(Utils.processMarkup(content));

                    if ($rs.isPrefabType) {
                        $rs.prefabTemplate   = $content;
                        $rs.isPrefabTemplate = true;
                        $content             = WM.element('<wm-prefab-run></wm-prefab-run>');
                    }

                    return $content;
                }

                function clearPagesCache() {
                    cache.destroy();
                    cache = $cacheFactory('APP_PAGES');
                }

                function loadSecurityConfig() {
                    var deferred = $q.defer(),
                        page;

                    if (!$rs.isApplicationType) {
                        if ($location.path() === '/') {
                            $location.path(_WM_APP_PROPERTIES.homePage);
                        }
                        deferred.resolve();
                    } else {
                        SecurityService.getConfig(function (config) {
                            $rs.isSecurityEnabled   = config.securityEnabled;
                            $rs.isUserAuthenticated = config.authenticated;
                            if (config.securityEnabled) {
                                if (config.authenticated) {
                                    page = config.userInfo.homePage || _WM_APP_PROPERTIES.homePage;
                                    $rs.userRoles = config.userInfo.userRoles;
                                } else {
                                    page = config.homePage;
                                }
                            } else {
                                page = config.homePage;
                            }
                            if ($location.path() === '/') {
                                $location.path(page);
                            }
                            deferred.resolve();
                        }, deferred.resolve);
                    }

                    return deferred.promise;
                }

                $rs.$on('app-logout-success', clearPagesCache);

                this.loadPage                   = loadPage;
                this.getPageContent             = getPageContent;
                this.loadCommonPage             = loadCommonPage;
                this.initI18nService            = initI18nService;
                this.initAppVariables           = initAppVariables;
                this.updateLoggedInUserVariable = updateLoggedInUserVariable;
                this.getPreparedPageContent     = getPreparedPageContent;
                this.isDeviceReady              = isDeviceReady;
                this.loadSecurityConfig         = loadSecurityConfig;
                this.handleSessionTimeOut       = handleSessionTimeout;
                this.showPageSwitchSpinner      = showPageSwitchSpinner;
                this.hidePageSwitchSpinner      = hidePageSwitchSpinner;
            }
        ])
    .config(
        [
            '$routeProvider',
            function ($routeProvider) {
                'use strict';

                var initText    = '<div></div>',
                    routeConfig = {
                        'template': initText,
                        'resolve' : {
                            'securityConfig': function (AppManager) {
                                return AppManager.loadSecurityConfig();
                            },
                            // make sure that the app Variables are loaded before processing the page content
                            'appVariables': ['$q', '$rootScope', function ($q, $rs) {
                                var deferred = $q.defer();

                                // for the prefab/template bundle type do not wait for the app variables.
                                if ($rs.isApplicationType) {
                                    $rs.$watch(':: Variables', deferred.resolve);
                                } else {
                                    deferred.resolve();
                                }

                                return deferred.promise;
                            }]
                        }
                    };

                $routeProvider
                    .when('/', routeConfig)
                    .when('/:name', {
                        'template': initText,
                        'resolve' : WM.extend({
                            'pageContent': function (AppManager, $route) {
                                var pageName = $route.current.params.name;
                                return AppManager.loadPage(pageName);
                            }
                        }, routeConfig.resolve)
                    });
            }
        ]
    )
    .controller('AppController',
        [
            '$scope',
            '$rootScope',
            'ProjectService',
            'i18nService',
            'Utils',
            'AppManager',
            'SecurityService',
            'Variables',
            'CONSTANTS',
            'wmSpinner',

            //do not remove the below lines
            'BasicVariableService',
            '$servicevariable',
            '$liveVariable',
            'NavigationVariableService',
            'NotificationVariableService',
            'LoginVariableService',
            'LogoutVariableService',
            'TimerVariableService',

            function ($s, $rs, ProjectService, i18nService, Utils, AppManager, SecurityService, Variables, CONSTANTS, wmSpinner) {
                'use strict';

                var projectID      = ProjectService.getId(), // ProjectID will always be at the same index in the URL
                    appProperties  = Utils.getClonedObject(_WM_APP_PROPERTIES),
                    pageReadyDeregister;

                $rs.projectName             = appProperties.name;

                $rs.isPrefabType            = appProperties.type === 'PREFAB';
                $rs.isApplicationType       = appProperties.type === 'APPLICATION';
                $rs.isTemplateBundleType    = appProperties.type === 'TEMPLATEBUNDLE';

                $rs.project = {
                    'id'          : projectID,
                    'activeTheme' : appProperties.activeTheme,
                    'deployedUrl' : ProjectService.getDeployedUrl()
                };

                $rs.changeLocale = function ($is) {
                    i18nService.setSelectedLocale($is.datavalue);
                };

                /*
                 * Route Change Handler, for every page
                 * Page content is fetched here and provided to the template for rendering
                 * Page Variables are also set and made available for registration
                 * For Prefabs: localization resources are loaded
                 */
                $rs.$on('$routeChangeSuccess', function (evt, $route) {
                    var pageName = $route.params.name,
                        pageVars,
                        supportedLocale;

                    if (pageName) {
                        pageName = pageName.split('.').shift();
                        $route.locals.$template = AppManager.getPreparedPageContent(pageName);
                        // set the page-level variables, registration will occur in the page directive
                        pageVars = AppManager.getPageContent(pageName, 'variables');
                        Variables.setPageVariables(pageName, pageVars);

                        if ($rs.isPrefabType) {
                            supportedLocale = Utils.findValueOf(pageVars, 'supportedLocale.dataSet');
                            AppManager.initI18nService(_.keys(supportedLocale), appProperties.defaultLanguage);
                        }
                    }

                    // hide the app-spinner
                    AppManager.hidePageSwitchSpinner();
                });

                // show the app-spinner on route change start
                $rs.$on('$routeChangeStart', function () {
                    AppManager.showPageSwitchSpinner();
                });

                /*
                 * Following content loaded only application type projects, not template bundles, prefabs
                 * - Common Page
                 * - App Variables
                 * - Localization Resource
                 */
                if ($rs.isApplicationType) {
                    AppManager.isDeviceReady()
                        .then(function () {
                            return AppManager.loadCommonPage($s);
                        }).then(function () {
                            SecurityService.getConfig(function (config) {
                                AppManager.initAppVariables($s)
                                    .then(function (appVariables) {
                                        var supportedLocale = (appVariables.supportedLocale || {}).dataSet;
                                        AppManager.initI18nService(_.keys(supportedLocale), appProperties.defaultLanguage);
                                        // if user us authenticated, update user details in loggedInUser variable
                                        if (config.authenticated) {
                                            AppManager.updateLoggedInUserVariable();
                                        }
                                    });
                            });
                        });
                }

                // load prefab configurations
                if ($rs.isPrefabType) {
                    Utils.fetchContent(
                        'json',
                        Utils.preventCachingOf('./config.json'),
                        function (response) {
                            if (!response.error) {
                                $rs.prefabConfig = response;
                            }
                        },
                        WM.noop,
                        true
                    );
                }

                if (CONSTANTS.hasCordova) {
                    pageReadyDeregister = $rs.$on('page-ready', function () {
                        navigator.splashscreen.hide();
                        pageReadyDeregister();
                    });
                }

                $rs.$on('update-loggedin-user', function () {
                    SecurityService.setConfig(null);
                    AppManager.updateLoggedInUserVariable();
                });

                // function to invoke a service during run time
                $rs.$on('invoke-service', function (event, name, options, onSuccess, onError) {
                    // if function call is bound with the button, return
                    if (_.includes(name, '(')) {
                        return;
                    }

                    var variable;
                    if (!options || !options.scope || !options.scope.Variables || !options.scope.Variables[name]) {
                        variable = Variables.getVariableByName(name);
                    } else {
                        variable = options.scope.Variables[name];
                    }

                    if (!variable) {
                        return;
                    }

                    // based on variable category, perform appropriate action
                    switch (variable.category) {
                    case 'wm.LiveVariable':
                        if (variable.operation === 'read') {
                            variable.update(options, onSuccess, onError);
                        } else {
                            // else call the respective db operation (insert/update/delete)
                            variable[variable.operation + 'Record'](options, onSuccess, onError);
                        }
                        break;
                    case 'wm.ServiceVariable':
                        variable.update(options, onSuccess, onError);
                        break;
                    case 'wm.NavigationVariable':
                        variable.navigate(options, onSuccess, onError);
                        break;
                    case 'wm.NotificationVariable':
                        variable.notify(options, onSuccess, onError);
                        break;
                    case 'wm.LoginVariable':
                        variable.login(options, onSuccess, onError);
                        break;
                    case 'wm.LogoutVariable':
                        variable.logout(options, onSuccess, onError);
                        break;
                    case 'wm.TimerVariable':
                        variable.fire(options, onSuccess, onError);
                        break;
                    case 'wm.DeviceVariable':
                        variable.invoke(options, onSuccess, onError);
                        break;
                    }
                });

                AppManager.isDeviceReady().then(function () {
                    $rs.$emit('application-ready');
                });

                // This is used to show and hide the spinner when variable is in-flight
                $rs.$on('toggle-variable-state', function (event, variableName, active) {
                    var variable = Variables.getVariableByName(variableName);
                    if (variable && !_.isEmpty(_.trim(variable.spinnerContext))) {

                        if (active) {
                            variable._spinnerId = wmSpinner.show(variable.spinnerMessage, variable._id);
                        } else {
                            wmSpinner.hide(variable._spinnerId);
                        }
                    }
                });
            }
        ]);